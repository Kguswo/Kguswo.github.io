---
title: "BOJ_1516_게임 개발 (Java)"
description: "문제 링크 메모리: 21636 KB, 시간: 224 ms다이나믹 프로그래밍, 그래프 이론, 방향 비순환 그래프, 위상 정렬2025년 8월 12일 05:05:23위상정렬 문제다. 진입차수를 순서에 맞게 잘 설정해 준 뒤 (선행되어야 할 것에 뒤에 따라올 친구들을 넣는 식"
date: 2025-08-11T20:07:40.583Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ1516게임-개발-Java"
thumbnail: "/assets/posts/32533be35df780bae0f02b6a0e590baa8cfad836338c3ff0848300199104e2c8.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:00:44.526Z
  hash: "51b84d03fc7be2f6f747f2b112cf883fb521f00c2e4891926c456d2ff0a4bc0f"
---

# [Gold III] 게임 개발 - 1516 

[문제 링크](https://www.acmicpc.net/problem/1516) 

### 성능 요약

메모리: 21636 KB, 시간: 224 ms

### 분류

다이나믹 프로그래밍, 그래프 이론, 방향 비순환 그래프, 위상 정렬

### 제출 일자

2025년 8월 12일 05:05:23

### 문제 설명

<p>숌 회사에서 이번에 새로운 전략 시뮬레이션 게임 세준 크래프트를 개발하기로 하였다. 핵심적인 부분은 개발이 끝난 상태고, 종족별 균형과 전체 게임 시간 등을 조절하는 부분만 남아 있었다.</p>

<p>게임 플레이에 들어가는 시간은 상황에 따라 다를 수 있기 때문에, 모든 건물을 짓는데 걸리는 최소의 시간을 이용하여 근사하기로 하였다. 물론, 어떤 건물을 짓기 위해서 다른 건물을 먼저 지어야 할 수도 있기 때문에 문제가 단순하지만은 않을 수도 있다. 예를 들면 스타크래프트에서 벙커를 짓기 위해서는 배럭을 먼저 지어야 하기 때문에, 배럭을 먼저 지은 뒤 벙커를 지어야 한다. 여러 개의 건물을 동시에 지을 수 있다.</p>

<p>편의상 자원은 무한히 많이 가지고 있고, 건물을 짓는 명령을 내리기까지는 시간이 걸리지 않는다고 가정하자.</p>

### 입력 

 <p>첫째 줄에 건물의 종류 수 N(1 ≤ N ≤ 500)이 주어진다. 다음 N개의 줄에는 각 건물을 짓는데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어져야 하는 건물들의 번호가 주어진다. 건물의 번호는 1부터 N까지로 하고, 각 줄은 -1로 끝난다고 하자. 각 건물을 짓는데 걸리는 시간은 100,000보다 작거나 같은 자연수이다. 모든 건물을 짓는 것이 가능한 입력만 주어진다.</p>

### 출력 

 <p>N개의 각 건물이 완성되기까지 걸리는 최소 시간을 출력한다.</p>


> ## 문제 풀이

위상정렬 문제다. 진입차수를 순서에 맞게 잘 설정해 준 뒤 (선행되어야 할 것에 뒤에 따라올 친구들을 넣는 식으로), 이후 queue나 deque을 사용해 선행되어야 할 것 중 최초부터 차례로 graph를 따라 진행한다.

![](/assets/posts/32533be35df780bae0f02b6a0e590baa8cfad836338c3ff0848300199104e2c8.png)

> ## 코드

```java
/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
	static int[] time, indegree, res;
	static int N;
	static ArrayList<Integer>[] board;
	static StringBuilder sb = new StringBuilder();
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        //br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_1516_게임개발/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

		N = Integer.parseInt(br.readLine());
		board = new ArrayList[N+1];
		for(int i=0; i<N+1; i++) {
			board[i] = new ArrayList<>();
		}

		time = new int[N+1];
		indegree = new int[N+1];
		res = new int[N+1];

		for(int i=1; i<=N; i++) {
			st = new StringTokenizer(br.readLine());
			time[i] = Integer.parseInt(st.nextToken());

			int n;
			while((n = Integer.parseInt(st.nextToken())) != -1){
				board[n].add(i);
				indegree[i]++;
			}
		}

		Deque<Integer> dq = new ArrayDeque<>();
		for(int i=1; i<=N; i++) {
			if(indegree[i]==0){
				dq.offer(i);
				res[i] = time[i];
			}
		}

		while(!dq.isEmpty()){
			int curr = dq.poll();
			for(int next : board[curr]){
				res[next] = Math.max(res[next], res[curr] + time[next]);
				indegree[next]--;
				if(indegree[next]==0){
					dq.offer(next);
				}
			}
		}

		for(int i=1; i<=N; i++) {
			sb.append(res[i]).append("\n");
		}

		System.out.println(sb.toString());
        bw.flush();
        bw.close();
        br.close();
    }
}
```