---
title: "BOJ_25707_팔찌 만들기 (C++)"
description: "문제 링크 메모리: 2020 KB, 시간: 0 ms애드 혹, 그리디 알고리즘, 수학, 정렬2024년 12월 22일 12:37:38반드시 한바퀴를 돌며 처음부터 끝까지 검사해야하는데 반드시 최소값과 최대값은 지나쳐야하며 최대값 - 최솟값의 절댓값이 있으면 양쪽으로 그 이"
date: 2024-12-23T13:40:55.259Z
tags: ["C++","백준","알고리즘"]
slug: "BOJ25707팔찌-만들기-C"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:09.198Z
  hash: "423d77df3c52dc008a12d014ab49d90d894c9985e6f9c3d768dcf60b95cafdef"
---

# [Silver V] 팔찌 만들기 - 25707 

[문제 링크](https://www.acmicpc.net/problem/25707) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

애드 혹, 그리디 알고리즘, 수학, 정렬

### 제출 일자

2024년 12월 22일 12:37:38

### 문제 설명

<p>용모는 유치원에서 아이들을 위해 자원봉사를 하고 있다.</p>

<p>오늘의 활동은 구슬 <em>N</em>개를 줄로 이어 팔찌를 만드는 것이다. 각 구슬에는 서로 다른 수가 하나씩 적혀 있는데, 두 구슬 사이를 잇는 줄의 길이는 두 구슬에 적힌 수들의 차의 절댓값이 되어야 한다. 선생님은 이 활동을 통해 아이들이 뺄셈을 즐겁게 배우길 기대하고 있다.</p>

<p style="text-align: center"><img alt="" src="https://upload.acmicpc.net/0898992d-618a-4f31-bef6-813b3bef1c09/-/preview/" style="width: 500px; height: 489px;"></p>

<p>용모는 아이들에게 완성된 팔찌의 견본을 보여주는 역할을 맡았다. 선생님은 똑똑한 용모에게 N개의 구슬을 건네주며, <em>N</em>개의 구슬로 팔찌를 만들되 줄을 가능한 적게 사용할 것을 부탁하였다. 하지만 자원봉사를 너무 열심히 하느라 지친 용모는 필요한 줄의 최소 길이를 구할 방법이 생각나질 않았다. 여러분이 용모 대신 <em>N</em>개의 구슬로 팔찌를 만드는데 필요한 줄의 최소 길이를 구해주자.</p>

### 입력 

 <p>첫 번째 줄에 구슬의 개수 <em>N</em>이 주어진다.</p>

<p>두 번째 줄에 각 구슬에 적힌 수 <em>N</em>개가 공백으로 구분되어 차례로 주어진다.</p>

### 출력 

 <p><em>N</em>개의 구슬을 모두 사용하여 조건에 맞게 팔찌를 만들 때 사용하는 줄의 길이의 최솟값을 출력한다.</p>

> ## 문제 풀이

반드시 한바퀴를 돌며 처음부터 끝까지 검사해야하는데 반드시 최소값과 최대값은 지나쳐야하며 최대값 - 최솟값의 절댓값이 있으면 양쪽으로 그 이상은 들쭉날쭉하지 않으므로 이걸 두배하면 된다. 

> ## 코드

```c
/**
 * Author: nowalex322, Kim HyeonJae
 */
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define MOD 1000000007
#define INF LLONG_MAX
#define ALL(v) v.begin(), v.end()

#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif

void solve() {
    int N;
    cin >> N;
    vector<int> arr(N);
    int minNum = INT_MAX, maxNum = INT_MIN;
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
        minNum = min(minNum, arr[i]);
        maxNum = max(maxNum, arr[i]);
    }
    /*
    반드시 한바퀴 돌 때 min->max 할 때 그리고 max->min할 때 각각 |max-min|
    이상의 길이가 필요하므로 최소값은 2 x |maxNum - minNum|
    */
    cout << 2 * abs(maxNum - minNum) << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리
    // cin >> tt;    // 테스트 케이스 수 입력 (필요 시)

    while (tt--) {
        solve();
    }
    return 0;
}
```