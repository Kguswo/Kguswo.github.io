---
title: "BOJ_1655_가운데를 말해요 (Java)"
date: 2025-11-18T08:29:53.522Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ1655가운데를-말해요-Java"
image: "../assets/posts/e40a9ddef0a21def3d9cdd87376ab76054b2df3a9bfe1aca30793c9dcdc08a3a.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-11-19T01:41:22.140Z
  hash: "ffec14f6dd393164a80a612008e4562873a514a26ce76a502e19e7b40bf20176"
---

# [Gold II] 가운데를 말해요 - 1655 

[문제 링크](https://www.acmicpc.net/problem/1655) 

### 성능 요약

메모리: 34180 KB, 시간: 428 ms

### 분류

자료 구조, 우선순위 큐

### 제출 일자

2025년 11월 18일 17:21:19

### 문제 설명

<p>백준이는 동생에게 "가운데를 말해요" 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.</p>

<p>예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.</p>

### 출력 

<p>한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.</p>



> ## 문제 풀이

우선순위 큐를 통해 작은 집합과 큰 집합을 정확히 반을 나눴다.

문제 예시로 

```
 1 입력 	▶ [1] [ ]				→ 1 출력

 5 입력 	▶ [1] [5]   			→ 1 출력

 2 입력 	▶ [1 2] [5]  			→ 2 출력

10 입력 	▶ [1 2] [5 10]  		→ 2 출력

-99 입력	▶ [-99 1 2] [5 10]  	→ 2 출력

 7 입력 	▶ [-99 1 2] [5 7 10]  	→ 2 출력

 5 입력 	▶ [-99 1 2 5] [5 7 10]  → 5 출력
```

이런식으로 동작한다.

그리고 어떻게 이러한 두 집합을 잘 만들지를 고민해야하는데, 아래 예시로 swap 과정을 알 수 있다.

```
[1] [2] 인 상황에서 5가 들어오면

5 입력	▶ [5 1] [2] 가 되는데

왼쪽 최대힙의 루트 vs 오른쪽 최소힙의 루트를 비교해 스왑해주어야한다.

결과 	▶ [1 2] [5]

```

![](/assets/posts/e40a9ddef0a21def3d9cdd87376ab76054b2df3a9bfe1aca30793c9dcdc08a3a.png)


> ## 코드

```java
/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(br.readLine());
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for(int i=0; i<n; i++) {
            int num = Integer.parseInt(br.readLine());

            if(minHeap.size() == maxHeap.size()) {
                maxHeap.offer(num);
            }
            else minHeap.offer(num);

            if(!maxHeap.isEmpty() && !minHeap.isEmpty()) {
                if(maxHeap.peek() > minHeap.peek()) {
                    int tmp = minHeap.poll();
                    minHeap.offer(maxHeap.poll());
                    maxHeap.offer(tmp);
                }
            }

            sb.append(maxHeap.peek()).append("\n");
        }

        System.out.println(sb.toString());

        bw.flush();
        bw.close();
        br.close();
    }
}
```