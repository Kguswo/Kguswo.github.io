---
title: "BOJ_17073_나무 위의 빗물 (Java, C++)"
date: 2024-12-31T15:59:57.483Z
tags: ["C++","Java","백준","알고리즘"]
slug: "BOJ17073나무-위의-빗물-Java-C"
image: "../assets/posts/95aa66a08fe6b03151b1af5bfd1975ad34be47ee10631428404f7a642fc38c9e.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:03.598Z
  hash: "9c7278005e254ca723dc3c868bb5e832bf7352369dfd08c20305a5f1feba81b8"
---

# [Gold V] 나무 위의 빗물 - 17073 

[문제 링크](https://www.acmicpc.net/problem/17073) 

### 성능 요약

메모리: 118868 KB, 시간: 460 ms

### 분류

그래프 이론, 그래프 탐색, 수학, 트리

### 제출 일자

2025년 1월 1일 00:54:45

### 문제 설명

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/96077f22-38dc-4cab-8122-1a693bc3928f/-/preview/" style="height: 282px; width: 300px;"><br>
 </p>

<p>트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 1번 정점을 루트로 하는 어떤 트리를 나타낸 모습이다.</p>

<p>사실 이 트리는 영훈이가 뒷마당에서 기르고 있는 나무이다. 어제는 비가 왔기 때문에, 트리의 1번 정점에는 <em>W</em>만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.</p>

<p>이제 매초마다 모든 정점은 아래의 작업을 순서대로 반복한다.</p>

<ul>
	<li>물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.</li>
	<li>만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.</li>
</ul>

<p>이때, 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 즉시 자식 정점에게 줄 수는 없다.</p>

<p>영훈이는 나무를 바라보면서 더 이상 물이 움직이지 않는 상태가 되었을 때 각 정점에 어느 정도의 물이 있게 될지 궁금해졌다. 더 이상 물이 움직이지 않을 때, <em>i</em>번 정점에 쌓인 물의 양의 기댓값을 <em>P<sub>i</sub></em>라 하자. 이때, <em>P<sub>i</sub></em>가 0보다 큰 정점들에 대해서 <em>P<sub>i</sub></em>들의 평균은 어느 정도가 될까?</p>

### 입력 

 <p>첫째 줄에 트리의 노드의 수 <em>N</em>과 1번 노드에 고인 물의 양을 의미하는 정수 <em>W</em>가 주어진다. (2 ≤ <em>N </em>≤ 500,000, 1 ≤ <em>W</em> ≤ 10<sup>9</sup>)</p>

<p>다음 <em>N-1</em>줄에 걸쳐, 트리에 존재하는 간선의 정보가 <em>U V</em>의 형태로 주어진다. (1 ≤ <em>U</em>,<em> V</em> ≤<em> N</em>​​​​, <em>U </em>≠ <em>V</em>)</p>

<p>이는 양 끝 정점이 각각 <em>U</em>와 <em>V</em>인 간선이 트리에 존재한다는 의미이다.</p>

<p>입력으로 주어지는 트리는 항상 올바른 연결 트리임이 보장되며, 주어지는 트리의 루트는 항상 1번 정점이다.</p>

### 출력 

 <p>문제의 정답을 출력한다. 정답과의 차이가 10<sup>-3</sup> 이하인 값은 모두 정답으로 인정된다.</p>

> ## 문제 풀이

문제 이해가 꽤 난해했다. 나무가 있고 빗물이 떨어지는데 결국 노드마다 무한대의 물을 저장할 수 있으므로 맨 아래 즉 리프 노드에 모두 저장된다. 그리고 물의 양도 정해져있기 때문에 매우 쉬운 문제다. 

> ## 코드

#### Java 코드
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;
    static int N, W, tree[];
    double leaf, res;
	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		W = Integer.parseInt(st.nextToken());
		tree = new int[500010];
		leaf = 0;
		
		for(int i=0; i<N-1; i++) {
			st = new StringTokenizer(br.readLine());
			int U = Integer.parseInt(st.nextToken());
			int V = Integer.parseInt(st.nextToken());
			tree[U]++;
			tree[V]++;
		}
		
		for(int i=2; i<=500000; i++) {
			if(tree[i] == 1) leaf++;
		}
		
		res = W / leaf;
		bw.write(String.valueOf(res));
		bw.flush();
		bw.close();
		br.close();
	}
}
```
---

#### C++ 코드
```c
/**
 * Author: nowalex322, Kim HyeonJae
 */
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define MOD 1000000007
#define INF LLONG_MAX
#define ALL(v) v.begin(), v.end()

#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif

void solve() {
    int N, W;
    cin >> N >> W;
    long long leaf = 0;
    double res = 0;
    vector<int> tree(500010, 0);

    for (int i = 0; i < N - 1; i++) {
        int U, V;
        cin >> U >> V;
        tree[U]++;
        tree[V]++;
    }

    for (int i = 2; i <= 500000; i++) {
        if (tree[i] == 1) leaf++;
    }

    res = 1.0 * W / leaf;
    cout << fixed << setprecision(10) << res << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리
    // cin >> tt;    // 테스트 케이스 수 입력 (필요 시)

    while (tt--) {
        solve();
    }
    return 0;
}
```