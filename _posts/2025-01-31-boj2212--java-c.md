---
title: "BOJ_2212_센서 (Java, C++)"
date: 2025-01-31T06:41:38.117Z
tags: ["C++","Java","백준","알고리즘"]
slug: "BOJ2212센서-Java-C"
thumbnail: "../assets/posts/1c0e91f637eaf9ddec007ce87406a35d0efe1a6042f13a98131dcd91f308402c.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:03:32.721Z
  hash: "7d4eacc767ffe1770fd7564f197ee93296f605f3994a385e78d1f41ba5c6c3b8"
---

# [Gold V] 센서 - 2212 

[문제 링크](https://www.acmicpc.net/problem/2212) 

### 성능 요약

메모리: 16220 KB, 시간: 168 ms

### 분류

그리디 알고리즘, 정렬

### 제출 일자

2025년 1월 31일 15:34:27

### 문제 설명

<p>한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.</p>

<p>각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.</p>

<p>편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.</p>

### 입력 

 <p>첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.</p>

### 출력 

 <p>첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/1c0e91f637eaf9ddec007ce87406a35d0efe1a6042f13a98131dcd91f308402c.png)

> ## 코드

#### Java 코드

```java
/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static int N, K, arr[], len[], res;
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
//        br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_2212_센서/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        K = Integer.parseInt(br.readLine());
        // K>=Ndl면 각각 설치할 수 있으므로 0
        if (K >= N) {
            bw.write("0");
            bw.flush();
            bw.close();
            br.close();
            return;
        }
        
        arr = new int[N];
        len = new int[N-1];
        st = new StringTokenizer(br.readLine());
        res = 0;
        for(int i=0; i<N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }
        Arrays.sort(arr);

        for(int i=0; i<N-1; i++) {
            len[i] = arr[i+1]-arr[i];
            res += len[i];
        }

        Arrays.sort(len);
        for(int i=len.length-1; i>len.length-1-(K-1); i--){
            res -= len[i];
        }
        bw.write(String.valueOf(res));
        bw.flush();
        bw.close();
        br.close();
    }
}
```

---

#### C++ 코드

```c
/**
 * Author: nowalex322, Kim HyeonJae
 */
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define MOD 1000000007
#define INF LLONG_MAX
#define ALL(v) v.begin(), v.end()

#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif

void solve() {
    int N, K;
    cin >> N >> K;
    if (K >= N) {
        cout << 0;
        return;
    }

    vector<int> arr(N);
    vector<int> len(N - 1);
    int res = 0;

    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    sort(ALL(arr));

    for (int i = 0; i < N - 1; i++) {
        len[i] = arr[i + 1] - arr[i];
        res += len[i];
    }

    sort(ALL(len));

    for (int i = len.size() - 1; i > len.size() - 1 - (K - 1); i--) {
        res -= len[i];
    }

    cout << res << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리
    // cin >> tt;    // 테스트 케이스 수 입력 (필요 시)

    while (tt--) {
        solve();
    }
    return 0;
}
```