---
title: "PGMS_추석 트래픽 (Java)"
date: 2025-09-10T02:49:39.976Z
tags: ["Java","알고리즘","프로그래머스"]
slug: "PGMS추석-트래픽-Java"
image: "../assets/posts/c9a9bd11b277f89a50eb8e44523c75619d48410bc0e94ab9bfb35bf2c564520b.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-09-11T15:26:32.838Z
  hash: "93801d97d8d23fe8f32c43b7dcf53d3a84ad9104723ed921fa7c824160ce9aee"
---

# [level 3] [1차] 추석 트래픽 - 17676 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/17676) 

### 성능 요약

메모리: 83.2 MB, 시간: 100.74 ms

### 구분

코딩테스트 연습 > 2018 KAKAO BLIND RECRUITMENT

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 09월 10일 11:40:34

### 문제 설명

<h2>추석 트래픽</h2>

<p>이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. <strong>초당 최대 처리량</strong>은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다. </p>

<h3>입력 형식</h3>

<ul>
<li><code>solution</code> 함수에 전달되는 <code>lines</code> 배열은 <strong>N</strong>(1 ≦ <strong>N</strong> ≦ 2,000)개의 로그 문자열로 되어 있으며,
각 로그 문자열마다 요청에 대한 응답완료시간 <strong>S</strong>와 처리시간 <strong>T</strong>가 공백으로 구분되어 있다.</li>
<li>응답완료시간 <strong>S</strong>는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 <code>2016-09-15 hh:mm:ss.sss</code> 형식으로 되어 있다.</li>
<li>처리시간 <strong>T</strong>는 <code>0.1s</code>, <code>0.312s</code>, <code>2s</code> 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 <code>s</code>로 끝난다.</li>
<li>예를 들어, 로그 문자열 <code>2016-09-15 03:10:33.020 0.011s</code>은 "2016년 9월 15일 오전 3시 10분 <strong>33.010초</strong>"부터 "2016년 9월 15일 오전 3시 10분 <strong>33.020초</strong>"까지 "<strong>0.011초</strong>" 동안 처리된 요청을 의미한다. <strong>(처리시간은 시작시간과 끝시간을 포함)</strong></li>
<li>서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 <strong>0.001 ≦ T ≦ 3.000</strong>이다.</li>
<li><code>lines</code> 배열은 응답완료시간 <strong>S</strong>를 기준으로 오름차순 정렬되어 있다.</li>
</ul>

<h3>출력 형식</h3>

<ul>
<li><code>solution</code> 함수에서는 로그 데이터 <code>lines</code> 배열에 대해 <strong>초당 최대 처리량</strong>을 리턴한다.</li>
</ul>

<h3>입출력 예제</h3>

<h4>예제1</h4>

<ul>
<li><p>입력: [<br>
"2016-09-15 01:00:04.001 2.0s",<br>
"2016-09-15 01:00:07.000 2s"<br>
]</p></li>
<li><p>출력: 1</p></li>
</ul>

<h4>예제2</h4>

<ul>
<li><p>입력: [<br>
"2016-09-15 01:00:04.002 2.0s",<br>
"2016-09-15 01:00:07.000 2s"<br>
]</p></li>
<li><p>출력: 2</p></li>
<li><p>설명: 처리시간은 시작시간과 끝시간을 <strong>포함</strong>하므로 <br>
첫 번째 로그는 <code>01:00:02.003 ~ 01:00:04.002</code>에서 2초 동안 처리되었으며,<br>
두 번째 로그는 <code>01:00:05.001 ~ 01:00:07.000</code>에서 2초 동안 처리된다.<br>
따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 <code>01:00:04.002 ~ 01:00:05.001</code> 1초 동안 최대 2개가 된다.</p></li>
</ul>

<h4>예제3</h4>

<ul>
<li><p>입력: [<br>
"2016-09-15 20:59:57.421 0.351s",<br>
"2016-09-15 20:59:58.233 1.181s",<br>
"2016-09-15 20:59:58.299 0.8s",<br>
"2016-09-15 20:59:58.688 1.041s",<br>
"2016-09-15 20:59:59.591 1.412s",<br>
"2016-09-15 21:00:00.464 1.466s",<br>
"2016-09-15 21:00:00.741 1.581s",<br>
"2016-09-15 21:00:00.748 2.31s",<br>
"2016-09-15 21:00:00.966 0.381s",<br>
"2016-09-15 21:00:02.066 2.62s"<br>
]</p></li>
<li><p>출력: 7</p></li>
<li><p>설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 <code>(1)</code>은 4개, <code>(2)</code>는 7개, <code>(3)</code>는 2개임을 알 수 있다. 따라서 <strong>초당 최대 처리량</strong>은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.<br>
<img src="http://t1.kakaocdn.net/welcome2018/chuseok-01-v5.png" title="" alt="Timeline"></p></li>
</ul>

<p><a href="http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/" target="_blank" rel="noopener">해설 보러가기</a></p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges


![](/assets/posts/c9a9bd11b277f89a50eb8e44523c75619d48410bc0e94ab9bfb35bf2c564520b.png)

> ## 문제 풀이

일단 로그를 1ms단위로 쭉 찾으며 진행하는 브루트포스 방법은 당연히 시간초과다. 이에 어떻게 효율적으로 겹치는 구간 찾기를 진행할지 고민했다.

생각보다 간단했는데 그냥 로그 처음과 끝이 포함되면 된다. 로그 중간이 포함된다는 거는 전체가 걸쳐있거나 한쪽이 걸쳐있다는건데 이는 처음부분, 끝부분 중 하나라도 1초구간에 포함되면 그 로그는 ok라는거다.

그래서 O(N^2) 으로 마무리할 수 있다.

작성하면서 주의할 점은 "."으로 문자열 split 파싱할 때 `String[] sec = time[2].split("\\.");` 이렇게 이스케이프를 잘 붙여줘야한다.

그리고 

`long gapMs = (long) Double.parseDouble(s);`  이렇게 하니까 0.123같은걸 0으로 만들어버려서 double변수상태에서 1000을 곱하고 그 값을 long으로 만들었다. (소숫점 셋째짜리까지 존재하므로)


> ## 코드

```java
import java.util.*;

class Solution {
    static long[][] logs;
    public int solution(String[] lines) {
        int res = 0;
        logs = new long[lines.length][2];
        
        for(int i=0; i<lines.length; i++){
            // "2016-09-15 20:59:57.421 0.351s",
            String[] split = lines[i].split(" ");
            String[] time = split[1].split(":"); // 20, 59, 57.421
            String[] sec = time[2].split("\\."); // 57 421(소수점)
            String gap = split[2]; // 0.351s
            long endTime = getEndTime(time, sec);
            long startTime = getStartTime(endTime, gap);
            
            // System.out.println(startTime);
            // System.out.println(endTime);
            
            logs[i][0] = startTime;
            logs[i][1] = endTime;
        }
        
        List<Long> points = new ArrayList<>();
        for(int i=0; i<logs.length; i++){
            points.add(logs[i][0]);
            points.add(logs[i][1]);
        }
        
        for(long p : points){
            int cnt = 0;
            
            // |1초구간| 사이에 start나 end가 있어야함
            // logs[i][0]..1 -- |t -- logs[i][1]..1 ----- logs[i][0]..2 --- t+999| --- logs[i][1]..2
            for(int i=0; i<logs.length; i++){
                if(logs[i][0] <= p+999 && logs[i][1] >= p) cnt++;
            }
            
            res = Math.max(res, cnt);
        }
        
        
        return res;
    }
    
    private long getEndTime(String[] time, String[] sec){
        int h = Integer.parseInt(time[0]);
        int m = Integer.parseInt(time[1]);
        int s = Integer.parseInt(sec[0]);
        int ms = Integer.parseInt(sec[1]);
        
        return h * 3600 * 1000L + m * 60 * 1000L + s * 1000L + ms;
    }
    
    private long getStartTime(long endTime, String gap){
        String s = gap.substring(0, gap.length()-1); // s떼기
        // System.out.println(s);
        // long gapMs = (long) Double.parseDouble(s); // 소수점이 다 날아감 이렇게 하면 안됨
        double gapMs = Double.parseDouble(s);
        // System.out.println("gapMS : " + gapMs);
        
        long gapSec = (long) (gapMs * 1000);
        // System.out.println("gapSec : " + gapSec);
        
        return endTime - gapSec + 1;
    }
}
```