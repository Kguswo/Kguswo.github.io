---
title: "BOJ_15683_감시 (Java)"
date: 2025-02-10T18:03:32.215Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ15683감시-Java"
thumbnail: "../assets/posts/329d589893e31e61aaa0049c93f477ef20bb9927fd5a3cb3484bb436bc4ac5ac.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:03:07.069Z
  hash: "2b272decd656798d3ab993c07ff29a769a582316f0a544427e6822fb78c15427"
---

# [Gold III] 감시 - 15683 

[문제 링크](https://www.acmicpc.net/problem/15683) 

### 성능 요약

메모리: 44284 KB, 시간: 292 ms

### 분류

백트래킹, 브루트포스 알고리즘, 구현, 시뮬레이션

### 제출 일자

2025년 2월 11일 02:47:05

### 문제 설명

<p>스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.</p>

<table class="table table table-bordered" style="width: 100%;">
	<tbody>
		<tr>
			<td style="width: 20%; text-align: center; vertical-align: middle;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/1.png" style="width: 113px; height: 70px;"></td>
			<td style="width: 20%; text-align: center;vertical-align: middle;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/2.png" style="width: 156px; height: 70px;"></td>
			<td style="width: 20%; text-align: center;vertical-align: middle;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/3.png" style="width: 100px; height: 100px;"></td>
			<td style="width: 20%; text-align: center;vertical-align: middle;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/4.png" style="width: 138px; height: 100px;"></td>
			<td style="width: 20%; text-align: center;vertical-align: middle;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/5.png" style="width: 149px; height: 150px;"></td>
		</tr>
		<tr>
			<td style="width: 20%; text-align: center;">1번</td>
			<td style="width: 20%; text-align: center;">2번</td>
			<td style="width: 20%; text-align: center;">3번</td>
			<td style="width: 20%; text-align: center;">4번</td>
			<td style="width: 20%; text-align: center;">5번</td>
		</tr>
	</tbody>
</table>

<p>1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.</p>

<p>CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.</p>

<p>CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.</p>

<pre>0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0</pre>

<p>지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '<code>#</code>'로 나타내면 아래와 같다.</p>

<table class="table table table-bordered" style="width: 100%;">
	<tbody>
		<tr>
			<td style="width: 25%; text-align: center;">
			<pre>0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 # 6 0
0 0 0 0 0 0</pre>
			</td>
			<td style="width: 25%; text-align: center;">
			<pre>0 0 0 0 0 0
0 0 0 0 0 0
# # 1 0 6 0
0 0 0 0 0 0</pre>
			</td>
			<td style="width: 25%; text-align: center;">
			<pre>0 0 # 0 0 0
0 0 # 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0</pre>
			</td>
			<td style="width: 25%; text-align: center;">
			<pre>0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 # 0 0 0</pre>
			</td>
		</tr>
		<tr>
			<td style="width: 25%; text-align: center;">→</td>
			<td style="width: 25%; text-align: center;">←</td>
			<td style="width: 25%; text-align: center;">↑</td>
			<td style="width: 25%; text-align: center;">↓</td>
		</tr>
	</tbody>
</table>

<p>CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.</p>

<pre>0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5</pre>

<p>위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.</p>

<table class="table table table-bordered" style="width: 100%;">
	<tbody>
		<tr>
			<td style="width: 25%; text-align: center;">
			<pre>0 0 0 0 0 #
# 2 # # # #
0 0 0 0 6 #
0 6 # # 2 #
0 0 0 0 0 #
# # # # # 5</pre>
			</td>
			<td style="width: 25%; text-align: center;">
			<pre>0 0 0 0 0 #
# 2 # # # #
0 0 0 0 6 #
0 6 0 0 2 #
0 0 0 0 # #
# # # # # 5</pre>
			</td>
			<td style="width: 25%; text-align: center;">
			<pre>0 # 0 0 0 #
0 2 0 0 0 #
0 # 0 0 6 #
0 6 # # 2 #
0 0 0 0 0 #
# # # # # 5</pre>
			</td>
			<td style="width: 25%; text-align: center;">
			<pre>0 # 0 0 0 #
0 2 0 0 0 #
0 # 0 0 6 #
0 6 0 0 2 #
0 0 0 0 # #
# # # # # 5</pre>
			</td>
		</tr>
		<tr>
			<td style="width: 25%; text-align: center;">왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔</td>
			<td style="width: 25%; text-align: center;">왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕</td>
			<td style="width: 25%; text-align: center;">왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔</td>
			<td style="width: 25%; text-align: center;">왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕</td>
		</tr>
	</tbody>
</table>

<p>CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.</p>

<pre>0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0
</pre>

<p>위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.</p>

<pre># # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #
</pre>

<p>사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)</p>

<p>둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다. </p>

<p>CCTV의 최대 개수는 8개를 넘지 않는다.</p>

### 출력 

 <p>첫째 줄에 사각 지대의 최소 크기를 출력한다.</p>

> ## 문제 풀이

간단한 구현 문제

> ## 코드

```java
package BOJ_15683_감시;

/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static class Node{
        int r,c,type;
        public Node(int r,int c,int type){
            this.r=r;
            this.c=c;
            this.type=type;
        }
    }
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static int N, M, res = Integer.MAX_VALUE;
    static int[] dr = {-1, 0, 1, 0}, dc = {0, 1, 0, -1};
    static int[][] board;
    static List<Node> cctv = new ArrayList<>();
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
//        br = new BufferedReader(new InputStreamReader(System.in));
        br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_15683_감시/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        board = new int[N][M];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            for (int j = 0; j < M; j++) {
                board[i][j] = Integer.parseInt(st.nextToken());
                if(1 <= board[i][j] && board[i][j] <= 5 ) {
                    cctv.add(new Node(i, j, board[i][j]));
                }
            }
        }

        cctvComb(0, board);
        bw.write(String.valueOf(res));
        bw.flush();
        bw.close();
        br.close();
    }
    private static void cctvComb(int depth, int[][] currBoard) {
        if(depth == cctv.size()) {
            res = Math.min(res, count(currBoard));
            return;
        }

        Node currCCTV = cctv.get(depth);
        int[][] newBoard = new int[N][M];

        if(currCCTV.type == 1) {
            for(int k=0; k<4; k++){
                copyCurrBoard(currBoard, newBoard);
                changeCurrBoard(currCCTV, newBoard, k);
                cctvComb(depth+1, newBoard);
            }
        }
        else if(currCCTV.type == 2) {
            for(int k=0; k<2; k++){
                copyCurrBoard(currBoard, newBoard);
                changeCurrBoard(currCCTV, newBoard, k);
                changeCurrBoard(currCCTV, newBoard, k+2);
                cctvComb(depth+1, newBoard);
            }
        }
        else if(currCCTV.type == 3) {
            for(int k=0; k<4; k++){
                copyCurrBoard(currBoard, newBoard);
                changeCurrBoard(currCCTV, newBoard, k);
                changeCurrBoard(currCCTV, newBoard, (k+1)%4);
                cctvComb(depth+1, newBoard);
            }
        }
        else if(currCCTV.type == 4) {
            for(int k=0; k<4; k++){
                copyCurrBoard(currBoard, newBoard);
                changeCurrBoard(currCCTV, newBoard, k);
                changeCurrBoard(currCCTV, newBoard, (k+1)%4);
                changeCurrBoard(currCCTV, newBoard, (k+2)%4);
                cctvComb(depth+1, newBoard);
            }
        }
        else if(currCCTV.type == 5) {
            copyCurrBoard(currBoard, newBoard);
            for(int k=0; k<4; k++){
                changeCurrBoard(currCCTV, newBoard, k);
            }
            cctvComb(depth+1, newBoard);
        }
    }

    private static void changeCurrBoard(Node curr, int[][] currBoard, int k) { // cctv가 보는 한 방향 보기
        int nr = curr.r, nc = curr.c;
        while(true){
            nr += dr[k];
            nc += dc[k];
            if(nr < 0 || nr >= N || nc < 0 || nc >= M) break;
            if(currBoard[nr][nc] == 6) break;
            if(currBoard[nr][nc] == 0) currBoard[nr][nc] = -1;
        }
    }

    private static void copyCurrBoard(int[][] currBoard, int[][] newBoard) {
        for(int i=0; i<N; i++) {
            for(int j=0; j<M; j++) {
                newBoard[i][j] = currBoard[i][j];
            }
        }
    }

    private static int count(int[][] currBoard) {
        int cnt = 0;
        for(int i=0; i<N; i++) {
            for(int j=0; j<M; j++) {
                if(currBoard[i][j] == 0) cnt++;
            }
        }
        return cnt;
    }
}
```