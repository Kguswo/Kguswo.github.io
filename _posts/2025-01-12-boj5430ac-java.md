---
title: "BOJ_5430_AC (Java)"
description: '문제 링크 메모리: 92696 KB, 시간: 696 ms덱, 파싱, 구현, 문자열, 자료 구조2025년 1월 12일 18:00:57아무것도 없는 경우에 RRRRR만 하면 \[] 가 출력된다는 반례를 생각해내야한다!'
date: 2025-01-12T09:11:43.481Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ5430AC-Java"
thumbnail: "/assets/posts/917afead7a058616acec1d407fd8cb35fdb226933c6b2ce326c5be24db1d7dee.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:04:33.431Z
  hash: "84092e9bb31339233951afc18130e3538a104a3846e9e2e7f7d913cb86203a23"
---

# [Gold V] AC - 5430 

[문제 링크](https://www.acmicpc.net/problem/5430) 

### 성능 요약

메모리: 92696 KB, 시간: 696 ms

### 분류

덱, 파싱, 구현, 문자열, 자료 구조

### 제출 일자

2025년 1월 12일 18:00:57

### 문제 설명

<p>선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.</p>

<p>함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.</p>

<p>함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, "AB"는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, "RDD"는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.</p>

<p>배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.</p>

<p>각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.</p>

<p>다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)</p>

<p>다음 줄에는 [x<sub>1</sub>,...,x<sub>n</sub>]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ x<sub>i</sub> ≤ 100)</p>

<p>전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.</p>

### 출력 

 <p>각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/917afead7a058616acec1d407fd8cb35fdb226933c6b2ce326c5be24db1d7dee.png)

아무것도 없는 경우에 RRRRR만 하면 [] 가 출력된다는 반례를 생각해내야한다!

> ## 코드

```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;
	static StringBuilder sb = new StringBuilder();
	static int T, N;
	static String command, nums;
	static Deque<Integer> dq = new ArrayDeque<Integer>();
	static boolean isError, isReversed;
	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int T = Integer.parseInt(br.readLine());
		while(T-->0) {
			dq.clear();
			isError = false;
			isReversed = false;
			
			command = br.readLine();
			N = Integer.parseInt(br.readLine());
			nums = br.readLine();
			
			if(N == 0) {
				for(int i=0; i<command.length(); i++) {
					if(command.charAt(i) == 'R') continue;
					else {
						isError = true;
						break;
					}
				}
			}
			else {
				String[] split = nums.substring(1, nums.length()-1).split(",");
	//			System.out.println(Arrays.toString(split));
				for(String s : split) dq.offer(Integer.parseInt(s));
				
				for(int i=0; i<command.length(); i++) {
					if(command.charAt(i) == 'R') isReversed = !isReversed;
					else {
						if(dq.isEmpty()) {
							isError = true;
							break;
						}
						
					    if(isReversed) dq.pollLast();
					    else dq.pollFirst();
					}
				}
			}
			if(isError) sb.append("error").append("\n");
			else {
			/*
			출력을 간단하게 toArray로 하면 원소마다 , 뒤
			*/
//				if(isReversed) {
//					List<Integer> tmp = new ArrayList<Integer>();
//					while(!dq.isEmpty()) tmp.add(dq.pollLast());
//					sb.append(Arrays.toString(tmp.toArray())).append("\n");
//				}
//			    else sb.append(Arrays.toString(dq.toArray())).append("\n");
				sb.append("[");
			    if(isReversed) {
			        List<Integer> tmp = new ArrayList<>();
			        while(!dq.isEmpty()) tmp.add(dq.pollLast());
			        for(int i = 0; i < tmp.size(); i++) {
			            sb.append(tmp.get(i));
			            if(i < tmp.size() - 1) sb.append(",");
			        }
			    } else {
			        int size = dq.size();
			        for(int i = 0; i < size; i++) {
			            sb.append(dq.pollFirst());
			            if(i < size - 1) sb.append(",");
			        }
			    }
			    sb.append("]\n");
			}
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}
```