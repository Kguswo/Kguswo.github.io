---
title: "BOJ_11054_가장 긴 바이토닉 부분수열 (Java)"
date: 2024-10-01T22:46:47.972Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ11054가장-긴-바이토닉-부분수열-Java"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:52.907Z
  hash: "107d8f81feca1cfbabb00f1e4c5115a8b024af6b93724f8b523ada6766480df7"
---

# [Gold IV] 가장 긴 바이토닉 부분 수열 - 11054 
[문제 링크](https://www.acmicpc.net/problem/11054) 
### 성능 요약
메모리: 15564 KB, 시간: 132 ms
### 분류
다이나믹 프로그래밍
### 제출 일자
2024년 10월 2일 07:44:13
### 문제 설명
<p>수열 S가 어떤 수 S<sub>k</sub>를 기준으로 S<sub>1</sub> < S<sub>2</sub> < ... S<sub>k-1</sub> < S<sub>k</sub> > S<sub>k+1</sub> > ... S<sub>N-1</sub> > S<sub>N</sub>을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.</p>
<p>예를 들어, {10, 20, <strong>30</strong>, 25, 20}과 {10, 20, 30, <strong>40</strong>}, {<strong>50</strong>, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.</p>
<p>수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.</p>
### 입력 
 <p>첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 A<sub>i</sub>가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ A<sub>i</sub> ≤ 1,000)</p>
### 출력 
 <p>첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.</p>


> ## 문제 풀이

가장 긴 증가하는 부분수열을 풀 줄 알면 쉽게 풀 수 있다. 꺾이는 부분을 생각하면 되는데 이때부턴 감소하므로 그냥 응용해서 한 점에서 양쪽으로 반대로 구하고 -1해주면 된다.

### 코드
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;
	static int N, A[], ASC[], DESC[], ans[];
	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
//		br = new BufferedReader(new InputStreamReader(System.in));
		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		N = Integer.parseInt(br.readLine());
		A = new int [N];
		ASC = new int [N];
		DESC = new int [N];
		ans = new int[N];

		st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			A[i] = Integer.parseInt(st.nextToken());
		}
		
		// 오름차순
		for(int i=0; i<N; i++) {
			ASC[i] = 1;
			for(int j=0; j<i; j++) {
				if(A[j] < A[i] && ASC[i] < ASC[j] + 1) ASC[i] = ASC[j] + 1;
			}
		}
		
		// 내림차순
		for(int i=N-1; i>=0; i--) {
			DESC[i] = 1;
			for(int j=N-1; j>i; j--) {
				if(A[j] < A[i] && DESC[i] < DESC[j] + 1) DESC[i] = DESC[j] + 1;
			}
		}
		
		int max = -987654321;
        for (int i = 0; i < N; i++) {
            ans[i] = ASC[i] + DESC[i] - 1;
            max = Math.max(max, ans[i]);
        }
		
        bw.write(String.valueOf(max));
		bw.flush();
		bw.close();
		br.close();
	}
}

```