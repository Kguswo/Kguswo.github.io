---
title: "BOJ_20125_쿠키의 신체 측정 (Java)"
description: "  문제 링크  메모리: 21568 KB, 시간: 260 ms 구현 2025년 4월 11일 20:59:58"
date: 2025-04-11T12:05:25.448Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ20125쿠키의-신체-측정-Java"
thumbnail: "/assets/posts/a7223bff4f802fa2104e06984aa3484273a4748aac72a25638dea37572eb1dcd.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:01:30.749Z
  hash: "dbee083c09ce890c0a6febcbf4276bc14917c7ff3de9b5cc6143edd569923ddc"
---

# [Silver IV] 쿠키의 신체 측정 - 20125 
 
 [문제 링크](https://www.acmicpc.net/problem/20125) 
 
 ### 성능 요약
 
 메모리: 21568 KB, 시간: 260 ms
 
 ### 분류
 
 구현
 
 ### 제출 일자
 
 2025년 4월 11일 20:59:58
 
 ### 문제 설명
 
 <p>쿠키런은 데브시스터즈에서 제작한 모바일 러닝 액션 게임이다. 마녀의 오븐에서 탈출한 쿠키들과 함께 모험을 떠나는 게임으로, 점프와 슬라이드 2가지 버튼만으로 손쉽게 플레이할 수 있는 것이 특징이다.</p>
 
 <p>연세대학교를 졸업한 김강산 선배님이 데브시스터즈에 취직하면서 주변 사람들에게 쿠키런을 전파시켰다. 하지만 게임을 전파하던 중에 쿠키들에게 신체적으로 이상이 생기는 것을 발견하였다. 팔, 다리 길이가 임의적으로 변한 것이다. 때문에 긴급하게 각 쿠키들의 신체들을 측정하려고 한다.</p>
 
 <p>쿠키들은 신체를 측정하기 위해서 한 변의 길이가 <em>N</em>인 정사각형 판 위에 누워있으며, 어느 신체 부위도 판 밖으로 벗어나지 않는다. 판의 <em>x</em>번째 행, <em>y</em>번째 열에 위치한 곳을 (<em>x</em>, <em>y</em>)로 지칭한다. 판의 맨 왼쪽 위 칸을 (1, 1), 오른쪽 아래 칸을 (<em>N</em>, <em>N</em>)으로 나타낼 수 있다.</p>
 
 <p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/94002737-4414-4de5-8d1f-d80da455de7d/-/preview/"></p>
 
 <p>그림과 같이 쿠키의 신체는 머리, 심장, 허리, 그리고 좌우 팔, 다리로 구성되어 있다. 그림에서 빨간 곳으로 칠해진 부분이 심장이다. 머리는 심장 바로 윗 칸에 1칸 크기로 있다. 왼쪽 팔은 심장 바로 왼쪽에 붙어있고 왼쪽으로 뻗어 있으며, 오른쪽 팔은 심장 바로 오른쪽에 붙어있고 오른쪽으로 뻗어있다. 허리는 심장의 바로 아래 쪽에 붙어있고 아래 쪽으로 뻗어 있다. 왼쪽 다리는 허리의 왼쪽 아래에, 오른쪽 다리는 허리의 오른쪽 아래에 바로 붙어있고, 각 다리들은 전부 아래쪽으로 뻗어 있다. 각 신체 부위들은 절대로 끊겨있지 않으며 굽혀진 곳도 없다. 또한, 허리, 팔, 다리의 길이는 1 이상이며, 너비는 무조건 1이다.</p>
 
 <p>쿠키의 신체가 주어졌을 때 심장의 위치와 팔, 다리, 허리의 길이를 구하여라.</p>
 
 ### 입력 
 
  <p>다음과 같이 입력이 주어진다.</p>
 
 <div style="background:#eeeeee;border:1px solid #cccccc;padding:5px 10px;"><em>N</em><br>
 <em>a<sub>1,1</sub></em> . . . <em>a<sub>1,N</sub></em><br>
 . . . . . .<br>
 <em>a<sub>N,1</sub></em> . . . <em>a<sub>N,N</sub></em></div>
 
 ### 출력 
 
  <p>첫 번째 줄에는 심장이 위치한 행의 번호 <em>x</em>와 열의 번호 <em>y</em>를 공백으로 구분해서 출력한다.</p>
 
 <p>두 번째 줄에는 각각 왼쪽 팔, 오른쪽 팔, 허리, 왼쪽 다리, 오른쪽 다리의 길이를 공백으로 구분해서 출력하여라.</p>
 

> ## 문제 풀이

간단한 구현문제다. 내 생각에 내 코드는 별로 효율적인 것 같진 않다. 그냥 읽고 문제 풀면 풀 수 있는 문제다.

좀 더 나은 방향으로 풀자면 입력을 받으며 그때그떄 필요한 정보를 기억해놓고, 구할 수 있는 값을 구하는것이다.

머리 : 처음 별 하나 나올때 -> 이 정보로 심장 구할 수 있음 -> 심장 좌우로 팔 길이 구할 수 있음

심장 구했으면 -> 쭉 내려가면서 그 세로선으로 몸통 길이가 나옴 -> 몸통의 끝이 나온다는건 다음에 다리가 나온다는 것.

다리도 col 좌표 이미 머리 저장한 순간 구해지므로 세로로 2번 해도되고, 입력 받으면서 그 column별로 각각 1씩 더해주면서 진행해도됨.

내 생각에 가장 효율적인건 입력을 받으면서 모두 계산하고 (필요한 반복문 만큼만) 바로 정답 출력하는것.

> ## 코드

```java
/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;

    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        //br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_20125_쿠키의신체측정/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine());
        char[][] board = new char[N][N];

        int[] head = new int[2];
        boolean firstStar = false;

        int[] heart = new int[2];

        int armLen = 0;

        int[] belly = new int[2];

        for (int i = 0; i < N; i++) {
            String line = br.readLine();
            int cnt = 0;
            for (int j = 0; j < N; j++) {
                board[i][j] = line.charAt(j);
                if (board[i][j] == '*' && !firstStar) {
                    firstStar = true;
                    head[0] = i;
                    head[1] = j;
                }

                if (board[i][j] == '*') {
                    cnt++;
                    if (cnt >= 3) {
                        heart[0] = i;
                        heart[1] = head[1];
                    }
                }
                if (i == heart[0]) armLen = cnt;
            }
        }

        int legR = 0;
        for (int i = head[0]; i < N; i++) {
            if (board[i][head[1]] != '*') {
                legR = i;
                break;
            }
        }
        belly[1] = head[1];
        belly[0] = legR - 1;

        List<Integer> l_list = new ArrayList<>();
        for (int j = head[1] - 1; j <= head[1] + 1; j += 2) {
            int l_cnt = 0;
            for (int i = legR; i < N; i++) {
                if (board[i][j] == '*') {
                    l_cnt++;
                } else break;
            }
            l_list.add(l_cnt);
        }

        int a_cnt = 0;
        for (int j = 0; j < N; j++) {
            if (j >= (heart[1] + 1) && board[heart[0]][j] == '*') {
                a_cnt++;
            }
        }

        StringBuilder sb = new StringBuilder();
        sb.append(heart[0] + 1).append(" ").append(heart[1] + 1).append("\n");
        sb.append(armLen - (1 + a_cnt)).append(" ").append(a_cnt).append(" ").append(belly[0] - heart[0]).append(" ").append(l_list.get(0)).append(" ").append(l_list.get(1));
        System.out.println(sb.toString());

        br.close();
    }
}

```