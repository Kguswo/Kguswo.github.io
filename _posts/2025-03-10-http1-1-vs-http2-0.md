---
title: "HTTP/1.1 vs HTTP/2.0"
date: 2025-03-09T18:13:59.241Z
tags: ["백엔드"]
slug: "HTTP1.1-vs-HTTP2.0"
image: "../assets/posts/9e00af19a9ddd8dce732d57c502a9586367df97c505830cf0b9e959e0682ddd7.png"
categories: 공부
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:02:13.559Z
  hash: "8caf213ba40dc21c00fdac0cdb5ddab81f6a83935424473d4637cfea08245cad"
---

### HTTP/1.1
HTTP는 웹상에서 클라이언트와 서버간의 통신을 위한 프로토콜이다. HTTP/1.0의 경우 한개의 요청과 응답마다 TCP 커넥션을 생성하여 사용되었다. 하지만 이러한 요청은 매 요청마다 연결을 생성하는 오버헤드가 발생한다. **HTTP/1.1**은 이러한 문제를 **지속 커넥션 (Persistent Connection)** 이라는 지정한 타임아웃만큼 커넥션을 종료하지 않는 방식으로 해결한다.

또한 **Pipelining(파이프라이닝)**을 지원하여 요청의 응답 지연을 감소한다. 파이프라이닝에서 HTTP요청은 연속적이며, 순차적으로 전달된다. 기존에는 요청한 이후에 응답을 기다리고 그 다음 요청을 보냈지만, 파이프라이닝에선 필요한 모든 자원에 대한 요청을 순차적으로 서버로 전송한 다음 모든 요청에 대한 응답을 한 번에 기다린다.

HTTP/1.1은 1.0버전에 비해 상당히 개선되었지만 여전히 문제가 존재했다. 대표적으로 **Head-of-Line Blocking(HOL Blocking) 문제**가 있다. 
만약 3개의 요청을 파이프라인을 통해 전송을 한다고 했을때, 서버는 모든 요청을 순서에 맞춰서 응답해야한다. 이때 첫번째 요청이 오래 걸린다면, 나머지 요청은 첫번째 요청의 처리를 기다려야한다. 또한 1.1버전은 매 요청마다 **동일한 헤더를 반복하여 전송한다는 문제점**도 존재한다.

### HTTP/2.0
HTTP/1.1은 메시지를 일반 텍스트 형식으로 전송했다. 2.0부터는 기존 HTTP메시지를 프레임이라는 단위로 분할하고 이를 바이너리 형태로 만들어서 전송한다. 따라서, 기존 1.1버전에 비해 파싱 및 전송 속도가 향상되었다. 

또한, HTTP/2.0부터는 **Multiplexing(멀티플렉싱)**을 지원한다. 이는 하나의 커넥션을 사용하여 요청과 응답을 병렬로 처리할 수 있는 방식이다. 클라이언트가 서버로 여러 요청을 동시에 보내도 각 요청이 독립적으로 처리되기 때문에 애플리케이션 레이어의 HOL Blocking 문제를 해결한다. 또한 **HPACK 헤더 압축 방식**을 사용해 반복되는 헤더를 효율적으로 관리하여 대역폭 사용이 최적화되었다.

![](/assets/posts/d111469ed20a130e3abfa601a17697cc2344ed63a6b1c04f55672e086e3c2dcd.png)

### References
- [HTTP/2 For Web Developers](https://blog.cloudflare.com/http-2-for-web-developers/)