---
title: "Operating System Concepts"
date: 2024-07-07T12:25:40.620Z
tags: ["공룡책","운영체제"]
slug: "운영체제"
image: "../assets/posts/24041eca271ee637a6dfb4f987e9336ae4e7c2d30494cd4ff0dc07b8071f94f8.PNG"
categories: 운영체제
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:06:29.894Z
  hash: "1f5880585613c1e8d3118b6f413ad99728abb45904fbe7f14fc5a97f3604bc50"
---

> ### 운영체제 개요 (Ch1. Overview)

**운영체제란?** 

컴퓨터 하드웨어를 관리하는 소프트웨어. 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다.
컴퓨터에서 항상 실행되는 프로그램이다. (일반적으로 커널이라고 함)


**운영체제의 목적** : 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공.

컴퓨터 시스템 - 하드웨어 , 운영체제, 응용프로그램, 사용자로 구성.
- 하드웨어 : 중앙처리장치 (CPU) + 메모리 및 입출력장치(I/O)로 구성, 기본 계산용 자원 제공.
- 응용프로그램 : 워드프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등 사용자의 계산문제 해결을 위해 자원이 어떻게 사용될 지 정의.
---
**사용자 관점**
사용자는 PC앞에서 작업하고 시스템의 목표는 사용자가 수행하는 작업을 최대화하는 것이다. 운영체제는 사용의 용이성을 위해 설계되었으며 사용자들이 자원을 공평하게 사용할 수 있도록 한다.

**시스템 관점**
컴퓨터 관점에서 운영체제는 하드뒈어와 가장 밀접한 프로그램이므로 **`자원할당자`**로 볼 수 있음. 컴퓨터 시스템은 문제를 해결하기위해 요구되는 자원들 즉, CPU시간, 메모리공간, 저장장치 공간, 입출력장치 등을 가진다. 다른 관점으로는 여러가지 입출력 장치와 사용자 프로그램을 제어하는 **`제어프로그램`** 으로도 본다.

**운영체제의 기능**
- CPU스케줄링 : CPU가 어떤 프로그램에게 CPU사용권을 줄 지 결정
- 메모리 관리 : 한정된 메모리를 어떻게 쪼개어 쓸 지 결정 - 운영체제 및 여러 프로그램들
- 디스크 스케줄링 : 디스크에 들어온 요청을 어떤 순서로 처리할 지 결정
- 인터럽트, 캐싱 : 빠른 CPU와 느린 I/O 장치간 속도차를 어떻게 극복할 지 결정
(ps. CPU는 일반적으로 메모리에 비해 100배 빠르고 디스크에 비해 100만배 빠르다)


#### 운영체제의 분류
- 동시 작업 가능 여부
  - Single tasking(단일 작업) : 한 번에 하나의 작업만 처리 
  ex) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음
  - Multi tasking(다중 작업) : 동시에 두 개 이상의 작업 처리 
  ex) UNIX/MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음
- 사용자의 수
  - Single User(단일 사용자)
  ex) MS-DOS, MS Windows
  - Multi User(다중 사용자)
  ex) UNIX, NT server
- 처리 방식
  - Batch Processing(일괄 처리)
    - 작업 요청의 일정량 모아서 한꺼번에 처리
    - 작업이 완전 종료될 때까지 기다려야 함
    ex) 초기 Punch Card 처리 시스템
  - Time Sharing(시분할)
    - 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용
    - 일괄 처리 시스템에 비해 짧은 응답 시간을 가짐 : UNIX 등
    - Interactive한 방식
  - Realtime OS(실시간 운영체제)
    - 처리기의 작동이나 데이터의 흐름에 엄격한 시간제약이 있을 때 사용
    - 정해진 시간안에 어떤 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS
    ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어
    - 확장 
    1. Hard realtime system(경성 실시간 시스템)
    2. Soft realtime system(연성 실시간 시스템) - 비디오
    
---
>### CPU 스케줄링 (p.226 참조)

**스케줄링 알고리즘**
CPU 스케줄링은 준비 큐에 있는 어느 프로세스이 CPU코어를 할당할 것인지를 결정하는 문제를 다룬다. 최신 CPU아키텍처에는 여러개의 처리코어가 있지만 한개의 처리코어를 가진 CPU가 한개인 시스템으로 가정해 한번에 1개의 프로세스를 실행할 수 있다고 생각하자.

**1. First-Come, First-Served Scheduling(선입 선처리 스케줄링)**
- 가장 간단한 CPU스케줄링 알고리즘
- CPU를 먼저 요청하는 프로세스가 먼저 할당한다. FIFO 선입선출 방식(구현이 쉬움)
- 프로세스 처리 순서에 따라 성능이 매우 달라진다.
- 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 Convoy Effect(호위효과)가 발생할 수 있다. 
- 먼저 온 프로세스가 끝날때까지 운영체제가 개입하지 않는 **`비선점 스케줄링`** 방식에 주의!

**2. Shortest-Job-First-Scheduling (최단 작업 우선 스케줄링)**
- Shortest-next-CPU-burst; 최단 다음 CPU 버스트 알고리즘
- 가장 작은 CPU버스트를 가진 프로세스를 할당한다.
- 위 Convoy Effect를 해결할 수 있다.
- 주어진 프로세스 집합에 대해 최소의 평균 대기시간을 가지기 때문에 최적이라 할 수 있다. 하지만 다음 CPU버스트 길이를 할 순 없어 근사값을 구한다.
  - 일반적인 CPU버스트 길이(다음 CPU버스트 예상하기 위함) : `Tn+1 = a*Tn _ (1+a)Tn , (0 <= a <= 1)`
- CPU버스트 시간이 긴 프로세스는 계속 밀려 Starvation Effect가 발생할 수 있다. -> 영원히 수행될 수 없음
- 버스트 시간이 짧은 프로세스가 끝날때까지 운영체제가 개입하지 않는 **`비선점 스케줄링`** 방식

**3. Round-Robin Scheduling (라운드 로빈 스케줄링)**
- 선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨다닐 수 있도록 선점이 추가된다.
- Time quantum(시간 할당량) 단위로 여러 프로세스를 번갈아가며 프로세서에 할당.
- CPU스케줄러는 준비 큐를 돌면서 한번에 한 프로세스에 한 번의 시간 할당량동안 CPU를 할당한다.
- 한번의 시간할당량 이후에 인터럽트를 걸도록 (timer)타이머를 설정한 후 프로세스를 dispatch한다(준비상태에서 실행상태로).
- 시간 할당량에 따라 운영체제가 계속 개입하는 **`선점 스케줄링 방식`**!

> ### 메모리 관리 (p.452 참조)

**Memory Management**

메인 메모리는 현대 컴퓨터 시스템의 핵심이며, 바이트의 대용량 배열이다. 그리고 각 바이트는 자신의 주소를 가진다. 프로그램이 수행될 때 절대 주소(Abolute addresses)로 매핑(Mapping)되어 메모리에 로드되고 메모리의 프로그램 명령어와 데이터에 접근한다. 메모리 관리는 여러 요인을 고려해야 하는 작업이며, 특히 시스템의 **`하드웨어 설계`**에 좌우된다.

운영체제는 메모리 관리를 위해 메모리의 어떤 부분이 어디에 쓰이는지, 누가 사용하는지 추적하고, 어떤 프로세스와 데이터가 메모리의 안팎으로 옮겨질지 결정한다. 또한 메모리 공간을 할당하고 해제하는 것도 운영체제가 하는 일이다.

**Page Replacement**
- 한정적인 메모리를 효율적으로 사용하기 위한 기법, 메모리에 올려진 페이지 중 어떤 것을 내리고 어떤 새로운 페이지를 올릴지를 결정하는 규칙이다.

- 페이지 결함이 발생할 때 페이지 교체 절차
  1. 디스크에서 페이지의 위치를 찾는다
  2. 빈 프레임을 찾는다. 빈 프레임이 있으면 거기 페이지를 적재하고, 없으면 페이지 교체 알고리즘을 이용하여 희생 프레임을 선택한다. 이후 희생 프레임에 있는 페이지를 디스크에 쓰고,  프레임에 새 페이지를 적재한다.
  3. 페이지 테이블과 프레임 테이블을 변경한다.
  4. 프로세스를 재개한다.
  
**1. FIFO 페이지 교체**
- 가장 먼저 메모리에 올려진 페이지를 교체하는 방식
- 현실성과 효율성이 떨어져서 실제로 잘 사용되지는 않는다. 
 
**2. Optimal Page Replacement(최적 페이지 교체)** 
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 방식
- 일반 OS에서는 구현 불가(예측이 불가능 하기 때문)

**3. LRU Page Replacement(LRU 페이지 교체)**
- 최근의 과거를 가까운 미래의 근사치로 본다면 가장 오랜기간 사용되지 않은 페이지를 교체하는 방식.
- LRU알고리즘은 페이지마다 마지막 사용시간을 유지.
- Counters(계수기)방식 혹은 Stack(스택) 방식으로 구현
  - Counters방식 : 각 페이지 항목마다 사용 시간 필드를 넣고 CPU에 논리적인 시계나 계수기를 추가. 메모리가 접근될 때 마다 시간 증가. 페이지 테이블이 변경될 때 마다 시간 값을 관리해야하며 시간값의 Overflow도 고려해야함.
  - Stack방식 : 페이지 번호의 스택을 유지하는 방법. 페이지가 참조될 대 마다 페이지 번호는 스택 중간에서 제거되어 Top에 위치하게 되고 Bottom은 가장 오랫동안 이용되지 않은 페이지. Doubly Linked List로 구현.
- 프로세스에 프레임을 더 주었는데 오히려 페이지 폴트율은 더 증가하는 Belady's anomaly를 야기하지 않는다. 
(ps. *페이지 폴트는 프로세스가 참조하려는 가상 메모리 페이지가 현재 물리적 메모리에 로드되어 있지 않을 때 발생. 이는 메모리 접근 시도 중에 발생하는 인터럽트 또는 예외 상황.)

**4. Least Frequently Used 알고리즘(LFU)**
- 참고횟수가 가장 적은 페이지를 교체하는 방식
- why? 활발하게 사용되는 페이지는 큰 참조 횟수값을 갖게될거라는 점
- 맹점 : 어떤 프로세스가 그 초기단계에서는 한 페이지를 집중적으로 많이 사용하지만 그 후로 다시는 이 페이지를 사용하지 않는 경우
- 해결책 : 참조 횟수를 **일정한 시간마다 하나씩 오른쪽으로 시프트**해서 지수적으로 그 영향력을 감소시킬 수는 있다.

**5. Most Frequently Used 알고리즘(MFU)**
- 반대로 가장 작은 참조회수를 가진 페이지가 가장 최근 참조된것이고, 앞으로 사용될 것이라는 판단에 근거한다. 

> ### 디스크 스케줄링 (p.492, 500참조)

#### Access time(디스크 접근시간)의 구성
- Seek Time(탐색시간) - 디스크 암을 원하는 실린더로 이동하는데 필요한 시간
- Rotational latency(회전지연) - 원하는 섹터가 디스크 헤드 위치까지 회전하는 데 걸리는 시간
- Transfer time - 드라이브와 컴퓨터 간의 데이터 흐름의 속도

#### Disk Scheduling(디스크 스케줄링)
- seek time을 최소화 하는것이 목표
- seek time = seek distance

#### 1. FCFS Scheduling(선입 선처리 스케줄링)
- 가장 단순한 방법, 헤드 움직임을 최적화 하지 않기 때문에 성능은 나쁠 수 있다.

#### 2. SSTF Scheduling(Shortest Seek Time First)
- 탐색 시간이 가장 작은 것부터 처리하는 방식
- 문제점 : Starvation 현상

#### 3. SCAN Scheduling(SCAN 스케줄링)
- Disk Arm(디스크 암)이 디스크의 한 끝에서 시작하여 다른 끝으로 이동하며, 가는 길에 있는 요청을 모두 처리하는 방식.
- 다른 한쪽 끝에 도달하면 (또는 그쪽 방향으로 더는 대기하고 있는 요청이 없으면) 역방향으로 이동하면서 오는 길에 있는 요청을 모두 처리한다. 즉 헤드는 디스크 양쪽을 계속해서 가로지르며 왕복한다.
- 흡사 엘리베이터와 비슷하다고 하여 Elevator Algorithm이라고도 부른다.

> ### 저장장치 계층구조와 캐싱(Caching) (p.14, 33 참조)

#### Interrupt(인터럽트)

컨트롤러가 장치 드라이버에게 작업을 사실을 어떻게 알릴까? 인터럽트를 통해서!
- 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. 인터넙트는 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.
- 즉 컴퓨터에서 신호를 보내 이벤트 발생을 알리는 것을 의미한다.
- 보통 컴퓨터에서 여러 작업을 동시에 처리하는데, 기존 작업을 중단하고 타 작업을 진행해야 할 때 인터럽트 신호를 보내 기존작업을 중단하라고 신호를 보낸다. 그러면 커널이 작업을 멈추고 인터럽트 처리한 뒤 기존 작업으로 돌아온다.
![출력을 수행하고 있는 단일 프로세스에 대한 인터럽트 시간 일정](/assets/posts/78d030a8c4f1e7cf2189144a84855433f033126ad1d30bd4329e8f90ff2fb304.png)
- Trap(트랩) : 소프트웨어에 의해 발생하는 인터럽트
- 하드웨어는 **`System Bus(시스템 버스)`** 를 통해 CPU에 신호 보내서 인터럽트 발생시키고, 소프트웨어는 **`System Call(시스템 콜)`** 이라는 명령으로 인터럽트 발생시킨다.

#### Cache Management(캐시 관리)
- 굉장히 빠르가 작은 저장장치
- Caching (캐싱) : 캐시메모리를 사용해 컴퓨터의 속도를 높이는 기술
- 우리가 특정 정보가 필요할 경우, 우리는 먼저 캐시에 그 정보가 있는지를 조사한다.
  - 만약 캐시에 있으면 그 정보를 캐시로부터 직접 사용
  - 만약 없으면 메인 메모리 시스템으로부터 그 정보를 가져와서 사용하고, 다음에 곧 사용될 확률이 높다는 가정하에 캐시에 넣는다.

![저장장치 계층 구조](/assets/posts/26c4b9c6e62e9d864fac73b958c463438b5315027d7e4fcf1748daf639b153dd.jpg)

#### 플래시 메모리
- 플래시 메모리
  - 반도체 장치(하드 디스크 : 마그네틱)
  - NAND형(스토리지), NOR형(임베디드 코드저장용)
- 플래시메모리의 특징
  - Nonvolatile
  - Low power consumption
  - Shock resisteance
  - Small size
  - Lightweight
  - 쓰기 횟수 제약
- 플래시메모리의 사용 형태
  - 휴대폰, PDA등 임베디드 시스템 구성용
  - USB용 메모리 스틱
  - 디지털카메라 등의 SD카드, CompactFlash, Smart Media card
  - 모바일 장치 뿐 아니라 대용량 시스템에서 SSD(Solid State Drive)란 이름으로 하드디스크 대체 시도
![여러 저장장치의 특성](/assets/posts/e7ee5dd05f1f00c125fddc7dc4d58eb519020cb1ae413053054f2112c349d444.jpg)
> 운영체제의 분류 p16

### 추가 학습
#### 용어
- `Multitasking`
- `Multiprogramming`
- `Time sharing`
- `Multiprocess`
- 구분
  - 위 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻한다.
  - Multiprogramming은 여러 프로그램이 메모리에 올라가 있음을 강조
  - Time Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조
  * *`Multiprocessor` : 하나의 컴퓨터에 CPU가 여러개 붙어있음을 의미


### 출처(참고문헌)
[Bélády's anomaly](https://medium.com/@ioseunggi/beladys-anomaly-4d2bafe4f735)