---
title: ".NET Core MVC + Dapper"
date: 2026-01-06T18:46:36.702Z
tags: []
slug: ".NET-Core-MVC-Dapper"
image: "../assets/posts/8e9d380155281fdfb903ae902701d9b23ab9693c7960fdd40a3ae3040c136964.png"
categories: dotnet
toc: true
velogSync:
  lastSyncedAt: 2026-01-07T01:50:23.755Z
  hash: "d5c71a5eab0542ae26d66e28c2a062ccccd48148beb1b8e7c4005b4c7b80d2d9"
---

### 들어가며

Dapper는 Stack Overflow 팀이 만든 **Micro ORM** 이다. Entity Framework처럼 무거운 ORM 대신, SQL을 직접 작성하면서도 객체 매핑은 자동으로 해주는 가벼운 도구다.

Java 개발자 관점에서 보면, **Spring JDBC Template** 또는 **MyBatis** 와 비슷한 위치에 있다. JPA처럼 SQL을 추상화하지 않고, 개발자가 직접 쿼리를 작성한다.

이 글에서는 .NET Core MVC 프로젝트에서 Dapper를 사용해 기본적인 CRUD를 구현하는 과정을 정리한다. Java 경험이 있는 개발자가 C#으로 넘어올 때 참고할 수 있도록, 두 언어의 개념을 비교하며 설명한다.

<br/>

## 프로젝트 구조

최종적으로 완성되는 프로젝트 구조는 다음과 같다.

```
DapperMvcDemo/
├── Data/
│   └── DapperDbContext.cs       ← DB 연결 관리
├── Models/
│   └── ProductModel.cs          ← 엔티티
├── Repositories/
│   ├── IProductRepository.cs    ← 인터페이스
│   └── ProductRepository.cs     ← Dapper 쿼리 실행
├── Controllers/
│   └── ProductsController.cs    ← 요청 처리
├── Views/Products/
│   ├── Index.cshtml             ← 목록
│   ├── Create.cshtml            ← 등록
│   ├── Edit.cshtml              ← 수정
│   └── Delete.cshtml            ← 삭제
├── Program.cs                   ← DI 등록
└── appsettings.json             ← 연결 문자열
```

Java Spring 프로젝트와 비교하면 이렇다.

| C# .NET Core | Java Spring |
|--------------|-------------|
| Models/ | domain/ 또는 entity/ |
| Repositories/ | repository/ |
| Controllers/ | controller/ |
| Views/ | templates/ (Thymeleaf) |
| Program.cs | @Configuration 클래스 |
| appsettings.json | application.properties |

<br/>

## 환경 설정

### 프로젝트 생성 및 패키지 설치

```bash
dotnet new mvc -n DapperMvcDemo
cd DapperMvcDemo
dotnet add package Dapper
dotnet add package Microsoft.Data.SqlClient
```

Java로 치면 `build.gradle`이나 `pom.xml`에 의존성을 추가하는 것과 같다.

### 연결 문자열 설정 (appsettings.json)

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server={SSMS 연결할때 쓴 본인 서버이름};Database=SampleDB;Trusted_Connection=true;TrustServerCertificate=true;"
  }
}
```

> SSMS에서 SSL 인증서 오류가 발생하면 연결 옵션에서 **서버 인증서 신뢰** 를 체크하면 된다.
{: .prompt-tip }

<br/>

## DbContext - 연결 관리 클래스

### DapperDbContext.cs

```csharp
public class DapperDbContext
{
    private readonly IConfiguration _configuration;
    private readonly string _connectionString;

    public DapperDbContext(IConfiguration configuration)
    {
        _configuration = configuration;
        _connectionString = configuration.GetConnectionString("DefaultConnection");
    }

    public IDbConnection CreateConnection() => new SqlConnection(_connectionString);
}
```

이 클래스의 역할은 단순하다. **연결 문자열을 보관하고, 필요할 때 DB 연결 객체를 생성** 해주는 것이다.

Java로 비유하면 `DataSource` 또는 `ConnectionFactory`에 해당한다. `CreateConnection()` 메서드는 `dataSource.getConnection()`과 같은 역할을 한다.

#### Q. 왜 이렇게 분리하는가? 

연결 문자열을 한 곳에서 관리하기 위해서다. 여러 Repository에서 각자 연결 문자열을 하드코딩하면 유지보수가 어려워진다.

<br/>

## Repository 패턴

### 인터페이스 정의 (IProductRepository.cs)

```csharp
public interface IProductRepository
{
    Task<IEnumerable<ProductModel>> GetAll();
    Task<ProductModel> GetById(Guid id);
    Task<ProductModel> Create(ProductModel model);
    Task<ProductModel> Update(ProductModel model);
    Task Delete(Guid id);
}
```

Java의 `JpaRepository` 인터페이스를 직접 정의한다고 생각하면 된다.

여기서 낯선 키워드들이 보인다.

| C# | Java 대응 | 설명 |
|----|-----------|------|
| `Task<T>` | `CompletableFuture<T>` | 비동기 결과를 담는 래퍼 |
| `IEnumerable<T>` | `List<T>` / `Iterable<T>` | 컬렉션 인터페이스 |
| `Guid` | `UUID` | 고유 식별자 |

<br/>

### 구현 클래스 (ProductRepository.cs)

```csharp
public class ProductRepository : IProductRepository
{
    private readonly DapperDbContext _context;

    public ProductRepository(DapperDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<ProductModel>> GetAll()
    {
        var sql = "SELECT * FROM Products";
        using var connection = _context.CreateConnection();
        return await connection.QueryAsync<ProductModel>(sql);
    }

    public async Task<ProductModel> GetById(Guid id)
    {
        var sql = "SELECT * FROM Products WHERE ProductId = @Id";
        using var connection = _context.CreateConnection();
        return await connection.QueryFirstOrDefaultAsync<ProductModel>(sql, new { Id = id });
    }

    public async Task<ProductModel> Create(ProductModel model)
    {
        model.ProductId = Guid.NewGuid();
        model.CreatedOn = DateTime.Now;

        var sql = @"INSERT INTO Products 
                    (ProductId, ProductName, Price, ProductDescription, CreatedOn)
                    VALUES 
                    (@ProductId, @ProductName, @Price, @ProductDescription, @CreatedOn)";

        using var connection = _context.CreateConnection();
        await connection.ExecuteAsync(sql, model);
        return model;
    }

    // Update, Delete도 동일한 패턴...
}
```

### Dapper 메서드 패턴

모든 메서드가 다음과 같은 비슷한 패턴을 따른다.

```csharp
public async Task<리턴타입> 메서드명(파라미터)
{
    // 1. SQL 작성
    var sql = "쿼리문";

    // 2. 연결 생성 (자동 종료)
    using var connection = _context.CreateConnection();

    // 3. 실행
    await connection.XXXAsync(sql, 파라미터);

    // 4. 리턴
    return 결과;
}
```

`using var`는 Java의 **try-with-resources** 와 같다. 블록이 끝나면 자동으로 `connection.Dispose()`가 호출되어 연결이 종료된다.

### 작업별 Dapper 메서드

| 작업 | Dapper 메서드 | 리턴 타입 |
|------|---------------|-----------|
| SELECT 여러 개 | `QueryAsync<T>` | `IEnumerable<T>` |
| SELECT 하나 | `QueryFirstOrDefaultAsync<T>` | `T` 또는 `null` |
| INSERT/UPDATE/DELETE | `ExecuteAsync` | `int` (영향받은 행 수) |

<br/>

## Controller

### ProductsController.cs

```csharp
public class ProductsController : Controller
{
    private readonly IProductRepository _repository;

    public ProductsController(IProductRepository repository)
    {
        _repository = repository;
    }

    public async Task<IActionResult> Index()
    {
        var products = await _repository.GetAll();
        return View(products);
    }

    [HttpPost]
    [ValidateAntiForgeryToken]
    public async Task<IActionResult> Create(ProductModel model)
    {
        if (ModelState.IsValid)
        {
            await _repository.Create(model);
            return RedirectToAction(nameof(Index));
        }
        return View(model);
    }

    // Edit, Delete도 동일한 패턴...
}
```

`IActionResult`는 Controller 메서드가 반환할 수 있는 **모든 응답 타입의 인터페이스** 다. Java Spring의 `ResponseEntity<?>`와 비슷하다.

| C# 메서드 | 역할 | Java Spring 대응 |
|-----------|------|------------------|
| `View()` | 뷰 페이지 반환 | `return "viewName"` |
| `RedirectToAction()` | 리다이렉트 | `redirect:/path` |
| `NotFound()` | 404 응답 | `ResponseEntity.notFound()` |

<br/>

## 의존성 주입 (DI) 등록

### Program.cs

```csharp
var builder = WebApplication.CreateBuilder(args);

// 서비스 등록
builder.Services.AddSingleton<DapperDbContext>();
builder.Services.AddScoped<IProductRepository, ProductRepository>();

builder.Services.AddControllersWithViews();

var app = builder.Build();
// ...
```

Java Spring에서는 `@Repository`, `@Service` 어노테이션만 붙이면 자동으로 빈이 등록된다. 하지만 C#에서는 **직접 등록** 해야 한다.

```csharp
builder.Services.AddScoped<IProductRepository, ProductRepository>();
//                         ↑ 인터페이스          ↑ 구현 클래스
```

이 등록을 빠뜨리면 다음 에러가 발생한다.

![](/assets/posts/8e9d380155281fdfb903ae902701d9b23ab9693c7960fdd40a3ae3040c136964.png)


```
InvalidOperationException: Unable to resolve service for type 
'IProductRepository' while attempting to activate 'ProductsController'.
```

> DI 등록을 잊으면 Controller에서 Repository를 주입받을 수 없다. 에러 메시지가 길지만, 핵심은 **"해당 타입을 찾을 수 없다"** 는 것이다.
{: .prompt-warning }

<br/>

## 결과

#### 상품목록 뷰 및 DB
![](/assets/posts/22d0bab7495c1f67acbfd7cd0bf232861dad7df18f49d8bdd0df06ef824ae91f.png)

![](/assets/posts/bb4ecc3be1f1c2fce842b7f615486306e01d10faff07341e7d78683851c57fd9.png)


#### 상품등록 뷰
![](/assets/posts/09f0166367456decb0ace765a84602d8c33d73848413aaab2b84be04a7ff1d13.png)



#### 상품등록 후 목록 및 DB
![](/assets/posts/da5ecd9c86e74acb58b033d6cdd21daf94b75290aff2c2c7a2a73482664e067d.png)

![](/assets/posts/c4730a215ab9b87eccdad365b94710f7215a57c3e5008fd92ba52a18dc2eff36.png)

#### 상품상세 뷰
![](/assets/posts/9bd90a83cfe9aec832de0686000a7333304eba560a5e6f8d47329645961d7c26.png)

#### 상품수정 뷰
![](/assets/posts/dfbd46b52608507435088ff236fcdc017279b92636deab1c030273becfa74eea.png)

#### 수정 후
![](/assets/posts/080d4175f7865e03911a7558d3f70fbb62b04a753bd7b18afd684640f870020e.png)
![](/assets/posts/58dad56a0fc960bc1bdb89f80e8f961d7bf4bc36b79e3867e4e71375300019ea.png)

#### 삭제
![](/assets/posts/451c06acea5db448d9635c919ba811272b4ad286d99d912125dac38f0922ac5e.png)
![](/assets/posts/49248b88f38f5a7722432e0564c2efbc7a4b18f626955ea932adc4d3200a9ca1.png)



<br/>

## 트러블슈팅

### 1. SSMS SSL 인증서 오류

```
신뢰되지 않은 기관에서 인증서 체인을 발급했습니다
```

**해결:** 연결 창 → 옵션 → 연결 속성 → **서버 인증서 신뢰** 체크

### 2. SQL 문법 오류
코드 작성 시 문자열을 적는것과 같은 판정이므로 오타나 빨간줄이 보이지 않아 주의해서 적어야한다! 여기서 오타나 문법 오류가 생기면 찾기 상당히 힘들다.

```csharp
var sql = @"";
```

### 2. 파라미터 전달 오류

```csharp
// ❌ 잘못된 예
await connection.ExecuteAsync(sql, new { model });

// ✅ 올바른 예
await connection.ExecuteAsync(sql, model);
```

`new { model }`로 감싸면 `model`이라는 이름의 프로퍼티를 가진 익명 객체가 되어버린다. Dapper는 객체의 프로퍼티 이름과 SQL의 `@파라미터명`을 매칭하므로, 객체를 직접 전달해야 한다.

<br/>

### 마치며

Dapper + .NET Core MVC로 CRUD를 구현하는 과정을 정리했다. 핵심 원칙을 요약하면 다음과 같다.

- **DbContext** 는 연결 문자열을 관리하고 연결 객체를 생성하는 역할이다
- **Repository 패턴** 은 SQL 작성 → 연결 생성 → 실행 → 리턴의 일관된 구조를 따른다
- `using var`는 Java의 try-with-resources와 같다. 연결 자동 종료를 보장한다
- `async/await`는 비동기 처리다. DB 응답을 기다리는 동안 스레드를 블로킹하지 않는다
- **DI 등록을 잊지 말 것.** `Program.cs`에서 서비스를 등록해야 Controller에서 주입받을 수 있다

Java Spring에 익숙하다면 개념 자체는 비슷하다. 문법과 네이밍 컨벤션만 다를 뿐, Repository 패턴, DI, MVC 구조 모두 동일한 철학을 공유한다.

---

### References

- [Learn Dapper](https://www.learndapper.com/)
- [C# Corner - CRUD Operation with Dapper](https://www.c-sharpcorner.com/article/crud-operation-with-dapper-using-asp-net-core-6-mvc/)