---
title: "Computer Networking: a Top Down Approach - (3)"
date: 2025-01-20T18:46:04.531Z
tags: ["네트워크"]
slug: "Chapter-1"
thumbnail: "../assets/posts/1c9076e49f72a6ce1e529a1172724edfa854292b9f6cff01ea050eb4bbafdc87.png"
categories: 네트워크
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:04:02.095Z
  hash: "0e744c5b71392bffeaf5a4eb048105746a0d44c7e63935987e56256eb1f4ddaf"
---

 > # Application Layer
 
 ## Socket Programming![](/assets/posts/4f65edd3547a9bb5f0df748ba512bd49375df93eb3fe6d196a9b05558a354ddb.png)

- 어플리케이션과 네트워크 사이의 통신을 위한 인터페이스
- 2가지 타입의 소켓 : 소켓 타입이 소통 방식을 결정 (TCP 소켓 / UDP 소켓)
- 생성후 소켓을 통해 데이터를 전달하고 전달받을 수 있음
---
## Two Essential Types of Sockets![](/assets/posts/75e9d14ff31507de96190f7c47477c3c79bdc411cb3d869da29cef2071ca2679.png)
---
## Socket API![](/assets/posts/eb7d1e83cbd0a353948af0cdd6f46569506bb46e7aaa1de972d86426924bd109.png)


**1.** **`socket()`** : 웹서버가 소켓을 생성한다.

**2.** **`bind()`** : 생성한 소켓을 특정 포트에 연결하겠다.

**3.** **`listen()`** : 이 소켓으로 listen 하겠다. non-blocking(함수 호출 시 조건이 만족되지 않더라도 함수가 리턴하므로 해당 스레드는 계속 진행)
 
**4.** **`accept()`** : 클라이언트로부터 받을 준비가 되었다. blocking(함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)

**5.** **`block until connection from client`** : 서버는 클라이언트로부터 연결이 들어올 때까지 block된다

**6.** **`socket()` and `connect()`** : 클라이언트가 소켓을 열고 원하는 서버의 프로세스에 connect한다. connect는 blocking

**7.** **`read()` and `write()`** : 연결이 되었으므로 읽기, 쓰기 등여러 작업 가능. 통신이 된다는 의미

$...$

![](/assets/posts/cefe5a9baa881c995885975a1073ca66368addda36b7b039a409bb871d806cc6.png)



**8.** **`close()`** : 필요한 통신이 충분히 완료되면 소켓을 닫아 연결을 끊는다.

---

## Sockets API
- #### 1. Creation and Setup
- #### 2. Establishing a Connection (TCP)
- #### 3. Sending and Receiving Data
- #### 4. Tearing Down a Connection (TCP)

---

> ## 1. Socket Creation and Setup

![](/assets/posts/071d9e88e49a9fe6d1024b1cbf6388c9c4b5b71c8bc779e4560c6861c61e24b2.png)
- create 함수와 bind 함수 있다.
- 3개의 파라미터
  - 소켓 특정하는 인덱스가 있음


## `socket()` function![](/assets/posts/e511532044eed1dafa1a0202b5a6d6750de2e1cf9f84748b11e2a19351401719.png)
- `type` 파라미터 : TCP/UDP를 결정, 중요함!!
  **- TCP : SOCK_STREAM**
  **- UDP : SOCK_DGRAM**

- 리턴값으로 **소켓의 ID값**을 반환 - 이 소켓의 주소라고 보면 됨

---

## `Bind()` function![](/assets/posts/4e6388787522aa6424b2442aa61ffdbd0030384407fd41704a0d70ff2dcf9978.png)
- 방금 생성한 소켓 아이디를 통해서 이 소켓을 특정 address(포트)에 바인드 하겠다.

---

## `accept()` function
- **non-blocking** (함수 호출 시 조건이 만족되지 않더라도 함수가 리턴하므로 해당 스레드는 계속 진행)
![](/assets/posts/4ebac02f39bf229c87a538fbdfbb798aa8e59afebe8921b87195b0ce16fdd1a7.png)
- 클라이언트로부터 연결을 기다리겠다.

## `Listen()` function
- **non-blocking** (함수 호출 시 조건이 만족되지 않더라도 함수가 리턴하므로 해당 스레드는 계속 진행)
![](/assets/posts/0878229ce0b953d2bf5653cce9fe8ca219c9a72ba5534026c51f98dc3c53b3e7.png)
- 소켓을 listen용도로 사용할것이고, 동시에 여러 요청이 들어오면 최대 `backlog` 개만큼 queue에 담아서 처리하겠다.

---

> ## 2. Establishing a Connection (TCP)

## `Connect()` function
- **bloking** (함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)
![](/assets/posts/c20a8299d4d9e7ab5311ae6a245b7b2c1cb5db3175116d288d85ee202959d9d9.png)
- bind쓰는게 아닌 이유는 클라이언트는 아무 포트나 쓰면 되기 때문. 서버처럼 특정 포트일 필요가 없다. 서버는 특정(ex. 80번 포트) 를 써야할 이유가 있지만 클라이언트는 필요없다.

---

## TCP Socket Connection Setup![](/assets/posts/e6eca0569f4837c4f35f71b4e7f955827c668e62f7f046044aad9d90feea9531.png)

---

## Code : Server![](/assets/posts/ef44f81e1a5fd518651e872447b200ac5a1abbc6f14cfdd4a3ef77504a251a51.png)![](/assets/posts/dbf87254c94d86f8d81284b805031ff76b2c873182c5b7e175f5f75e9812e09f.png)![](/assets/posts/4156014e47bd09cf6f8bbae244e53485c294f7a7c2230425cb4e612521be50a7.png)![](/assets/posts/82745b49bd109ccacfb4884814db213ea93475ddf5b2eab16d42e244fc04226b.png)

## Code : Client![](/assets/posts/ef1535772a80530b4b88850846b179c8747888356994824e0820f1cf3cb2396a.png)

---

> ## 3. Sending and Receiving Data

## `Write()` function
- **bloking** (함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)
![](/assets/posts/1974aac4be925148951335095f0e0b7f37322320ce509cb36541ce6ecab535a1.png)

## `Read()` function
- **bloking** (함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)
![](/assets/posts/b5e852bcf72e7cf914ee300485cbd74b2326175d68a1b8b6b01672351711faa0.png)

---

## UDP Socket Functions![](/assets/posts/4550cecb6108109ece1c050885aef9366e55ff0ba08cbac3ed1e7c90a82708e7.png)
- UDP는 훨씬 단순하다. 소켓 생성하고 바로 보낸다.
---

> ## 4. Tearing Down a Connection (TCP)

## close() function![](/assets/posts/22a0ba42fe713c438580cdee4e48468cb735015528f16610eeae80bb5c825eb1.png)

- 데이터 교환후에 마지막으로 사용했던 소켓을 release해준다. 그래야 다른 프로세스가 사용할 수 있다.

---

## Release of Ports![](/assets/posts/e6f498d08142985aaedf378aec66b4edae281cf59444b36d3bae765b36d5f3f2.png)

- 실제로 프로세스를 죽여도, 바인딩된 포트는 죽지 않고 남아 있는 경우가 있다.
- 코드에 프로세스를 실행을 멈출때 포트 바인딩을 풀어주자.

---

