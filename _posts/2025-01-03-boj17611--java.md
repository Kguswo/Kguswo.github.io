---
title: "BOJ_17611_직각다각형 (Java)"
date: 2025-01-03T03:33:48.350Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ17611직각다각형-Java"
thumbnail: "../assets/posts/f45197f26f4313b0a895a42de97207d983a3ba975052188e5b94282527e324b0.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:04:59.332Z
  hash: "6724fd82b5db2376ef17530b7c4148bfd5c6e1b22f5c59fd5d1132d7a38be91a"
---

# [Gold II] 직각다각형 - 17611 

[문제 링크](https://www.acmicpc.net/problem/17611) 

### 성능 요약

메모리: 46140 KB, 시간: 276 ms

### 분류

누적 합, 정렬, 스위핑

### 제출 일자

2025년 1월 3일 12:25:29

### 문제 설명

<p>다각형의 두 선분이 연속하는 선분의 꼭짓점을 제외하고는 만나지 않는 다각형을 <strong>단순다각형</strong>이라고 부른다. 다각형의 각 변이 x축과 y축에 평행한 다각형을 <strong>직각다각형이라</strong> 부른다. 단순다각형이면서 직각다각형을 <strong>단순직각다각형</strong>이라 부른다. 아래 두 그림은 단순직각다각형의 예를 보여준다. </p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/8ea43503-6e96-4908-a565-447ecc44bc75/-/preview/"><img alt="" src="https://upload.acmicpc.net/5eecd6fa-b085-4884-aa4c-5341e50e2738/-/preview/"></p>

<p>단순직각다각형이 주어질 때, 수평선 H가 다각형의 <strong>수직선분</strong>과 몇 번 교차하는지 또는 수직선 V가 다각형의 <strong>수평선분</strong>과 몇 번 교차하는지 알고자 한다. 첫 번째 그림에서 수평선 H는 4개의 수직선분과 교차하고 수직선 V는 2개의 수평선분과 교차한다. 두 번째 그림은 첫 번째 그림에서 수평선 H의 위치를 조금 위로 옮긴 것으로 8개의 수직선분과 교차하게 된다. </p>

<p>이때, 단순직각다각형과 가장 많이 교차하는 수평선 H와 수직선 V의 위치를 찾아 그때의 교차 횟수를 구하고자 한다. <strong>단, 수평선 H는 다각형의 어떤 수평선분과도 겹처 놓여서는 안 되고, 유사하게 수직선 V는 다각형의 어떤 수직선분과도 겹쳐 놓여서는 안 된다.</strong></p>

<p>수평선 H의 위치를 잘 정해서 주어진 단순직각다각형의 수직선분과 가장 많이 교차하는 지점을 찾을 때, 그 때의 교차 횟수를 h라 하고, 유사하게 수직선 V와 주어진 단순직각다각형의 수평선분과 가장 많이 교차하는 횟수를 v라 할 때, max(h, v)를 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>입력의 첫 줄에는 단순직각다각형의 꼭지점의 개수를 나타내는 정수 n(4 ≤ n ≤ 100,000)이 주어지고, 이어지는 n개 줄 각각에 단순직각다각형 꼭지점의 좌표 (x<sub>i</sub>, y<sub>i</sub>)가 차례대로 주어진다. 주어지는 꼭지점들의 순서는 시계방향이다. 다각형의 꼭지점을 나타내는 <strong>각 좌표값은 정수</strong>이며, -500,000 ≤ x<sub>i</sub>, y<sub>i</sub> ≤ 500,000이다.</p>

### 출력 

 <p>max(h, v)를 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/f45197f26f4313b0a895a42de97207d983a3ba975052188e5b94282527e324b0.png)


> ## 코드

```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;
	static int N, point[][], startX, startY, initialX, initialY, currX, currY, res=-1;
	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		N = Integer.parseInt(br.readLine());
		point = new int[1000001][2]; // 0 : 세로, 1 : 가로
		
		st = new StringTokenizer(br.readLine());
		startX = Integer.parseInt(st.nextToken()) + 500000;
		startY = Integer.parseInt(st.nextToken()) + 500000;
		
		initialX = startX;
		initialY = startY;
		
		for(int i=1; i<N; i++) {
			st = new StringTokenizer(br.readLine());
			currX = Integer.parseInt(st.nextToken()) + 500000;
			currY = Integer.parseInt(st.nextToken()) + 500000;
			
			if(startY == currY) { // 세로검사
				checkV(startX, currX);
			}
			else { // 가로검사
				checkH(startY, currY);
			}
			
			startX = currX;
			startY = currY;
		}
		
		if(startY == initialY) {
			checkV(startX, initialX);
		}
		else {
			checkH(startY, initialY);
		}
		
		for(int i=0; i<point.length; i++) {
			res = Math.max(res, Math.max(point[i][0], point[i][1]));
		}
		
		bw.write(String.valueOf(res));
		bw.flush();
		bw.close();
		br.close();
	}

	private static void checkV(int r1, int r2) {
		int left = Math.min(r1, r2);
		int right = Math.max(r1, r2);
		for(int i=left; i<right; i++) {
			point[i][0]++;
//	        System.out.println("V : " + (i-500000) + ", value: " + point[i][0]);

		}
	}

	private static void checkH(int c1, int c2) {
		int up = Math.max(c1, c2);
		int down = Math.min(c1, c2);
		for(int i=down; i<up; i++) {
			point[i][1]++;
//	        System.out.println("H : " + (i-500000) + ", value: " + point[i][1]);

		}
	}
}
```
