---
title: "Operating System Concepts - 운영체제의 작동"
date: 2025-06-10T10:39:52.910Z
tags: ["OS"]
slug: "Operating-System-Concepts-운영체제의-작동"
thumbnail: "../assets/posts/21c0555d1c643d794aa689585b5dfd4e8fdb04b8412c54573cd334ab9ae50e24.png"
categories: 운영체제
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:00:53.641Z
  hash: "7d9613352b6cfd2180d101e4052308d73a3130c7f3d7614772d00a378bbbc1e5"
---

## Operating System 작동
<br/>
컴퓨터의 전원을 켜거나 재부팅 할 때와 같이 컴퓨터를 실행하려면 초기 프로그램을 실행해야 한다. 

이 초기 프로그램(부트스트랩 프로그램)은 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다.

<br/>

부트스트랩 프로그램은 운영체제를 적재하는 방법과 해당 시스템 실행을 시작하는 방법을 알아야한다.

부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재한다.

<br/>

일부 서비스는 커널이 실행되는 전체 시간 동안 실행되는 **시스템 데몬** 이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다.

```
시스템 데몬 : 백그라운드에서 계속 실행되면서 특정 서비스를 제공하는 프로그램
```

Linux에서 첫 번째 시스템 프로그램은 **“systemd”** 이며 다른 많은 데몬을 시작한다.

<br/>

시스템이 완전히 부팅되면 어떤 이벤트가 발생할 때까지 기다린다.

이벤트는 거의 인터럽트를 발생시켜 신호를 보내고, 이 인터럽트의 종류로는 **하드웨어 인터럽트**, **트랩**, **오류**, **소프트웨어 인터럽트**등이 있다.

<br/>

### 다중 프로그래밍과 다중 태스킹 (multiprogramming and multitasking)

#### 다중 프로그래밍
> CPU가 **항상 하나 이상의 프로그램을 실행**할 수 있도록하여 CPU 이용률을 높이고 사용자의 만족도를 높이는 프로그래밍.
> 이런 시스템에서 실행 중인 프로그램을 **`프로세스`** 라고 한다.

##### 다중 프로그래밍 시스템을 위한 메모리 배치
![](/assets/posts/b495f785e96a318bc6226644ec0bea867a1302893ac5e5e550bd3b84113d0797.png)


운영체제는 이러한 프로세스 중 하나를 선택하여 실행하기 때문에 특정 프로세스가 다른 프로세스의 작업이 완료되기를 기다려야 할 수도 있다.
 
<br/>

#### 다중 태스킹

> 다중 프로그래밍의 논리적 확장이다. 멀티태스킹 시스템에서 CPU는 **여러 프로세스를 전환**하며 프로세스를 실행하지만 전환이 자주 발생하여 **사용자에게 빠른 응답 시간을 제공**하게 된다.

보통 사람이 사용하는 마우스, 키보드 등을 통한 입출력은 **사람의 속도로 수행**되므로, 완료까지 상당한 시간이 걸릴 수 있다.

이러한 **대화식 입력** 이 진행되는 동안 CPU를 쉬게 하지 않고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.

<br/>

### 이중-모드와 다중모드 운용 (Dualmode and Multimode Operation)

운영체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 올바르게 설계된 운영체제는 잘못된 (또는 악의적인) 프로그램으로 인해 다른 프로그램 또는 운영체제 자체가 잘못 실행될 수 없도록 보장해야 한다.

따라서 시스템을 올바르게 실행하려면 **운영체제 코드 실행**과 **사용자 정의 코드 실행**을 구분할 수 있어야 한다.

##### 사용자 모드에서 커널 모드로의 전환
![](/assets/posts/d71b30231b28d7ebf3561553cd7c7c3e8016d5df42096ffe68d5d872d1e190ae.png)

운영체제는 두 개의 독립된 연산 모드, **사용자 모드**와 **커널 모드**를 필요로 한다.

**`모드 비트`** 라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다. 이 비트는 **커널 모드(0) 또는 사용자 모드(1)를 나타낸다.**

<br/>

- 시스템 부트 시 **하드웨어**는 **커널 모드에서 시작**한다.

- 이후 운영체제가 적재되고 **사용자 모드**에서 **사용자 프로세스가 시작**된다.

- 트랩이나 인터럽트가 발생할 때마다, 하드웨어는 **사용자 모드에서 커널 모드로 전환**한다.(모드 비트를 0으로 변경)

  그러므로 **운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드**에 있게 된다.

<br/>

### 타이머 (Timer)

사용자 프로그램이 무한루프에 빠지거나 시스템 서비스 호출에 실패하여 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야 한다. 

이를 위해 **타이머** 로 **지정된 시간 후 컴퓨터를 인터럽트** 하도록 설정할 수 있다.

- 타이머 시간은 고정 혹은 가변 일 수 있으며, 가변 타이머는 일반적으로 고정률의 클록(fixed-rate clock)과 계수기로 구현된다.

사용자에게 제어를 양도하기 전에 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되었는지를 확인한다.

타이머의 값을 변경하는 명령은 명백히 특권 명령이다.

```
특권 명령 : 커널 모드에서만 실행 가능한 특별한 명령어. 사용자 모드에서 실행하려고 하면 OS로 트랩을 건다.
```
