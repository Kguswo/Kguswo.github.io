---
title: "BOJ_18186_라면 사기 (Large) (Java, C++)"
date: 2024-12-07T07:58:28.550Z
tags: ["C++","Java","백준","알고리즘"]
slug: "BOJ18186라면-사기-Large-Java-C"
image: "../assets/posts/e461de84eed98c8591c25a6557d569c3caa07734578fd7a81ea5b41380703b7e.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:25.158Z
  hash: "2750d2db70cd6e189b6f8345d4e6ac804fc710f9814cd8427048c35de77e3d05"
---

# [Diamond IV] 라면 사기 (Large) - 18186 

[문제 링크](https://www.acmicpc.net/problem/18186) 

### 성능 요약

메모리: 9836 KB, 시간: 100 ms

### 분류

그리디 알고리즘

### 제출 일자

2024년 12월 7일 16:50:43

### 문제 설명

<p>라면매니아 교준이네 집 주변에는 <em>N</em>개의 라면 공장이 있다. 각 공장은 1번부터 <em>N</em>번까지 차례대로 번호가 부여되어 있다. 교준이는 <em>i</em>번 공장에서 정확하게 <em>A<sub>i</sub></em>개의 라면을 구매하고자 한다(1 ≤ <em>i</em> ≤ <em>N</em>).</p>

<p>교준이는 아래의 세 가지 방법으로 라면을 구매할 수 있다.</p>

<ol>
	<li><em>i</em>번 공장에서 라면을 하나 구매한다(1 ≤ <em>i</em> ≤ <em>N</em>). 이 경우 비용은 <em>B</em>원이 든다.</li>
	<li><em>i</em>번 공장과 (<em>i</em>+1)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ <em>i</em> ≤ <em>N</em>-1). 이 경우 비용은 (<em>B</em>+<em>C</em>)원이 든다.</li>
	<li><em>i</em>번 공장과 (<em>i</em>+1)번 공장, (<em>i</em>+2)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ <em>i</em> ≤ <em>N</em>-2). 이 경우 비용은 (<em>B</em>+2<em>C</em>)원이 든다.</li>
</ol>

<p>최소의 비용으로 라면을 구매하고자 할 때, 교준이가 필요한 금액을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에 라면 공장의 개수를 의미하는 자연수 <em>N</em>과 두 자연수 <em>B</em>, <em>C</em>가 사이에 공백을 두고 주어진다.</p>

<p>두번째 줄에 <em>N</em>개의 정수 <em>A</em><sub>1</sub>, ···, <em>A<sub>N</sub></em>가 사이에 공백을 두고 주어진다.</p>

### 출력 

 <p>첫 번째 줄에 교준이가 필요한 최소 금액을 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/e461de84eed98c8591c25a6557d569c3caa07734578fd7a81ea5b41380703b7e.png)

C++에서 int 대신 long long리턴 시 **`unsigned main`**으로 바꾸었다! (++새로운 지식)
> ## 코드

#### Java 코드
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;

	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		st = new StringTokenizer(br.readLine());
		long N = Long.parseLong(st.nextToken());
		long B = Long.parseLong(st.nextToken());
		long C = Long.parseLong(st.nextToken());
		long[] arr = new long[(int) (N+2)];
		st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			arr[i] = Long.parseLong(st.nextToken());
		}
		
		long minCnt = 0;
		if(B<C) {
			for(int i=0; i<N; i++){
				minCnt += B * arr[i];
			}
		}
		else {
			for(int i=0; i<N; i++) {
				if(arr[i+1] > arr[i+2]) {
					// 2개짜리
					long cycle = Math.min(arr[i], arr[i+1] - arr[i+2]);
					for(int j=0; j<2; j++) {
						arr[i+j] -= cycle;
					}
					minCnt += (B+C)*cycle;
				
					// 3개짜리
					cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2])); 
					for(int j=0; j<3; j++) {
						arr[i+j] -= cycle;
					}
					minCnt += (B+2*C)*cycle;
					
					cycle = arr[i];
					arr[i] -= cycle;
					minCnt += B*cycle;
				}
				else {
					long cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2])); 
					for(int j=0; j<3; j++) {
						arr[i+j] -= cycle;
					}
					minCnt += (B+2*C)*cycle;
					
					cycle = Math.min(arr[i], arr[i+1]);
					for(int j=0; j<2; j++) {
						arr[i+j] -= cycle;
					}
					minCnt += (B+C)*cycle;
					
					cycle = arr[i];
					arr[i] -= cycle;
					minCnt += B*cycle;
				}
			}
		}
		
		bw.write(String.valueOf(minCnt));
		bw.flush();
		bw.close();
		br.close();
	}
}
```
---
#### C++ 코드
```c
/**
 * Author: nowalex322, Kim HyeonJae
 */
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define MOD 1000000007
#define INF LLONG_MAX
#define ALL(v) v.begin(), v.end()

#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif

void solve() {
    int N, B, C;
    cin >> N >> B >> C;
    vector<int> arr(N + 2);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    int minCnt = 0;
    if (B < C) {
        for (int i = 0; i < N; i++) {
            minCnt += arr[i] * B;
        }
    } else {
        for (int i = 0; i < N; i++) {
            int cycle;
            if (arr[i + 1] > arr[i + 2]) {
                // 2묶음
                cycle = min(arr[i], arr[i + 1] - arr[i + 2]);
                for (int j = 0; j < 2; j++) {
                    arr[i + j] -= cycle;
                }
                minCnt += (B + C) * cycle;

                // 3묶음
                cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));
                for (int j = 0; j < 3; j++) {
                    arr[i + j] -= cycle;
                }
                minCnt += (B + 2 * C) * cycle;

                // 1묶음
                cycle = arr[i];
                arr[i] -= cycle;
                minCnt += cycle * B;
            } else {
                // 3묶음
                cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));
                for (int j = 0; j < 3; j++) {
                    arr[i + j] -= cycle;
                }
                minCnt += (B + 2 * C) * cycle;

                // 2묶음
                int cycle = min(arr[i], arr[i + 1]);
                for (int j = 0; j < 2; j++) {
                    arr[i + j] -= cycle;
                }
                minCnt += (B + C) * cycle;

                // 1묶음
                cycle = arr[i];
                arr[i] -= cycle;
                minCnt += cycle * B;
            }
        }
    }
    cout << minCnt << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리
    // cin >> tt;    // 테스트 케이스 수 입력 (필요 시)

    while (tt--) {
        solve();
    }
    return 0;
}
```