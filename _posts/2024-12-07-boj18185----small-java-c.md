---
title: "BOJ_18185_라면 사기 (Small) (Java, C++)"
description: "문제 링크 메모리: 2180 KB, 시간: 0 ms그리디 알고리즘2024년 12월 7일 16:43:43이전 Skyline문제를 이 문제를 풀기 위해 공부했다. 사실상 똑같은 문젠데왜 난이도 차이가 한 티어나 차이나는지 모르겠다. 그리디 문제로 Skyline과 똑같이 풀"
date: 2024-12-07T07:55:28.793Z
tags: ["C++","Java","백준","알고리즘"]
slug: "BOJ18185라면-사기-Small-Java-C"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:25.246Z
  hash: "7bb3e92f9838742dea091f27239792cd5fe945adb0f042f326ea1b25f32c9573"
---

# [Diamond V] 라면 사기 (Small) - 18185 

[문제 링크](https://www.acmicpc.net/problem/18185) 

### 성능 요약

메모리: 2180 KB, 시간: 0 ms

### 분류

그리디 알고리즘

### 제출 일자

2024년 12월 7일 16:43:43

### 문제 설명

<p>라면매니아 교준이네 집 주변에는 <em>N</em>개의 라면 공장이 있다. 각 공장은 1번부터 <em>N</em>번까지 차례대로 번호가 부여되어 있다. 교준이는 <em>i</em>번 공장에서 정확하게 <em>A<sub>i</sub></em>개의 라면을 구매하고자 한다(1 ≤ <em>i</em> ≤ <em>N</em>).</p>

<p>교준이는 아래의 세 가지 방법으로 라면을 구매할 수 있다.</p>

<ol>
	<li><em>i</em>번 공장에서 라면을 하나 구매한다(1 ≤ <em>i</em> ≤ <em>N</em>). 이 경우 비용은 3원이 든다.</li>
	<li><em>i</em>번 공장과 (<em>i</em>+1)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ <em>i</em> ≤ <em>N</em>-1). 이 경우 비용은 5원이 든다.</li>
	<li><em>i</em>번 공장과 (<em>i</em>+1)번 공장, (<em>i</em>+2)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ <em>i</em> ≤ <em>N</em>-2). 이 경우 비용은 7원이 든다.</li>
</ol>

<p>최소의 비용으로 라면을 구매하고자 할 때, 교준이가 필요한 금액을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에 라면 공장의 개수를 의미하는 자연수 <em>N</em>가 주어진다.</p>

<p>두번째 줄에 <em>N</em>개의 정수 <em>A</em><sub>1</sub>, ···, <em>A<sub>N</sub></em>가 사이에 공백을 두고 주어진다.</p>

### 출력 

 <p>첫 번째 줄에 교준이가 필요한 최소 금액을 출력한다.</p>

> ## 문제 풀이

이전 Skyline문제를 이 문제를 풀기 위해 공부했다. 사실상 똑같은 문젠데왜 난이도 차이가 한 티어나 차이나는지 모르겠다. 그리디 문제로 Skyline과 똑같이 풀었다. 자세한 내용은 **[Skyline 문제 풀이](https://velog.io/@kguswo/BOJ11835Skyline-Java-C)** 참고

> ## 코드

#### Java 코드
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;

	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));

		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N+2];
		st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
		
		int minCnt = 0;
		for(int i=0; i<N; i++) {
			if(arr[i+1] > arr[i+2]) {
				// 2개짜리
				int cycle = Math.min(arr[i], arr[i+1] - arr[i+2]);
				for(int j=0; j<2; j++) {
					arr[i+j] -= cycle;
				}
				minCnt += 5*cycle;
			
				// 3개짜리
				cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2])); 
				for(int j=0; j<3; j++) {
					arr[i+j] -= cycle;
				}
				minCnt += 7*cycle;
				
				cycle = arr[i];
				arr[i] -= cycle;
				minCnt += 3*cycle;
			}
			else {
				int cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2])); 
				for(int j=0; j<3; j++) {
					arr[i+j] -= cycle;
				}
				minCnt += 7*cycle;
				
				cycle = Math.min(arr[i], arr[i+1]);
				for(int j=0; j<2; j++) {
					arr[i+j] -= cycle;
				}
				minCnt += 5*cycle;
				
				cycle = arr[i];
				arr[i] -= cycle;
				minCnt += 3*cycle;
			}
		}
		
		bw.write(String.valueOf(minCnt));
		bw.flush();
		bw.close();
		br.close();
	}
}
```
---
### C++ 코드
```c
/**
 * Author: nowalex322, Kim HyeonJae
 */
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define MOD 1000000007
#define INF LLONG_MAX
#define ALL(v) v.begin(), v.end()

#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif

void solve() {
    int N;
    cin >> N;
    vector<int> arr(N + 2);
    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    int minCnt = 0;
    for (int i = 0; i < N; i++) {
        int cycle;
        if (arr[i + 1] > arr[i + 2]) {
            // 2묶음
            cycle = min(arr[i], arr[i + 1] - arr[i + 2]);
            for (int j = 0; j < 2; j++) {
                arr[i + j] -= cycle;
            }
            minCnt += cycle * 5;

            // 3묶음
            cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));
            for (int j = 0; j < 3; j++) {
                arr[i + j] -= cycle;
            }
            minCnt += cycle * 7;

            // 1묶음
            cycle = arr[i];
            arr[i] -= cycle;
            minCnt += cycle * 3;
        } else {
            // 3묶음
            cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));
            for (int j = 0; j < 3; j++) {
                arr[i + j] -= cycle;
            }
            minCnt += cycle * 7;

            // 2묶음
            int cycle = min(arr[i], arr[i + 1]);
            for (int j = 0; j < 2; j++) {
                arr[i + j] -= cycle;
            }
            minCnt += cycle * 5;

            // 1묶음
            cycle = arr[i];
            arr[i] -= cycle;
            minCnt += cycle * 3;
        }
    }
    cout << minCnt << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리
    // cin >> tt;    // 테스트 케이스 수 입력 (필요 시)

    while (tt--) {
        solve();
    }
    return 0;
}
```