---
title: "BOJ_2437_저울"
description: "문제 링크 메모리: 14788 KB, 시간: 112 ms그리디 알고리즘, 정렬2024년 10월 31일 01:59:38"
date: 2024-10-30T17:03:11.500Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ2437저울"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:46.352Z
  hash: "799490e0409e12daf7259866635f44825238f1a20a71e4ff19660103cfc92d43"
---

# [Gold II] 저울 - 2437 

[문제 링크](https://www.acmicpc.net/problem/2437) 

### 성능 요약

메모리: 14788 KB, 시간: 112 ms

### 분류

그리디 알고리즘, 정렬

### 제출 일자

2024년 10월 31일 01:59:38

### 문제 설명

<p>하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 한다. 이 저울의 양 팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/7d2a2428-a1b0-47f5-9f53-fecd714d1b1b/-/preview/" style="width: 221px; height: 141px;"></p>

<p>무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 프로그램을 작성하시오.</p>

<p>예를 들어, 무게가 각각 3, 1, 6, 2, 7, 30, 1인 7개의 저울추가 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21이다. </p>

### 입력 

 <p>첫 째 줄에는 저울추의 개수를 나타내는 양의 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 둘째 줄에는 저울추의 무게를 나타내는 N개의 양의 정수가 빈칸을 사이에 두고 주어진다. 각 추의 무게는 1이상 1,000,000 이하이다.</p>

### 출력 

 <p>첫째 줄에 주어진 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 출력한다.</p>

### 코드
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;

	public static void main(String[] args) throws Exception {
		new Main().solution();
	}

	public void solution() throws Exception {
//		br = new BufferedReader(new InputStreamReader(System.in));
		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
		
		st = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
		Arrays.sort(arr);
		
		int res = 1;
		for(int i=0; i<N; i++) {
			if(arr[i] > res) break;
			res += arr[i];
		}

		bw.write(String.valueOf(res));
		bw.flush();
		bw.close();
		br.close();
	}
}
```