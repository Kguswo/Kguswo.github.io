---
title: "BOJ_1305_광고(Java)"
date: 2024-08-27T18:57:09.428Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ1305광고Java"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:06:03.171Z
  hash: "f33ebe0fd9c7a187ea8e00445cac681408fd12a7faa41c0abad4d8f3925a66ae"
---

# [Platinum IV] 광고 - 1305 

[문제 링크](https://www.acmicpc.net/problem/1305) 

### 성능 요약

메모리: 24096 KB, 시간: 252 ms

### 분류

KMP, 문자열

### 제출 일자

2024년 8월 28일 03:32:15

### 문제 설명

<p>세준이는 길 한가운데에서 전광판을 쳐다보고 있었다. 전광판에는 광고가 흘러나오고 있었다. 한참을 전광판을 쳐다본 세준이는 이 광고가 의미하는 것이 무엇인지 궁금해지기 시작했다.</p>

<p>전광판에는 같은 내용의 문구가 무한히 반복되어 나온다. 또, 전광판의 크기는 전광판에서 한번에 보이는 최대 문자수를 나타낸다. 만약 전광판의 크기가 L이라면, 한번에 L개의 문자를 표시할 수 있는 것이다.</p>

<p>광고업자는 최대한의 광고효과를 내기 위해서 길이가 N인 광고를 무한히 붙여서 광고한다.</p>

<p>예를 들어, 광고 업자 백은진이 광고하고 싶은 내용이 aaba 이고, 전광판의 크기가 6이라면 맨 처음에 보이는 내용은 aabaaa 이다. 시간이 1초가 지날 때마다, 문자는 한 칸씩 옆으로 이동한다. 따라서 처음에 aabaaa가 보였으면 그 다음에는 abaaab가 보인다. 그 다음에는 baaaba가 보인다.</p>

<p>세준이가 어느 순간 전광판을 쳐다봤을 때, 그 때 쓰여 있는 문자가 입력으로 주어졌을 때, 가능한 광고의 길이중 가장 짧은 것을 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 광고판의 크기 L이 주어지고, 둘째 줄에 현재 광고판에 보이는 문자열이 주어진다.</p>

### 출력 

 <p>첫째 줄에 가능한 광고의 길이중 가장 짧은 것의 길이를 출력한다.</p>
 
 

> ## 문제 풀이

광고가 반복된다면, 우리가 본 부분의 앞부분과 뒷부분이 같다. 이 같은 부분을 최대한 길게 찾으면, 그게 반복되는 부분.

예시 : `abcabcab`
pi : [0, 0, 0, 1, 2, 3, 4, 5]

abc가 반복되고 정답은 ( 전체길이 - 3 ) 인 5

KMP 알고리즘의 pi 배열이 바로 이 "앞뒤로 같은 부분"의 길이를 찾아주고, pi 배열의 마지막 값이 바로 가장 긴 "같은 부분"의 길이
그러므고 `전체 길이 - pi[마지막]`이 최소 광고 길이가 되는 것


### 코드
```java
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	static String T;
	static int L, pi[];
	static List<Integer> positions;

	public static void main(String[] args) throws IOException {
        br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));

		L = Integer.parseInt(br.readLine());
		T = br.readLine();
		System.out.println(getMinLength());

	}

	private static int getMinLength() {
		int[] pi = new int[T.length()];
		int j=0; 
		int min = 987654321;

		for(int i=1; i<T.length(); i++) {
			while(j>0 && T.charAt(i) != T.charAt(j)) j = pi[j-1];

			if(T.charAt(i) == T.charAt(j)) pi[i] = ++j;
		}
		return T.length() - pi[T.length() - 1];
	}
}
```