---
title: "PGMS_주식가격 (Java)"
date: 2025-11-15T09:28:00.276Z
tags: ["Java","알고리즘","프로그래머스"]
slug: "PGMS주식가격-Java"
image: "../assets/posts/86a42f0f4a25adec18240887e1b3e193dffb5fbe672cb4809c86fb417cedcfb8.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-11-16T01:46:33.296Z
  hash: "cb87971b1ff235d3bdf5a8e1b8a3812ac08b2f5a85edcfc179cda42d9be7a8bc"
---

# [level 2] 주식가격 - 42584 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42584) 

### 성능 요약

메모리: 72.4 MB, 시간: 42.60 ms

### 구분

코딩테스트 연습 > 스택／큐

### 채점결과

정확성: 66.7<br/>효율성: 33.3<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 11월 15일 18:25:39

### 문제 설명

<p>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.</p>

<h5>제한사항</h5>

<ul>
<li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li>
<li>prices의 길이는 2 이상 100,000 이하입니다.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>prices</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[1, 2, 3, 2, 3]</td>
<td>[4, 3, 1, 1, 0]</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<ul>
<li>1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.</li>
<li>3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.</li>
<li>4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.</li>
<li>5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.</li>
</ul>

<p>※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges


> ## 문제 풀이

간단한 문제다. 지금 들어오는 항목과 과거 항목들을 비교하면서 진행해야 하기 때문에 굳이 O(N^2) 일 필요가 없다. 스택 자료구조로 간단히 구현했다.

![](/assets/posts/86a42f0f4a25adec18240887e1b3e193dffb5fbe672cb4809c86fb417cedcfb8.png)

> ## 코드

```java
import java.util.*;

class Node {
    int idx, price;
    public Node(int idx, int price) {
        this.idx = idx;
        this.price = price;
    }
}

class Solution {
    public int[] solution(int[] prices) {
        int n = prices.length;
        int[] res = new int[n];
        
        Stack<Node> stack = new Stack<>();
        stack.push(new Node(0, prices[0]));
        
        for(int i=1; i<n; i++){
            while(!stack.isEmpty() && stack.peek().price > prices[i]){
                Node n1 = stack.pop();
                res[n1.idx] = i - n1.idx;
            }
            stack.push(new Node(i, prices[i]));
        }
        
        while(!stack.isEmpty()){
            Node n2 = stack.pop();
            res[n2.idx] = (prices.length - 1) - n2.idx;
        }
        // System.out.println(Arrays.toString(res));
        return res;
    }
}
```