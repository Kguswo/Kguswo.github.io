---
title: "프리코스 1주차를 진행하며"
date: 2025-10-20T12:24:58.097Z
tags: ["우아한테크코스"]
slug: "프리코스-1주차를-진행하며"
image: "../assets/posts/f01da244b1d82397d877f84be26c73d15c09b59fb26361cc395d5cc73ecae1b2.png"
categories: 우아한테크코스
toc: true
velogSync:
  lastSyncedAt: 2025-10-20T13:52:14.086Z
  hash: "e05f7ee8d1b22e7637ff65729d157176dd705c00f66bb3256925a159856c56a9"
---

### 들어가며

> 우아한테크코스 8기 프리코스 1주차 과제는 문자열 계산기 구현이었다. 간단해 보이는 과제였지만, 실제로 구현하면서 다양한 문제 상황을 마주했고 하나씩 해결해나가는 과정에서 많은 것을 배울 수 있었다. 이 글에서는 구현 중 만났던 여러 고민들과 해결 과정을 기록한다.

---

<br/>

## 1. 커스텀 구분자 사용 시 기본 구분자도 함께 쓸까?


요구사항에는 이렇게 적혀있었다.

> 앞의 기본 구분자(쉼표, 콜론) **외에** 커스텀 구분자를 지정할 수 있다.

"외에"라는 표현이 애매했다. 예를 들어 `//?\n1?2:3`이라는 입력이 들어왔을 때 두 가지 상황을 생각해볼 수 있었다.
- **Case 1**: 커스텀 구분자 `?` **추가** → `?`, `,`, `:` 모두 구분자 → 결과: 6
- **Case 2**: 커스텀 구분자 `?` **대체** → `?`만 구분자 → `2:3`은 파싱 불가

<br/>

일반적으로 "커스텀 구분자를 지정한다"는 것은 **기본값을 대체**한다는 의미로 해석된다. 만약 기본 구분자와 함께 쓰려면 "추가로 지정할 수 있다" 같은 표현을 사용했을 것이다.

또한 추가 방식이면 의도하지 않은 동작이 발생할 수 있다:
```java
"//?\n1?2:3"  // 커스텀 구분자 ?
// 만약 추가 방식이면: ?, ,, : 모두 구분자
// 사용자는 ?만 쓰고 싶었는데 ,도 구분자가 됨
```

### 해결방법

**커스텀 구분자 지정 시 기본 구분자는 사용하지 않는 것으로 결정했다. 커스텀 구분자 하나만 사용한다는 의미로 해석한 것이다.**

```java
private static String findSeparator(String expression) {
    if (hasCustomSeparator(expression)) {
        return extractCustomSeparator(expression);  // 커스텀만 반환
    }
    return USE_DEFAULT_SEPARATOR;  // 기본 구분자 사용 신호
}
```

<br/>

## 2. DEFAULT_SEPARATOR의 의미 혼재

수정 전 처음 코드는 아래와 같았다:

```java
private static final String DEFAULT_SEPARATOR = ",:";

private static String findSeparator(String expression) {
    if (hasCustomSeparator(expression)) {
        return extractCustomSeparator(expression);
    }
    return DEFAULT_SEPARATOR;  // ",:" 반환
}

private static String[] split(String numbers, String separator) {
    if (separator.equals(DEFAULT_SEPARATOR)) {
        return numbers.split("[" + separator + "]");  // [,:]
    }
    return numbers.split(Pattern.quote(separator));
}
```

#### 문제점은 `DEFAULT_SEPARATOR`가 두 가지 의미로 사용되고 있다는 것이었다.

1. **"기본 구분자를 사용한다"는 신호** (`findSeparator`에서)
2. **실제 구분자 문자들** (`split`에서 `[,:]` 만들 때)

하나의 변수가 두 가지 역할을 하니 코드 의도가 불명확했다.

### 해결방법

**책임을 명확히 분리하자!**

```java
private static final String DEFAULT_SEPARATORS = ",:";     // 실제 구분자 문자
private static final String USE_DEFAULT_SEPARATOR = "USE_DEFAULT_SEPARATOR";   // 기본 구분자 사용 신호

private static String findSeparator(String expression) {
    if (hasCustomSeparator(expression)) {
        return extractCustomSeparator(expression);
    }
    return USE_DEFAULT_SEPARATOR;  // 신호로만 사용
}

private static String[] split(String numbers, String separator) {
    if (separator.equals(USE_DEFAULT_SEPARATOR)) {
        return numbers.split("[" + DEFAULT_SEPARATORS + "]");  // 실제 문자 사용
    }
    return numbers.split(Pattern.quote(separator));
}
```

<br/>

#### 변수 하나도 명확한 책임을 가져야 한다! 는 것을 느꼈다.

"이 변수는 정확히 무엇을 표현하는가?"를 항상 고민해야 한다.

이는 객체지향의 **SRP(Single Responsibility Principle, 단일 책임 원칙)**와 맥락이 같다. SRP는 "하나의 클래스는 하나의 책임만 가져야 한다"는 원칙인데, 이를 변수 단위로 적용하면 "하나의 변수는 하나의 의미만 표현해야 한다"가 된다.

`DEFAULT_SEPARATOR` 하나가 "신호"와 "실제 값"이라는 두 가지 역할을 하면, 변경 사유도 두 가지가 된다. 이는 SRP 위반이며 코드의 응집도를 낮춘다.

<br/>

## 3. hasCustomSeparator와 extractCustomSeparator의 중복

커스텀 구분자 검증 로직이 두 메서드에 중복되었다:

```java
private static boolean hasCustomSeparator(String expression) {
    if (!expression.startsWith("//")) return false;
    
    int endIndex = expression.indexOf("\n");
    if (endIndex == -1) return false;
    
    String separator = expression.substring(2, endIndex);
    return !separator.isEmpty();
}

private static String extractCustomSeparator(String expression) {
    int endIndex = expression.indexOf("\n");
    
    if (endIndex == -1) {
        throw new IllegalArgumentException("커스텀 구분자 형식이 잘못되었습니다.");
    }
    
    String separator = expression.substring(2, endIndex);
    
    if (separator.isEmpty()) {
        throw new IllegalArgumentException("커스텀 구분자가 비었습니다.");
    }
    
    return separator;
}
```

### 고민

DRY(Don't Repeat Yourself) 원칙을 지키려면 중복을 제거해야 하지 않나? 

**옵션 1**: `hasCustomSeparator`에서 완전 검증, `extractCustomSeparator`는 단순 추출만
- 장점: 검증 로직 한 곳에 집중
- 단점: `extractCustomSeparator`가 `hasCustomSeparator`에 의존

**옵션 2**: 중복 허용, 각 메서드 독립적으로 동작
- 장점: 메서드 간 의존성 없음, 각자 명확한 책임
- 단점: 코드 중복

<br/>

### 해결방법

**약간의 중복을 허용하고 메서드 독립성 유지**

왜냐하면 각 메서드별로 기능과 의의가 뚜렷하게 나뉘기 때문이다.

`hasCustomSeparator` 메서드는 **커스텀 구분자를 사용할 수 있는가/아닌가** 를 중점으로 바라본다. 그렇기 때문에 예/아니오만 수행해야하며, 이렇게 boolean은 오류를 던지는 것이 맞지 않다고 생각했다.

반면 `extractCustomSeparator` 메서드에서는 **"그럼 커스텀 구분자 사용가능하니까 어떤 구분자인지 추출해봐"** 라는 의미로 해석할 수 있다. 이를 문자열로 반환해야 하는 과정이기 때문에 반환이 불가능하다면 오류를 던지자! 로 결정했다.

다음과 같은 결정이 나름 이유가 있다고 결론 내렸다.


- `hasCustomSeparator`는 boolean 반환에 집중
- `extractCustomSeparator`는 구분자 추출 및 반환과 예외 처리에 집중

<br/>

#### **항상 중복 제거가 정답은 아니다!** 

중복을 제거하면서 메서드 간 결합도가 높아진다면, 오히려 약간의 중복을 허용하는 게 나을 수 있음을 느꼈다.

<br/>

## 4. 테스트에서 빈 문자열 입력이 실패하는 이유


테스트 코드를 작성하고 실행했는데 에러가 발생했다:

```java
@Test
void 빈_문자열_입력() {
    assertSimpleTest(() -> {
        run("");  // 빈 문자열 입력
        assertThat(output()).contains("결과 : 0");
    });
}
```

에러:
```
java.util.NoSuchElementException: No line found
at Console.readLine(Console.java:12)
```

<br/>

### NsTest의 내부 동작

**NsTest의 command 메서드:**
```java
private void command(String... args) {
    byte[] buf = String.join("\n", args).getBytes();
    System.setIn(new ByteArrayInputStream(buf));
}
```

**동작 과정:**
```java
run("")
→ command("")
→ String.join("\n", "")  // "" (빈 문자열)
→ "".getBytes()  // 빈 바이트 배열
→ new ByteArrayInputStream(빈 배열)  // 빈 입력 스트림
```

#### 문제점

> 빈 입력 스트림에서 `readLine()` 호출 → 읽을 줄이 없음 → `NoSuchElementException`

<br/>

### 해결방법
```java
@Test
void 빈_문자열_입력() {
    assertSimpleTest(() -> {
        run("\n");  // ✅ 개행 문자 포함 (Enter만 친 것)
        assertThat(output()).contains("결과 : 0");
    });
}
```

**동작 과정:**
```java
run("\n")
→ command("\n")
→ String.join("\n", "\n")  // "\n" (개행 1개)
→ "\n".getBytes()  // [10] (개행문자 바이트)
→ ByteArrayInputStream에 빈 줄 하나 존재
→ readLine() 반환값: ""  ✅
```

<br/>

#### 배운점

- `String.join("\n", "")`은 빈 문자열을 반환한다
- `String.join("\n", "\n")`은 개행문자를 반환한다
- "사용자가 아무것도 입력하지 않고 Enter만 침"을 표현하려면 `"\n"`을 사용해야 한다

<br/>

## 5. 특수문자 이스케이프와 Pattern.quote()

### 구현 중 고민

커스텀 구분자를 split할 때, 사용자가 어떤 문자를 입력할지 알 수 없다. 만약 `?`나 `*` 같은 정규식 특수문자가 들어온다면?

```java
String text = "1?2?3";
String[] result = text.split("?");  // ❌ PatternSyntaxException 발생 가능!
```

#### split()과 정규식

`split()`은 **정규식**을 매개변수로 받는다:
```java
public String[] split(String regex)  // regex = regular expression
```

정규식 특수문자: `. ^ $ * + ? { } [ ] \ | ( )`

이 문자들은 정규식에서 특별한 의미를 가진다:
- `?`: "0개 또는 1개"
- `*`: "0개 이상"
- `.`: "모든 문자"

<br/>

### 해결방법: Pattern.quote() 사용

```java
private static String[] split(String numbers, String separator) {
    if (separator.equals(USE_DEFAULT)) {
        return numbers.split("[" + DEFAULT_SEPARATORS + "]");
    }
    
    // 커스텀 구분자는 정규식 이스케이프
    return numbers.split(Pattern.quote(separator));
}
```

### Pattern.quote()의 동작 원리

**기본 동작:**
```java
Pattern.quote("?")   // "\\Q?\\E"
Pattern.quote("**")  // "\\Q**\\E"
```

**실제 구현 코드:**
```java
public static String quote(String s) {
    int slashEIndex = s.indexOf("\\E");
    if (slashEIndex == -1)
        return "\\Q" + s + "\\E";  // \\E가 없으면 간단히 감싸기
    
    // \\E가 있으면 이스케이프 처리
    // ...
}
```

### \Q...\E의 의미

정규식에서 `\Q`와 `\E` 사이의 모든 문자는 **메타문자가 아닌 리터럴**로 취급된다:
- `?` → "0개 또는 1개" (정규식 메타문자)
- `\Q?\E` → 물음표 문자 그대로 (일반 문자)

**예시:**
```java
"test.txt".matches("test.txt")  // true (. = 모든 문자)
"testXtxt".matches("test.txt")  // true (. = 모든 문자)

"test.txt".matches("\\Qtest.txt\\E")  // true
"testXtxt".matches("\\Qtest.txt\\E")  // false (. = 점 문자 그대로)
```

### 특수 케이스: 문자열에 \E가 포함된 경우

만약 구분자 자체가 `\E`를 포함하면?

```java
Pattern.quote("A\\EB")
// 결과: "\\QA\\E\\\\E\\QB\\E"
```

**처리 과정:**
1. `\Q` - 리터럴 모드 시작
2. `A` - 문자 A
3. `\E` - 리터럴 모드 종료
4. `\\E` - 역슬래시+E 문자 추가
5. `\Q` - 리터럴 모드 재시작
6. `B` - 문자 B
7. `\E` - 리터럴 모드 종료

**코드로 보는 처리:**
```java
do {
    sb.append(s, current, slashEIndex)
            .append("\\E\\\\E\\Q");  // 인용 종료 → \E 추가 → 인용 재시작
    current = slashEIndex + 2;
} while ((slashEIndex = s.indexOf("\\E", current)) != -1);
```

결과는 다음과 같이 성공적이었다.

```java
"1?2?3".split(Pattern.quote("?"))     // ["1", "2", "3"] ✅
"1**2**3".split(Pattern.quote("**"))  // ["1", "2", "3"] ✅
"1.2.3".split(Pattern.quote("."))     // ["1", "2", "3"] ✅
```

#### 배운 점

- 사용자 입력을 정규식으로 사용할 때는 반드시 이스케이프 처리가 필요하다
- `Pattern.quote()`는 단순히 `\Q...\E`로 감싸는 것이 아니라, 문자열 내의 `\E`까지 정교하게 처리한다
- 정규식 리터럴 모드(`\Q...\E`)를 알면 메타문자를 안전하게 일반 문자로 취급할 수 있다
- Java 표준 라이브러리의 내부 구현을 들여다보면 예외 케이스까지 꼼꼼히 처리한다는 것을 알 수 있다

---

### 마치며

1주차 과제는 간단해 보였지만, 막상 구현하니 생각보다 고민할 것들이 많았다.

"이 변수는 정확히 무엇을 표현하는가?", "이 중복은 제거해야 하나, 유지해야 하나?", "테스트 환경과 실제 실행 환경은 어떻게 다를까?" 같은 질문들을 계속 던지면서 코드를 작성했다.

특히 요구사항이 애매할 때 어떻게 해석할지, 책임을 어떻게 분리할지 같은 부분에서 많이 고민했다. 정답이 정해져 있지 않은 문제들이라 더 고민이 깊어졌던 것 같다.

Java 표준 라이브러리의 내부 구현(`Pattern.quote()`, `String.join()` 등)을 들여다보면서 "이렇게까지 꼼꼼하게 예외 케이스를 처리하는구나"를 느꼈고, 좋은 코드란 무엇인가에 대해 다시 생각해보는 계기가 되었다.

1단계 과제였지만 생각보다 많은 걸 배웠다. 다음 단계가 기대된다.

---

### References

- [Pattern (Java SE 8 Documentation)](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)
- [String (Java SE 8 Documentation)](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)
- [단일 책임 원칙 (SRP)](https://en.wikipedia.org/wiki/Single-responsibility_principle)
- [DRY 원칙 (Don't Repeat Yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
