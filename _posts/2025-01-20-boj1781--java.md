---
title: "BOJ_1781_컵라면 (Java)"
date: 2025-01-20T12:40:31.851Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ1781컵라면-Java"
image: "../assets/posts/ae4f1420116520145938ed566499ae26e2606d7400b180b0de464b296295a52b.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:04:06.414Z
  hash: "b77cfc4521e551b10680197bd0a4bb3d31b5826ad6b9e47889fbfda2c6f230a1"
---

# [Gold II] 컵라면 - 1781 

[문제 링크](https://www.acmicpc.net/problem/1781) 

### 성능 요약

메모리: 71064 KB, 시간: 708 ms

### 분류

자료 구조, 그리디 알고리즘, 우선순위 큐, 정렬

### 제출 일자

2025년 1월 20일 21:09:35

### 문제 설명

<p>상욱 조교는 동호에게 N개의 문제를 주고서, 각각의 문제를 풀었을 때 컵라면을 몇 개 줄 것인지 제시 하였다. 하지만 동호의 찌를듯한 자신감에 소심한 상욱 조교는 각각의 문제에 대해 데드라인을 정하였다.</p>

| 문제 번호 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|----------|---|---|---|---|---|---|---|
| 데드라인  | 1 | 1 | 3 | 3 | 2 | 2 | 6 |
| 컵라면 수 | 6 | 7 | 2 | 1 | 4 | 5 | 1 |

<p>위와 같은 상황에서 동호가 2, 6, 3, 1, 7, 5, 4 순으로 숙제를 한다면 2, 6, 3, 7번 문제를 시간 내에 풀어 총 15개의 컵라면을 받을 수 있다.</p>

<p>문제는 동호가 받을 수 있는 최대 컵라면 수를 구하는 것이다. 위의 예에서는 15가 최대이다.</p>

<p>문제를 푸는데는 단위 시간 1이 걸리며, 각 문제의 데드라인은 N이하의 자연수이다. 또, 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 2<sup>31</sup>보다 작은 자연수이다.</p>

### 입력 

 <p>첫 줄에 숙제의 개수 N (1 ≤ N ≤ 200,000)이 들어온다. 다음 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 문제에 대한 데드라인과 풀면 받을 수 있는 컵라면 수가 공백으로 구분되어 입력된다.</p>

### 출력 

 <p>첫 줄에 동호가 받을 수 있는 최대 컵라면 수를 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/ae4f1420116520145938ed566499ae26e2606d7400b180b0de464b296295a52b.png)

> ## 코드

```java
package BOJ_1781_컵라면;

/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    class Work implements Comparable<Work> {
        int deadline, ramen;
        public Work(int deadline, int ramen) {
            this.deadline = deadline;
            this.ramen = ramen;
        }

        @Override
        public int compareTo(Work o) {
            if(this.deadline == o.deadline){
                return o.ramen - this.ramen;
            }
            return this.deadline - o.deadline;
        }
    }
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static int N, d, r, beforeTime=0, currTime=0;
    static long maxRamen;
    static PriorityQueue<Work> pq = new PriorityQueue<Work>();
    static PriorityQueue<Integer> ramens = new PriorityQueue<Integer>();
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
//        br = new BufferedReader(new InputStreamReader(System.in));
        br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_1781_컵라면/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        N = Integer.parseInt(br.readLine());
        for(int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            d = Integer.parseInt(st.nextToken());
            r = Integer.parseInt(st.nextToken());
            beforeTime = Math.max(beforeTime, d);
            pq.add(new Work(d, r));
        }

        while(!pq.isEmpty()) {
            Work currW = pq.poll();
            /*
            데드라인까지 개수 부족하게는 넣을 수 있음 (데드라인 1 3 5 세개면 다 가능)
            근데 데드라인 오버되도록 진행하면 문제가 발생
            예를들어
            1 4
            2 5
            3 6
            3 7
            
               
            1일차 4
            2일차 4 5
            3일차 4 5 7 (x)
                 5 6 7 (o)
            
            이런경우에는 최적해가 5 6 7 로 진행해야함../ 데드라인이 최대 그날까진 해야한다이므로 그 전에 더 높은거 해도됨
            그러므로 이런 경우에는 고른 라면중에 제일 적게 받은과제를 빼고 이번에 고른걸 선택
             */
            if(ramens.size() < currW.deadline) {
                ramens.add(currW.ramen);
                maxRamen += currW.ramen;
            }
            else if(!ramens.isEmpty() && ramens.peek() < currW.ramen) { // 최저 컵라면 교체
                maxRamen -= ramens.poll();
                ramens.add(currW.ramen);
                maxRamen += currW.ramen;
            }
        }

        bw.write(String.valueOf(maxRamen));
        bw.flush();
        bw.close();
        br.close();
    }
}

```