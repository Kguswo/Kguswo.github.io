---
title: "BOJ_1644_소수의 연속합"
date: 2024-09-04T04:21:00.620Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ1644소수의-연속합"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:05:59.521Z
  hash: "3e85073566728daaafa1bffc8b0e1f6152ef11ebafaeb7ae1491244adf73bc58"
---

# [Gold III] 소수의 연속합 - 1644 

[문제 링크](https://www.acmicpc.net/problem/1644) 

### 성능 요약

메모리: 27052 KB, 시간: 204 ms

### 분류

수학, 정수론, 소수 판정, 에라토스테네스의 체, 두 포인터

### 제출 일자

2024년 9월 4일 13:17:35

### 문제 설명

<p>하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.</p>

<ul>
	<li>3 : 3 (한 가지)</li>
	<li>41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)</li>
	<li>53 : 5+7+11+13+17 = 53 (두 가지)</li>
</ul>

<p>하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.</p>

<p>자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)</p>

### 출력 

 <p>첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.</p>

### 코드
```java

/**
 * Author : nowalex322, Kim hyeonjae
 */
import java.io.*;
import java.util.*;

public class Main {
	static BufferedReader br;
	static int N, num[], cnt;
	static List<Integer> primeNum = new ArrayList<Integer>();

	public static void main(String[] args) throws IOException {
//		br = new BufferedReader(new InputStreamReader(System.in));
		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));

		N = Integer.parseInt(br.readLine());
		if (N == 1) {
			System.out.println(0);
			return;
		}
		if (N == 2) {
			System.out.println(1);
			return;
		}
		makePrimeNum();

		cnt = 0;
		int left = 0, right = 0, sum = primeNum.get(left);

		while (right < primeNum.size() && left < primeNum.size() && left <= right) {
			if(left == primeNum.size()-1 && right == primeNum.size()-1){
				sum = primeNum.get(right);
				break;
			}
			if (sum >= N && left < right) {
				sum -= primeNum.get(left++);
			} else {
				if (right < primeNum.size()-1) {
					sum += primeNum.get(++right);
				}
			}

			if (sum == N) {
				cnt++;
			}
		}

		System.out.println(cnt);
	}

	private static void makePrimeNum() {
		boolean[] isPrime = new boolean[N + 1];
		Arrays.fill(isPrime, true);
		isPrime[0] = isPrime[1] = false;

		for (int i = 2; i * i <= N; i++) {
			if (isPrime[i]) {
				for (int j = i * i; j <= N; j += i) {
					isPrime[j] = false;
				}
			}
		}

		for (int i = 2; i <= N; i++) {
			if (isPrime[i]) {
				primeNum.add(i);
			}
		}
	}
}
```