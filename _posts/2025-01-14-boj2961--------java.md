---
title: "BOJ_2961_도영이가 만든 맛있는 음식 (Java)"
description: "문제 링크 메모리: 14256 KB, 시간: 104 ms백트래킹, 비트마스킹, 브루트포스 알고리즘2025년 1월 14일 21:13:23dfs로 모든 조합을 검사해보며 최소값을 갱신했다. 최소 하나의 재료는 골라야한다는 조건을 비트마스킹 방문조건처리인 visited값이 "
date: 2025-01-14T12:28:02.990Z
tags: []
slug: "BOJ2961도영이가-만든-맛있는-음식-Java"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:04:25.752Z
  hash: "b368d7fa932d38171020adcf5455bfd42d97806f73a1bb71ea781d24602ce1ed"
---

# [Silver II] 도영이가 만든 맛있는 음식 - 2961 
[문제 링크](https://www.acmicpc.net/problem/2961) 
### 성능 요약
메모리: 14256 KB, 시간: 104 ms
### 분류
백트래킹, 비트마스킹, 브루트포스 알고리즘
### 제출 일자
2025년 1월 14일 21:13:23
### 문제 설명
<p>도영이는 짜파구리 요리사로 명성을 날렸었다. 이번에는 이전에 없었던 새로운 요리에 도전을 해보려고 한다.</p>

<p>지금 도영이의 앞에는 재료가 N개 있다. 도영이는 각 재료의 신맛 S와 쓴맛 B를 알고 있다. 여러 재료를 이용해서 요리할 때, 그 음식의 신맛은 사용한 재료의 신맛의 곱이고, 쓴맛은 합이다.</p>

<p>시거나 쓴 음식을 좋아하는 사람은 많지 않다. 도영이는 재료를 적절히 섞어서 요리의 신맛과 쓴맛의 차이를 작게 만들려고 한다. 또, 물을 요리라고 할 수는 없기 때문에, 재료는 적어도 하나 사용해야 한다.</p>

<p>재료의 신맛과 쓴맛이 주어졌을 때, 신맛과 쓴맛의 차이가 가장 작은 요리를 만드는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 재료의 개수 N(1 ≤ N ≤ 10)이 주어진다. 다음 N개 줄에는 그 재료의 신맛과 쓴맛이 공백으로 구분되어 주어진다. 모든 재료를 사용해서 요리를 만들었을 때, 그 요리의 신맛과 쓴맛은 모두 1,000,000,000보다 작은 양의 정수이다.</p>

### 출력 
 <p>첫째 줄에 신맛과 쓴맛의 차이가 가장 작은 요리의 차이를 출력한다. </p>
 

> ## 문제 풀이

dfs로 모든 조합을 검사해보며 최소값을 갱신했다. 최소 하나의 재료는 골라야한다는 조건을 비트마스킹 방문조건처리인 visited값이 0보다 큰지 검사로 적용했다. n<=10이란 조건이 있어 가능했다

> ## 코드

#### Java 코드
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */
import java.io.*;
import java.util.*;
public class Main {
	static BufferedReader br;
	static BufferedWriter bw;
	static StringTokenizer st;
	static int N, visited, flavor[][], res=Integer.MAX_VALUE;
	public static void main(String[] args) throws Exception {
		new Main().solution();
	}
	public void solution() throws Exception {
		br = new BufferedReader(new InputStreamReader(System.in));
//		br = new BufferedReader(new InputStreamReader(new FileInputStream("input.txt")));
		bw = new BufferedWriter(new OutputStreamWriter(System.out));
		N = Integer.parseInt(br.readLine());
		visited = 0;
		flavor = new int[N][2];
		for(int i=0; i<N; i++) {
			st = new  StringTokenizer(br.readLine());
			flavor[i][0] = Integer.parseInt(st.nextToken());
			flavor[i][1] = Integer.parseInt(st.nextToken());
		}
		dfs(0, visited, 1, 0);
		bw.write(String.valueOf(res));
		bw.flush();
		bw.close();
		br.close();
	}
	private void dfs(int depth, int visited, int sour, int bitter) {
		if(depth == N) {
			if(visited > 0) {
				res = Math.min(res, Math.abs(sour - bitter));
			}
			return;	
		}
		
		dfs(depth + 1, visited | (1<<depth), sour * flavor[depth][0], bitter + flavor[depth][1]);
		dfs(depth + 1, visited, sour, bitter);
		
	}
}
```
---

#### C++ 코드
```c
/**
 * Author: nowalex322, Kim HyeonJae
 */
#include <bits/stdc++.h>
using namespace std;

// #define int long long
#define MOD 1000000007
#define INF LLONG_MAX
#define ALL(v) v.begin(), v.end()

#ifdef LOCAL
#include "algo/debug.h"
#else
#define debug(...) 42
#endif

int n, res;
vector<pair<int, int>> flavor;

void dfs(int depth, int visited, int sour, int bitter) {
    if (depth == n) {
        if (visited > 0) {
            res = min(res, abs(sour - bitter));
        }
        return;
    }

    dfs(depth + 1, visited | (1 << depth), sour * flavor[depth].first,
        bitter + flavor[depth].second);
    dfs(depth + 1, visited, sour, bitter);
}

void solve() {
    cin >> n;
    flavor.resize(n);
    for (int i = 0; i < n; i++) {
        cin >> flavor[i].first >> flavor[i].second;
    }
    res = INT_MAX;
    dfs(0, 0, 1, 0);
    cout << res << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리
    // cin >> tt;    // 테스트 케이스 수 입력 (필요 시)

    while (tt--) {
        solve();
    }
    return 0;
}
```