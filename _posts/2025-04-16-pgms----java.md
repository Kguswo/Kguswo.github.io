---
title: "PGMS_풍선 터트리기 (Java)"
description: "문제 링크 메모리: 128 MB, 시간: 33.98 ms코딩테스트 연습 > 월간 코드 챌린지 시즌1정확성: 100.0합계: 100.0 / 100.02025년 04월 16일 00:47:01출처: 프로그래머스 코딩 테스트 연습, https&#x3A;//school.prog"
date: 2025-04-15T15:51:27.344Z
tags: ["Java","알고리즘","프로그래머스"]
slug: "PGMS풍선-터트리기-Java"
thumbnail: "/assets/posts/34329dcd912fd1b4daa25bea88d08daf4fc1a4fb0305e8a9eba75f9cd54a9ba4.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:01:28.084Z
  hash: "808b9f7280a1e71f15271406ba5832bb42de33fa2a51a3602f655e67a0956554"
---

# [level 3] 풍선 터트리기 - 68646 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/68646) 

### 성능 요약

메모리: 128 MB, 시간: 33.98 ms

### 구분

코딩테스트 연습 > 월간 코드 챌린지 시즌1

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 04월 16일 00:47:01

### 문제 설명

<p>일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.</p>

<ol>
<li>임의의 <strong>인접한</strong> 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.</li>
<li>터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.</li>
</ol>

<p>여기서 조건이 있습니다. 인접한 두 풍선 중에서 <strong>번호가 더 작은 풍선</strong>을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.</p>

<p>당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 <strong>불가능</strong>할 수도 있습니다.</p>

<p>일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.</p>

<hr>

<h5>제한 사항</h5>

<ul>
<li>a의 길이는 1 이상 1,000,000 이하입니다.

<ul>
<li><code>a[i]</code>는 i+1 번째 풍선에 써진 숫자를 의미합니다.</li>
<li>a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.</li>
<li>a의 모든 수는 서로 다릅니다.</li>
</ul></li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>a</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td><code>[9,-1,-5]</code></td>
<td>3</td>
</tr>
<tr>
<td><code>[-16,27,65,-2,58,-92,-71,-68,-61,-33]</code></td>
<td>6</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p>입출력 예 #1</p>

<ul>
<li>첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.

<ol>
<li><code>[9, -1, -5]</code> 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.</li>
<li><code>[9, -5]</code> 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.</li>
</ol></li>
<li>두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.

<ol>
<li><code>[9, -1, -5]</code> 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.</li>
<li><code>[-1, -5]</code> 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.</li>
</ol></li>
<li>세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.

<ol>
<li><code>[9, -1, -5]</code> 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.</li>
<li><code>[-1, -5]</code> 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.</li>
</ol></li>
<li>3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.</li>
</ul>

<p>입출력 예 #2</p>

<ul>
<li>최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.</li>
</ul>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

> ## 문제 풀이

일단 문제 제목이 터트리다여서 터뜨리다 아닌가? 하고 찾아보니 예전엔 터트리다가 틀렸는데 복수 표준어라서 둘 다 맞다고 한다.

![](/assets/posts/34329dcd912fd1b4daa25bea88d08daf4fc1a4fb0305e8a9eba75f9cd54a9ba4.png)

양쪽 그룹의 최솟값이 지금 보고있는 숫자보다 둘 다 작다면 그 숫자는 불가능.

예시로 `[-5, 9, -1]`을 해보면 알 것이다.

> ## 코드

```java
// 20min

import java.util.*;

class Solution {
    public int solution(int[] a) {
        if(a.length<=2) return a.length;
        
        int res = a.length;
        int[] left_min = new int[a.length];
        int[] right_min = new int[a.length];
        
        left_min[0] = Integer.MAX_VALUE;
        for(int i=1; i<a.length; i++){
            left_min[i] = Math.min(left_min[i-1], a[i-1]);
        }

        right_min[a.length-1] = Integer.MAX_VALUE;
        for(int i=a.length-2; i>=0; i--){            
            right_min[i] = Math.min(right_min[i+1], a[i+1]);
        }
        
        for(int i=0; i<a.length; i++){
            if(left_min[i] < a[i] && right_min[i] < a[i]) res--;
        }
        // System.out.println(Arrays.toString(left_min));
        // System.out.println(Arrays.toString(right_min));
        return res;
    }
}
```