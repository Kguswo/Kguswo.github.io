---
title: "BOJ_17485_진우의 달 여행 (Large) (Java)"
date: 2025-02-18T17:33:41.323Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ17485진우의-달-여행-Large-Java"
thumbnail: "../assets/posts/f3264f97a95e16424b9135ff096ea57255d5fbc92afc017b2b3a686dabdc15c1.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:02:51.673Z
  hash: "8bc2daf6c72604fc292edf611a1efb2126ece3c0bdbce076202f77bb807efc23"
---

# [Gold V] 진우의 달 여행 (Large) - 17485 

[문제 링크](https://www.acmicpc.net/problem/17485) 

### 성능 요약

메모리: 18468 KB, 시간: 196 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2025년 2월 19일 02:30:21

### 문제 설명

<p>우주비행이 꿈이였던 진우는 음식점 '매일매일싱싱'에서 열심히 일한 결과 달 여행에 필요한 자금을 모두 마련하였다! 지구와 우주사이는 N X M 행렬로 나타낼 수 있으며 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료의 양이다.</p>

<p style="text-align: center;">[예시]</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/9e155c65-43ea-492b-af73-d3f9f9c9dc44/-/preview/" style="height: 353px; width: 150px;"></p>

<p>진우는 여행경비를 아끼기 위해 조금 특이한 우주선을 선택하였다. 진우가 선택한 우주선의 특징은 아래와 같다.</p>

<p><strong>1. 지구 -> 달로 가는 경우 우주선이 움직일 수 있는 방향은 아래와 같다.</strong></p>

<p><img alt="" src="https://upload.acmicpc.net/8f6fc516-9870-4ef6-8474-b5d82f7b6f21/-/preview/" style="width: 200px; height: 200px;"><img alt="" src="https://upload.acmicpc.net/eb6f87f0-f4d0-43cc-8e9d-5d94bfc41936/-/preview/" style="width: 200px; height: 200px;"><img alt="" src="https://upload.acmicpc.net/e7b501aa-c92c-4a17-aed7-c7868b89af7a/-/preview/" style="width: 200px; height: 200px;"></p>

<p><strong>2. 우주선은 전에 움직인 방향으로 움직일 수 없다. 즉, 같은 방향으로 두번 연속으로 움직일 수 없다.</strong></p>

<p>진우의 목표는 <strong>연료를 최대한 아끼며 지구의 어느위치에서든 출발하여 달의 어느위치든 착륙하는 것</strong>이다.</p>

<p>최대한 돈을 아끼고 살아서 달에 도착하고 싶은 진우를 위해 달에 도달하기 위해 필요한 연료의 최소값을 계산해 주자.</p>

### 입력 

 <p>첫줄에 지구와 달 사이 공간을 나타내는 행렬의 크기를 나타내는 <strong>N, M (2 ≤ N, M ≤ 1000)</strong>이 주어진다.</p>

<p>다음 N줄 동안 각 행렬의 원소 값이 주어진다. 각 행렬의 원소값은 100 이하의 자연수이다.</p>

### 출력 

 <p>달 여행에 필요한 최소 연료의 값을 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/f3264f97a95e16424b9135ff096ea57255d5fbc92afc017b2b3a686dabdc15c1.png)

간단한 3차원 dp문제다. 이전 방향을 포함해서 고려해야하기때문이다

> ## 코드

### 코드 1
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static int N, M, dp[][][], res = Integer.MAX_VALUE;
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        //br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_17485_진우의달여행Large/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        dp = new int[N+1][M+1][3];

        for(int i = 1; i <= N; i++) {
            for(int j = 1; j <= M; j++) {
                for(int k=0; k < 3; k++) {
                    dp[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }


        for(int i=1; i<=N; i++) {
            if(i==1){
                st = new StringTokenizer(br.readLine());
                for(int j=1; j<=M; j++){
                    int num = Integer.parseInt(st.nextToken());
                    for(int k=0; k<3; k++) {
                        dp[i][j][k] = num;
                    }
                }
            }
            else{
                st = new StringTokenizer(br.readLine());
                for(int j=1; j<=M; j++) {
                    int num = Integer.parseInt(st.nextToken());
                    // 밑으로 |
                    dp[i][j][0] = Math.min(dp[i-1][j][1], dp[i-1][j][2]) + num;
                    // 왼오\방향
                    if(j>=2) dp[i][j][1] = Math.min(dp[i-1][j-1][0], dp[i-1][j-1][2]) + num;
                    // 오왼/ 방향
                    if(j<M) dp[i][j][2] = Math.min(dp[i-1][j+1][0], dp[i-1][j+1][1]) + num;
                }
            }
        }

        for(int j=1; j<=M; j++) {
            for(int k=0; k<3; k++) {
                res = Math.min(res, dp[N][j][k]);
            }
        }
        System.out.println(res);
        bw.flush();
        bw.close();
        br.close();
    }
}
```

---

### 코드 2 (빠른 입출력)
```java
/**
 * Author: nowalex322, Kim HyeonJae
 */

import java.io.*;
import java.util.*;

public class Main {
    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static int N, M, dp[][][], res = Integer.MAX_VALUE;
    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        //br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_17485_진우의달여행Large/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        dp = new int[N+1][M+1][3];

        for(int i = 1; i <= N; i++) {
            for(int j = 1; j <= M; j++) {
                for(int k=0; k < 3; k++) {
                    dp[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }


        for(int i=1; i<=N; i++) {
            if(i==1){
                st = new StringTokenizer(br.readLine());
                for(int j=1; j<=M; j++){
                    int num = Integer.parseInt(st.nextToken());
                    for(int k=0; k<3; k++) {
                        dp[i][j][k] = num;
                    }
                }
            }
            else{
                st = new StringTokenizer(br.readLine());
                for(int j=1; j<=M; j++) {
                    int num = Integer.parseInt(st.nextToken());
                    // 밑으로 |
                    dp[i][j][0] = Math.min(dp[i-1][j][1], dp[i-1][j][2]) + num;
                    // 왼오\방향
                    if(j>=2) dp[i][j][1] = Math.min(dp[i-1][j-1][0], dp[i-1][j-1][2]) + num;
                    // 오왼/ 방향
                    if(j<M) dp[i][j][2] = Math.min(dp[i-1][j+1][0], dp[i-1][j+1][1]) + num;
                }
            }
        }

        for(int j=1; j<=M; j++) {
            for(int k=0; k<3; k++) {
                res = Math.min(res, dp[N][j][k]);
            }
        }
        System.out.println(res);
        bw.flush();
        bw.close();
        br.close();
    }
}
```

![](/assets/posts/7122fd82d73e020a3c6cad56464f8a8a9d12a67d139594f83f1790e8a074985a.png)

