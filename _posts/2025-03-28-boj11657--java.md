---
title: "BOJ_11657_타임머신 (Java)"
date: 2025-03-28T07:18:10.226Z
tags: ["Java","백준","알고리즘"]
slug: "BOJ11657타임머신-Java"
image: "../assets/posts/0df0bba2bca984f652d110c67f472b1d615dd6d961768aaaa8a247a25f980666.png"
categories: 알고리즘
toc: true
velogSync:
  lastSyncedAt: 2025-08-26T02:01:40.815Z
  hash: "abcacc06a5d0ca666ab0085b25906f357c866a449c2478da5225f364e2b3be77"
---

# [Gold IV] 타임머신 - 11657 
 
 [문제 링크](https://www.acmicpc.net/problem/11657) 
 
 ### 성능 요약
 
 메모리: 19564 KB, 시간: 256 ms
 
 ### 분류
 
 벨만–포드, 그래프 이론, 최단 경로
 
 ### 제출 일자
 
 2025년 3월 28일 16:08:59
 
 ### 문제 설명
 
 <p>N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 버스가 M개 있다. 각 버스는 A, B, C로 나타낼 수 있는데, A는 시작도시, B는 도착도시, C는 버스를 타고 이동하는데 걸리는 시간이다. 시간 C가 양수가 아닌 경우가 있다. C = 0인 경우는 순간 이동을 하는 경우, C < 0인 경우는 타임머신으로 시간을 되돌아가는 경우이다.</p>
 
 <p>1번 도시에서 출발해서 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.</p>

 ### 입력 
 
  <p>첫째 줄에 도시의 개수 N (1 ≤ N ≤ 500), 버스 노선의 개수 M (1 ≤ M ≤ 6,000)이 주어진다. 둘째 줄부터 M개의 줄에는 버스 노선의 정보 A, B, C (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)가 주어진다. </p>

 ### 출력 
 
  <p>만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다. 그렇지 않다면 N-1개 줄에 걸쳐 각 줄에 1번 도시에서 출발해 2번 도시, 3번 도시, ..., N번 도시로 가는 가장 빠른 시간을 순서대로 출력한다. 만약 해당 도시로 가는 경로가 없다면 대신 -1을 출력한다.</p>

> ## 문제 풀이

![](/assets/posts/0df0bba2bca984f652d110c67f472b1d615dd6d961768aaaa8a247a25f980666.png)

벨만 포드를 풀기위해 풀었다. 벨만포드는 생각보다 구현이 쉽다. 그리고 어떤 문제에 사용해야하는지도 거의 정해져있는것같다. 간선의 가중치가 음수가 있을때 사용하면 좋은 것 같다.

> ## 코드

```java
package BOJ_11657_타임머신;

/**
 * Author: nowalex322, Kim HyeonJae
 * 15:51 ~ 16:08
 */

import java.io.*;
import java.util.*;

public class Main {
    class Edge {
        int from, to, weight;

        public Edge(int from, int to, int weight) {
            this.from = from;
            this.to = to;
            this.weight = weight;
        }
    }

    static BufferedReader br;
    static BufferedWriter bw;
    static StringTokenizer st;
    static StringBuilder sb = new StringBuilder();

    public static void main(String[] args) throws Exception {
        new Main().solution();
    }

    public void solution() throws Exception {
//        br = new BufferedReader(new InputStreamReader(System.in));
        br = new BufferedReader(new InputStreamReader(new FileInputStream("src/main/java/BOJ_11657_타임머신/input.txt")));
        bw = new BufferedWriter(new OutputStreamWriter(System.out));

        st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        List<Edge> edges = new ArrayList<>();
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            edges.add(new Edge(u, v, w));
        }

        // 벨만 포드
        long[] dist = new long[N + 1];
        Arrays.fill(dist, Long.MAX_VALUE);
        dist[1] = 0; // 시작 1

        boolean negativeCycle = false; // 음의 사이클 체크 -> -1

        for (int i = 0; i < N - 1; i++) { // N-1개
            for (Edge e : edges) {
                if (dist[e.from] != Long.MAX_VALUE) {
                    if (dist[e.to] > dist[e.from] + e.weight) {
                        dist[e.to] = dist[e.from] + e.weight;
                    }
                }
            }
        }

        for (Edge e : edges) {
            if (dist[e.to] != Long.MAX_VALUE) {
                if (dist[e.to] > dist[e.from] + e.weight) {
                    negativeCycle = true;
                    break;
                }
            }
        }

        if (negativeCycle) sb.append("-1");
        else {
            for (int i = 2; i <= N; i++) {
                if (dist[i] != Long.MAX_VALUE) {
                    sb.append(dist[i]).append("\n");
                } else sb.append("-1").append("\n");
            }
        }
        System.out.println(sb.toString());
        br.close();
    }
}
```