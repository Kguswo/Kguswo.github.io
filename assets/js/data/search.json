[
  
  {
    "title": "Spring AI에 대하여",
    "url": "/posts/Spring-AI%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/",
    "categories": "공부",
    "tags": "Spring",
    "date": "2025-09-21 01:32:30 +0900",
    "content": "   들어가며   최근 AI와 LLM이 소프트웨어 개발의 새로운 패러다임으로 자리 잡으면서, 기존 Spring 생태계에서도 이러한 변화에 대응할 수 있는 프레임워크가 필요해졌다. Spring AI는 이런 요구에 응답하여 탄생한 프레임워크로, Spring 개발자들이 익숙한 방식으로 AI 기능을 통합할 수 있게 해준다.  AI에 큰 관심과 향후 커리어에 AI를 접목하고싶은 서버 개발자로서, 이 글을 통해 Spring AI의 핵심 개념들을 기술적으로 간단히 살펴보고 실제 구현에서 고려해야 할 세부사항들을 정리해보려 한다.  Spring AI란?   Spring AI는 AI 엔지니어링을 위한 애플리케이션 프레임워크다. 핵심 목표는 Spring 생태계의 설계 원칙인 이식성(Portability)과 모듈화 설계(Modular Design) 를 AI 도메인에 적용하여, POJO를 애플리케이션의 구성 요소로 활용할 수 있게 하는 것이다.  Spring AI의 핵심 가치  1. 벤더 중립성 (Vendor Neutrality)  Spring AI의 가장 큰 장점 중 하나는 벤더 중립성인 추상화다. 이는 다음과 같은 이점을 제공한다.  // OpenAI 사용 ChatModel openAiModel = new OpenAiChatModel(openAiApi);  // Anthropic으로 변경 시 - 인터페이스는 동일 ChatModel anthropicModel = new AnthropicChatModel(anthropicApi);  // 코드 변경 없이 모델 교체 가능 String response = chatModel.call(\"안녕하세요\");   2. Spring 생태계와의 일관성  Spring Boot의 Auto Configuration, Dependency Injection 등 기존 Spring 개발자들이 익숙한 패턴을 그대로 활용할 수 있다.  @RestController public class ChatController {          private final ChatModel chatModel;          // Constructor Injection     public ChatController(ChatModel chatModel) {         this.chatModel = chatModel;     }          @PostMapping(\"/chat\")     public String chat(@RequestBody String message) {         return chatModel.call(message);     } }   Spring AI의 핵심 아키텍처  1. Message 추상화 계층 Spring AI는 다양한 LLM 벤더들의 메시지 형식을 통일된 인터페이스로 추상화한다.  public interface Message {     MessageType getMessageType();     String getContent();     Map&lt;String, Object&gt; getMetadata(); }      Message 타입별 특징      SystemMessage: LLM의 행동을 정의하는 시스템 지시사항   SystemMessage systemMessage = new SystemMessage(     \"당신은 한국어로 친근하게 대화하는 AI 어시스턴트입니다.\" );      UserMessage: 사용자의 실제 질문이나 요청   UserMessage userMessage = new UserMessage(\"Spring AI에 대해 설명해주세요.\");     AssistantMessage: AI의 응답 메시지   AssistantMessage assistantMessage = new AssistantMessage(\"Spring AI는...\");   2. ChatOptions의 상세 파라미터  ChatOptions는 LLM 호출 시 사용되는 파라미터들을 정의한다. 각 파라미터의 의미와 활용법을 살펴보자.  Temperature (창의성 조절)     범위: 0.0 ~ 2.0   의미: 응답의 창의성과 무작위성 조절   활용:            0.0: 일관되고 예측 가능한 응답 (FAQ, 번역)       0.7: 균형잡힌 창의성 (일반 대화)       1.5+: 높은 창의성 (브레인스토밍, 창작)           ChatOptions conservativeOptions = ChatOptions.builder()     .temperature(0.1f)  // 매우 일관된 응답     .build();  ChatOptions creativeOptions = ChatOptions.builder()     .temperature(1.2f)  // 창의적인 응답     .build();   MaxTokens (응답 길이 제한)  ChatOptions shortResponse = ChatOptions.builder()     .maxTokens(100)  // 짧은 응답     .build();  ChatOptions detailedResponse = ChatOptions.builder()     .maxTokens(2000)  // 상세한 응답     .build();   Stop Sequences (응답 중단 조건) ChatOptions codeGeneration = ChatOptions.builder()     .stopSequences(Arrays.asList(\"```\", \"END_CODE\"))     .build();   TopP와 TopK (토큰 선택 전략)     TopP (Nucleus Sampling): 누적 확률이 P 이하인 토큰들만 고려   TopK: 상위 K개 토큰만 고려   ChatOptions focusedOptions = ChatOptions.builder()     .topP(0.8f)  // 상위 80% 확률 토큰만 사용     .topK(40)    // 상위 40개 토큰만 고려     .build();   3. ChatModel의 내부 동작 메커니즘  ChatModel 인터페이스의 구현체들이 어떻게 동작하는지 상세히 살펴보자.           입력으로 받은 Prompt 를 벤더의 API 형식에 맞게 변환합니다.           변환된 메시지를 사용하여 벤더의 API를 호출합니다.           벤더로부터 받은 응답을 ChatResponse 형식으로 변환하여 반환합니다.      요청 변환 과정  public class OpenAiChatModel implements ChatModel {          @Override     public ChatResponse call(Prompt prompt) {         // 1. Spring AI Prompt → OpenAI API 형식 변환         OpenAiChatCompletionRequest request = convertToOpenAiRequest(prompt);                  // 2. HTTP 요청 실행         OpenAiChatCompletionResponse apiResponse = openAiApi.chatCompletion(request);                  // 3. OpenAI 응답 → Spring AI ChatResponse 변환         return convertToChatResponse(apiResponse);     }          private OpenAiChatCompletionRequest convertToOpenAiRequest(Prompt prompt) {         return OpenAiChatCompletionRequest.builder()             .model(prompt.getOptions().getModel())             .messages(convertMessages(prompt.getInstructions()))             .temperature(prompt.getOptions().getTemperature())             .maxTokens(prompt.getOptions().getMaxTokens())             .stop(prompt.getOptions().getStopSequences())             .build();     } }   벤더별 파라미터 매핑  각 벤더마다 파라미터 이름이 다르지만, Spring AI가 자동으로 매핑해준다:    4. ChatResponse의 메타데이터 활용 ChatResponse에는 응답 텍스트뿐만 아니라 유용한 메타데이터가 포함된다:  ChatResponse response = chatModel.call(prompt);  // 기본 응답 텍스트 String content = response.getResult().getOutput().getContent();  // 토큰 사용량 정보 ChatResponseMetadata metadata = response.getMetadata(); Usage usage = metadata.getUsage();  System.out.println(\"프롬프트 토큰: \" + usage.getPromptTokens()); System.out.println(\"생성된 토큰: \" + usage.getGenerationTokens()); System.out.println(\"전체 토큰: \" + usage.getTotalTokens());  // 모델 정보 System.out.println(\"사용된 모델: \" + metadata.getModel());  // 완료 이유 (정상 완료, 길이 제한, 중단 시퀀스 등) FinishReason finishReason = response.getResult().getMetadata().getFinishReason();   Spring AI로 구현하는 RAG 시스템  단순한 LLM 호출을 넘어, Spring AI는 RAG(Retrieval-Augmented Generation) 시스템 구축도 강력하게 지원한다. RAG는 외부 데이터를 검색하여 LLM에게 맥락을 제공함으로써, 더 정확하고 신뢰할 수 있는 답변을 생성하도록 도와주는 기술이다.    RAG가 필요한 이유  LLM은 아무리 뛰어난 모델이라도 학습한 지식 안에서만 답변할 수 있다. 특정 기업의 사내 문서나 최신 법률처럼 외부 도메인 지식이 필요한 경우에는, 전혀 엉뚱한 답을 하거나 틀린 정보(Hallucination)를 말하기도 한다.  RAG는 이런 문제를 해결하기 위해 등장한 개념으로, 크게 두 단계로 나뉜다:     Data Indexing : 문서를 청킹하고 벡터화하여 저장   Data Retrieval &amp; Generation : 질문과 유사한 문서를 검색하여 LLM에 컨텍스트로 제공   Spring AI RAG 핵심 컴포넌트  1. EmbeddingModel - 텍스트를 벡터로 변환 LLM과 검색 시스템을 연결하는 첫 번째 단계는 임베딩이다. Spring AI는 EmbeddingModel 인터페이스를 통해 다양한 벤더의 임베딩 모델을 쉽게 연동할 수 있게 해준다.  public interface EmbeddingModel extends Model&lt;EmbeddingRequest, EmbeddingResponse&gt; {          EmbeddingResponse call(EmbeddingRequest request);          // 단일 텍스트 임베딩     default float[] embed(String text);          // 문서 임베딩     float[] embed(Document document);          // 다중 텍스트 임베딩     default List&lt;float[]&gt; embed(List&lt;String&gt; texts);          // 메타데이터와 함께 임베딩     default EmbeddingResponse embedForResponse(List&lt;String&gt; texts);          // 임베딩 차원 수     default int dimensions(); }   사용 예시:  // OpenAI 임베딩 모델 설정 EmbeddingModel embeddingModel = OpenAiEmbeddingModel.builder()     .apiKey(apiKey)     .options(OpenAiEmbeddingOptions.builder()         .model(\"text-embedding-3-small\")         .build())     .build();  // 텍스트를 벡터로 변환 float[] embedding = embeddingModel.embed(\"Spring AI는 훌륭한 프레임워크다\"); System.out.println(\"임베딩 차원: \" + embedding.length);   2. VectorStore - 벡터 저장 및 유사도 검색 벡터 저장소는 임베딩된 문서를 저장하고, 질문과 유사한 문서를 빠르게 검색해주는 핵심 컴포넌트다.  public interface VectorStore extends DocumentWriter {          // 저장소 이름     default String getName() { return this.getClass().getSimpleName(); }          // 문서 추가     void add(List&lt;Document&gt; documents);          // 문서 삭제     void delete(List&lt;String&gt; idList);     void delete(Filter.Expression filterExpression);          // 유사도 검색     List&lt;Document&gt; similaritySearch(String query);     List&lt;Document&gt; similaritySearch(SearchRequest request); }   단계별 벡터스토어 확장 전략:     1단계: 개발/테스트 - SimpleVectorStore   // 인메모리 벡터 저장소 VectorStore vectorStore = SimpleVectorStore.builder(embeddingModel)     .build();      2단계: 프로덕션 - PGVector   // PostgreSQL 기반 벡터 저장소 VectorStore prodStore = PgVectorStore.builder(jdbcTemplate, embeddingModel)     .dimensions(1536)  // OpenAI text-embedding-3-small 차원     .distanceType(PgDistanceType.COSINE_DISTANCE)     .removeExistingVectorStoreTable(false)     .build();      3단계: 대규모 - Qdrant, Milvus   // 대규모 벡터 검색을 위한 전문 DB VectorStore qdrantStore = QdrantVectorStore.builder()     .host(\"localhost\")     .port(6333)     .collectionName(\"spring-ai-docs\")     .embeddingModel(embeddingModel)     .build();   3. TextSplitter - 문서 청킹 전략  LLM은 긴 문서를 한 번에 처리하지 못하기 때문에, 문서를 적절한 길이로 나누는 작업이 필요하다.  public abstract class TextSplitter implements DocumentTransformer {          // 다중 문서 분할     public List&lt;Document&gt; split(List&lt;Document&gt; documents);          // 단일 문서 분할     public List&lt;Document&gt; split(Document document); }  public class TokenTextSplitter extends TextSplitter {     protected List&lt;String&gt; doSplit(String text, int chunkSize); }   청킹 전략별 활용:     토큰 기반 분할   TextSplitter tokenSplitter = TokenTextSplitter.builder()     .withChunkSize(500)      // 500 토큰 단위     .withChunkOverlap(50)    // 50 토큰 겹침     .build();      문단 기반 분할   TextSplitter paragraphSplitter = ParagraphTextSplitter.builder()     .withChunkSize(1000)     .withChunkOverlap(100)     .build();      커스텀 분할   TextSplitter customSplitter = new TextSplitter() {     @Override     protected List&lt;String&gt; doSplit(String text, int chunkSize) {         // 섹션 헤더 기준으로 분할하는 커스텀 로직         return Arrays.asList(text.split(\"(?=## )\"));     } };     완전한 RAG 구현 예시  @Service public class DocumentRAGService {          private final ChatModel chatModel;     private final EmbeddingModel embeddingModel;     private final VectorStore vectorStore;     private final TextSplitter textSplitter;          public DocumentRAGService(ChatModel chatModel,                               EmbeddingModel embeddingModel,                              VectorStore vectorStore) {         this.chatModel = chatModel;         this.embeddingModel = embeddingModel;         this.vectorStore = vectorStore;         this.textSplitter = TokenTextSplitter.builder()             .withChunkSize(500)             .withChunkOverlap(50)             .build();     }          // 1단계: 문서 인덱싱     public void indexDocument(String documentContent, Map&lt;String, Object&gt; metadata) {         // 1. 문서 생성         Document document = new Document(documentContent, metadata);                  // 2. 청킹         List&lt;Document&gt; chunks = textSplitter.split(document);                  // 3. 벡터 저장소에 저장 (자동으로 임베딩 생성됨)         vectorStore.add(chunks);                  log.info(\"문서 인덱싱 완료: {} 개 청크\", chunks.size());     }          // 2단계: RAG 기반 질의응답     public String answerQuestion(String question) {         // 1. 유사 문서 검색         SearchRequest searchRequest = SearchRequest.builder()             .query(question)             .topK(5)  // 상위 5개 유사 문서             .similarityThreshold(0.7)  // 유사도 임계값             .build();                      List&lt;Document&gt; relevantDocs = vectorStore.similaritySearch(searchRequest);                  if (relevantDocs.isEmpty()) {             return \"관련된 문서를 찾을 수 없습니다.\";         }                  // 2. 컨텍스트 구성         String context = relevantDocs.stream()             .map(Document::getContent)             .collect(Collectors.joining(\"\\n\\n\"));                  // 3. RAG 프롬프트 구성         String prompt = String.format(\"\"\"             다음 문서들을 참고하여 질문에 답변해주세요.                          === 참고 문서 ===             %s                          === 질문 ===             %s                          === 답변 규칙 ===             - 참고 문서의 내용을 바탕으로만 답변해주세요             - 문서에 없는 내용은 추측하지 마세요             - 출처를 명시해주세요             \"\"\", context, question);                  // 4. LLM 호출         ChatResponse response = chatModel.call(prompt);         return response.getResult().getOutput().getContent();     }          // 문서 업데이트     public void updateDocument(String documentId, String newContent) {         // 기존 문서 삭제         vectorStore.delete(Arrays.asList(documentId));                  // 새 문서 인덱싱         Map&lt;String, Object&gt; metadata = Map.of(\"id\", documentId);         indexDocument(newContent, metadata);     } }   RAG 시스템 최적화 전략          검색 정확도 향상                      메타데이터 필터링: 날짜, 카테고리, 작성자 등으로 검색 범위를 제한하여 관련성 높은 문서만 검색한다.                       하이브리드 검색: 키워드 검색과 벡터 검색을 결합하여 정확도를 높인다. 키워드로 정확한 용어 매칭을, 벡터로 의미적 유사성을 모두 활용할 수 있다.                       리랭킹: 초기 검색 결과를 다시 정렬하여 질문과 가장 관련성 높은 문서를 우선순위로 배치한다.                       청킹 전략 최적화                      계층적 청킹: 문서를 섹션 → 문단 → 문장 순으로 단계적 분할하여 문맥을 보존한다.                       의미 기반 청킹: 고정 길이가 아닌 문맥상 완결된 단위로 분할한다. 표나 코드 블록 같은 구조화된 데이터는 온전하게 유지한다.                       오버랩 전략: 청크 간 일정 부분을 겹치게 하여 문맥 손실을 방지한다. 보통 전체 길이의 10-20% 정도가 적절하다.                       성능 최적화                      배치 처리: 다수 문서를 한 번에 임베딩하여 API 호출 비용과 응답 시간을 줄인다.                       캐싱: 자주 사용되는 임베딩 결과를 Redis나 메모리에 캐시하여 중복 계산을 방지한다.                       벡터 압축: 임베딩 차원을 줄이거나 양자화하여 저장 공간과 검색 속도를 개선한다.                  실전 구현 시 고려사항  1. 비동기 처리 LLM 호출은 보통 3-10초의 응답 시간이 소요되므로 비동기 처리가 필수다. Spring의 @Async 어노테이션을 활용하여 사용자 요청을 논블로킹으로 처리할 수 있다.  @Service public class AsyncChatService {          @Async     public CompletableFuture&lt;String&gt; getChatResponseAsync(String message) {         return CompletableFuture.supplyAsync(() -&gt; chatModel.call(message));     } }   2. 스트리밍 응답  긴 답변의 경우 사용자 경험을 위해 실시간 스트리밍 응답을 제공하는 것이 좋다. Spring AI는 Reactive Streams를 지원한다.  3. 에러 처리 및 재시도  LLM 서비스는 네트워크 이슈나 토큰 제한으로 실패할 수 있으므로 Resilience4j나 Spring Retry를 활용한 재시도 로직이 필요하다.  마치며  Spring AI는 기존 Spring 개발자들이 AI 기능을 자연스럽게 통합할 수 있게 해주는 강력한 프레임워크다. 벤더 중립적인 추상화를 통해 모델 변경의 유연성을 제공하고, Spring 생태계의 장점들을 그대로 활용할 수 있다.  특히 RAG 시스템 구축을 위한 EmbeddingModel, VectorStore, TextSplitter 등의 컴포넌트들이 잘 추상화되어 있어서, 복잡한 문서 검색 기반 AI 서비스도 Spring 개발자라면 쉽게 구현할 수 있다.  실제 프로덕션 환경에서는 비동기 처리, 에러 처리, 토큰 사용량 모니터링, 벡터 저장소 확장성 등을 고려한 robust한 구현이 필요하며, Spring AI는 이런 요구사항들을 충족할 수 있는 충분한 확장성을 제공한다.  Spring AI를 활용하면 단순한 챗봇부터 고도화된 도메인 특화 AI 어시스턴트까지, 다양한 AI 서비스를 Spring 스타일로 우아하게 구현할 수 있을 것이다.  Ref     sionic Spring AI series 1  "
  },
  
  {
    "title": "PGMS_2차원 동전 뒤집기 (Java)",
    "url": "/posts/PGMS2%EC%B0%A8%EC%9B%90-%EB%8F%99%EC%A0%84-%EB%92%A4%EC%A7%91%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-09-18 10:34:45 +0900",
    "content": "[level 3] 2차원 동전 뒤집기 - 131703  문제 링크  성능 요약  메모리: 74 MB, 시간: 3.49 ms  구분  코딩테스트 연습 &gt; 연습문제  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 09월 17일 11:28:01  문제 설명  한수는 직사각형 모양의 공간에 놓인 동전들을 뒤집는 놀이를 하고 있습니다. 모든 동전들은 앞과 뒤가 구분되어 있으며, 동전을 뒤집기 위해서는 같은 줄에 있는 모든 동전을 뒤집어야 합니다. 동전들의 초기 상태와 목표 상태가 주어졌을 때, 초기 상태에서 최소 몇 번의 동전을 뒤집어야 목표 상태가 되는지 알아봅시다.    예를 들어, 위 그림에서 맨 왼쪽이 초기 상태, 맨 오른쪽이 목표 상태인 경우에 대해 알아봅시다. 그림에서 검은색 원은 앞면인 동전, 흰색 원은 뒷면인 동전을 의미합니다. 초기 상태에서 2행과 4행의 돌들을 뒤집으면, 두 번째 그림이 됩니다. 그 후, 2열, 4열, 5열의 돌들을 순서대로 뒤집는 다면, 총 5번의 동전 뒤집기를 통해 목표 상태가 되며, 이 경우가 최소인 경우입니다.  직사각형 모양의 공간에 놓인 동전들의 초기 상태를 나타내는 2차원 정수 배열 beginning, 목표 상태를 나타내는 target이 주어졌을 때, 초기 상태에서 목표 상태로 만들기 위해 필요한 동전 뒤집기 횟수의 최솟값을 return 하는 solution 함수를 완성하세요. 단, 목표 상태를 만들지 못하는 경우에는 -1을 return 합니다.    제한사항   1 ≤ beginning의 길이 = target의 길이 ≤ 10 1 ≤ beginning[i]의 길이 = target[i]의 길이 ≤ 10   beginning[i][j]와 target[i][j]는 i + 1행 j + 1열의 동전의 상태를 나타내며, 0 또는 1의 값으로 주어집니다. 0은 동전의 앞면을, 1은 동전의 뒷면을 의미합니다.      입출력 예           beginning target result            [[0, 1, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 1, 1, 0], [1, 0, 1, 1, 0], [0, 1, 0, 1, 0]] [[0, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 1, 0, 1], [0, 0, 0, 1, 0], [0, 0, 0, 0, 1]] 5   [[0, 0, 0], [0, 0, 0], [0, 0, 0]] [[1, 0, 1], [0, 0, 0], [0, 0, 0]] -1            입출력 예 설명  입출력 예 #1   문제 예시와 같습니다.   입출력 예 #2   목표 상태를 만들지 못합니다. 따라서 -1을 return 합니다.      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   처음에 보자마자 떠오른 방법은 dfs + 비트마스킹이지만 좀 더 수학적인 접근이 있을 것 같았다.  이후 생각한 방식으로 문제를 좀 더 단순화시킬 수 있었다.  먼저 처음과 끝 상태가 주어져있기 때문에 어떤 칸이 뒤집혔고, 뒤집히지 않았는지를 알 수 있다. 이를 XOR 연산으로 한번에 구할 수 있다.  즉 어떤칸이 짝수번 뒤집혔고 홀수번 뒤집혔는지를 알 수 있다는 의미다.  이후 정답 값에 관한 생각도 할 수 있었는데 (row + col) 값보다 커질 수 없었다. 왜냐하면 뒤집을 줄의 조합은 교환법칙이 성립하고 그걸 두번 뒤집으면 뒤집지 원상복구이기 때문에 뒤집지 않은것과 같은 효과기 때문이다.  따라서 모든 열 종류 + 모든 행 종류에서 뒤집거나 뒤집지 않거나 중 하나인 것이다.  따라서 나는 이 문제를 다음과 같이 바꾸었다.  =&gt; “뒤집을 행 + 열의 조합을 결정하는 결정 문제”  이제 이를 쉽게 구하는 방법은 먼저 열 종류 중에서 뒤집을 조합을 정하고 (비트마스킹 조합), 이후 행들도 XOR에서 뒤집어야함을 1로 체크하면 그 행을 뒤집는다. 이후 완료되었는지를 보고 잘 완성되었으면 그 cnt를 최솟값갱신한다.     코드   import java.util.*;  class Solution {     static int n, m, res;     static int [][] XOR;     static boolean isValidRes = false;     public int solution(int[][] beginning, int[][] target) {         res = Integer.MAX_VALUE;         n = beginning.length;         m = beginning[0].length;         XOR = new int[n][m];                  for(int i=0; i&lt;n; i++){             for(int j=0; j&lt;m; j++){                 XOR[i][j] = beginning[i][j] ^ target[i][j];             }         }                  for(int comb=0; comb&lt;(1&lt;&lt;m); comb++){             check(comb);         }                       return isValidRes ? res : -1;     }          private void check(int comb){         int[][] makeZero = new int[n][m];         for(int a=0; a&lt;n; a++){             makeZero[a] = Arrays.copyOf(XOR[a], m);         }                      int cnt = 0;                      for(int j=0; j&lt;m; j++){             if(((1&lt;&lt;j) &amp; comb) != 0){ // 뒤집기조건                 cnt++;                 for(int i=0; i&lt;n; i++){                     makeZero[i][j] = 1-makeZero[i][j];                 }             }         }                      for(int i=0; i&lt;n; i++){             if(makeZero[i][0] == 1){                 cnt++;                 for(int j=0; j&lt;m; j++){                     makeZero[i][j] = 1-makeZero[i][j];                 }             }         }                      boolean flag = true;         outer : for(int i=0; i&lt;n; i++){             for(int j=0; j&lt;m; j++){                 if(makeZero[i][j] != 0) {                     flag = false;                     break outer;                 }             }         }                  if(flag) {             res = Math.min(res, cnt);             if(!isValidRes) isValidRes = true;         }     } }  "
  },
  
  {
    "title": "PGMS_스킬트리 (Java)",
    "url": "/posts/PGMS%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-09-17 11:40:33 +0900",
    "content": "[level 2] 스킬트리 - 49993  문제 링크  성능 요약  메모리: 79.6 MB, 시간: 0.21 ms  구분  코딩테스트 연습 &gt; Summer／Winter Coding（～2018）  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 09월 17일 10:33:38  문제 설명  선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.  예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.  위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.  선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.  제한 조건   스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다. 스킬 순서와 스킬트리는 문자열로 표기합니다.   예를 들어, C → B → D 라면 \"CBD\"로 표기합니다  선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다. skill_trees는 길이 1 이상 20 이하인 배열입니다. skill_trees의 원소는 스킬을 나타내는 문자열입니다.   skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.    입출력 예           skill skill_trees return            \"CBD\" [\"BACDE\", \"CBADF\", \"AECB\", \"BDA\"] 2          입출력 예 설명   \"BACDE\": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다. \"CBADF\": 가능한 스킬트리입니다. \"AECB\": 가능한 스킬트리입니다. \"BDA\": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다.        스킬 트리: 유저가 스킬을 배울 순서&nbsp;↩         출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   간단하게 순서대로 skill이 포함되어있는지를 체크하면 된다. 이를 간단히 각 알파벳을 증가하는 수열로 치환하였고, 해당 문자가 나올 때 기존 최대값보다 1 커졌는지를 체크하였다.     코드   import java.util.*;  class Solution {     static Map&lt;Character, Integer&gt; order = new HashMap&lt;&gt;();     public int solution(String skill, String[] skill_trees) {         int res = skill_trees.length;                  for(int i=0; i&lt;skill.length(); i++){             order.put(skill.charAt(i), i);         }                  for(String s : skill_trees){             int curr = -1;             for(int i=0; i&lt;s.length(); i++){                 if(order.containsKey(s.charAt(i))){                     int v = order.get(s.charAt(i));                     if(v != curr+1) {                         res--;                         break;                     }                     else{                         curr = v;                     }                 }                 else continue;             }         }                           return res;     } }  "
  },
  
  {
    "title": "PGMS_거리두기 확인하기 (Java)",
    "url": "/posts/PGMS%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-Java-63sj1vsu/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-09-12 01:21:37 +0900",
    "content": "[level 2] 거리두기 확인하기 - 81302  문제 링크  성능 요약  메모리: 75.7 MB, 시간: 0.19 ms  구분  코딩테스트 연습 &gt; 2021 카카오 채용연계형 인턴십  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 09월 10일 10:44:45  문제 설명  개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다. 코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데 개발 직군 면접인 만큼 아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.    대기실은 5개이며, 각 대기실은 5x5 크기입니다. 거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요. 단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.    예를 들어,                          위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다. 위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다. 위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다.        응시자가 앉아있는 자리(P)를 의미합니다. 빈 테이블(O)을 의미합니다. 파티션(X)을 의미합니다.          5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.    제한사항   places의 행 길이(대기실 개수) = 5   places의 각 행은 하나의 대기실 구조를 나타냅니다.  places의 열 길이(대기실 세로 길이) = 5 places의 원소는 P,O,X로 이루어진 문자열입니다.   places 원소의 길이(대기실 가로 길이) = 5 P는 응시자가 앉아있는 자리를 의미합니다. O는 빈 테이블을 의미합니다. X는 파티션을 의미합니다.  입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다. return 값 형식   1차원 정수 배열에 5개의 원소를 담아서 return 합니다. places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다. 각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.      입출력 예           places result            [[\"POOOP\", \"OXXOX\", \"OPXPX\", \"OOXOX\", \"POXXP\"], [\"POOPX\", \"OXPXP\", \"PXXXO\", \"OXXXO\", \"OOOPP\"], [\"PXOPX\", \"OXOXP\", \"OXPOX\", \"OXXOP\", \"PXPOX\"], [\"OOOXX\", \"XOOOX\", \"OOOXX\", \"OXOOX\", \"OOOOO\"], [\"PXPXP\", \"XPXPX\", \"PXPXP\", \"XPXPX\", \"PXPXP\"]] [1, 0, 1, 1, 1]            입출력 예 설명  입출력 예 #1  첫 번째 대기실                            No. 0 1 2 3 4   0 P O O O P   1 O X X O X   2 O P X P X   3 O O X O X   4 P O X X P           모든 응시자가 거리두기를 지키고 있습니다.   두 번째 대기실                            No. 0 1 2 3 4   0 P O O P X   1 O X P X P   2 P X X X O   3 O X X X O   4 O O O P P           (0, 0) 자리의 응시자와 (2, 0) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (1, 2) 자리의 응시자와 (0, 3) 자리의 응시자가 거리두기를 지키고 있지 않습니다. (4, 3) 자리의 응시자와 (4, 4) 자리의 응시자가 거리두기를 지키고 있지 않습니다.   세 번째 대기실                            No. 0 1 2 3 4   0 P X O P X   1 O X O X P   2 O X P O X   3 O X X O P   4 P X P O X           모든 응시자가 거리두기를 지키고 있습니다.   네 번째 대기실                            No. 0 1 2 3 4   0 O O O X X   1 X O O O X   2 O O O X X   3 O X O O X   4 O O O O O           대기실에 응시자가 없으므로 거리두기를 지키고 있습니다.   다섯 번째 대기실                            No. 0 1 2 3 4   0 P X P X P   1 X P X P X   2 P X P X P   3 X P X P X   4 P X P X P           모든 응시자가 거리두기를 지키고 있습니다.   두 번째 대기실을 제외한 모든 대기실에서 거리두기가 지켜지고 있으므로, 배열 [1, 0, 1, 1, 1]을 return 합니다.    제한시간 안내   정확성 테스트 : 10초   ※ 공지 - 2022년 4월 25일 테스트케이스가 추가되었습니다.       두 테이블 T1, T2가 행렬 (r1, c1), (r2, c2)에 각각 위치하고 있다면, T1, T2 사이의 맨해튼 거리는 |r1 - r2| + |c1 - c2| 입니다.&nbsp;↩         출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   간단한 BFS 문제다.  맨해튼 거리는 공식으로 구하거나 bfs를 통해 진행할 수 있는데 5x5 상황에서 별 차이가 없어 bfs로 구현했다.     코드   import java.util.*;  class Solution {     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     public int[] solution(String[][] places) {         int[] res = new int[5];                  for(int t=0; t&lt;5; t++){             char[][] board = new char[5][5];             for(int i=0; i&lt;5; i++){                 board[i] = places[t][i].toCharArray();             }             boolean flag = true;             outer: for(int i=0; i&lt;5; i++){                 for(int j=0; j&lt;5; j++){                     if(board[i][j] == 'P'){                         if(!bfs(board, i, j)) {                             flag = false;                             break outer;                         }                     }                 }             }                          if(flag) res[t] = 1;             else res[t] = 0;         }                  return res;     }          private static boolean bfs(char[][] board, int r, int c){         Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();         boolean[][] visited = new boolean[5][5];                  queue.offer(new int[] {r, c});         visited[r][c] = true;                  int depth = 0;                 while(!queue.isEmpty() &amp;&amp; depth &lt; 2){             int size = queue.size();             for(int i=0; i&lt;size; i++){                 int[] curr = queue.poll();                 int cr = curr[0];                 int cc = curr[1];                 for(int k=0; k&lt;4; k++){                     int nr = cr + dr[k];                     int nc = cc + dc[k];                                          if(isValid(nr, nc) &amp;&amp; !visited[nr][nc]){                         char node = board[nr][nc];                         if(node == 'X') continue;                         else if(node == 'P') return false;                         else if(node == 'O') {                             queue.offer(new int[] {nr, nc});                             visited[nr][nc] = true;                         }                     }                 }             }             depth++;         }         return true;     }          private static boolean isValid(int r, int c){         return r &gt;= 0 &amp;&amp; r&lt;5 &amp;&amp; c &gt;= 0 &amp;&amp; c&lt;5;     } }  "
  },
  
  {
    "title": "PGMS_추석 트래픽 (Java)",
    "url": "/posts/PGMS%EC%B6%94%EC%84%9D-%ED%8A%B8%EB%9E%98%ED%94%BD-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-09-10 11:49:39 +0900",
    "content": "[level 3] [1차] 추석 트래픽 - 17676  문제 링크  성능 요약  메모리: 83.2 MB, 시간: 100.74 ms  구분  코딩테스트 연습 &gt; 2018 KAKAO BLIND RECRUITMENT  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 09월 10일 11:40:34  문제 설명  추석 트래픽  이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.   입력 형식   solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다. 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다. 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다. 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 \"2016년 9월 15일 오전 3시 10분 33.010초\"부터 \"2016년 9월 15일 오전 3시 10분 33.020초\"까지 \"0.011초\" 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함) 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다. lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.   출력 형식   solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다.   입출력 예제  예제1   입력: [ \"2016-09-15 01:00:04.001 2.0s\", \"2016-09-15 01:00:07.000 2s\" ] 출력: 1   예제2   입력: [ \"2016-09-15 01:00:04.002 2.0s\", \"2016-09-15 01:00:07.000 2s\" ] 출력: 2 설명: 처리시간은 시작시간과 끝시간을 포함하므로  첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며, 두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다. 따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다.   예제3   입력: [ \"2016-09-15 20:59:57.421 0.351s\", \"2016-09-15 20:59:58.233 1.181s\", \"2016-09-15 20:59:58.299 0.8s\", \"2016-09-15 20:59:58.688 1.041s\", \"2016-09-15 20:59:59.591 1.412s\", \"2016-09-15 21:00:00.464 1.466s\", \"2016-09-15 21:00:00.741 1.581s\", \"2016-09-15 21:00:00.748 2.31s\", \"2016-09-15 21:00:00.966 0.381s\", \"2016-09-15 21:00:02.066 2.62s\" ] 출력: 7 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.    해설 보러가기     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges        문제 풀이   일단 로그를 1ms단위로 쭉 찾으며 진행하는 브루트포스 방법은 당연히 시간초과다. 이에 어떻게 효율적으로 겹치는 구간 찾기를 진행할지 고민했다.  생각보다 간단했는데 그냥 로그 처음과 끝이 포함되면 된다. 로그 중간이 포함된다는 거는 전체가 걸쳐있거나 한쪽이 걸쳐있다는건데 이는 처음부분, 끝부분 중 하나라도 1초구간에 포함되면 그 로그는 ok라는거다.  그래서 O(N^2) 으로 마무리할 수 있다.  작성하면서 주의할 점은 “.”으로 문자열 split 파싱할 때 String[] sec = time[2].split(\"\\\\.\"); 이렇게 이스케이프를 잘 붙여줘야한다.  그리고  long gapMs = (long) Double.parseDouble(s);  이렇게 하니까 0.123같은걸 0으로 만들어버려서 double변수상태에서 1000을 곱하고 그 값을 long으로 만들었다. (소숫점 셋째짜리까지 존재하므로)     코드   import java.util.*;  class Solution {     static long[][] logs;     public int solution(String[] lines) {         int res = 0;         logs = new long[lines.length][2];                  for(int i=0; i&lt;lines.length; i++){             // \"2016-09-15 20:59:57.421 0.351s\",             String[] split = lines[i].split(\" \");             String[] time = split[1].split(\":\"); // 20, 59, 57.421             String[] sec = time[2].split(\"\\\\.\"); // 57 421(소수점)             String gap = split[2]; // 0.351s             long endTime = getEndTime(time, sec);             long startTime = getStartTime(endTime, gap);                          // System.out.println(startTime);             // System.out.println(endTime);                          logs[i][0] = startTime;             logs[i][1] = endTime;         }                  List&lt;Long&gt; points = new ArrayList&lt;&gt;();         for(int i=0; i&lt;logs.length; i++){             points.add(logs[i][0]);             points.add(logs[i][1]);         }                  for(long p : points){             int cnt = 0;                          // |1초구간| 사이에 start나 end가 있어야함             // logs[i][0]..1 -- |t -- logs[i][1]..1 ----- logs[i][0]..2 --- t+999| --- logs[i][1]..2             for(int i=0; i&lt;logs.length; i++){                 if(logs[i][0] &lt;= p+999 &amp;&amp; logs[i][1] &gt;= p) cnt++;             }                          res = Math.max(res, cnt);         }                           return res;     }          private long getEndTime(String[] time, String[] sec){         int h = Integer.parseInt(time[0]);         int m = Integer.parseInt(time[1]);         int s = Integer.parseInt(sec[0]);         int ms = Integer.parseInt(sec[1]);                  return h * 3600 * 1000L + m * 60 * 1000L + s * 1000L + ms;     }          private long getStartTime(long endTime, String gap){         String s = gap.substring(0, gap.length()-1); // s떼기         // System.out.println(s);         // long gapMs = (long) Double.parseDouble(s); // 소수점이 다 날아감 이렇게 하면 안됨         double gapMs = Double.parseDouble(s);         // System.out.println(\"gapMS : \" + gapMs);                  long gapSec = (long) (gapMs * 1000);         // System.out.println(\"gapSec : \" + gapSec);                  return endTime - gapSec + 1;     } }  "
  },
  
  {
    "title": "System Design Interview - 검색어 자동완성 시스템",
    "url": "/posts/System-Design-Interview-%EA%B2%80%EC%83%89%EC%96%B4-%EC%9E%90%EB%8F%99%EC%99%84%EC%84%B1-%EC%8B%9C%EC%8A%A4%ED%85%9C/",
    "categories": "시스템, 디자인",
    "tags": "System Design Interview",
    "date": "2025-09-08 05:57:28 +0900",
    "content": "들어가며  많은 포털 사이트, 웹 사이트 검색창에는 단어를 입력하면 입력중인 글자에 맞는 추천 검색어들이 표시된다. 이러한 기능을 자동완성 이라고 한다.   이 글은 특정 입력에 대한 검색어 자동 완성 기능을 다룬다.    1. 문제 이해 및 설계 범위     자동완될 검색어는 첫 부분으로 한정한다.   5개의 자동완성 검색어가 표시되어야 한다.   인기 순위를 기준으로 5개의 검색어를 표시한다.   맞춤법 검사나 자동수정은 지원하지 않는다   질의어는 영어지만, 다국어 지원을 생각하면 좋다.   질의는 영어 소문자로 구성된다.   DAU는 천만명 기준이다.     요구사항 정리     빠른 응답 속도 : 사용자가 검색어를 입력할 때마다 자동완성 검색어도 표시되어야 한다. (100ms 이내)   연관성 : 사용자가 입력한 단어와 연관되어야 한다.   정렬 : 인기도 등의 순위 모델에 의해 정렬되어 있어야 한다.   규모 확장성 : 시스템은 많은 트래픽을 감당할 수 있도록 확장 가능해야 한다.   고가용성 : 시스템의 문제가 생겨도 가용할 수 있어야 한다.     개략적 규모 추정     DAU는 천 만명으로 가정   평균적으로 한 사용자는 매일 10건의 검색을 수행한다고 가정   질의할 때마다 평균적으로 20바이트의 데이터를 입력한다고 가정            ASCII를 사용한다고 가정하면, 1 문자 = 1 byte           평균적으로 1회 검색당 20건의 요청이 백엔드로 전달된다고 가정   대략 초당 24,000건의 QPS가 발생할 것이고 최대 QPS는 48,000건이 될 것이다.            천만 사용자 x 10질의 / 일 x 20자 / 24시간 / 3600초           질의 가운데 20%는 신규 검색어라고 가정하면            천만 사용자 x 10질의 / 일 x 20자 x 20%로 매일 0.4GB 의 신규 데이터가 시스템에 추가된다             2. 개략적 설계안 데이터 수집 서비스, 질의 서비스 두 부분으로 나뉜다.  데이터 수집 서비스    사용자가 입력한 질의를 실시간으로 수집하는 시스템이다.   질의문과 사용빈도를 저장하는 빈도 테이블을 두었다고 가정한다면, 사용자가 twitch, twitter, twitter, twillo 순서를 검색하면 아래와 같이 빈도 테이블이 바뀌어진다.   질의 서비스    주어진 질의에 k개의 인기 검색어를 정렬해 내놓는 서비스다.   질의서비스는 아래 표와 같이 query, frequency 필드를 가지고 있다.     query : 질의문을 저장하는 필드   frequency : 질의문이 사용된 빈도를 저장하는 필드     이 상태에서 사용자가  tw 를 입력한다면, 다음 SQL를 통해 twitter, twitch, twilight, twin peak, twitch prime 순으로 표시될 것이다.   가장 많이 사용된 5개 검색어는 아래의 SQL 질의문을 사용해 계산할 수 있다. SELECT * FROM frequency_table \tWHERE query Like `prefix%` \t\tORDER BY frequency DESC \t\t\tLIMIT 5;   데이터 양이 적을 때는 괜찮지만, 데이터가 아주 많아진다면 데이터베이스의 병목 현상이 발생할 수 있다.    3. 상세 설계  트라이 자료구조, 데이터 수집 서비스, 질의 서비스, 트라이 연산, 저장소 규모 확장을 통해 최적화 설계를 해보자.  트라이 자료구조    문자열들을 간략하게 저장할 수 있는 자료구조다. 문자열을 꺼내는 연산에 최적화되어 있다.   특징     트라이는 트리형태의 자료구조   루트 노드는 빈 문자열   각 노드는 문자 하나를 저장하며, 26개의 자식노드를 가질 수 있다.   각 트리 노드는 하나의 단어 또는 prefix string 을 나타낸다.   아래는  tree, try, true, toy, wish, win 이 저장된 트라이다.  이용 빈도에 따라 정렬된 값을 반환하기 위해서 노드에 빈도 정보를 같이 저장한다.    해당 트라이로 검색어 자동완성을 어떻게 구현할 수 있을까?  p : prefix의 길이 n : 트라이 노드 개수 c : 주어진 노드의 자식 개수  이 정보를 가지고 be 를 입력했을 때 자동완성의 시간복잡도와 알고리즘을 알아보자.  가장 많이 사용된 질의어 k 개는 다음과 같이 찾을 수 있다. (k = 3이라 가정)          해당 접두어를 표현하는 노드를 찾는다. O(p)           해당 노드부터 시작하는 하위 트리를 탐색하여 모든 유효 노드를 찾는다. O(n)             유효 노드 : 사용자가 검색한 문자열을 구성하는 노드 ex) [bee: 20], [beer: 10], [best: 35], [bet: 29]                상위  k개 검색어를 정렬한다. O(clogc) (최소힙 사용시 O(clogk) 로 더 효과적) 결과 :  [best:35], [bet:29], [bee: 20]      따라서 총 시간 복잡도는 O(p) + O(n) + O(clogc) 가 된다.    하지만 최악의 경우 전체 트라이를 다 검색해야 하는 일이 생길 수 있고, 여기서 더 최적화 할 수 있다.  1. 접두어 최대 길이 제한  p값을 작은 정숫값으로 제한한다면 O(p) 에서 O(작은 상숫값) = O(1) 이 될 것이다.  2. 노드에 인기 검색어 캐시  아래 그림과 같이 각 노드에 인기 질의어를 캐시 하면 공간 복잡도는 증가하겠지만 시간 복잡도를 O(1) 로 획기적으로 낮출 수 있다.      데이터 수집 서비스  지금까지의 설계안은 사용자가 검색창에 검색어를 입력할 때마다 실시간으로 데이터를 수정하고 있다. 이 방법에는 두 가지 문제가 있다.  문제 1. 매일 수천만 건의 질의가 입력되면 수천 만 번의 트라이 갱신이 발생할텐데, 서비스가 심각하게 느려질 것이다.  문제 2. 인기 검색어는 자주 바뀌지 않을 것이기 때문에 트라이 갱신을 자주 할 필요가 없을 것이다.    위 그림과 같이 개선안을 만들 수 있다. 차례로 살펴보자.  데이터 분석 서비스 로그 (Analytics Logs)    검색창에 입력된 질의에 관한 원본 데이터가 보관된다. 데이터가 추가만 되고 수정은 없으며, 로그 데이터에는 인덱스를 걸지 않는다.     로그 취합 서버 (Aggregators)    데이터 분석 서비스로부터 나오는 방대한 양의, 제각각인 데이터 형식 데이터를 잘 취합(aggregation)하여 해당 시스템이 쉽게 소비할 수 있도록 한다.   대부분의 경우 일주일에 한 번 정도로 로그를 취합하는데 트위터와 실시간 애플리케이션의 경우 취합 주기를 짧게 설정한다.  취합된 데이터 (Aggregated Data)     time : 해당 주가 시작된 날짜 (취합)   frequency : 해당 질의가 해당 주에 사용된 횟수의 합 (빈도)     작업 서버 (Workers)    주기적으로 비동기적 작업(job)을 실행하는 서버 집합이다.   작업서버는 트라이 자료구조 생성 및 트라이 데이터베이스에 저장하는 역할을 담당한다.  트라이 캐시    분산 캐시 시스템으로 트라이 데이터를 메모리에 유지하여 읽기 연산 성능을 높인다.   매주 데이터베이스 스냅샷을 떠서 갱신한다.  트라이 데이터베이스    지속성 저장소다.   트라이 데이터베이스로 사용할 수 있는 선택지 2개          문서 저장소             새 트라이를 매주 만들 것이므로 주기적으로 트라이를 직렬화하여 데이터베이스에 저장한다.       MongoDB 같은 문서 저장소를 활용 가능하다.                키-값 저장소             해시 테이블 형태로 변환 가능하다.       트라이에 보관된 모든 prefix를 해시 테이블 키로 변환하여 저장한다.       각 트라이 노드에 보관된 모든 데이터를 해시 테이블 값으로 변환한다. (인기 검색어)               질의 서비스  방금 전 설계안의 비효율성을 개선한 새 설계안은 아래와 같다.   동작 과정         검색 질의가 로드 밸런서로 전송된다.           로드밸런서는 해당 질의를 API 서버로 전달한다.           API 서버는 트라이 캐시에서 데이터를 가져와 자동완성 검색어 제안 응답을 구성한다.           데이터가 트라이 캐시에 없는 경우 트라이 데이터베이스에서 가져와 캐시에 채운다. (캐시 미스는 캐시 서버 메모리 부족 or 캐시 서버 장애가 때문에도 발생함)        질의 서비스는 매우 빨라야 하므로 다음과 같은 최적화 방안을 제안할 수 있다.          AJAX 요청 : 요청을 보내고 받기 위해 페이지를 새로고침 할 필요 없다. (실시간 반영)      브라우저 캐싱 : 대부분의 애플리케이션의 경우 자동완성 검색어 제안 결과는 짧은 시간 안에 자주 바뀌지 않으므로 브라우저 캐시에 넣어두면 후속 질의어 결과는 해당 캐시에서 바로 가져갈 수 있다.            HTTP의 Cache-Control 헤더를 조절하여 자주 변하지 않는 데이터를 브라우저 캐시에 저장하면, 사용자에게 빠른 응답을 제공하고 서버 부하를 줄일 수 있다.           데이터 샘플링 : 모든 질의 결과를 로깅하도록 하면 CPU 자원과 저장공간을 많이 소진하므로, N개 요청 가운데 1개만 로깅한다.     트라이 연산  트라이 생성  트라이는 작업서버가 담당하며, 데이터 분석 서비스의 로그나 데이터베이스로부터 취합된 데이터를 이용한다.  트라이 갱신    매주 한 번 갱신하는 방법 (추천)            새로운 트라이를 만든 다음 기존 트라이를 대체한다.           트라이의 각 노드를 개별적으로 갱신하는 방법 (트라이가 작을때 고려해볼만 하다)            성능이 좋지 않다. (노드를 갱신할 때 모든 상위 노드도 갱신해야 하는데, 사우이 노드에도 인기 검색어같은 캐시 데이터가 보관되기 때문)           검색어 삭제    여러 위험한 질의어를 자동완성 결과에서 제거해야 한다. (욕설, 혐오성, 폭력성 등 관련)   트라이 캐시 앞에 필터 계층(Filter Layer) 을 두고 부적절한 질의어를 거를 수 있다.  데이터베이스에서 해당 검색어 물리적으로 삭제하는건 다음 업데이트 사이클에 비동기적으로 진행한다.      저장소 규모 확장  구현 조건은 영어만 지원하면 되므로 간단하게는 첫 글자 기준으로 샤딩하는 방법이 있다.          Case 1) 검색어 보관에 두 대의 서버가 필요한 경우 a ~ m 으로 시작하는 검색어는 첫 번째 서버, 나머지 n ~ z 는 두 번째 서버에 저장한다.           Case 2) 검색어 보관에 세 대의 서버가 필요한 경우 a ~ i 까지는 첫 번째 서버에, j ~ r까지는 두 번째 서버에, 나머지 s ~ z 는 세 번째 서버에 저장한다.      이 방식으로는 사용 가능한 서버 최대 26개다. 그 이상으로 서버수 늘리려면 샤딩을 계층적으로 해야 한다.  예시)     Case 3) a 로 시작하는 검색어를 네 대의 서버에 나눠서 보관하는 경우 aa ~ ag, ah ~ an, ao ~ au, 나머지 av ~ az 로 4개의 서버에 나누어 보관하면 된다.   그럴싸해 보이지만 이는 데이터를 각 서버에 균등하게 배분할 수 없다.  a 로 시작하는 단어가 z 로 시작하는 단어보다 많다는 것을 생각해보면 알 수 있다. 각 알파벳으로 시작하는 단어의 개수가 비슷하지 않기 때문이다.    검색어 대응 샤드 관리자(shard map manager)    어떤 검색어가 어느 저장소 서버에 저장되는지에 대한 정보를 관리한다.   검색어 대응 샤드 관리자를 사용하면 이를 개선할 수 있다.   ( s 로 시작하는 검색어 양 ) = ( w, x, y, z 로 시작하는 검색어 양 ) 이라면, s 에 대한 샤드 하나, w ~ z에 대한 샤드 하나 이렇게 두개만 두어도 충분하다.  추가 확장 개선점    다국어 지원 : 유니코드로 저장   국가별 인기 검색어 지원 : 국가별로 다른 트라이 사용하고 이를 CDN에 저장하여 응답속도 향상     실시간 검색어 자동완성 시스템 고급 구현  책에서 추가로 소개하는 실시간 검색 추이 반영을 위한 핵심 아이디어는 다음과 같다.  샤딩을 통해 작업 대상 데이터의 양을 줄인다.  순위 모델(ranking model)을 바꾸어 최근 검색어에 보다 높은 가중치를 주도록 한다.  데이터가 스트림 형태로 올 수 있기 때문에 스트림 프로세싱에 적합한 시스템을 고려한다. (아파치 하둡 맵리듀스, 아파치 스파크 스트리밍, 아파치 스톰, 아파치 카프카 등이 이 그런 부류의 시스템이다.)  이 중 핵심은 데이터 스트림 처리 시스템이다.  Apache Kafka를 이용한 실시간 데이터 처리    Apache Kafka 는 실시간으로 기록 스트림을 게시, 구독, 저장 및 처리할 수 있는 분산형 데이터 스트리밍 플랫폼이다. 하루에 1조 4천억 건의 메시지를 처리하기 위해 LinkedIn이 개발한 내부 시스템으로 시작했다.   카프카는 대규모 실시간 데이터를 안정적으로 처리할 수 있다. 검색어 자동완성에서는 사용자가 입력하는 검색어를 실시간으로 수집하고 분석해야 하는데, 카프카가 이 용도에 딱 맞다.  Spark Streaming으로 실시간 분석 스파크 스트리밍은 데이터 스트림을 시간 단위로 잘게 쪼개어 마이크로 배치 형태로 처리하기 때문에 배치 처리와 유사한 방식이지만, 실시간으로 데이터를 처리할 수 있다는 점에서 차이가 있다.    결국 Kafka로 데이터를 받고 → Spark로 실시간 처리 → 다시 Kafka로 결과 전송하는 파이프라인을 만드는 것이다.    LinkedIn의 신경망 기반 접근법  LinkedIn에서는 단순한 키워드 매칭을 넘어, 사용자의 검색 의도를 파악하는 고도화된 기술을 사용한다. LinkedIn에서 발표된 ‘Efficient Neural Query Auto Completion’ 논문을 기반으로 FST(Finite State Transducer)와 MCG(Maximum Context Generation) 라는 두 가지 핵심 개념을 적용했다. 이 방식은 단순한 패턴 매칭을 넘어, 검색어의 문맥을 이해하여 더 정확한 추천을 제공한다.       FST와 MCG: 검색어 자동완성 원리   사용자가 “cheapest flights from seattle to” 라는 검색어를 입력했다고 가정해보자  1. FST(Finite State Transducer): 후보 단어 생성  FST는 과거의 방대한 검색 기록을 분석하여 구축된 결정론적 유한 오토마타이다. FST는 ‘seattle to’ 뒤에 자주 등장했던 패턴, 예를 들어 ‘new york’, ‘london’, ‘san francisco’와 같은 도시 이름을 후보로 생성하는 역할을 한다.  하지만 FST는 순수한 패턴 분석에 의존하기 때문에 검색어의 의미적 맥락을 완벽하게 이해하지는 못한다. 따라서 FST가 생성하는 후보 목록에는 ‘pizza’와 같이 문맥상 관련성이 떨어지는 단어도 포함될 수 있다!  2. MCG(Maximum Context Generation): 최적의 순위 결정  이때 MCG가 등장한다. MCG는 신경망(Neural Network) 기반의 모델로, FST가 제시한 후보 단어들 중에서 전체 검색어의 맥락(context) 을 고려해 가장 적합한 단어의 순위를 매기는 역할을 한다.  MCG는 ‘cheapest flights’라는 단어가 ‘여행’과 관련된 맥락임을 이해하고, ‘seattle to’ 뒤에 오는 단어가 ‘여행지’일 확률이 높다고 판단한다. 만약 FST가 ‘new york’, ‘pizza’와 같은 단어를 후보로 제시했다면, MCG는 ‘pizza’가 여행 맥락과 무관하다고 판단해 순위를 낮추고, ‘new york’과 같은 여행지 관련 단어를 상위에 배치하여 사용자에게 보여준다.  이처럼 FST가 후보 단어를 생성하고, MCG가 그 단어들의 순위를 최적화하는 이원화된 접근법을 통해, 단순한 트라이 구조보다 훨씬 똑똑하게 예측하는 것이다.  정확한 데이터 처리를 위한 Exactly-Once 실시간 시스템에서 가장 중요한 건 데이터 중복이나 손실 없이 정확히 한 번만 처리하는 것이다.  실시간 스트리밍 데이터 처리에서 한 번만 정확하게(exactly-once) 처리하는 것은 중복 데이터 처리와 데이터 손실을 방지하고 분석 결과가 왜곡되지 않도록 하는 데 중요하다. 이는 카프카에서 간단히 설정할 수 있음을 저번 글에서 소개했다.    마치며  검색창에 단 한 글자를 입력하는 단순한 행위 뒤에는, 빠른 응답 속도, 높은 가용성, 그리고 정확한 추천을 보장하기 위한 복잡하고 정교한 시스템 설계가 숨겨져 있었다.  트라이 자료구조부터 실시간 스트리밍 처리, 신경망 기반 예측까지 우리가 당연하게 여기는 검색어 자동완성은 대규모 시스템 설계의 핵심 개념들이 모두 집약된 놀라운 엔지니어링의 결과물이다.    References     웹 서비스 캐시 똑똑하게 다루기   Apache-Kafka란?   Google 자동 완성 예상 검색어의 작동 방식   Efficient Neural Query Auto Completion   "
  },
  
  {
    "title": "Cloud Run 콜드 스타트 삽질기",
    "url": "/posts/15%EB%B6%84%EC%9D%B4%EB%A9%B4-%EC%B6%A9%EB%B6%84%ED%95%A0-%EC%A4%84-%EC%95%8C%EC%95%98%EB%8A%94%EB%8D%B0/.-Cloud-Run-%EC%BD%9C%EB%93%9C-%EC%8A%A4%ED%83%80%ED%8A%B8-%EC%82%BD%EC%A7%88%EA%B8%B0/",
    "categories": "사이드, 프로젝트",
    "tags": "Cloud Run, GCP",
    "date": "2025-09-08 02:46:56 +0900",
    "content": "들어가며     서비스를 배포 비용을 최소화 하기위해 노력해본 사람들은 콜드 스타트에 대한 경험이 있을 것이다. 필자도 Hit Me Up 이라는 서비스를 운영하며 겪었던 콜드 스타트에서 벗어나기까지의 과정을 기록해 보고자 한다.     콜드 스타트란?  클라우드 환경에서 일정 시간 요청이 없으면 인스턴스가 자동 종료되고, 다시 요청이 들어올 때 서버가 재시작되면서 초기화 지연이 발생하는 현상을 콜드 스타트라고 한다.  이로 인해 사용자에게 서비스 응답 지연이 발생해 불편함을 줄 수 있다. 특히 Cloud Run 같은 서버리스 환경에서 빈번히 나타난다.    문제 상황  처음 Cloud Run에 Spring Boot 애플리케이션을 배포했을 때 콜드 스타트 문제는 간단히 해결될 줄 알았다. Google 문서에 따르면 Cloud Run 인스턴스는 요청이 없으면 15분 후에 자동으로 종료된다고 했기 때문이다.  “그럼 15분마다 한 번씩 ping 보내면 되겠네!” 라고 생각했고 그래서 다음과 같이 간단한 github actions 자동화 스크립트를 작성했다.  # 첫 번째 시도: 15분 간격 on:   schedule:     - cron: '*/15 * * * *'  # 15분마다 실행   여기 cron 표현식은 공백으로 구분된 다섯 개의 필드로 이루어져 있고, 각 필드는 다음을 나타낸다.          분(Minute) : 0부터 59까지           시(Hour) : 0부터 23까지           일(Day of Month) : 1부터 31까지           월(Month) : 1부터 12까지           요일(Day of Week) : 0부터 6까지 (0은 일요일, 6은 토요일)      15분 외 *은 모든 항목을 선택한다는 의미다.  테스트 해보니 여전히 콜드 스타트가 발생했고, 응답 시간이 10초가 넘는 상황이 반복됐다.    첫 번째 시도: 10분으로 단축 “10분으로 줄여보자”  # 두 번째 시도: 10분 간격 on:   schedule:     - cron: '*/10 * * * *'  # 10분마다 실행   하지만 여전히 콜드 스타트는 계속 발생했다. 뭔가 근본적으로 잘못되었다는 것을 깨닫고 분석해보았다.    GitHub Actions의 불안정성  Cloud Run 로그를 살펴보았다.  로그 데이터:  23:50 ping (9월 6일) → 01:49 ping (9월 7일) = 1시간 59분 01:49 ping → 02:57 ping = 1시간 8분   02:57 ping → 03:36 ping = 39분 03:36 ping → 03:52 ping = 16분 03:52 ping → 04:25 ping = 33분  ...  20:21 ping 성공 20:38 ping (10.503s) - 콜드스타트 (17분 후) 20:50 ping 성공   21:39 ping (10.741s) - 콜드스타트 (49분 후!!)   GitHub Actions의 cron 스케줄이 정확히 실행되지 않고 있었던 것이다. */10 설정에도 불구하고 완전히 불규칙하게 실행되고 있었다.  이에 Github Actions 공식문서를 통해 다음과 같은 명시적인 경고를 찾을 수 있었다.     Note: The schedule event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.   즉, 워크플로우 실행량이 많으면 예약 이벤트가 지연되거나 누락될 수 있다는 것이다.    두 번째 시도: 5분 교차 워밍 전략  문제를 해결하기 위해 이중 스케줄 전략을 고안했다.  name: Keep Cloud Run Warm  on:   schedule:     - cron: '*/5 * * * *'      # 0,5,10,15,20,25,30,35,40,45,50,55분     - cron: '2-59/5 * * * *'   # 2,7,12,17,22,27,32,37,42,47,52,57분   workflow_dispatch:  jobs:   warm-service:     runs-on: ubuntu-latest     timeout-minutes: 3          steps:       - name: Primary ping         id: primary         run: |           if curl -f -s -o /dev/null --max-time 20 \\             \"https://hitmeup-backend-593087166771.asia-northeast1.run.app/api/ping\"; then             echo \"success=true\" &gt;&gt; $GITHUB_OUTPUT           else             echo \"success=false\" &gt;&gt; $GITHUB_OUTPUT           fi              - name: Backup ping         if: steps.primary.outputs.success != 'true'         run: |           sleep 30           curl -f -s -o /dev/null --max-time 20 \\             \"https://hitmeup-backend-593087166771.asia-northeast1.run.app/api/ping\"   이 방법의 핵심은 다음과 같다.     5분 간격 이중 스케줄링: 두 개의 cron이 번갈아가며 실행되어 실질적으로 2.5분마다 ping   백업 메커니즘: 첫 번째 ping이 실패하면 30초 후 재시도   안전 마진: 한 스케줄이 지연되어도 다른 스케줄이 백업 역할   스케줄링 시간 간격을 극단적으로 줄여버려서 그런지, 이 방법으로 콜드 스타트 오류는 면하게 되었다!    새로운 문제: 비용 폭탄 위험  Github Actions도 무제한이 아니다. 한달에 사용 가능한 시간 제한이 있다.  Github Actions Billing 에서 Free 플랜을 보면 아래 표와 같다.                 계획       스토리지       분(월)                       GitHub Free       500 MB       2,000           필자는 현재 Github Education으로 다음과 같은 사용량 제한이 있다.    사진을 보면 3000 Actions 분/월 인데 이 제한을 넘어가면 비용이 청구되는 것이다.  5분 교차 전략을 적용하려고 비용을 계산해보았다.     5분 이중 스케줄 : 월 17,280분 → 576% 초과 ❌   10분 단일 스케줄 : 월 4,320분 → 144% 초과 ❌   예상 추가 비용 : $10.56/월 (10분) ~ $114.24/월 (5분 이중)   Pro 계정이어도 둘 다 할당량을 초과한다는 현실을 깨달았다.  최소 인스턴스수를 0으로 만들며 몇달러 줄이려다, 오히려 비용이 여기서 더 발생하는 상황을 만든 것이다.    마지막 해결책: UptimeRobot  이에 Github Actions가 아닌 외부 모니터링 서비스를 검색했다.  그리고 발견한 서비스가 UptimeRobot 이다.  UptimeRobot을 선택한 이유는 다음과 같은 무료 플랜의 장점때문이다.     50개 모니터 - 1개도 충분하고 여유롭게 여러개 사용 가능   짧은 시간 간격 - 최소 30초부터 가능하고 디폴트값인 5분으로 충분히 콜드스타트 방지 가능   전용 모니터링 서비스 - GitHub Actions보다 안정적으로 정확히 작동함   즉시 알림 - 문제 발생 시 이메일, SMS, 전화, 전용 앱 푸시 등으로 바로 확인가능   설정 방법도 매우 간단했다.     무료로 사이트 가입을 한다.   모니터 타입을 선택한다.(필자의 서비스는 웹 서비스 엔드포인트로 요청을 보내는 것이 목표이므로 “HTTP / website monitoring” 선택)        타겟 URL 등 설정을 한다            자신이 원하는 작업 엔드 포인트 ex) https://hitmeup-backend-593087166771.asia-northeast1.run.app/api/ping       Friendly Name: Hit Me Up Warmer       Monitoring Interval: 5 minutes (Default값)       Request Timeout: 30 seconds (Default값)               결과    위 사진은 Cloud Run 로그 탐색기에서 warmer 요청인 ping 엔드포인트 로그를 확인한 결과다.  몇초 이하의 딜레이를 제외하고 거의 정확히 5분간격으로 잘 실행되는것을 볼 수 있다.  또한 UptimeRobot 대시보드에서도 문제없이 잘 작동함을 확인할 수 있다.    요약하자면 아래와 같은 개선이 있었다.  이전 상황 (GitHub Actions) : 20:38 ping (10.503초) - 콜드스타트 21:39 ping (10.741초) - 콜드스타트 간격: 17분, 49분, 최대 1시간 59분!   이후 상황 (UptimeRobot 5분 간격) : 00:57:23 - UptimeRobot 요청 (4ms 응답) ✅ 01:02:26 - UptimeRobot 요청 (5ms 응답) ✅   01:07:29 - UptimeRobot 요청 (5ms 응답) ✅ 간격: 오차범위 내에서 거의 정확히 5분!   성능 개선: 10초 → 5ms (2,000배 개선!)  이렇게 완전히 무료로 콜드 스타트를 해결할 수 있었다.    마치며  15분이면 충분할 줄 알았던 단순한 생각에서 시작해, GitHub Actions의 불안정성을 발견하고, 무료 할당량의 현실을 깨달으며, 최종적으로 UptimeRobot이라는 완벽한 해결책을 찾아가는 여정이었다.  때로는 문제의 원인이 예상과 전혀 다른 곳에 있을 수 있다는 것을 배웠다. Cloud Run 자체의 문제가 아니라 GitHub Actions의 스케줄링 이슈였던 것처럼 말이다.  ps. 무료로 콜드 스타트를 해결하고 싶다면, UptimeRobot을 강력히 추천한다. GitHub Actions의 불안정함과 비용 문제를 모두 해결해주는 완벽한 솔루션이다. (광고아님)    References    GitHub Actions billing   Cloud Run 가격 책정   Google Cloud 무료 등급  "
  },
  
  {
    "title": "Effective Java - Ch.2 (Item 1) 생성자 대신 정적 팩터리 메서드를 고려하라",
    "url": "/posts/Effective-Java-Ch.2-Item-1-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/",
    "categories": "개발서적",
    "tags": "Java",
    "date": "2025-09-07 06:39:27 +0900",
    "content": "Ch 2. 객체 생성과 파괴  Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라  들어가며  클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 public 생성자다.  하지만 프로그래머가 꼭 알아야 할 한가지 기법이 더 있는데, 클래스는 생성자와 별도로 정적 팩터리 메서드(static factory methos)를 제공할 수 있다.  쉽게 말해 그 클래스의 인스턴스를 반환하는 단순한 정적 메서드다.  public static Boolean valueOf(boolean b) { \treturn b ? Boolean.TRUE : Boolean.FALSE; }   위 예시 메서드는 기본타입인 boolean\t값을 받아 Boolean 객체 참조로 변환해준다.    클래스는 클라이언트에 public 생성자 대신 (혹은 생성자와 함께) 정적 팩터리 메서드를 제공할 수 있다.  지금부터 정적 팩터리 메서드를 생성자와 비교한 각 장점과 단점에 대해 알아보자.    장점  1. 이름을 가질 수 있다.  생성자에 넘기는 매개변수와 생성자 자체만으로는 반환될객체의 특성을 제대로 설명하지 못한다.  반면 정적 팩터리는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.    또한 하나의 시그니처로는 생성자를 하나만 만들 수 있다. 입력 매개변수들의 순서를 바꿈으로써 생성자를 추가할 순 있지만 좋지 않은 방법이다.  아래와 같은 방법은 불가능하다. public class User {     private String name;     private String email;          // 이름으로 생성     public User(String name) {         this.name = name;     }          // 이메일로 생성     public User(String email) {         this.email = email;     } }   이럴땐 정적 팩터리 메서드로는 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어주면 된다.  다음과 같은 방법으로 해결할 수 있다. public class User {     private String name;     private String email;          private User() {} // 생성자는 private으로          // 이름으로 생성: 의도가 명확하다.     public static User withName(String name) {         User user = new User();         user.name = name;         return user;     }          // 이메일로 생성: 의도가 명확하다.     public static User withEmail(String email) {         User user = new User();         user.email = email;         return user;     } }   // 사용할 때 - 의도가 명확 User user1 = User.withName(\"김현재\"); User user2 = User.withEmail(\"khj@email.com\");     2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.  정적 팩터리 메서드는 호출될 때마다 새로운 인스턴스를 생성하지 않아도 된다. 불변 클래스(immutable class; 아이템 17)의 경우, 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 반환할 수 있다. 이는 불필요한 객체 생성을 막아 성능을 최적화하고 메모리 사용량을 절약하는 데 큰 도움이 된다.  대표적인 예시는 Boolean 클래스다.      public static Boolean valueOf(boolean b) {         return (b ? Boolean.TRUE : Boolean.FALSE);     }   위 메서드는 객체를 아예 생성하지 않는다. Boolean.TRUE 와 Boolean.FALSE 는 이미 Boolean 클래스 내부에 미리 정의된 상수다. 따라서 new Boolean(true) 를 반복적으로 호출하는 것보다 훨씬 효율적이다.  따라서 같은 객체(특히 생성 비용이 큰) 가 자주 요청되는 상황이라면 성능 향상이 가능하다.  플라이웨이트 패턴(Flyweight pattern) 도 이와 비슷한 기법이다.  플라이웨이트 패턴은 수많은 객체를 효율적으로 관리하여 메모리 사용량을 최소화하는 구조적 디자인 패턴이다.  [핵심 원리] 이 패턴의 핵심은 객체의 상태를 내적(intrinsic) 상태와 외적(extrinsic) 상태로 나누는 것이다.  - 내적 상태: 여러 객체가 공유할 수 있는 변하지 않는 상태다.  예를 들어, 텍스트 문서의 'A' 문자는 어떤 위치에 있든 모양은 항상 동일히다. 이 변하지 않는 'A'라는 정보가 내적 상태다.  - 외적 상태: 객체를 사용하는 문맥에 따라 변하는 상태다. 예를 들어, 텍스트 문서에서 'A' 문자의 위치, 색상, 글꼴 크기 등은 매번 달라질 수 있다. 이러한 정보는 공유하지 않고 별도로 관리한다.  [어떻게 동작하는가?] 공유 가능한 객체 풀(Pool) 생성: 팩토리(Factory)를 사용하여 공유 가능한 객체들을 미리 만들어 저장해 둔다.  객체 재사용: 새로운 객체 요청이 들어오면, 팩토리는 객체 풀에서 이미 존재하는 객체를 찾아 반환한다. 만약 객체가 없으면 새로 생성하여 풀에 추가한 후 반환한다.  외적 상태 분리: 클라이언트는 공유된 객체를 받아 사용하되, 외적 상태는 객체에 직접 저장하지 않고 별도로 전달하거나 관리한다.     이렇게 반복되는 요청에 같은 객체를 반환하는 방식으로, 정적 팩터리 방식의 클래스는 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다.  이러한 클래스를 인스턴스 통제(instance-controlled) 클래스라 한다.  Q) 인스턴스를 통제하는 이유는 무엇일까?    인스턴스 통제의 장점은 단순히 성능을 향상시키는 것을 넘어, 클래스의 행동을 제어하고 설계 원칙을 강화한다는 점이다.      클래스를 싱글턴(singleton; 아이템 3)으로 만들 수 있다.            public 생성자를 없애고, 정적 팩터리 메서드가 항상 동일한 하나의 인스턴스를 반환하도록 만든다. 이는 시스템 내에 단 하나의 객체만 존재함을 보장한다.           클래스를 인스턴스화 불가(noninstantiable; 아이템 4)로 만들 수 있다.            private 생성자와 정적 팩터리 메서드를 통해 객체 생성 방식을 통제할 수 있다.           불변값 클래스(아이템 17)에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.            논리적으로 같은 두 객체가 물리적으로도 같은 인스턴스를 가리키게 하여, 동치성 비교 비용을 줄이고 예측 가능성을 높인다. (a == b 일때만 a.equals(b) 가 성립)             3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.  정적 팩터리 메서드는 호출 시 반환하는 객체의 구체적인 클래스를 자유롭게 선택할 수 있다. 예를 들어, 반환 타입은 부모 클래스나 인터페이스로 지정하되, 실제로는 그 하위 타입의 객체를 반환할 수 있다.  이는 클라이언트가 객체의 구체적인 구현체를 알 필요 없이 인터페이스에 의존하여 프로그래밍할 수 있게 해준다. 따라서 클라이언트 코드의 유연성이 크게 향상된다.  API를 만들 때 이 유연성을 응용하면 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.  다음은 자바의 Collections 프레임워크의 예시다. public static final &lt;T&gt; List&lt;T&gt; emptyList() {     return (List&lt;T&gt;) EMPTY_LIST; }  private static class EmptyList&lt;E&gt;         extends AbstractList&lt;E&gt;         implements RandomAccess, Serializable { ... }   위 코드에서 Collections.emptyList() 메서드는 반환타입으로 List 인터페이스를 명시하고 있다. 하지만 실제 반환하는 객체는 Collections 클래스 내부에 정의된 private 클래스 EmptyList 의 인스턴스다.  클라이언트는 List 인터페이스만 알면 되므로, 구현체인 EmptyList 의 존재를 몰라도 된다. 이러한 방식은 프로그래머가 API를 사용하기 위해 익혀야 할 개념의 수와 난이도를 낮췄다.  과거에는 Collections 와 같이 정적 팩터리를 담는 유틸리티 클래스가 필수적이었다. 하지만 자바 8부터 인터페이스에 public static 메서드를 추가하는 것이 가능해졌다. 이로 인해 정적 팩터리 메서드를 클래스 외부에 별도로 두지 않고, 인터페이스 자체에 구현할 수 있게 되었다.  더 나아가 자바9부터는 인터페이스에 private static 메서드까지 추가할 수 있게 되면서, 정적 팩터리 메서드가 내부에서만 사용하는 헬퍼 메서드를 갖는 것이 가능해졌다.    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.  정적 팩터리 메서드는 매개변수에 따라 다른 클래스 객체를 유연하게 반환할 수 있다.  예시로 EnumSet 클래스가 있다.  EnumSet은 enum 타입의 원소들을 효율적으로 저장하는 특화된 Set 구현체다.  EnumSet 클래스(아이템 36)는 public 생성자 없이 오직 정적 팩터리만 제공하는데, OpenJDK에서는 원소의 수에 따라 두 가지 하위 클래스 중 하나의 인스턴스를 반환한다.  아래 예시 코드를 보자.  public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {     Enum&lt;?&gt;[] universe = getUniverse(elementType);     if (universe == null)         throw new ClassCastException(elementType + \" not an enum\");      if (universe.length &lt;= 64)         return new RegularEnumSet&lt;&gt;(elementType, universe);     else         return new JumboEnumSet&lt;&gt;(elementType, universe); }  이 noneOf 메서드는 enum 타입의 원소 개수(여기서는 64)에 따라 두 가지 다른 EnumSet 구현체 중 하나를 반환한다.          원소의 수가 64개 이하일 경우: RegularEnumSet을 반환한다. 이 구현체는 long 비트 필드를 사용하여 매우 빠르고 메모리를 적게 사용합니다.           원소의 수가 64개를 초과할 경우: JumboEnumSet을 반환합니다. 이 구현체는 long 배열을 사용해 더 많은 원소를 처리할 수 있습니다.      클라이언트는 팩터리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수도 없고 알 필요도 없다. EnumSet의 하위 클래스이기만 하면 되므로 클라이언트는 EnumSet.noneOf(...) 를 호출하기만 하면 된다.    5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.  정적 팩터리 메서드의 반환타입이 인터페이스일때 빛을 발한다. 메서드가 정의되는 시점에는 반환할 객체의 구체적인 하위 클래스가 존재하지 않아도 된다. 나중에 해당 인터페이스를 상속받아 새로운 클래스를 만들면, 기존의 정적 팩터리 메서드 코드를 전혀 수정하지 않고도 이 새로운 클래스의 인스턴스를 반환할 수 있다.  이것은 구현체를 자유롭게 바꿔 끼울 수 있는 유연성을 제공한다. 클라이언트는 특정 구현체에 의존하는 대신, 인터페이스에만 의존해서 프로그래밍할 수 있기 때문이다.  이 장점은 서비스 제공자 프레임워크(Service Provider Framework)를 구현하는데 핵심적인 역할을 한다.  서비스 제공자 프레임워크는 보통 3가지 핵심 컴포넌트로 구성된다.          서비스 인터페이스 (Service Interface) : 서비스 제공자가 구현해야 할 기능을 정의하는 인터페이스다. 클라이언트는 이 인터페이스의 메서드를 통해 서비스를 이용한다.           제공자 등록 API (Provider Registration API) : 제공자가 구현체를 시스템에 등록할 때 사용한다.           서비스 접근 API (Service Access API) : 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 API다. 이것이 바로 정적 팩터리 메서드이며, 클라이언트는 이 메서드만 호출하면 된다.        가장 대표적인 예시는 JDBC(Java Database Connectivity)이다. JDBC는 특정 데이터베이스에 종속되지 않고 데이터베이스에 접근할 수 있게 해주는 프레임워크다.  JDBC 서비스 제공자 프레임워크     서비스 인터페이스 (서비스 구현체 대표) : Connection   프로바이더 등록 API (구현체 등록) : DriverManager.registerDriver()   서비스 엑세스 API (클라이언트가 서비스의 인스턴스를 가져갈 때 사용) : DriverManager.getConnection()   서비스 프로바이더 인터페이스 (서비스 인터페이스의 인스턴스 제공): Driver   // 1. 서비스 인터페이스 - 구현체들이 제공해야 할 서비스를 정의 public interface Connection extends Wrapper, AutoCloseable {     Statement createStatement() throws SQLException;     PreparedStatement prepareStatement(String sql) throws SQLException;     void commit() throws SQLException;     void close() throws SQLException;     // ... 실제로는 훨씬 많은 메서드들 }  // 2. 서비스 제공자 인터페이스 - 서비스 인터페이스의 인스턴스를 생성 public interface Driver {     // 핵심 메서드: Connection 객체를 생성하여 반환     Connection connect(String url, Properties info) throws SQLException;          // URL을 처리할 수 있는지 확인     boolean acceptsURL(String url) throws SQLException;          // 기타 메서드들... }  // 3. 서비스 관리자 클래스 - 실제 DriverManager 클래스 public class DriverManager {     // 등록된 드라이버들을 저장하는 리스트     private static final CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers          = new CopyOnWriteArrayList&lt;&gt;();          // 제공자 등록 API - 구현체를 시스템에 등록     public static void registerDriver(Driver driver) throws SQLException {         if (driver != null) {             registeredDrivers.addIfAbsent(new DriverInfo(driver, null));         } else {             throw new NullPointerException();         }         println(\"registerDriver: \" + driver);     }          // 서비스 접근 API - 클라이언트가 서비스 인스턴스를 획득 (정적 팩터리 메서드!)     public static Connection getConnection(String url, Properties info)              throws SQLException {                  ensureDriversInitialized(); // 드라이버 초기화                  // 등록된 모든 드라이버를 순회하면서 연결 시도         for (DriverInfo aDriver : registeredDrivers) {             if (isDriverAllowed(aDriver.driver, callerCL)) {                 try {                     Connection con = aDriver.driver.connect(url, info);                     if (con != null) {                         // 성공! Connection 반환                         return con;                     }                 } catch (SQLException ex) {                     // 다음 드라이버 시도                 }             }         }                  throw new SQLException(\"No suitable driver found for \" + url, \"08001\");     } }   이후 각 데이터베이스 제조사의 구현체 (나중에 개발됨)  // MySQL 팀이 나중에 개발한 구현체 public class MySQLDriver implements Driver {     static {         // 클래스 로딩 시 자동으로 자신을 등록         try {             DriverManager.registerDriver(new MySQLDriver());         } catch (SQLException e) {             throw new RuntimeException(\"Failed to register MySQL driver\", e);         }     }          @Override     public Connection connect(String url, Properties info) throws SQLException {         if (acceptsURL(url)) {             return new MySQLConnection(url, info); // MySQL용 Connection 구현체         }         return null; // 처리할 수 없는 URL이면 null 반환     }          @Override     public boolean acceptsURL(String url) throws SQLException {         return url.startsWith(\"jdbc:mysql:\");     } }   핵심 동작 과정     초기화 단계 : DriverManager.ensureDriversInitialized() 메서드가 호출되면:            jdbc.drivers 시스템 프로퍼티에서 드라이버 클래스들을 로드       ServiceLoader 를 통해 서비스 제공자들을 자동 발견하여 로드           연결 요청 단계 : DriverManager.getConnection() 호출 시:            등록된 모든 드라이버들을 순회       각 드라이버의 acceptsURL() 메서드로 URL 처리 가능 여부 확인       처리 가능한 드라이버의 connect() 메서드 호출       성공하면 Connection 객체 반환, 실패하면 다음 드라이버 시도           즉 DriverManager.getConnection() 이 작성되는 시점에는 MySQLConnection, PostgreSQLConnection 등의 구체적인 구현체가 존재하지 않아도 된다. 각 데이터베이스 벤더가 나중에 Driver 인터페이스를 구현하면 자동으로 지원되고, 기존 클라이언트 코드는 전혀 수정할 필요 없다.    단점  1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.  // Collections 클래스의 내부 구현체들 public class Collections {     // EmptyList는 private static 클래스     private static class EmptyList&lt;E&gt; extends AbstractList&lt;E&gt;              implements RandomAccess, Serializable {         // 외부에서 이 클래스를 상속할 수 없음     }          // 정적 팩터리 메서드로만 접근 가능     public static final &lt;T&gt; List&lt;T&gt; emptyList() {         return (List&lt;T&gt;) EMPTY_LIST;     } }  // 이런 식으로 EmptyList를 상속하려고 하면 불가능 class MyEmptyList extends Collections.EmptyList { } // 컴파일 에러!   하지만 이 제약은 오히려 상속보다 컴포지션을 사용하도록 유도하고, 불변 타입으로 만들려면 제약을 지켜야 한다는 점에서 장점으로 받아들여질 수도 있다.    2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.  생성자는 API 문서에서 명확하게 드러나지만, 정적 팩터리 메서드는 일반 메서드와 구분되지 않아 찾기 어려울 수 있다.  예를 들어 LocalDate 클래스의 경우     생성자는 private이고 정적 팩터리 메서드만 제공한다   LocalDate.of(), LocalDate.now(), LocalDate.parse() 등 여러 정적 팩터리 메서드가 존재하기 때문에  처음 사용하는 개발자는 어떤 메서드를 써야 할지 혼란스러울 수 있다.   따라서 정적 팩터리 메서드를 제공할 때, API 문서를 잘 써놓고 메서드 이름을 널리 알려진 규약에 따라 짓는 것이 중요하다.  다음은 정적 팩터리 메서드에 흔히 사용하는 명명 방식들이다.     from : 하나의 매개 변수를 받아서 객체를 생성   ex) Date date = Date.from(instant);      of : 여러개의 매개 변수를 받아서 객체를 생성   valueOf: from과 of의 더 자세한 버전   ex) BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);      instance 또는 getInstance : 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.   create 또는 newInstance : 새로운 인스턴스를 생성   get[OtherType] : 다른 타입의 인스턴스를 생성. 이전에 반환했던 것과 같을 수 있음.   new[OtherType] : 다른 타입의 새로운 인스턴스를 생성.     References    이펙티브 자바 3/E   Flyweight Pattern in Java: Maximizing Memory Efficiency with Shared Object Instances  "
  },
  
  {
    "title": "BOJ_1514_자물쇠 (Java)",
    "url": "/posts/BOJ1514%EC%9E%90%EB%AC%BC%EC%87%A0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-09-03 03:44:38 +0900",
    "content": "[Platinum III] 자물쇠 - 1514  문제 링크  성능 요약  메모리: 18068 KB, 시간: 144 ms  분류  다이나믹 프로그래밍, 그래프 이론, 최단 경로  제출 일자  2025년 9월 3일 03:35:58  문제 설명  세준이는 노트북을 누가 가져갈까봐 자물쇠로 잠가놓는다. 자물쇠는 동그란 디스크 N개로 구성되어 있다. 각 디스크에는 숫자가 0부터 9까지 숫자가 표시되어 있다. 디스크는 원형이기 때문에, 0과 9는 인접해 있다.  세준이는 한 번 자물쇠를 돌릴 때, 최대 세 칸을 시계 방향 또는 반시계 방향으로 돌릴 수 있다. 또, 최대 세 개의 인접한 디스크를 한 번에 돌릴 수 있다.  현재 자물쇠의 상태와 세준이의 비밀번호가 주어질 때, 자물쇠를 최소 몇 번 돌려야 풀 수 있는지 구하는 프로그램을 작성하시오.  자물쇠의 상태가 555이고, 세준이의 비밀번호가 464인 경우에, 각 디스크를 따로 따로 돌리면 3번 돌려야 한다. 하지만, 디스크 3개를 동시에 돌려서 444로 만들고, 2번째 디스크를 6으로 돌리면 2번만에 돌릴 수 있다.  입력  첫째 줄에 세준이의 비밀번호의 길이 (자물쇠의 크기) N이 주어진다. N은 100보다 작거나 같다. 둘째 줄에 현재 자물쇠의 상태가 주어지고, 셋째 줄에 세준이의 비밀번호가 주어진다.  출력  첫째 줄에 최소 몇 번을 돌려야 풀 수 있는지 구하는 프로그램을 작성하시오.     문제 풀이   이 문제는 동적 계획법(DP)으로 해결할 수 있다. 핵심은 현재 인덱스부터 끝까지 최소 회전 횟수를 재귀적으로 계산하고, 이미 계산한 상태는 메모이제이션하여 재사용하는 것이다. DP의 상태는 현재 디스크와 다음 두 디스크의 값으로 정의한다. 이는 한 번에 최대 세 개 디스크를 돌릴 수 있기 때문이다. 따라서 dp[currIdx][x][y][z]는 currIdx 위치부터 끝까지, 현재 디스크 값이 x, 다음 디스크 값이 y, 그 다음 디스크 값이 z일 때 최소 회전 횟수를 의미한다.  재귀 함수에서 먼저 현재 디스크가 목표 값까지 얼마나 돌려야 하는지 계산한다. 시계 방향과 반시계 방향 두 가지 경우를 모두 고려하며, 가능한 조작을 세 가지로 나누어 탐색한다. 첫 번째 디스크만 돌리는 경우, 첫 번째와 두 번째 디스크를 함께 돌리는 경우, 세 디스크 모두를 돌리는 경우이다. 각 조작에서 필요한 회전 수를 3으로 나누어 올림하면 실제 회전 횟수를 계산할 수 있다. 이 과정을 통해 단순히 자리별 회전 수를 더하는 방식보다 훨씬 효율적으로 최소 횟수를 구할 수 있다.  구현할 때는 배열 범위 문제를 고려하여 start 배열의 크기를 N+3으로 설정하였다. 이렇게 하면 currIdx + 3 접근 시 안전하게 값을 가져올 수 있다. DP 배열은 -1로 초기화하여 이미 계산된 상태를 재사용하도록 하였다. 이를 통해 동일한 상태를 반복적으로 계산하는 비효율을 피할 수 있다.  최종적으로 시작 인덱스 0에서 목표 상태까지 solve(0, start[0], start[1], start[2])를 호출하면 최소 회전 횟수를 얻을 수 있다. 이 접근법은 문제의 조건을 모두 반영하면서도 계산량을 크게 줄여, N이 최대 100일 때도 효율적으로 동작한다.  결과적으로, 이번 문제를 통해 한 번에 여러 자리를 동시에 돌릴 수 있는 경우에는 단순 계산보다 DP로 상태를 관리하는 것이 효율적이라는 알고리즘 설계 원리를 확인할 수 있다.     코드   package BOJ_1514_자물쇠;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.Arrays; import java.util.StringTokenizer;  public class Main { \tstatic int N; \tstatic int[] start, end; \tstatic int[][][][] dp; \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\t//br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1514_자물쇠/input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tString s = br.readLine(); \t\tString e = br.readLine();  \t\tstart = new int[103]; \t\tend = new int[103];  \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tstart[i] = s.charAt(i) - '0'; \t\t\tend[i] = e.charAt(i) - '0'; \t\t}  \t\tdp = new int[101][10][10][10]; \t\tfor (int i = 0; i &lt; 101; i++) { \t\t\tfor (int j = 0; j &lt; 10; j++) { \t\t\t\tfor (int k = 0; k &lt; 10; k++) { \t\t\t\t\tArrays.fill(dp[i][j][k], -1); \t\t\t\t} \t\t\t} \t\t}  \t\tSystem.out.println(solve(0, start[0], start[1], start[2]));  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \t/** \t * @param currIdx 현재 맞추고 있는 인덱스 (0 ≤ currIdx &lt; N) \t * @param x       현재 위치(currIdx)에 있는 디스크의 숫자 (0~9) \t * @param y       다음 위치(currIdx+1)에 있는 디스크의 숫자 (0~9) \t * @param z       그 다음 위치(currIdx+2)에 있는 디스크의 숫자 (0~9) \t * @return currIdx부터 끝까지 목표 상태(end[])로 맞추는 데 필요한 최소 조작 횟수 \t * \t * &lt;p&gt;설명: \t * &lt;ul&gt; \t *   &lt;li&gt;한 번의 조작에서 최대 세 개 연속 디스크를 같은 방향으로 최대 3칸까지 돌릴 수 있다.&lt;/li&gt; \t *   &lt;li&gt;현재 자리 x를 end[currIdx]에 맞추기 위해 필요한 칸 수를 왼쪽/오른쪽 두 방향으로 모두 고려한다.&lt;/li&gt; \t *   &lt;li&gt;필요한 칸 수를 (x만 돌림, x+y 돌림, x+y+z 돌림)으로 분배하여 최소 조작 횟수를 계산한다.&lt;/li&gt; \t *   &lt;li&gt;dp[currIdx][x][y][z]에 메모이제이션하여 동일 상태의 중복 연산을 방지한다.&lt;/li&gt; \t * &lt;/ul&gt; \t */ \tprivate int solve(int currIdx, int x, int y, int z) { \t\tif (currIdx == N) return 0;  \t\tif (dp[currIdx][x][y][z] != -1) return dp[currIdx][x][y][z];  \t\tint res = Integer.MAX_VALUE;  \t\tint diff = (end[currIdx] - x + 10) % 10; \t\tint[] ableDiffs = {diff, 10 - diff}; // {시계방향 회전수, 반시계방향 회전수}  \t\tfor (int i = 0; i &lt;= 1; i++) { // x 디스크는 i=0 시계, i=1 반시계 \t\t\tfor (int j = 0; j &lt;= ableDiffs[i]; j++) { // y 디스크는 0~ableDiffs[i] 만큼 \t\t\t\tfor (int k = 0; k &lt;= j; k++) { // z 디스크는 0~j 만큼 \t\t\t\t\tint next_y = (y + (i == 0 ? j : -j) + 10) % 10; \t\t\t\t\tint next_z = (z + (i == 0 ? k : -k) + 10) % 10;  \t\t\t\t\tint rot = solve(currIdx + 1, next_y, next_z, start[currIdx + 3]);  \t\t\t\t\t// 최소 돌린횟수 = 세개 나눠서 돌린 횟수 (xyz돌리기 + xy돌리기 + x돌리기) \t\t\t\t\trot += (k + 2) / 3 + ((j - k) + 2) / 3 + ((ableDiffs[i] - j) + 2) / 3; \t\t\t\t\tres = Math.min(res, rot); \t\t\t\t} \t\t\t} \t\t}  \t\treturn dp[currIdx][x][y][z] = res; \t} }  "
  },
  
  {
    "title": "무료로 구축하는 협업 자동화 : Trello + Github + Slack",
    "url": "/posts/%EB%AC%B4%EB%A3%8C%EB%A1%9C-%EA%B5%AC%EC%B6%95%ED%95%98%EB%8A%94-%ED%98%91%EC%97%85-%EC%9E%90%EB%8F%99%ED%99%94-Trello-Github-Slack/",
    "categories": "사이드, 프로젝트",
    "tags": "github, slack, trello",
    "date": "2025-09-02 01:36:47 +0900",
    "content": "들어가며  사이드 프로젝트를 진행할 때 개발 전, 협업 규칙과 컨벤션 등을 정한다. 이 기본 틀이 가장 중요하며 프로젝트 속도를 늦추지 않는 중요한 규칙이 된다.  이번 글은 어떻게 협업 자동화를 (무료로!) 구성했는지에 관한 이야기다.  레퍼런스가 없어 상당히 고생했기 때문에 비슷한 시도를 하는 모두에게 도움이 되었으면 좋겠다!    협업 툴  협업 툴로는 다양한 후보군들이 많다. 그 중에서 어떤 것을 선택할지 정하는 것도 쉽지 않았다.  선택한 협업 툴에 관한 짧은 설명과, 왜 선택하게 되었는지에 대해 정리하겠다.  Trello    칸반 보드 방식의 직관적인 작업 관리 도구      무료 플랜으로도 충분한 기능을 제공한다.   직관적인 UI로 작업 상태를 한눈에 파악 가능하다.   강력한 Automation 기능과 Power-Up 을 제공한다.   Jira나 Linear 같은 복잡한 도구 대신, 소규모 사이드 프로젝트에서는 간단하면서도 시각적인 관리가 필요했다. 특히 Automation Rules로 카드 생성시 GitHub 링크를 자동 생성할 수 있고, API가 잘 문서화되어 GitHub Actions와 연동하기 적합했다.    GitHub    코드 저장소 및 이슈 트래킹 툴      GitHub Actions를 통한 무료 CI/CD를 제공한다   풍부한 템플릿 기능   GitHub Actions의 강력함과 월 2000분 무료 제공이 결정적이었다. 무엇보다 Trello API 호출을 통한 자동화 구현이 가장 용이했다.    Slack: 팀 커뮤니케이션    팀 커뮤니케이션 툴      GitHub와의 연동성이 뛰어나다.   실시간 알림으로 빠른 피드백이 가능하다.   Discord나 Microsoft Teams도 있었지만, GitHub App의 연동 품질이 Slack이 가장 뛰어났다. 특히 팀 슬랙 채널에 PR, 이슈, 커밋 알림을 받아볼 수 있어 팀 전체가 프로젝트 진행상황을 실시간으로 공유할 수 있었다.    다음은 협업 툴 연동 파트인데, 이를 설명하기 전 협업 Flow 전략부터 설명하겠다. 왜냐하면 이 플로우에 맞게 연동 설정을 구축했기 때문에 미리 이해해야 쉽다.  Git Flow 및 브랜치 전략 체계적인 협업을 위해 명확한 Git Flow를 정의했다.  ver 1.0 master : 제품으로 출시될 수 있는 브랜치 develop : 다음 출시 버전을 개발하는 브랜치 feature : 기능을 개발하는 브랜치  ver 1.1 ~  release : 이번 출시 버전을 준비하는 브랜치 hotfix : 출시 버전에서 발생한 버그를 수정 하는 브랜치     브랜치 네이밍 컨벤션 일관성 있는 브랜치 관리를 위해 다음과 같은 컨벤션을 적용했다:     feature/ : 새로운 기능 개발 (예: feature/login-system )   design/ : 디자인 변경 (예: design/landing-page-redesign )   bugfix/ : 버그 수정 (예: bugfix/login-error )   hotfix/ : 긴급한 프로덕션 버그 수정 (예: hotfix/security-vulnerability )   release/ : 새로운 제품 출시 준비 (예: release/v1.2.0 )   refactor/ : 코드 리팩토링 (예: refactor/improve-performance )   docs/ : 문서 업데이트 (예: docs/api-guide )   test/ : 테스트 관련 변경 (예: test/integration-tests )   chore/ : 빌드 작업, 패키지 매니저 설정 등 (예: chore/update-dependencies )   style/ : 코드 스타일 변경 (예: style/lint-fixes )     작업 프로세스 효율적인 협업을 위해 명확한 작업 순서를 정의했다.  작업 전     Trello 카드를 Backlog 리스트 에 생성 (간단한 내용과 체크리스트)   라벨 및 담당자 할당   카드에 생성된 GitHub Issue 링크로 접속   Issue 템플릿을 활용하여 작업 내용 상세 작성   작업 중     작업할 Trello Card를 In Progress 리스트 로 이동   브랜치 네이밍 컨벤션에 따라 브랜치 생성 후 작업 시작   커밋 컨벤션에 맞게 커밋 작성 ( #이슈번호 필수 포함)   작업 완료 후     develop 브랜치로의 PR 생성   Reviewer 최소 1명 할당, Assignees, Labels, Milestone 설정   코드 리뷰 후 approve 및 merge   (선택사항) GitHub Actions 오류 발생시 디버그 로그로 수정     커밋 컨벤션 일관성 있는 커밋 히스토리 관리를 위한 컨벤션을 적용했다. feat: 유저 엔티티 추가  유저 id, email, password, createdAt, DeletedAt 필드 추가  #1   커밋 메시지에 이슈 번호를 포함하여 GitHub에서 자동으로 이슈와 커밋을 연결하도록 했다.  예시: 이슈 #10 에 커밋 연결     템플릿 활용  Issue 템플릿 작업의 일관성을 위해 Issue 템플릿을 만들었다.  **Add a title** (제목 작성)  **📋 Trello 카드 연결** Trello 카드 URL 또는 카드 ID를 입력하세요 (trello 카드에서 복사한 카드ID 입력)  **Description** 이슈에 대한 설명 작성 (설명 작성)  **Tasks** 필요한 작업 작성 (작업 작성) - [ ] 체크리스트 형태 - [x] 완료된 작업 표시  **Additional Infos** 스크린샷, 예시, 레퍼런스 등 (참고자료 url, 사진, 코드 등..)    생성 예시     PR 템플릿 Pull Request 생성 시 자동으로 적용되는 템플릿도 구성했다.  # Pull Request Summary (PR 내용 작성)  ## 🔗 Related Issue Closes #(이슈번호)  ## 📋 Trello 카드 (트렐로 카드 ID or URL)  ## 🔄 변경 유형 - [ ] 새 기능 - [ ] 버그 수정 - [ ] 문서 업데이트 - [ ] 빌드/설정 변경 - [ ] 스타일/UI 변경 - [ ] 리팩토링 (기능 변경 없음) - [ ] 테스트 추가/수정 - [ ] 성능 개선  ## ✅ 체크리스트 - [ ] 코드 컨벤션에 맞게 작성함 - [ ] 코드에 적절한 주석을 추가함 - [ ] 관련 문서를 업데이트함 - [ ] 변경사항이 기존 테스트를 통과함  ## 📝 추가 정보 (작성할 내용 있으면 작성)    생성 예시     자동화의 핵심: Trello Automation Trello의 Automation Rules를 활용하여 카드 생성시 자동으로 GitHub 연동 정보를 추가하도록 설정했다.   해당 rule을 단계에 따라 잘 진행하면 when a card is added to list \"🗒 Backlog\" by anyone,  post comment \"🔗 **GitHub 연동 안내**\\n\\n               **카드 ID**: {cardid}\\n\\n\\n카드 ID를 복사하세요!\\n\\n               **이슈 생성**: https://github.com/Im-almost-there/Server/issues\\n\\n\\n               이슈 생성 후 커밋시 #이슈번호를 포함하세요!\"   이 설정으로 카드가 생성되면 자동으로 카드 ID와 GitHub Issue 생성 링크가 댓글로 추가된다.     GitHub Actions를 통한 완전 자동화 가장 핵심적인 부분인 GitHub Actions를 통한 자동화 설정이다.  이를 통해 다음과 같은 작업들이 자동으로 처리된다:  1. 커밋시 Trello 카드에 커밋 정보 추가 2. PR 생성시 카드를 Code Review 리스트로 이동 3. PR 머지시 카드를 Done 리스트로 이동  GitHub Actions 워크플로우 name: Trello Integration  on:   push:   pull_request:     types: [opened, closed]  jobs:   # 커밋에 이슈 번호가 있으면 Trello 카드에 커밋 정보 추가   commit-to-trello:     if: github.event_name == 'push'     runs-on: ubuntu-latest     steps:     - name: Checkout code       uses: actions/checkout@v4       with:         fetch-depth: 2      - name: Extract issue numbers and update Trello       env:         TRELLO_API_KEY: ${{ secrets.TRELLO_API_KEY }}         TRELLO_TOKEN: ${{ secrets.TRELLO_TOKEN }}         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}       run: |         COMMIT_MSG=$(git log -1 --pretty=format:\"%B\")         ISSUE_NUMBERS=$(echo \"$COMMIT_MSG\" | grep -oE '#[0-9]+' | sed 's/#//')          for ISSUE_NUM in $ISSUE_NUMBERS; do           # GitHub Issue에서 Trello 카드 ID 추출           ISSUE_DATA=$(curl -s -H \"Authorization: token $GITHUB_TOKEN\" \\             \"https://api.github.com/repos/${{ github.repository }}/issues/$ISSUE_NUM\")                      ISSUE_BODY=$(echo \"$ISSUE_DATA\" | jq -r '.body // \"\"')           TRELLO_CARD_ID=$(echo \"$ISSUE_BODY\" | grep -oE \"[a-zA-Z0-9]{8,24}\" | head -1)            if [ -n \"$TRELLO_CARD_ID\" ]; then             # Trello 카드에 커밋 정보 댓글 추가             COMMIT_URL=\"https://github.com/${{ github.repository }}/commit/${{ github.sha }}\"             COMMENT_TEXT=\"커밋: $COMMIT_URL\"                          curl -X POST \\               -H \"Content-Type: application/json\" \\               \"https://api.trello.com/1/cards/$TRELLO_CARD_ID/actions/comments?key=$TRELLO_API_KEY&amp;token=$TRELLO_TOKEN\" \\               -d \"{\\\"text\\\":\\\"$COMMENT_TEXT\\\"}\"           fi         done     이런 방식으로 커밋할 때마다 해당 이슈와 연결된 Trello 카드에 자동으로 커밋 정보가 추가된다.    PR 생성시 자동화 # PR 생성시 Code Review 리스트로 이동   pr-to-review:     if: github.event.action == 'opened'     runs-on: ubuntu-latest     steps:     - name: Move Trello card to Code Review       env:         TRELLO_CODE_REVIEW_LIST_ID: ${{ secrets.TRELLO_CODE_REVIEW_LIST_ID }}       run: |         # PR 본문에서 이슈 번호 추출         ISSUE_NUMBERS=$(echo \"${{ github.event.pull_request.body }}\" | grep -oiE \"(closes?|fixes?|resolves?) #([0-9]+)\" | grep -oE \"#[0-9]+\" | sed 's/#//')                  for ISSUE_NUM in $ISSUE_NUMBERS; do           # 해당 이슈의 Trello 카드를 Code Review 리스트로 이동           curl -X PUT \\             \"https://api.trello.com/1/cards/$TRELLO_CARD_ID?key=$TRELLO_API_KEY&amp;token=$TRELLO_TOKEN&amp;idList=$TRELLO_CODE_REVIEW_LIST_ID\"                      # PR 정보를 카드에 댓글로 추가           curl -X POST \\             \"https://api.trello.com/1/cards/$TRELLO_CARD_ID/actions/comments?key=$TRELLO_API_KEY&amp;token=$TRELLO_TOKEN\" \\             -d \"{\\\"text\\\":\\\"PR: ${{ github.event.pull_request.html_url }}\\\"}\"         done   PR 머지시 자동화 # PR 머지시 Done 리스트로 이동   pr-to-done:     if: github.event.action == 'closed' &amp;&amp; github.event.pull_request.merged == true     runs-on: ubuntu-latest     steps:     - name: Move Trello card to Done       env:         TRELLO_DONE_LIST_ID: ${{ secrets.TRELLO_DONE_LIST_ID }}       run: |         # PR이 머지되면 해당 카드를 Done 리스트로 이동         curl -X PUT \\           \"https://api.trello.com/1/cards/$TRELLO_CARD_ID?key=$TRELLO_API_KEY&amp;token=$TRELLO_TOKEN&amp;idList=$TRELLO_DONE_LIST_ID\"                  # 머지 정보를 카드에 댓글로 추가         curl -X POST \\           \"https://api.trello.com/1/cards/$TRELLO_CARD_ID/actions/comments?key=$TRELLO_API_KEY&amp;token=$TRELLO_TOKEN\" \\           -d \"{\\\"text\\\":\\\"머지: ${{ github.event.pull_request.html_url }}\\\"}\"    이 설정을 통해 PR이 생성되었을 때 해당 이슈와 연동된 PR은 Code Review 리스트 에 자동으로 이동된다.  똑같이 PR이 병합되면 해당 카드는 자동으로 Done 리스트 로 이동된다.    필요한 설정 값 및 설정 방법 자동화를 구현하기 위해 다음과 같은 GitHub Secrets 설정이 필요하다. 각각을 어떻게 얻는지 단계별로 설명하겠다.  1. Trello API 키와 토큰 발급 Step 1: Trello Power-Up 관리자 페이지 접속     https://trello.com/power-ups/admin 접속   로그인 후 “New” 버튼 클릭하여 새 Power-Up 생성   Step 2: API Key 발급     Power-Up 생성 후 API Key를 확인할 수 있음   이 값을 TRELLO_API_KEY 로 사용   Step 3: Token 발급     API Key 페이지에서 “Token” 링크 클릭   권한을 허용하면 Token 발급   이 값을 TRELLO_TOKEN 으로 사용     2. Trello 보드 및 리스트 ID 확인     Trello 보드 ID 확인 방법     // 아래 예시 URL에서 /b/ 다음 문자열이 보드 ID    https://trello.com/b/[BOARD_ID]/board-name           리스트 ID 확인 방법:             Trello 보드에서 F12 (개발자 도구) 열기       Network 탭 활성화       카드를 다른 리스트로 이동       Network 탭에서 PUT 요청 확인       요청 URL에서 idList 파라미터 값이 리스트 ID           또는  curl \"https://api.trello.com/1/boards/[BOARD_ID]/lists?key=[API_KEY]&amp;token=[TOKEN]\"  위 명령어에 BOARD_ID , API_KEY , TOKEN 값 넣고 명령어 실행해보기.    3. GitHub Secrets 설정 Step 1: GitHub 저장소의 Settings 접속     저장소 → Settings → Secrets and variables → Actions   Step 2: Repository secrets 추가     TRELLO_API_KEY : 위에서 발급받은 API Key   TRELLO_TOKEN : 위에서 발급받은 Token   TRELLO_BOARD_ID : 트렐로 보드 ID   TRELLO_CODE_REVIEW_LIST_ID : “Code Review” 리스트 ID   TRELLO_DONE_LIST_ID : “Done” 리스트 ID   Secret 값들은 한번 저장하면 다시 볼 수 없으므로 정확히 입력해야 함  API Key 와 Token 은 외부에 노출되지 않도록 주의 (잘 저장해두자)    Slack 연동을 통한 실시간 알림 GitHub Repository의 Webhooks 기능을 활용하여 팀 슬랙 채널로 실시간 알림을 받도록 설정했다.  GitHub Webhooks 설정 Step 1: Slack에서 웹훅 URL 생성     Slack 워크스페이스의 앱 설정에서 “Incoming Webhooks” 추가   알림을 받고 싶은 채널 선택   생성된 웹훅 URL 복사 ( https://hooks.slack.com/services/... )   Step 2: GitHub Repository Webhooks 설정     Repository → Settings → Webhooks → Add webhook   Payload URL에 Slack 웹훅 URL 입력   Content type: application/json   원하는 이벤트 선택 (예: pull_request , pull_request_review )     설정한 알림 이벤트 현재 레포지토리에선 다음 이벤트들에 대한 알림을 받고 있다     Pull Request : PR 생성, 수정, 병합 등   Pull Request Review : 코드 리뷰 승인, 변경 요청 등   실시간 알림 예시 설정 완료 후 다음과 같은 알림들을 팀 슬랙 채널에서 받을 수 있다:     PR 생성시: 새로운 PR 생성 알림   코드 리뷰 완료시: 리뷰 승인/거부 알림   PR 병합시: 병합 완료 알림   이를 통해 팀원들이 개발 진행상황을 실시간으로 파악하고 빠르게 피드백을 주고받을 수 있게 되었다.  이슈 생성    PR 생성    Commit &amp; PR 병합   "
  },
  
  {
    "title": "System Design Interview - 알림 시스템 설계",
    "url": "/posts/System-Design-Interview-%EC%95%8C%EB%A6%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/",
    "categories": "시스템, 디자인",
    "tags": "System Design Interview",
    "date": "2025-09-01 03:23:18 +0900",
    "content": "들어가며  알림 시스템은 최근 많은 프로그램에서 채택하는 인기 있는 기능이다. 최신 뉴스, 제품 업데이터, 이벤트, 선물 등 고객에게 중요할 만한 정보를 비동기적으로 제공한다.  이러한 알림 시스템을 순차적으로 확장하며 설계해보려 한다.    1단계. 문제 이해 및 설계 범위 확정  하루에 백만건 이상의 알림을 처리하는 확장성 높은 시스템을 구축하는게 쉬운 과제가 아니다. 알림 시스템이 어떻게 구현되는지에 대한 깊은 이해가 필요한 작업이다.  이에 관한 문제가 면접에 출제될 때는 보통 정해진 정답이 없고, 문제 자체가 모호하게 주어지는 것이 일반적이므로, 적절한 질문을 통해 요구사항이 무엇인지 우리가 스스로 알아내야 한다.       지원자 : 이 시스템은 어떤 종류의 알림을 지원해야 하나요?   면접관 : 푸시 알림, SMS 메시지, 그리고 이메일입니다.   지원자 : 실시간 시스템이어야 하나요?   면접관 : 연성 실시간(soft real-time) 시스템이라고 가정합니다. 알림은 가능한 빨리 전달되어야 하지만, 시스템에 높은 부하가 걸렸을 때 약간의 지연은 무방합니다.   지원자 : 어떤 종류의 단말을 지원해야 하나요?   면접관 : ios 단말, 안드로이드 단말, 그리고 랩탑/데스크탑을 지원해야 합니다.   지원자 : 사용자에게 보낼 알림은 누가 만들 수 있나요?   면접관 : 클라이언트 애플리케이션 프로그램이 만들 수도 있고, 서버 측에서 스캐줄링 할 수도 있습니다.   지원자 : 사용자가 알림을 받지 않도록 설정할 수도 있어야 하나요?   면접관 : 네. 해당 설정을 마친 사용자는 더 이상 알림을 받지 않습니다.   지원자 : 하루에 몇 건의 알림을 보낼 수 있어야 하나요?   면접관 : 천만 건의 모바일 푸시 알림, 백만 건의 SMS 메시지, 5백만 건의 이메일을 보낼 수 있어야 합니다.     2단계. 개략적 설계안 제시 및 동의 구하기  iOS 푸시 알림, 안드로이드 푸시 알림, SMS 메시지, 이메일을 지원하는 알림 시스템의 개략적 설계안을 만들어보자.     알림 유형별 지원 방안   연락처 정보 수집 절차   알림 전송 및 수신 절차     알림 유형별 지원 방안  iOS 푸시 알림   iOS에서 푸시 알림을 보내기 위해서는 3가지 컴포넌트가 필요하다.                 알림 제공자(provider) : 알림 요청을 만들어 애플 푸시 알림 서비스(APNS)로 보내는 주체. 알림 요청을 위해 필요한 데이터는 다음과 같다                    (a) 단말 토큰: 알림 요청을 보내는 데 필요한 고유 식별자           (b) 페이로드: 알림 내용을 담은 JSON 딕셔너리                           ex)       {   \"aps\":{   \t  \t\"alert\": {           \t\"title\": \"Game Request\",               \"body\": \"Bob wants to play chess\",               \"action-loc-key\": \"PLAY\"   \t  },         \"badge\": 5   }                       APNS : 애플이 제공하는 원격 서비스. 푸시 알림을 iOS 장치로 보내는 역할                       iOS 단말 : 푸시 알림을 수신하는 사용자 단말             안드로이드 푸시 알림   안드로이드 푸시 알림도 비슷하다. APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다.    SMS 메시지   SMS 메시지를 보낼 때는 보통 트윌리오, 넥스모 같은 제 3 사업자의 서비스를 많이 이용한다.    이메일   대부분의 회사는 고유 이메일 서버를 구축할 역량은 갖추고 있다. 그럼에도 많은 회사가 상용 이메일 서버를 이용한다. 그 중 유명한 서비스로 센드그리드, 메일침프가 있다. 전송 성공률도 높고, 데이터 분석 서비스도 제공한다.    연락처 정보 수집 절차    알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요하다. 사용자가 우리 앱을 설치하거나 처음으로 회원가입 하면 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.    이 데이터베이스에 연락처 정보를 저장할 테이블 구조는 다음과 같다.   이메일 주소와 전화번호는 user 테이블에 저장, 단말 토큰은 device 테이블에 저장한다.  한 사용자가 여러 단말을 가질 수 있고, 알림은 모든 단말에 전송되어야 한다는 점을 고려하였다.    알림 전송 및 수신 절차  개략적인 설계안부터 최적화해 나가보자.  개략적인 설계안 (초안)   위 그림 10-9는 개략적 설계 초안이다.          1~N까지의 서비스 : 이 서비스 각각은 MSA 일 수도 있고, CronJob 일 수도 있고, 분산 시스템 컴포넌트 일 수도 있다. 사용자에게 납기일을 알리고자 하는 과금 서비스, 배송 알림을 보내려는 쇼핑몰 웹 사이트 등이 그 예시다.           알림 시스템 : 알림 시스템은 알림 전송/수신 처리의 핵심이다. 우선 1개 서버만 사용하는 시스템이라고 가정해보자. 이 시스템은 서비스 1~N에 알림 전송을 위한 API 를 제공해야 하고, 제 3자 서비스에 전달할 알림 페이로드(payload) 를 만들어 낼 수 있어야 한다.           제 3자 서비스 (third party service) : 이 서비스들은 사용자에게 알림을 실제로 전달하는 역할을 한다. 제 3자 서비스와의 통합을 진행할 때 유의할 것은 확장성이다. 쉽게 새로운 서비스를 통합하거나 기존 서비스를 제거할 수 있어야 한다는 뜻이다. 또 하나 고려해야 할 점은, 어떤 서비스는 다른 시장에서는 사용 못 할 수도 있다는 점이다. 따라서 중국 시장에서는 제이푸시, 푸시와이 같은 서비스를 사용해야만 한다.           ios, 안드로이드, SMS, 이메일 단말 : 사용자는 자기 단말에서 알림을 수신한다.        문제점  하지만, 위 설계에는 몇 가지 문제점이 존재한다.          SPOF (Single-Point-Of-Failure) : 알림 서비스에 서버가 1대밖에 없기 때문에, 알림 서비스에 장애가 발생하면 전체 서비스의 장애로 이어진다.           규모 확장성 : 1대의 서비스로 푸시 알림에 관계된 모든 것을 처리하므로, 데이터베이스나 캐시 등 중요 컴포넌트의 규모를 개별적으로 늘릴 방법이 없다.           성능 병목 : 알림을 처리하고 보내는 것은 자원이 많이 필요한 작업이다.  예를들어 HTML 페이지를 만들고 서드파티 서비스의 응답을 기다리는 일은 시간이 많이 걸릴 가능성이 있는 작업이다. 따라서 모든 것을 한 서버로 처리하면 사용자 트래픽이 많이 몰리는 시간에는 시스템이 과부하 상태에 빠질 수 있다.        개략적 설계안 (개선된 버전)  아래 그림과 같이 개선할 수 있다.       개선점        데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리하였다.     알림 서버를 증설하고 자동으로 수평적 규모 확장(Scale Out) 이 이루어질 수 있도록 개선하였다.     메시지 큐를 이용해 시스템 컴포넌트 사이의 강한 결합을 끊었다.      각 컴포넌트의 역할          1부터 N까지의 서비스 : 알림 시스템 서버의 API 를 통해 알림을 보낼 서비스들           알림 서버             알림 전송 API : 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능하다.       알림 검증(validation) : 이메일 주소, 전화번호 등에 대한 기본적 검증을 수행한다.       데이터베이스 또는 캐시 질의 : 알림에 포함시킬 데이터를 가져오는 기능이다.       알림 전송 : 알림 데이터를 메시지 큐에 넣는다. 본 설계안의 경우 하나 이상의 메시지 큐를 사용하므로 알림을 병렬적으로 처리할 수 있다.                캐시 : 사용자 정보, 단말 정보, 알림 템플릿 등을 캐싱한다.           데이터베이스 : 사용자, 알림, 설정 등 다양한 정보를 저장한다.           메시지 큐 : 시스테 컴포넌트 간 의존성을 제거하기 위해 사용한다. 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 한다. 본 설계안에서는 알림의 종류별로 별도의 메시지 큐를 사용하였다. 따라서 서드파티 서비스 중 하나가 장애가 발생하더라도 다른 종류의 알림 기능은 정상 동작한다.           작업 서버 : 메시지 큐에서 전송할 알림을 꺼내서 서드파티 서비스로 전달하는 역할을 담당하는 서버        API 요청 플로우          API 를 호출하여 알림 서버로 알림을 보낸다.           알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 데이터베이스에서 가져온다.           알림 서버는 전송할 알림 종류에 알맞는 이벤트를 만들어서 해당 이벤트를 위한 큐에 넣는다.  가령 ios 푸시 알림 이벤트는 ios 푸시 알림 큐에 넣어야 한다.           작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.           작업 서버는 알림을 서드파티 서비스로 전송한다.           서드파티 서비스는 사용자 단말로 알림을 전송한다.        3단계. 상세 설계 개략적 설계를 진행하면서 알림의 종류, 연락처 정보 수집 절차, 그리고 알림 송수신 절차에 대해 알아보았다. 이제 아래 내용들을 더 자세히 알아보자.     안정성   추가로 필요한 컴포넌트 및 고려사항 : 알림 템플릿, 알림 설정, 전송률 제한, 재시도 매커니즘, 보안, 큐에 보관된 알림에 대한 모니터링과 이벤트 추적 등   개선된 설계안     안전성  분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보하기 위한 사항 몇가지를 반드시 고려해야한다.  데이터 손실 방지  알림 전송 시스템의 가장 중요한 요구사항 가운데 하나는 어떤 상황에서도 알림이 소실되면 안 된다는 것이다. 이 요구사항을 만족하려면 알림 시스템은 알림 데이터를 데이터베이스에 보관하고 재시도 메커니즘을 구현해야 한다. 아래 그림과 같이 알림 로그 데이터베이스를 유지하는 것이 한가지 방법이다.     알림 중복 전송 방지  같은 알림이 여러 번 반복되는 것을 완전히 막는 것은 가능하지 않다.대부분의 경우 알림은 딱 한 번만 전송되겠지만, 분산 시스템의 특성상 가끔은 같은 알림이 중복되어 전송되기도 할 것이다. 그 빈도를 줄이려면 중복을 탐지하는 메커니즘을 도입하고, 오류를 신중하게 처리해야 한다. 다음은 간단한 중복 방지 로직의 예이다.     보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 살핀다. 중복된 이벤트라면 버리고, 그렇지 않으면 알림을 발송한다.     분산 시스템에서 “정확히 한 번 전달” 논쟁: 불가능한가, 가능한가?    분산 시스템을 설계할 때 가장 어려운 문제 중 하나가 바로 메시지 전달 보장이다. 특히 “정확히 한 번 전달(exactly-once delivery)”에 대해서는 업계에서 오랫동안 치열한 논쟁이 벌어져 왔다. 관련 글을 통해 정리해봤다.   메시지 전달 방식의 종류 먼저 분산 시스템에서 제공할 수 있는 메시지 전달 방식을 정리해보자  (1) At-Most-Once (최대 한 번)     메시지가 0번 또는 1번 전달됨   메시지 손실 가능성 있음   중복 없음   높은 성능   (2) At-Least-Once (최소 한 번)     메시지가 1번 이상 전달됨   메시지 손실 없음   중복 가능성 있음   중간 성능   (3) Exactly-Once (정확히 한 번)     메시지가 정확히 1번만 전달됨   메시지 손실 없음   중복 없음   이론적으로 가장 이상적이지만 구현이 어려움     불가능론: 이론적 한계 Tyler Treat는 2015년 블로그에서 분산 시스템에서 정확히 한 번 전달이 원리적으로 불가능하다고 주장했다. 근거들은 다음과 같다.  1. Two Generals Problem과 FLP 결과     분산 시스템에서 완전한 합의(consensus) 달성의 근본적 한계   네트워크 파티션과 프로세스 실패가 항상 가능   *Two Generals Problem과 FLP 결과 Two Generals Problem (두 장군 문제)과 FLP 결과는 둘 다 분산 시스템에서 합의(consensus)를 이루는 것이 매우 어렵거나, 특정 조건에서는 불가능하다는 것을 보여주는 컴퓨터 과학의 중요한 개념입  [두 장군 문제] 신뢰할 수 없는 통신 환경에서 두 팀이 동시에 공격하는 것에 합의하는 것이 불가능하다는 것을 보여주는 비유적인 이야기다.  핵심: 마지막 확인 메시지가 전달되었다는 것을 절대 확신할 수 없기 때문에, 무한히 확인 메시지를 주고받는 딜레마에 빠져 결국 합의에 실패   [FLP 결과] 메시지 전달에 시간 제약이 없고(비동기), 최소 한 개 이상의 시스템에 장애가 발생할 수 있는 상황에서는 합의에 도달하는 결정론적인 알고리즘이 존재하지 않는다는 것을 수학적으로 증명한 정리  핵심: 이 결과 때문에 현실의 분산 시스템들은 FLP 정리의 전제를 피하기 위해 메시지 전송에 시간 제한을 두거나(동기), 실패 가능성을 허용하는 확률적인 방법을 사용한다    2. 확인응답(ACK)의 딜레마     Producer가 메시지를 보내고 ACK를 기다림   ACK 자체도 네트워크에서 손실될 수 있음   Producer는 메시지가 실제로 전달되었는지 확신할 수 없음   재전송 시 중복 가능성 발생      “현존하는 모든 메이저 메세지 큐가 exactly-once를 제공한다고 주장한다면, 그들이 거짓말을 하거나 분산 시스템을 이해하지 못하는 것이다.”   이렇게 강한 결론으로 마무리 짓고 있다.    가능론: 실용적 해결책  2017년 Kafka는 Apache Kafka 0.11 버전에서 exactly-once 기능을 출시하며 반박했다. 구현 핵심 내용을 간단히 알아보자.  멱등성 프로듀서(Idempotent Producer)  // 설정 예시 producer.props.put(\"enable.idempotence\", \"true\");     TCP와 유사한 시퀀스 번호 사용   Broker가 중복 메시지를 자동으로 제거   단일 파티션 내에서 정확히 한 번 보장     트랜잭션(Transactions)  producer.initTransactions(); try {     producer.beginTransaction();     producer.send(record1);     producer.send(record2);     producer.commitTransaction(); } catch(ProducerFencedException e) {     producer.close(); } catch(KafkaException e) {     producer.abortTransaction(); }     여러 파티션에 대한 원자적 쓰기   Consumer 오프셋까지 포함한 트랜잭션 처리     Kafka Streams에서의 활용 // 간단한 설정으로 exactly-once 활성화 props.put(StreamsConfig.PROCESSING_GUARANTEE_CONFIG,           StreamsConfig.EXACTLY_ONCE);   성능상 결과는 멱등성 프로듀서는 성능 영향 거의 없고, 트랜잭션은 at-least-once 대비 3% 성능 감소가 있어 사실상 성능 손실이 거의 없다.    2025 현재 상황    Kafka의 exactly-once 기능은 지속적으로 발전하고 있다. 현재 많은 기업에서 Kafka의 exactly-once 기능을 프로덕션 환경에서 성공적으로 사용하고 있다.   알림 시스템에서의 현실적 접근  1. 이벤트 ID로 중복 체크 만약 (이 알림을 이전에 본 적이 있다면) {     무시하고 버리기 } 아니면 {     알림 보내기 }   2. 사용자 경험 우선 설계     중요한 알림을 놓치는 것 &gt; 가끔 중복되는 것   사용자는 중복 알림보다 놓친 알림에 더 민감함   3. 클라이언트에서 추가 방어     앱에서 같은 내용의 알림이 짧은 시간에 여러 개 오면 하나만 표시   완벽하지 않더라도 사용자 경험은 보장        결론: 완벽함보다 실용성   분산 시스템에서 100% 완벽한 “정확히 한 번 전달”은 이론적으로 불가능할 수 있다. 하지만 현실에서는 99.9% 정확도로도 충분히 훌륭한 시스템을 만들 수 있다. 중요한 것은 완벽한 이론보다는 사용자에게 도움이 되는 실용적 해결책을 찾는 것이다.     추가로 필요한 컴포넌트 및 고려사항          알림 템플릿 : 알림 템플릿은 유사성을 고려하여 알림 메시지의 모든 부분을 처음부터 다시 만들 필요 없도록 해 준다.             알림 설정             사용자는 너무 많은 알림을 받으면 피곤함을 느낀다. 따라서 사용자가 알림 설정을 상세히 조정할 수 있도록 한다.       이 정보는 알림 설정 테이블에 보관되며, 이 테이블에는 다음과 같은 필드들이 필요할 것이다.                  전송률 제한 : 사용자에게 너무 많은 알림을 보내지 않도록 하는 한 가지 방법은, 한 사용자가 받을 수 있는 알림의 빈도를 제한하는 것이다.                재시도 방법             제3자 서비스가 알림 전송에 실패하면, 해당 알림을 재시도 전용 큐에 넣는다.       같은 문제가 계속해서 발생하면 개발자에게 통지한다.                푸시 알림과 보안 : IOS와 안드로이드 앱의 경우, 알림 전송 API는 appKey와 appSecret을 사용하여 보안을 유지한다.        큐 모니터링            알림 시스템을 모니터링 할 때 중요한 메트릭 하나는 큐에 쌓인 알림의 개수이다.       이 수가 너무 크면 작업 서버들이 이벤트를 빠르게 처리하고 있지 못하다는 뜻이다. 그런 경우에는 작업 서버를 증설하는 게 바람직할 것이다.                     이벤트 추적             알림 확인율, 클릭율, 실제 앱 사용으로 이어지는 비율 같은 메트릭은 사용자를 이해하는데 중요하다.       데이터 분석 서비스는 보통 이벤트 추적 기능도 제공한다. 따라서 보통 알림 시스템을 만들면 데이터 분석 서비스와도 통합해야만 한다.               수정된 설계안  모두 반영해 수정한 설계안이다.       알림 서버에 전송률 제한 기능이 추가 되었으며, 전송 실패에 대응하기 위해 재시도 기능이 추가되었다.   전송에 실패한 알림은 다시 큐에 넣고 지정된 횟수만큼 재시도한다.   전송 템플릿을 사용하여 알림 생성 과정을 단순화하고 알림 내용의 일관성을 유지한다.   모니터링과 추적 시스템을 추가하여 시스템 상태를 확인하고 추후 시스템을 개선하기 쉽도록 하였다.     References     Tyler Treat. “You Cannot Have Exactly-Once Delivery” (2015)   Neha Narkhede. “Exactly-Once Semantics Are Possible: Here’s How Kafka Does It” (2017)   Apache Kafka Documentation (2025)   Enter the Matrix: A practical guide to exactly-once semantics in Kafka Streams   KIP-98, KIP-129, KIP-890 등 Kafka 개선 제안서들  "
  },
  
  {
    "title": "PGMS_귤 고르기 (Java)",
    "url": "/posts/PGMS%EA%B7%A4-%EA%B3%A0%EB%A5%B4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-08-27 04:29:49 +0900",
    "content": "[level 2] 귤 고르기 - 138476  문제 링크  성능 요약  메모리: 108 MB, 시간: 59.84 ms  구분  코딩테스트 연습 &gt; 연습문제  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 08월 27일 04:27:36  문제 설명  경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 'k'개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.  예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.  경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.    제한사항   1 ≤ k ≤ tangerine의 길이 ≤ 100,000 1 ≤ tangerine의 원소 ≤ 10,000,000     입출력 예           k tangerine result            6 [1, 3, 2, 5, 4, 5, 2, 3] 3   4 [1, 3, 2, 5, 4, 5, 2, 3] 2   2 [1, 1, 1, 1, 2, 2, 2, 3] 1            입출력 예 설명  입출력 예 #1   본문에서 설명한 예시입니다.   입출력 예 #2   경화는 크기가 2인 귤 2개와 3인 귤 2개 또는 2인 귤 2개와 5인 귤 2개 또는 3인 귤 2개와 5인 귤 2개로 귤을 판매할 수 있습니다. 이때의 크기 종류는 2가지로 이 값이 최소가 됩니다.   입출력 예 #3   경화는 크기가 1인 귤 2개를 판매하거나 2인 귤 2개를 판매할 수 있습니다. 이때의 크기 종류는 1가지로, 이 값이 최소가 됩니다.      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   간단하게 각 count를 세고 k를 감소시키며 진행했다.       코드   import java.util.*;  class Solution {     public int solution(int k, int[] tangerine) {         int res = 0;                  Map&lt;Integer, Integer&gt; cMap = new HashMap&lt;&gt;();                  for(int t : tangerine){             cMap.put(t, cMap.getOrDefault(t, 0) + 1);         }                  List&lt;Integer&gt; cList = new ArrayList&lt;&gt;(cMap.values());         Collections.sort(cList, Collections.reverseOrder());                  for(int c : cList){             if(k&lt;=0) break;                          k-=c;             res++;         }                  return res;     } }  "
  },
  
  {
    "title": "System Design Interview - 분산 시스템을 위한 유일 ID 생성기 설계",
    "url": "/posts/System-Design-Interview-%EB%B6%84%EC%82%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9C%A0%EC%9D%BC-ID-%EC%83%9D%EC%84%B1%EA%B8%B0-%EC%84%A4%EA%B3%84/",
    "categories": "시스템, 디자인",
    "tags": "System Design Interview",
    "date": "2025-08-25 11:28:49 +0900",
    "content": "들어가며  이번은 책 7장인 분산 시스템을 위한 유일 ID 생성기를 설계해보겠다.  간단한 팀/개인 프로젝트에서 ID를 설계할 때는 auto_increment 속성으로 설정된 기본 키를 사용하곤 했었다.  하지만 대규모 분산 환경에서는 auto_increment를 사용할 수 없다.  데이터베이스 서버 한 대로는 요구를 충족할 수 없고, 여러 서버가 동시에 auto_increment 값을 생성한다면 중복된 값이 발생할 수도 있기 때문이다.    여러 유일한 ID 를 생성하는 방법을 다음과 같이 정리해보자.     다중 마스터 복제 (multi-master replication)   UUID (Universally Unique Identifier)   티켓 서버 (Ticket Server)   트위터 스노플레이크 (Twitter SnowFlake) 접근법     다중 마스터 복제 (multi-master replication)   다중 마스터 복제 방법은 데이터베이스의 auto_increment 기능을 활용한다.  다음 ID 값을 구할 때 1만큼 증가시키는 것이 아니라, 현재 사용중인 데이터베이스의 서버 수에 해당하는 k만큼 증가시킨다.  위의 예제에서는 특정 서버가 만들어 낼 다음 ID 값은 해당 서버에서 이전에 생성한 ID 값 + 전체 서버의 수 2 를 더한 값이다.    이렇게 하면 규모 확장성 문제를 어느 정도 해결할 수 있고, 충돌 없는 분산 ID를 생성할 수 있겠지만 아래와 같은 치명적인 문제점이 존재한다.     여러 데이터 센터에 걸쳐 규모 확장은 어렵다.   ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞춰 커지도록 보장할 수 없다.   서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.     UUID (Universally Unique Identifier)    컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수.   UUID는 유일성이 보장되는 ID를 만드는 간단한 방법이다.  UUID 값은 충돌 가능성이 지극히 낮은데, “중복 UUID가 1개 생길 확률을 50%로 끌어 올리려면 초당 10억개의 UUID를 100년동안 계속해서 만들어야 한다”고 한다.  #####    9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d 와 같은 형태로, 서버 간 조율 없이 독립적으로 생성 가능하다!    장점     UUID를 만드는 것은 단순하다. 서버 간 조율이 필요 없기에 동기화 이슈도 없다.   각 서버에서 자기가 쓸 ID를 직접 만드는 구조이므로 규모 확장도 쉽다.   단점     ID가 128비트로 길다. 저장 공간을 많이 차지한다.   순서 보장이 없기에 ID를 시간순으로 정렬할 수 없다.   ID에 숫자가 아닌 값이 포함될 수 있다.     티켓 서버 (Ticket Server)    티켓 서버의 핵심은 auto_increment 기능을 갖춘 데이터베이스 서버를 중앙 집중형으로 하나만 사용한다.   플리커(Flicker)는 분산 기본 키(distributed primary key)를 만들어내기 위해 티켓 서버 기술을 사용하고 있다.    장점     유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.   구현이 쉽고, 중소 규모의 애플리케이션에 적합하다.   단점     티켓 서버가 SPOF(Single Point Of Failure) 가 된다.  즉, 티켓 서버에서 장애가 발생하면 해당 서버를 이용하여 ID를 생성하는 모든 시스템이 영향을 받게 된다. 이를 해결하려면 티켓 서버를 여러 대 준비해야 하는데, 그러면 데이터 동기화와 같은 새로운 문제가 발생할 수 있다.     트위터 스노플레이크 (Twitter SnowFlake) 접근법  트위터(X)가 사용하는 ID 생성 기법이다.  스노플레이크를 통해 생성할 64비트 ID 구조          사인(sign) 비트: 1비트를 할당한다. 추후 음수/양수 구별에 사용할 수 있을 것이다.           타임스탬프(timestamp): 41비트를 할당한다. 기원 시각(epoch) 이후 몇 밀리초가 경과했는지를 나타내는 값이다. 트위터 스노플레이크 구현에서 사용하는 값은 1288834974657           데이터센터 ID: 5비트를 할당한다. 따라서 2^5 = 32개의 데이터센터를 지원할 수 있다.           서버 ID: 5비트를 할당한다. 따라서 데이터센터당 32개의 서버를 사용할 수 있다.           일련번호: 12비트를 할당한다. 각 서버에서 ID를 생성할 때마다 일련번호를 1만큼 증가시킨다.        상세 설계  _데이터센터 ID와 서버 ID는 시스템이 시작될 때 결정되며, 일반적으로 시스템 운영 중에는 바뀌지 않는다. _  타임스탬프     ID 구조 중 가장 중요한 41비트를 차지한다.   기원 시각(epoch) 이후 경과한 밀리초의 시간   시간의 흐름에 따라 점점 값이 커지므로 결국 시간 순 정렬이 가능해진다.     이렇게 이진표현형태로부터 UTC 시각 추출이 가능하며, 역으로 어떤 UTC 시간도 상술한 타임스탬프값으로 변환할 수 있다.  일련번호  ID를 생성할 때마다 증가되는 값으로, 1밀리 초가 경과하면 값은 0으로 초기화가 된다.  어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우만 0보다 큰 값을 갖게 된다.    장점     64bit로 UUID에 비해 차지하는 저장 공간이 작다.   timestamp 기반으로 값이 생성되기 때문에 정렬이 가능하다.   분산 시스템에 적합하다.   단점     UUID에 비해 구현이 더 복잡하다.     시계동기화와 NTP 분산 시스템에서 스노플레이크를 사용할 때 가장 중요한 이슈 중 하나는 시계 동기화다.    NTP(Network Time Protocol)는 1965년에 David L. Mills에 의해 최초로 제안되었으며, 2010년 RFC 5905로 NTPv4가 정립되었다.  NTP는 라디오나 원자시계에 맞추어 시간을 조정하며 밀리초 단위까지 시간을 맞출 수 있다. 기본적으로 straum 이라는 계층구조를 가지는데, straum 0 은 GPS나 세슘 원자 시계 등 시간을 구하는 장비이고, straum 1 은 이들에서 직접 시간을 동기화하는 서버를 의미한다.    스노플레이크에서 시계 동기화가 중요한 이유는 타임스탬프 기반으로 ID를 생성하기 때문이다.  여러 서버의 시계가 동기화되지 않으면 중복된 ID가 생성될 위험이 있다. Network Time Protocol이 이 문제에 대한 가장 일반적인 해결책이다.      References     UUID(Universally Unique Identifier) - 토스페이먼츠 개발자센터   Ticket Servers: Distributed Unique Primary Keys on the Cheap   Java - Using a ticket server to generate primary ids? - stack overflow   twitter-archive/snowflake - github repository   스노플레이크 ID - wikipedia   Announcing Snowflake - X engineering   How to crack a System Design Interview Series — Twitter Snowflake Approach  "
  },
  
  {
    "title": "개발하며 Kotlin 문법 공부하기 (vs Java)",
    "url": "/posts/%EA%B0%9C%EB%B0%9C%ED%95%98%EB%A9%B0-Kotlin-%EB%AC%B8%EB%B2%95-%EA%B3%B5%EB%B6%80%ED%95%98%EA%B8%B0-vs-Java/",
    "categories": "언어",
    "tags": "kotlin",
    "date": "2025-08-25 02:22:42 +0900",
    "content": "   Kotlin 기본문법만 알고 있는 상태에서 Kotlin 프로젝트를 진행하며 공부하고 찾아본 문법들을 정리해봤다. 실제 개발하면서 마주친 Kotlin 문법들을 Java와 비교하여 정리하기 위해 글을 작성했다. (계속 추가 예정)   1. 기본 문법 차이점  클래스 선언  Kotlin에서 data class는 자동으로 equals, hashCode, toString 생성 // Kotlin data class RecommendationRequestDto(...)  //   Java에서는 필드, 생성자, getter, setter, equals, hashCode, toString 모두 수동으로 작성 // Java equivalent public class RecommendationRequestDto {     // 작성... }    변수 선언  Kotlin에서는 val과 var로 구분  // Kotlin val immutable = \"변경불가\"     // final과 같음 (Java final) var mutable = \"변경가능\"       // 일반 변수   // Java final String immutable = \"변경불가\"; String mutable = \"변경가능\";     Null Safety (널 안전성) Kotlin은 컴파일 시점에 null 체크 // Kotlin val categories: List&lt;FoodCategory&gt;? = null  // ? 붙이면 : nullable val nonNull: String = \"null이 될 수 없음\"    // ? 없으면 : non-null  // 안전한 호출 val length = categories?.size  // categories가 null이면 null 반환  Java에서는 런타임에 NullPointerException 위험  // Java에서는 NullPointerException 위험 List&lt;FoodCategory&gt; categories = null; int length = categories.size(); // NPE 발생!     함수 선언 Kotlin은 fun 키워드로 함수 선언 // Kotlin fun isValid(): Boolean {     return maxSpicy?.let { it in 0..5 } ?: true }  // 단일 표현식 함수 fun add(a: Int, b: Int) = a + b   Java는 접근제한자와 반환타입 명시  // Java public boolean isValid() {     return maxSpicy != null ? (maxSpicy &gt;= 0 &amp;&amp; maxSpicy &lt;= 5) : true; }  public int add(int a, int b) {     return a + b; }      2. Kotlin만의 특별한 문법들  Elvis 연산자 (?:) null일 때 기본값 설정 // Kotlin val result = nullableValue ?: \"Default Value\" // nullableValue가 null이면 \"Default Value\" 사용   Java에서는 삼항연산자 사용 // Java String result = nullableValue != null ? nullableValue : \"기본값\";     let 함수와 스코프 함수 null이 아닐 때만 코드 실행 // Kotlin maxSpicy?.let { spicy -&gt;  // maxSpicy가 null이 아닐 때만 실행     spicy in 0..5         // it 대신 spicy 사용 가능 }  // it 사용 (기본) maxSpicy?.let { it in 0..5 }   Java에서는 명시적 null 체크 필요 // Java if (maxSpicy != null) {     boolean valid = maxSpicy &gt;= 0 &amp;&amp; maxSpicy &lt;= 5; }     범위 연산자 (Range) 숫자 범위를 간단하게 표현 // Kotlin val range = 0..5        // 0부터 5까지 (5 포함) val until = 0 until 5   // 0부터 4까지 (5 불포함) val check = it in 0..5  // it이 0~5 범위에 있는지 확인   Java에서는 조건문으로 체크 // Java if (it &gt;= 0 &amp;&amp; it &lt;= 5) { ... }     기본 매개변수 (Default Parameters) 매개변수에 기본값 설정 가능 // Kotlin data class Person(     val name: String,     val age: Int = 0,        // 기본값     val city: String = \"서울\"  // 기본값 )  val person1 = Person(\"김철수\")                    // age=0, city=\"서울\" val person2 = Person(\"이영희\", 25)                // city=\"서울\" val person3 = Person(\"박민수\", city = \"부산\")      // Named parameter   Java에서는 오버로딩으로 구현  // Java public class Person {     public Person(String name) {         this(name, 0, \"서울\");     }          public Person(String name, int age) {         this(name, age, \"서울\");     }          public Person(String name, int age, String city) {         // 실제 생성자     } }     문자열 템플릿 변수를 문자열에 직접 삽입 // Kotlin val name = \"김철수\" val message = \"안녕하세요, $name님!\"              // 변수 삽입 val complex = \"계산결과: ${1 + 2}\"                // 표현식 삽입   Java에서는 문자열 연결 사용 // Java String message = \"안녕하세요, \" + name + \"님!\";    when 표현식 (switch보다 강력) 패턴 매칭과 조건부 로직  // Kotlin when (priceRange) {     PriceRange.CHEAP -&gt; \"저렴해요\"     PriceRange.MODERATE -&gt; \"적당해요\"     PriceRange.EXPENSIVE -&gt; \"비싸요\"     null -&gt; \"가격 미정\" }  Java의 switch문 // Java switch switch (priceRange) {     case CHEAP: return \"저렴해요\";     case MODERATE: return \"적당해요\";     case EXPENSIVE: return \"비싸요\";     default: return \"기타\"; }      3. 컬렉션과 함수형 프로그래밍 컬렉션 조작  함수형 스타일의 컬렉션 처리 // Kotlin val numbers = listOf(1, 2, 3, 4, 5) val doubled = numbers.map { it * 2 }           // [2, 4, 6, 8, 10] val filtered = numbers.filter { it &gt; 3 }       // [4, 5] val first = numbers.firstOrNull { it &gt; 10 }    // null   Java Stream API와 비교 // Java numbers.stream()     .map(x -&gt; x * 2)     .filter(x -&gt; x &gt; 3)     .collect(Collectors.toList());      4. 확장 함수 (Extension Functions) 기존 클래스에 새로운 함수 추가 // Kotlin - 기존 클래스에 함수 추가 fun String.isValidEmail(): Boolean {     return this.contains(\"@\") }  val email = \"test@example.com\" val valid = email.isValidEmail()  // true   Java에서는 유틸리티 클래스 생성 필요 // Java public class StringUtils {     public static boolean isValidEmail(String email) {         return email.contains(\"@\");     } }  boolean valid = StringUtils.isValidEmail(email);   5. 스코프 함수 활용 실제 코드에서 자주 사용하는 스코프 함수들     let - “이 값이 null이 아니면 뭔가 해줘”   // let - null이 아닐 때만 실행, 결과 반환 maxSpicy?.let { spicy -&gt;      println(\"매운맛: $spicy\")     spicy in 0..5  // 마지막 표현식이 반환값 }       also - “이걸 하고 나서 원래 객체 그대로 줘”   // also - 객체 자체를 그대로 반환 (체이닝용) val numbers = mutableListOf(1, 2, 3).also { list -&gt;     println(\"리스트 크기: ${list.size}\")  // 3     list.add(4)  // 리스트에 4 추가 }  println(numbers)  // [1, 2, 3, 4] - 원래 리스트 객체 그대로   디버깅용으로 많이 씀   kotlinval result = calculateSomething()     .also { println(\"중간 결과: $it\") }  // 디버깅 로그     .processMore()     .also { println(\"최종 결과: $it\") }  // 디버깅 로그     apply - “이 객체의 설정을 바꾸고 나서 그 객체 줘”  // apply - 객체의 프로퍼티 설정 후 객체 반환 val person = Person().apply {     name = \"김철수\"     age = 30     city = \"서울\" }  // person은 name=\"김철수\", age=30, city=\"서울\" 로 설정된 Person 객체   Java와 비교  // Java로 같은 일 하기 Person person = new Person(); person.setName(\"김철수\"); person.setAge(30); person.setCity(\"서울\");     Conclusion  Java에서 Kotlin으로 넘어오면서 가장 인상적인 점들:     간결한 문법 - 보일러플레이트 코드 대폭 감소   널 안전성 - 컴파일 시점에 NPE 방지   함수형 프로그래밍 - 컬렉션 처리가 매우 직관적   확장 함수 - 기존 클래스에 기능 추가 가능   스마트 캐스팅 - 타입 체크와 캐스팅이 자동으로   실제 프로젝트를 진행하면서 Kotlin의 강력함을 점점 더 느끼고 있습니다. Java 개발자라면 충분히 빠르게 적응할 수 있을 것 같습니다. 하지만 축약된 표현이 많아 익숙해지려면 직접 많이 코드를 쳐봐야 할 것 같습니다.  그래도 코틀린 코드를 읽고 해석할 수 있도록 공부하였습니다.  "
  },
  
  {
    "title": "Singleton 에 대하여",
    "url": "/posts/Singleton-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/",
    "categories": "공부",
    "tags": "Design Pattern, Java",
    "date": "2025-08-24 22:27:54 +0900",
    "content": "들어가며  프로그래밍을 하다 보면 특정 객체가 딱 1개 필요한 상황이 있다. 예를 들어 설정 파일 관리자, 로그 기록기 등이 있다. 이런 경우 사용하는 것이 싱글턴 패턴 이다.    싱글턴 패턴이란?    클래스의 인스턴스가 오직 하나만 생성도도록 보장하고, 이 인스턴스에 전역적으로 접근할 수 있는 방법을 제공하는 생성 디자인 패턴이다.     왜 싱글턴이 필요할까? 예시를 통해 알아가보자. 서비스를 개발할 때 다음과 같은 상황은 피하고 싶을 것이다. DatabaseConnection db1 = new DatabaseConnection(); DatabaseConnection db2 = new DatabaseConnection(); DatabaseConnection db3 = new DatabaseConnection();   데이터베이스 연결이 3개나 생겼고 때문에 자원 낭비 및 데이터 일관성 문제가 생길 수 있다.  데이터베이스 연결 관리자는 하나만 있어도 충분하다. 오히려 단 1개만 있어야 한다.    싱글턴의 두 가지 책임 싱글턴이 해결하는 2가지 문제를 알아보자.     인스턴스 개수 제어 : 클래스의 인스턴스가 하나만 존재하도록 보장   전역 접근 제공 : 어디서든 이 인스턴스에 접근할 수 있는 방법을 제공     그러나 이것은 단일 책임 원칙 (Single Responsibility Principle) 을 위반하는 것으로 비판받기도 한다.    싱글턴 패턴 구현 방법  1. Eager Initialization (가장 단순한 형태) public class EagerSingleton {     // 클래스 로딩 시점에 인스턴스 생성     private static final EagerSingleton instance = new EagerSingleton();          // 외부에서 직접 생성하지 못하도록 생성자를 private으로     private EagerSingleton() {}          public static EagerSingleton getInstance() {         return instance;     } }      장점 : 단순한 구현, 스레드 안전   단점 : 사용하지 않아도 인스턴스가 생성되어 메모리를 차지함     2. 정적 블록을 이용한 초기화 public class StaticBlockSingleton {     private static StaticBlockSingleton instance;          private StaticBlockSingleton() {}          // 정적 블록에서 예외 처리 가능     static {         try {             instance = new StaticBlockSingleton();         } catch (Exception e) {             throw new RuntimeException(\"싱글턴 인스턴스 생성 중 오류 발생\");         }     }          public static StaticBlockSingleton getInstance() {         return instance;     } }     장점 : 예외처리 가능   단점 : 여전히 사용하지 않아도 인스턴스 생성됨     3. Lazy Initialization (지연 초기화) public class LazySingleton {     private static LazySingleton instance;          private LazySingleton() {}          public static LazySingleton getInstance() {         if (instance == null) {             instance = new LazySingleton();  // 필요할 때만 생성         }         return instance;     } }     장점 : 실제 사용할 때까지는 인스턴스 생성을 미룰 수 있음   단점 : 멀티스레드 환경에서 안전하지 않음   멀티스레드에서 왜 문제가 될까?  위 코드에서 Race Condition 이 발생하는 시나리오가 있다.  스레드 A, B가 있다고 하자. 두 스레드가 동시에 getInstance() 를 호출할 때  시간순                  ⬇                스레드 A                               스레드 B             ------------------------            ------------------------     1.   if (instance == null) 이 true             2.                                           if (instance == null) 이 true             3.   instance = new LazySingleton() 생성          4.                                           instance = new LazySingleton() 생성                                                이 때 이 객체2로 덮여씌워짐   이 상황에서    2개의 서로 다른 인스턴스 생성   싱글턴 패턴 x   메모리 누수 (첫번째 객체 가비지 컬렉션 대상임)         싱글턴 패턴의 근본적인 문제들  위 구현들은 모두 문제점들을 가지고 있다. 이 문제들을 먼저 이해한 뒤 안전한 싱글턴을 만들어 보자.  문제 1. 리플렉션을 통한 파괴    Reflection을 사용하면 private 생성자에도 접근할 수 있다.   public class ReflectionAttack {     public static void main(String[] args) throws Exception {                  BillPughSingleton instance1 = BillPughSingleton.getInstance();                  // 리플렉션을 이용해 생성자에 접근         Constructor&lt;BillPughSingleton&gt; constructor = BillPughSingleton.class.getDeclaredConstructor();         constructor.setAccessible(true);  // private 접근 제한 해제                  BillPughSingleton instance2 = constructor.newInstance();                           System.out.println(instance1 == instance2); // false - 싱글턴이 깨짐!         System.out.println(instance1.hashCode());   // 다른 해시코드         System.out.println(instance2.hashCode());   // 다른 해시코드     } }     문제 2: 직렬화/역직렬화 문제    객체를 파일에 저장했다가 다시 읽어올 때 새로운 인스턴스가 생성될 수 있다.   public class SerializableSingleton implements Serializable {     private static final SerializableSingleton instance = new SerializableSingleton();          private SerializableSingleton() {}          public static SerializableSingleton getInstance() {         return instance;     } }   문제 예시 코드 ▼ public class SerializationTest {     public static void main(String[] args) throws Exception {         SerializableSingleton instance1 = SerializableSingleton.getInstance();                  // 직렬화 (파일에 저장)         ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"singleton.ser\"));         out.writeObject(instance1);         out.close();                  // 역직렬화 (파일에서 읽기)         ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"singleton.ser\"));         SerializableSingleton instance2 = (SerializableSingleton) in.readObject();         in.close();                  System.out.println(instance1 == instance2); // false - 다른 객체가 됨!     } }     문제 3. 테스트가 어렵다    싱글턴은 전역 상태를 가지므로 단위 테스트가 어렵다.   // 테스트하기 어려운 코드 예시  public class UserService {     public boolean loginUser(String username, String password) {         DatabaseConnection db = DatabaseConnection.getInstance(); // 싱글턴에 강하게 의존         return db.authenticate(username, password);     } }   왜 테스트가 어려울까?    Mock 객체 사용 불가: 싱글턴은 항상 같은 인스턴스를 반환하므로 테스트용 가짜 객체로 바꿀 수 없습니다.   테스트 간 상태 공유: 여러 테스트가 같은 싱글턴 인스턴스를 공유해서 테스트 결과가 서로 영향을 줄 수 있습니다.     이제 위 문제들을 하나씩 해결하는 구현 방법들을 알아보자.    4. 스레드 안전 싱글턴 지연 초기화의 멀티스레드 문제부터 해결해보자  public class ThreadSafeSingleton {     private static ThreadSafeSingleton instance;          private ThreadSafeSingleton() {}          // synchronized 키워드로 스레드 안전성 확보     public static synchronized ThreadSafeSingleton getInstance() {         if (instance == null) {             instance = new ThreadSafeSingleton();         }         return instance;     } }   synchronized 를 매번 거치는 것은 비효율적이다. 이것을 한번 더 개선해보자.    public class DoubleCheckedLockingSingleton {     // volatile 키워드가 중요!     private static volatile DoubleCheckedLockingSingleton instance;          private DoubleCheckedLockingSingleton() {}          public static DoubleCheckedLockingSingleton getInstance() {         // 성능 최적화를 위한 로컬 변수 사용         DoubleCheckedLockingSingleton result = instance;         if (result != null) {             return result;         }                  synchronized (DoubleCheckedLockingSingleton.class) {             if (instance == null) {  // 동기화 블록 내에서 다시 체크                 instance = new DoubleCheckedLockingSingleton();             }             return instance;         }     } }   이렇게 개선한 방법이 Double-Checked Locking 방식이다!  * volatile 이란?    Java에서 변수가 메인 메모리에서 직접 읽고 쓰여야 함을 JVM에 알려주는 키워드다. 멀티스레드 환경에서 변수의 가시성과 순서를 보장한다.   1. 가시성(Visibility) 보장    CPU 캐시를 우회하고 메인 메모리에서 직접 읽기/쓰기   한 스레드의 변경사항이 다른 모든 스레드에게 즉시 보임   2. 순서 보장(Happens-Before Relationship)    Happens-Before 규칙:            volatile 변수 쓰기 이전의 모든 메모리 연산이 먼저 완료됨       volatile 변수 읽기 이후의 모든 메모리 연산이 나중에 실행됨             왜 volatile로 해결?  원인 분석부터 해보자.  객체 생성 instance = new Singleton(); 은 다음 과정을 거친다.  // 1단계: 메모리 할당 memory = allocate(Singleton.class);  // 2단계: 생성자 호출 (초기화) constructor(memory);  // 3단계: instance 변수에 참조 할당 instance = memory;  문제 상황으로 명령어 재배열 (Instruction Recording) 이 있다.  JVM 최적화로 인해 순서가 바뀔 수 있는데 // 원래 순서: 1 → 2 → 3 // 재배열 후: 1 → 3 → 2  memory = allocate(Singleton.class);    // 1단계 instance = memory;                     // 3단계 (먼저 실행!) constructor(memory);                   // 2단계 (나중에 실행!)   문제 상황으로는 두 스레드 A, B에서 잘못된 순서로 실행되면          스레드 A                            스레드 B ------------------------           ------------------------ if (instance == null) {                synchronized (...) {                    if (instance == null) {                 // 1. 메모리 할당             // 3. instance에 할당 (생성자 실행 전!)                                    if (instance == null) {  // false!                                        // 초기화 안된 객체 반환                                    }                                    return instance; // 반쪽짜리 객체!             // 2. 생성자 실행 (늦게 실행됨)         }     } }  스레드 B는 완전히 초기화되지 않은 객체를 할당받는다.  ➡ volatile로 해결하기    메모리 가시성 보장 : 모든 스레드가 같은 값을 본다.   명령어 재배열 방지 : 객체 생성 3단계가 순서대로 실행된다.   Happens-Before 보장 : 객체가 완전히 초기화된 후 다른 스레드가 접근한다.     아직 한계가 있다?     원자성 보장 문제   private static volatile int counter = 0;  // 스레드 안전 X public static void increment() {     counter++;  // 실제로는 3단계: 읽기 → 증가 → 쓰기 }  // 올바른 방법 public static synchronized void increment() {     counter++; } // 또는 private static AtomicInteger counter = new AtomicInteger(0);      복합연산도 부적합   private static volatile boolean flag1 = false; private static volatile boolean flag2 = false;  // 이것도 스레드 안전하지 않음 public static void updateFlags() {     if (!flag1) {     // 읽기         flag1 = true; // 쓰기         flag2 = true; // 다른 쓰기     }     // flag1과 flag2의 일관성이 깨질 수 있음 }    5. Bill Pugh 방식 (권장되는 방법)    Double-Checked Locking의 복잡성을 피하고 싶다면 이 방식을 사용하자.   public class BillPughSingleton {     private BillPughSingleton() {}          // 내부 정적 클래스     private static class SingletonHelper {         private static final BillPughSingleton INSTANCE = new BillPughSingleton();     }          public static BillPughSingleton getInstance() {         return SingletonHelper.INSTANCE;     } }   왜 이 방식이 좋을까?  JVM의 클래스 로딩 메커니즘을 잘 활용하기 때문!    JVM 클래스 로딩의 원리 JVM은 지연로딩 (Lazy Loading) 방식을 사용한다.  로딩 시점은    해당 클래스 인스턴스 생성시   해당 클래스 정적 메서드나 정적 변수 접근 시   해당 클래스를 상속받은 하위 클래스가 로딩될 때   이렇게 정리할 수 있다.  핵심은 내부 클래스는 외부 클래스와 별개로 로딩된다는 점이다.    그럼 Bill Fugh 방식으로는 어떤 과정을 거칠까?     BillPughSingleton 클래스가 로딩될 때 SingletonHelper 는 로딩되지 않는다.   getInstance() 가 호출될 때 드디어 SingletonHelper 클래스가 로딩된다.   클래스 로딩은 JVM이 보장하는 스레드 안전 과정이다.     장점    지연 로딩 가능 (getInstance() 호출될 때 SingletonHelper 클래스 로딩)   스레드 안전 (JVM의 클래스 로딩 메커니즘 활용)   synchronized 키워드 없이도 안전함     여전히 리플렉션과 직렬화 문제에는 취약하다…  A. 리플렉션 공격 방어 public class ReflectionSafeSingleton {     private static volatile ReflectionSafeSingleton instance;     private static boolean instanceCreated = false; // ← 핵심: 생성 플래그          private ReflectionSafeSingleton() {         // 생성자에서 중복 생성 체크         if (instanceCreated) {             throw new IllegalStateException(\"이미 인스턴스가 생성되었습니다!\");         }         instanceCreated = true; // ← 첫 생성 후 플래그 설정     }          private static class Holder {         // 정상 경로로 인스턴스 생성 (instanceCreated가 true가 됨)         private static final ReflectionSafeSingleton INSTANCE = new ReflectionSafeSingleton();     }          public static ReflectionSafeSingleton getInstance() {         return Holder.INSTANCE;     } }   이 방어코드도 완벽하진 않은게     공격자가 리플렉션으로 먼저 인스턴스를 생성하고   이후 정상적인 사용으로 getInstance() 가 호출되면 예외가 발생한다.   따라서 방어는 되지만 DOS(서비스 거부) 공격이 가능하다.    B. 직렬화 문제 해결 public class SerializationSafeSingleton implements Serializable {     private SerializationSafeSingleton() {}          private static class Holder {         private static final SerializationSafeSingleton INSTANCE = new SerializationSafeSingleton();     }          public static SerializationSafeSingleton getInstance() {         return Holder.INSTANCE;     }          // 역직렬화 시 기존 인스턴스 반환 (JVM이 역직렬화 과정에서 자동 호출)     protected Object readResolve() {         return getInstance(); // 새 객체 대신 기존 싱글턴 반환     } }    JVM 의 역직렬화 과정도 의사코드로 자세히 알아보면 Object deserializeObject() {     // 1. 새로운 객체 생성 (생성자 호출하지 않음)     Object newObj = createObjectWithoutConstructor();          // 2. 필드 값들 복원     restoreFields(newObj);          // 3. readResolve() 메서드가 있는지 확인     if (hasReadResolveMethod(newObj)) {         // 4. readResolve() 호출하고 그 결과를 반환         return newObj.readResolve(); // ← 우리가 정의한 readResolve() 메서드 호출     }          // 5. readResolve()가 없으면 새 객체 반환     return newObj; }     6. Enum 방식 (가장 안전한 방법)    Effective Java의 저자 Joshua Bloch가 제안한 방법이다.   public enum EnumSingleton {     INSTANCE;          public void doSomething() {         System.out.println(\"싱글턴에서 작업을 수행한다.\");     } }  // 사용 방법 EnumSingleton.INSTANCE.doSomething();   왜 가장 안전할까?    JVM이 enum의 인스턴스가 하나만 생성되는것을 보장하기 때문!     1. 리플렉션 공격 방어 : JVM이 enum의 리플렉션 기반 인스턴스 생성을 원천 차단  try {     Constructor&lt;EnumSingleton&gt; constructor = EnumSingleton.class.getDeclaredConstructor();     constructor.setAccessible(true);     EnumSingleton instance = constructor.newInstance(); // 예외 발생! } catch (Exception e) {     System.out.println(\"리플렉션 공격 실패: \" + e.getMessage());     // java.lang.IllegalArgumentException: Cannot reflectively create enum objects }     2. 직렬화/역직렬화 자동 처리 : JVM이 enum의 직렬화를 특별히 처리해서 항상 같은 인스턴스를 보장    JVM이 enum의 직렬화를 특별히 처리해서 항상 같은 인스턴스를 보장한다!     3. 스레드 안전성 자동 보장 : JVM이 enum 인스턴스 생성을 스레드 안전하게 처리    장점    리플렉션 공격에 안전하다   직렬화 / 역직렬화 문제 없음   스레드 안전   구현이 간단하다   단점    지연 로딩이 불가능함 (enum은 클래스 로딩 시점에 모든 인스턴스가 생성됨)   상속을 받을 수 없다 (enum은 이미 java.lang.Enum 을 상속받음)   유연성이 떨어진다 (복잡한 초기화 로직 구현이 어려움)     싱글턴 테스트 문제 해결 : 의존성 주입 (DI)    테스트가 어려운 문제는 싱글턴 패턴의 근본적 문제다. 가장 좋은 해결책은 Dependency Injection, 즉 의존성 주입을 사용하는것이다.   개선된 설계 public class UserService {     private DatabaseConnection db;          // 생성자를 통해 의존성 주입     public UserService(DatabaseConnection db) {         this.db = db;     }          public boolean loginUser(String username, String password) {         return db.authenticate(username, password);     } }   이제 테스트할 때 가짜 객체 (Mock) 을 주입할 수 있다.  @Test public void testLoginUser() {     // Mock 객체 생성     DatabaseConnection mockDb = mock(DatabaseConnection.class);     when(mockDb.authenticate(\"user1\", \"password\")).thenReturn(true);          // 테스트 대상에 Mock 주입     UserService userService = new UserService(mockDb);          // 테스트 실행     boolean result = userService.loginUser(\"user1\", \"password\");          // 검증     assertTrue(result); }     현대적 접근: 의존성 주입 최근에는 Spring Framework 같은 DI 컨테이너를 사용하여 싱글턴의 장점을 취하면서 단점을 보완한다.  @Component  // Spring에서 이 클래스를 빈으로 관리 (기본적으로 싱글턴) public class UserService {          @Autowired  // 의존성 주입     private UserRepository userRepository;          public User findUser(Long id) {         return userRepository.findById(id);     } }   Spring의 싱글턴은 GoF 싱글턴과는 다르다     GoF 싱글턴: JVM 전체에서 하나의 인스턴스   Spring 싱글턴: 스프링 컨테이너 내에서 하나의 인스턴스       마치며 싱글턴 패턴은 “하나만 있으면 되는” 객체를 만들 때 유용한 패턴이다.  하지만 전역 상태와 강한 결합을 만들 수 있기 때문에 신중하게 사용해야한다.     Bill Pugh 방식이 가장 일반적인 권장 방식이다.   Enum 방식이 가장 안전하지만 유연성은 떨어지는 방식이다.   현대적인 개발에서는 의존성 주입(DI) 을 통해 싱글턴의 이점을 더 안전하게 활용할 수 있다.   테스트 가능성도 항상 고려해야한다.   싱글턴 패턴을 이해하는 것이 중요하며, 꼭 필요한 곳에서만 사용하고 유연한 방법을 고려해야함을 배웠다.      References     싱글턴 패턴   Java Singleton Design Pattern Best Practices with Examples   Java volatile 키워드 예시  "
  },
  
  {
    "title": "BOJ_1623_신년 파티 (Java)",
    "url": "/posts/BOJ1623%EC%8B%A0%EB%85%84-%ED%8C%8C%ED%8B%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-08-20 03:22:55 +0900",
    "content": "[Gold I] 신년 파티 - 1623  문제 링크  성능 요약  메모리: 147364 KB, 시간: 3040 ms  분류  다이나믹 프로그래밍, 트리, 트리에서의 다이나믹 프로그래밍  제출 일자  2025년 8월 20일 03:09:29  문제 설명  '주식회사 월드'의 조직도는 루트가 있는 트리 형태의 구조를 가지고 있다. 즉, 사장님을 트리의 루트로 하며, 직원들은 자신의 직속상관 바로 밑에 매달려 있는 형태가 된다. 김진영 부사장은 2008년 설을 맞아 '주식회사 월드'의 신년 파티를 계획 중에 있다. 단, 만일 부하직원이 자신의 직속상관과 파티에 함께 오게 되면 분위기가 경직될 수 있으므로, 파티의 분위기를 위해 부하직원과 그 직속상관은 같이 초대될 수 없도록 하려고 한다. 예를 들어 최백준 과장이 오민식, 오영식 대리의 직속상관이라고 하자, 만일 최백준 과장을 파티에 초대하려 한다면 오민식, 오영식 두 대리는 파티에 초대할 수 없다. 마찬가지로 오민식, 오영식 대리 중 어느 한 명이라도 파티에 초대하려 한다면 최백준 과장 역시 파티에 초대될 수 없다. 각 직원들의 \"날라리 기질\"은 평소 인사과의 관찰을 통해 회사의 데이터베이스에 기록이 되어 있다고 한다. 신년 파티의 \"날라리 분위기\"란 파티 참가자들의 \"날라리 기질\"의 합으로 정해진다. 김진영 부사장은 위의 제한을 만족시키면서 이번 신년 파티의 \"날라리 분위기\"를 최대화하도록 참가자 목록을 작성하려고 한다. 단, 사장의 참석 여부가 아직 불투명한 상황이기 때문에 사장이 참석하는 경우와 그렇지 않은 경우 각각에 대해 모두 참가자 목록을 결정해 줄 프로그램을 작성해야 한다. 아무도 초대하지 않는 경우 \"날라리 분위기\"가 최대일 수도 있다는 점에 주의한다.  입력  첫째 줄에 사장을 포함한 모든 직원의 수 N이 주어진다. (2≤N≤200,000) 사장은 1번이며, 다른 직원들은 2번부터 N번까지 차례로 번호가 매겨져 있다. 둘째 줄에는 사장을 포함한 모든 직원의 \"날라리 기질\"을 나타내는 N개의 정수가 빈 칸을 사이에 두고 1번 직원(사장)부터 N번 직원까지 순서대로 주어진다. 주어지는 정수는 절댓값이 10,000을 넘지 않는다. 셋째 줄에는 사장을 제외한 모든 직원의 직속 상관의 번호를 나타내는 N-1개의 정수가 빈 칸을 사이에 두고 2번 직원부터 N번 직원까지 순서대로 주어진다. 주어지는 수는 물론 N 이하의 자연수이며, 항상 루트가 있는 트리 형태의 구조를 갖도록 입력이 주어진다고 가정해도 좋다.  출력  첫째 줄에는 사장이 참석하는 경우와 그렇지 않은 경우의  \"날라리 분위기\"의 최댓값을 빈 칸을 사이에 두고 순서대로 출력한다. 둘째 줄과 셋째 줄에는 각각 사장이 참석하는 경우와 그렇지 않은 경우의 참가자 번호를 빈 칸을 사이에 두고 증가하는 순서대로 출력한다. 각 줄의 끝에는 -1을 추가로 출력해서 끝을 표시하도록 한다.     문제 풀이     dfs와 tree 구조를 사용했다.  백트래킹으로 경로도 탐색했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st; \tstatic int N; \tstatic int[] arr; \tstatic int[][] dp; \tstatic List&lt;Integer&gt;[] graph; \tstatic StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1623_신년파티/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());  \t\tarr = new int[N+1]; \t\tgraph = new ArrayList[N+1]; \t\tfor(int i=0; i&lt;N+1; i++) { \t\t\tgraph[i] = new ArrayList&lt;&gt;(); \t\t} \t\tdp = new int[N+1][2];  \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t}  \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int child=2; child&lt;=N; child++) { \t\t\tint parent = Integer.parseInt(st.nextToken()); \t\t\tgraph[parent].add(child); \t\t}  \t\tdfs(1);  \t\tsb.append(dp[1][1]).append(\" \").append(dp[1][0]).append(\"\\n\");  \t\tList&lt;Integer&gt; withBoss = new ArrayList&lt;&gt;(); \t\tList&lt;Integer&gt; withoutBoss = new ArrayList&lt;&gt;();  \t\tfindPath(1, true, withBoss); \t\tfindPath(1, false, withoutBoss); \t\tCollections.sort(withBoss); \t\tCollections.sort(withoutBoss);  \t\tfor(int w : withBoss) { \t\t\tsb.append(w).append(\" \"); \t\t} \t\tsb.append(-1).append(\"\\n\"); \t\tfor(int w : withoutBoss) { \t\t\tsb.append(w).append(\" \"); \t\t} \t\tsb.append(-1);  \t\tSystem.out.println(sb.toString());         bw.flush();         bw.close();         br.close();     }  \tprivate void findPath(int i, boolean visited, List&lt;Integer&gt; res) { \t\tif(visited) { \t\t\tres.add(i);  \t\t\tfor(int g : graph[i]) { \t\t\t\tfindPath(g, false, res); \t\t\t} \t\t} \t\telse{ \t\t\tfor(int g : graph[i]) { \t\t\t\tif(dp[g][1] &gt; dp[g][0]){ // 부하 선택하는게 더 클 때 \t\t\t\t\tfindPath(g, true, res); \t\t\t\t} \t\t\t\telse{ // 부하 선택x 가 더 클 때 \t\t\t\t\tfindPath(g, false, res); \t\t\t\t} \t\t\t} \t\t} \t}  \tprivate void dfs(int i) { \t\tdp[i][0] = 0; \t\tdp[i][1] = arr[i];  \t\tfor(int g : graph[i]) { \t\t\tdfs(g); \t\t\tdp[i][0] += Math.max(dp[g][0], dp[g][1]); // 본인안오면 부하는 오거나 안오거나 \t\t\tdp[i][1] += dp[g][0]; // 본인 오면 부하는 못옴 \t\t} \t} }  "
  },
  
  {
    "title": "System Design Interview - (1)",
    "url": "/posts/System-Design-Interview-1/",
    "categories": "시스템, 디자인",
    "tags": "System Design Interview",
    "date": "2025-08-18 18:55:00 +0900",
    "content": "사용자 수에 따른 규모 확장성    단일 서버  웹 - 앱 - 데이터베이스 - 캐시 등이 한 서버에서 실행된다.    사용자 요청 처리 흐름     DNS 서버의 Domain address 에 대한 Ip address 를 요청한다.   DNS 에서 Ip address 를 반환 받는다.   해당 Ip address 를 통해서 웹서버에 HTTP 요청 보낸다.   웹 페이지나 JSON 형태의 응답 반환한다.     실제 요청이 오는 2가지 단말          웹 어플리케이션 : 비즈니스 로직, 데이터 저장 등을 처리하기 위해서 서버 구현용 언어를 사용한다. 프레젠테이션용으로 클라이언트 구현용 언어를 사용한다.           모바일 앱 : 통신을 위해서 HTTP 프로토콜을 이용한다. HTTP 프로토콜을 통해서 반환될 응답 데이터의 포맷으로는 보통 JSON(JavaScript Object Notation)이 그 간결함 덕에 널리 사용된다.        데이터베이스 서버 하나로는 충분하지 않아 여러 서버를 두어야 한다.  하나는 웹/모바일 트래픽 처리 용도고, 다른 하나는 데이터베이스용이다.    어떤 데이터베이스를 사용할 것인가?     관계형 데이터베이스 (Relational Database Management System, RDBMS )            종류 : MySQL, Oracle, PostgreSQL 등       테이블과 열과 컬럼으로 표현된다.       SQL 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인(join) 하여 합칠 수 있다.           비-관계형 데이터베이스 ( NoSQL )            종류 : CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등                    키-값(Key-value) 저장소           그래프(graph) 저장소           컬럼(column) 저장소           문서(document) 저장소                       일반적으로 조인 연산은 지원하지 않는다.       아래와 같은 경우에 비-관계형 데이터베이스가 바람직할 수도 있다.                    아주 낮은 응답 지연시간(latency)이 요구됨           다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님           데이터(JSON, YAML, XML 등)를 직렬화하거나(serialize) 역직렬화(deserialize) 할 수 있기만 하면 됨.           아주 많은 양의 데이터를 저장할 필요가 있음                             수직적 규모 확장 vs 수평적 규모 확장     스케일 업(scale up) : 수직적 규모 확장(vertical scaling) 프로세스다. 서버에 고사양 자원을 추가하는 행위를 말한다.    스케일 아웃(scale out) : 수평적 규모 확장 프로세스다. 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다.   서버로 유입되는 트래픽이 적을때 : 수직적 확장 이 좋은 선택    장점            단순함           단점            한계가 있음       자동 복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않음       서버 장애 시 웹사이트/앱은 완전히 중단된다.           이러한 단점 때문에, 대규모 어플리케이션을 지원하는 데는 수평적 규모 확장법이 적절하다.    앞서 본 설계에서 사용자는 웹 서버에 바로 연결된다. 웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없다. 너무 많은 사용자가 접속하여 웹 서버가 한계 상황에 도달하게 되면 응답 속도가 느려지거나 서버 접속이 불가능해질 수도 있다. 이런 문제 해결하는 데는 부하 분산기 또는 로드밸런서(Load Balancer)를 도입하는 것이 최선이다.    로드밸런서    로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.     부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면 장애를 자동 복구하지 못하는 문제(no failover)는 해소되며, 가용성(availability)은 향상된다.  서버 1이 다운되면(offline) 모든 트래픽은 서버 2로 전송 된다. 따라서 서버 전체가 다운되는 일이 방지된다.    데이터베이스 다중화  하나의 데이터베이스 서버는 장애의 자동 복구나 다중화를 지원하는 구성은 아니다.  서버 사이에 주(master, primary)-부(slave, secondary) 관계를 설정 하고 데이터 원본은 주 서버에서, 사본은 부 서버에 저장하는 방식이다.  쓰기 연산(write operation)은 주 서버에서만 지원한다.  부 데이터베이스는 주 데이터베이스의 사본을 전달 받으며, 읽기 연산(read operation)만을 지원한다. 데이터 베이스를 변경하는 명령어들(insert, delete, update 등)은 주 데이터 베이스로만 전달되어야 한다.  대부분의 어플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높다.  =&gt; 부 데이터베이스의 수 &gt; 주 데이터 베이스 수   데이터베이스를 다중화하면 좋은점     더 나은 성능 : 모든 데이터 변경 연산은 주 데이터베이스 서버로만 전달되지만, 읽기 연산은 부 데이터베이스 서버들로 분산된다. 병렬로 처리할 수 있는 질의(query)의 수가 늘어나므로 성능이 좋아진다.   안정성(reliability) : 자연 재해 등의 이유로 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존될 것이다. 데이터를 지역적으로 떨어진 여러 장소에 다중화시켜 놓을 수 있기 때문이다.   가용성(availability) : 데이터를 여러 지역에 복제해 둠으로써, 하나의 데이터 베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스를 할 수 있게 된다.     데이터베이스 서버 가운데 하나가 다운되면 무슨 일이 벌어질까?          부 서버가 한대뿐인데 다운된다면, 읽기 연산은 한시적으로 모두 주 데이터베이스로 전달될 것이다.      또한 즉시 새로운 부 데이터베이스 서버가 장애 서버를 대체할 것이다. 부 서버가 여러 대인 경우에 읽기 연산은 나머지 부 데이터 베이스 서버들로 분산될 것이며, 새로운 부 데이터베이스 서버가 장애 서버를 대체할 것이다.           주 데이터베이스 서버가 다운되면, 한 대의 부 데이터베이스만 있는 경우 해당 부 데이터베이스 서버가 새로운 주 서버가 될 것이며, 모든 데이터베이스 연산은 일시적으로 새로운 주 서버상에서 수행될 것이다. 그리고 새로운 부 서버가 추가될 것이다.      실제 프러덕션(production) 환경에서 벌어지는 일은 이것보다 더 복잡한데, 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있기 때문이다. 없는 데이터는 복구 스크립트(recovery script)를 돌려서 추가해야 한다.       위 그림은 로드밸런서와 데이터베이스 다중화를 고려한 설계안이다.  동작 순서     DNS로 부터 로드밸런서의 public IP address 조회   해당 IP address로 요청   로드밸런서는 해당 HTTP 요청을 서버1 또는 2로 전달   웹 서버는 필요한 작업에 맞는 데이터 베이스로 조회 혹은 추가, 삭제, 갱신 연산을 수행     캐시    캐시는 값비싼(latency가 큰) 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고 뒤이은 요청을 보다 빠르게 처리될 수 있도록 하는 저장소다.   캐시 계층  : 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.     장점            응답 성능 개선       데이터베이스 부하 감소       캐시 계층의 규모를 독립적으로 확장 가능             캐시 우선 읽기 전략 (read-through caching strategy)          요청 받은 웹서버는 캐시 조회를 통해 응답이 저장되어 있는 지 확인한다. 저장되어 있다면 해당 데이터를 반환한다.           없다면 데이터베이스에 조회 후 캐시에 저장한 뒤 클라이언트에 반환한다.      이 외에도 다양한 캐시 전략이 존재. 데이터의 종류, 크기, 엑세스 패턴에 맞게 선택이 필요    캐시 사용 시 유의할 점          바람직한 상황 : 갱신은 자주 일어나지 않고 참조는 빈번하게 일어나는 상황           어떤 데이터? : 휘발성 메모리기 때문에 영속적으로 보관할 데이터는 캐시에 두는 것은 바람직하지 않다.           보관된 데이터 만료 : 만료된 데이터는 캐시에서 삭제 되어야 한다. 너무 짧으면 데이터를 너무 자주 읽고 너무 길다면 데이터베이스와 차이가 날 가능성이 높아진다.           일관성 유지: 저장소의 원본 갱신과 캐시 갱신이 단일 트랜잭션에서 처리가 되지 않는 경우 일관성이 깨질 수 있다.           장애 대응: 캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(Single Point of Failure, SPOF)이 되어버릴 수 있다. 여러 지역에 걸쳐 캐시 서버를 분산해야 한다.           캐시 메모리 크기: 너무 작으면 엑세스 패턴에 따라서는 데이터 너무 자주 캐시에서 밀려나버려(eviction) 성능이 떨어진다. 이것을 막기 위해서 메모리를 과할당(overprovision)하는 것이다. 보관될 데이터가 갑자기 늘어나는 상황에서의 문제도 방지할 수 있다.           데이터 방출(eviction) 정책: 캐시가 꽉찬 상태에서 새로운 데이터를 넣어야할 경우 어떤 데이터를 내보낼 것인가를 결정해야 한다. 가장 널리 쓰이는 방식은 LRU(Least Recently Used)이고 다른 정책으로는 LFU(Least Frequently used), FIFO 등이 있다.        콘텐츠 전송 네트워크 (CDN)     CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버 네트워크이다. 이미, 비디오, CSS, Javascript 파일 등을 캐시할 수 있다.   동작 방식         사용자 A가 이미지 URL을 이용해 image.png에 접근 (URL 도메인은 CDN 서비스 사업자가 제공한 것)           CDN 서버의 캐시에 해당 이미지를 조회, 이미지가 없는 경우 원본(origin)서버에 요청하여 파일은 가져온다.           원본 서버가 파일을 CDN 서버에 반환한다. 응답의 HTTP 헤더에는 해당 파일을 얼마나 오래 캐시될 수 있는 지 설명하는 TTL(Time-To-Live) 값이 들어있다.           CDN 서버는 파일을 캐시하고 사용자 A에게 반환.           사용자 B가 같은 이미지 요청 시 만료되지 않은 이미지라면 캐시를 통해 반환        CDN 사용시 고려해야 할 사항          비용: CDN은 보통 third-party providers에 의해 운영되며, 데이터 전송양에 따라 요금을 낸다. 자주 사용되지 않는 콘텐츠는 이득이 크지 않으므로 CDN에서빼는 것을 고려하도록 하자.           TTL 적절한 만료 시한 설정: 시의성이 중요한(Time-sensitive) 콘텐츠인 경우 만료 시점을 잘 설정해야 한다.           CDN 장애 대응: CDN 자체가 죽었을 경우 웹사이트/어플리케이션이 어떻게 동작할 지 고려해야 한다. 콘텐츠 무효화(invalidation)방법: 아직 만료되지 않았더라도 아래의 방법들을 통해 CDN에서 제거 가능           CDN 서비스 사업자가 제공하는 API를 이용하여 콘텐츠 무효화 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 이용     "
  },
  
  {
    "title": "BOJ_1516_게임 개발 (Java)",
    "url": "/posts/BOJ1516%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-08-12 05:07:40 +0900",
    "content": "[Gold III] 게임 개발 - 1516  문제 링크  성능 요약  메모리: 21636 KB, 시간: 224 ms  분류  다이나믹 프로그래밍, 그래프 이론, 방향 비순환 그래프, 위상 정렬  제출 일자  2025년 8월 12일 05:05:23  문제 설명  숌 회사에서 이번에 새로운 전략 시뮬레이션 게임 세준 크래프트를 개발하기로 하였다. 핵심적인 부분은 개발이 끝난 상태고, 종족별 균형과 전체 게임 시간 등을 조절하는 부분만 남아 있었다.  게임 플레이에 들어가는 시간은 상황에 따라 다를 수 있기 때문에, 모든 건물을 짓는데 걸리는 최소의 시간을 이용하여 근사하기로 하였다. 물론, 어떤 건물을 짓기 위해서 다른 건물을 먼저 지어야 할 수도 있기 때문에 문제가 단순하지만은 않을 수도 있다. 예를 들면 스타크래프트에서 벙커를 짓기 위해서는 배럭을 먼저 지어야 하기 때문에, 배럭을 먼저 지은 뒤 벙커를 지어야 한다. 여러 개의 건물을 동시에 지을 수 있다.  편의상 자원은 무한히 많이 가지고 있고, 건물을 짓는 명령을 내리기까지는 시간이 걸리지 않는다고 가정하자.  입력  첫째 줄에 건물의 종류 수 N(1 ≤ N ≤ 500)이 주어진다. 다음 N개의 줄에는 각 건물을 짓는데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어져야 하는 건물들의 번호가 주어진다. 건물의 번호는 1부터 N까지로 하고, 각 줄은 -1로 끝난다고 하자. 각 건물을 짓는데 걸리는 시간은 100,000보다 작거나 같은 자연수이다. 모든 건물을 짓는 것이 가능한 입력만 주어진다.  출력  N개의 각 건물이 완성되기까지 걸리는 최소 시간을 출력한다.     문제 풀이   위상정렬 문제다. 진입차수를 순서에 맞게 잘 설정해 준 뒤 (선행되어야 할 것에 뒤에 따라올 친구들을 넣는 식으로), 이후 queue나 deque을 사용해 선행되어야 할 것 중 최초부터 차례로 graph를 따라 진행한다.       코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st; \tstatic int[] time, indegree, res; \tstatic int N; \tstatic ArrayList&lt;Integer&gt;[] board; \tstatic StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1516_게임개발/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tboard = new ArrayList[N+1]; \t\tfor(int i=0; i&lt;N+1; i++) { \t\t\tboard[i] = new ArrayList&lt;&gt;(); \t\t}  \t\ttime = new int[N+1]; \t\tindegree = new int[N+1]; \t\tres = new int[N+1];  \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\ttime[i] = Integer.parseInt(st.nextToken());  \t\t\tint n; \t\t\twhile((n = Integer.parseInt(st.nextToken())) != -1){ \t\t\t\tboard[n].add(i); \t\t\t\tindegree[i]++; \t\t\t} \t\t}  \t\tDeque&lt;Integer&gt; dq = new ArrayDeque&lt;&gt;(); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tif(indegree[i]==0){ \t\t\t\tdq.offer(i); \t\t\t\tres[i] = time[i]; \t\t\t} \t\t}  \t\twhile(!dq.isEmpty()){ \t\t\tint curr = dq.poll(); \t\t\tfor(int next : board[curr]){ \t\t\t\tres[next] = Math.max(res[next], res[curr] + time[next]); \t\t\t\tindegree[next]--; \t\t\t\tif(indegree[next]==0){ \t\t\t\t\tdq.offer(next); \t\t\t\t} \t\t\t} \t\t}  \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tsb.append(res[i]).append(\"\\n\"); \t\t}  \t\tSystem.out.println(sb.toString());         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "System Design Interviews @ FAANG",
    "url": "/posts/System-Design-Interviews-FAANG/",
    "categories": "시스템, 디자인",
    "tags": "system-design",
    "date": "2025-08-06 04:40:27 +0900",
    "content": "FAANG 시스템 설계 면접 완전 가이드  개요  FAANG 회사에 입사하는 것은 많은 기술 전문가들의 꿈입니다. 이러한 회사들은 시스템 설계를 포함하여 엔지니어링의 모든 측면에서 우수성을 요구합니다. FAANG 회사의 시스템 설계 면접은 대규모로 복잡한 문제를 해결하는 후보자의 능력을 평가합니다. 이들은 기술적 스킬뿐만 아니라 확장 가능한 시스템을 구축하는 창의성과 통찰력도 테스트합니다. 이러한 면접 준비는 깊이와 폭 때문에 어려울 수 있지만, 올바른 접근법으로 후보자들이 뛰어난 성과를 낼 수 있습니다.   FAANG 시스템 설계 면접의 중요 주제   Understanding System Design Interviews  시스템 설계 면접은 FAANG 회사의 엔지니어 채용 과정에서 중요한 구성 요소입니다. 이러한 면접은 후보자가 크고 복잡한 시스템을 설계할 수 있는 능력을 평가하도록 설계되었습니다.          시스템 설계 면접의 목적: 이러한 면접은 효율적이고 확장 가능하며 신뢰할 수 있는 소프트웨어 시스템을 구축하는 후보자의 스킬을 평가하는 것을 목표로 합니다. 면접관들은 문제 해결 능력과 아키텍처 설계 스킬의 명확한 시연을 찾습니다.           평가되는 스킬: 후보자들은 데이터베이스, 캐싱, 로드 밸런싱, 프록시 및 기타 시스템 구성 요소에 대한 지식으로 테스트됩니다. 프로그래밍 언어에 대한 숙련도와 시스템 제약 사항 및 트레이드오프에 대한 친숙함도 중요합니다.           일반적인 주제: 일반적으로 다루는 영역에는 분산 시스템 설계, 확장성 문제, 데이터 모델링, API 설계 및 잠재적으로 레거시 시스템 처리가 포함됩니다. 면접 질문은 종종 URL 단축 서비스나 확장 가능한 메시징 앱 설계와 같은 실제 문제를 포함합니다.           면접 형식: 이러한 면접은 보통 45~60분 동안 지속됩니다. 후보자들은 화이트보드에 설계를 그리고, 사고 과정을 설명하며, 지식의 깊이와 의사결정 논리를 탐구하는 후속 질문에 답하도록 요청받을 수 있습니다.           상호작용적 토론: 코딩 면접과 달리, 시스템 설계 면접은 더 개방적이고 토론 기반입니다. 후보자들은 면접관과 앞뒤로 상호작용하여 설계를 탐구하고 개선할 것으로 예상됩니다.        Interview Structure at FAANG  FAANG 회사의 시스템 설계 면접 구조는 후보자들이 실제 소프트웨어 엔지니어링 도전을 얼마나 잘 처리할 수 있는지 평가하도록 신중하게 설계되었습니다. 이러한 면접은 단순히 올바른 답을 찾는 것이 아니라 후보자의 사고 과정, 문제 해결 능력, 그리고 시스템 설계 원칙의 실제 적용을 탐구하는 것입니다.  다음은 FAANG 회사의 시스템 설계 면접의 기본 구조입니다:          초기 문제 진술: 면접은 후보자가 시스템을 설계하거나 복잡한 엔지니어링 도전을 해결해야 하는 광범위한 문제 진술로 시작됩니다.           화이트보드 설계: 후보자들은 종종 화이트보드를 사용하여 설계를 스케치할 것으로 예상됩니다. 이 시각적 구성 요소는 그들이 시스템을 구축하면서 사고와 아키텍처 선택을 설명할 수 있게 해줍니다.           심화 질문: 면접 전반에 걸쳐, 후보자들은 설계의 특정 부분에 대한 심화 질문을 예상할 수 있습니다. 이는 확장성 문제, 데이터베이스 선택, 또는 잠재적인 시스템 장애를 처리하는 방법을 포함할 수 있습니다.           최적화 및 확장성: 면접관들은 확장성과 성능 최적화에 자주 집중합니다. 후보자들은 설계가 어떻게 확장되는지와 다양한 제약 조건 하에서 만들 수 있는 가능한 트레이드오프에 대해 논의할 준비를 해야 합니다.           행동적 구성 요소: 일부 면접에는 후보자가 팀과 회사 문화에 어떻게 맞을 수 있는지 평가하는 행동적 구성 요소도 포함될 수 있습니다. 이는 과거 프로젝트나 특정 도전을 처리하는 방법에 대한 질문을 포함할 수 있습니다.           피드백 및 반복: 후보자들은 종종 자신의 설계에 대한 피드백을 제공하고 면접관의 제안에 따라 반복하도록 권장됩니다. 이 과정은 후보자의 적응 능력과 아이디어를 개선하는 능력을 평가합니다.       Interview Process System Design Interviews @FAANG  FAANG 회사의 시스템 설계 역할 면접 프로세스는 다단계 여정입니다. 이 프로세스는 이러한 최고 기술 회사의 요구와 빠른 속도에 잘 맞는 후보자만이 통과하도록 보장합니다.          지원서 검토: 프로세스는 이력서와 추천을 포함한 후보자의 지원서 검토로 시작됩니다. 이 단계는 후보자의 배경을 평가하여 해당 직위의 기본 자격을 충족하는지 확인합니다.           전화 스크리닝: 지원서가 검토를 통과하면, 후보자는 보통 한두 번의 전화 스크리닝 면접에 직면합니다. 이것들은 종종 코딩에 집중하는 기술 면접이며 때로는 초기 역량을 평가하기 위한 간단한 시스템 설계 질문을 포함합니다.           현장 면접: 전화 스크리닝을 통과하면 채용 프로세스의 핵심인 현장 면접으로 이어집니다. 여기에는 후보자가 실시간으로 복잡한 문제를 다뤄야 하는 여러 라운드의 시스템 설계 면접이 포함됩니다.           다학제 면접: 후보자들은 코딩, 문화적 적합성, 때로는 행동적 특성과 같은 다른 스킬을 평가하는 면접도 받을 수 있습니다. 이것들은 후보자가 팀에 얼마나 잘 통합될 수 있고 다양한 도전을 처리할 수 있는지 보기 위한 것입니다.           채용 위원회 검토: 면접 후, 채용 위원회가 모든 피드백을 검토하고 결정을 내립니다. 이 검토는 철저하며, 다양한 면접에서 후보자의 성과의 모든 측면을 고려합니다.           제안 및 협상: 성공한 후보자들은 제안을 받으며, 이는 조건, 급여 및 시작 날짜에 대한 협상이 따를 수 있습니다. 합의되면 온보딩 프로세스가 시작됩니다.       Preparation Tips System Design Interviews @ FAANG  FAANG 회사의 시스템 설계 면접을 준비하는 것은 단순히 기술적 스킬을 브러쉬업하는 것 이상을 포함합니다. 복잡한 시스템을 이해하고 설계하기 위한 전략적 접근이 필요합니다. 다음은 그 면접을 성공적으로 통과하는 데 도움이 되는 준비 팁들입니다:          핵심 개념 학습: 확장성, 로드 밸런싱, 데이터 분할, 캐싱, 내결함성을 포함한 시스템 설계의 핵심 원칙을 마스터하는 데 집중하세요. 이러한 영역에서의 견고한 기초가 중요합니다.           사례 연구 검토: 대형 기술 회사의 기존 시스템을 분석하여 그들이 어떻게 구조화되어 있고 왜 특정 아키텍처 결정이 내려졌는지 이해하세요. 이는 구글의 검색 엔진, 페이스북의 메시징 시스템, 또는 아마존의 백엔드 서비스를 연구하는 것을 포함할 수 있습니다.           시스템 설계 연습: API 속도 제한기나 알림 서비스와 같은 완전한 시스템이나 구성 요소를 정기적으로 설계하는 연습을 하세요. 연습 세션을 사용하여 선택을 설명하고 정당화하는 능력을 개선하세요.           모의 면접: 시스템 설계에 집중한 동료나 멘토와의 모의 면접에 참여하세요. 이러한 세션의 피드백은 강점과 개선이 필요한 영역을 이해하는 데 매우 귀중할 수 있습니다.           반복할 준비: 면접 중 피드백에 따라 설계를 수정할 준비를 하세요. 피드백을 신중하게 통합하고 설계를 개선할 수 있다는 것을 보여주는 것은 중요한 스킬입니다.           트레이드오프 이해: 다양한 설계 선택의 트레이드오프에 대해 논의할 준비를 하세요. 특정 조건 하에서 왜 한 접근법을 다른 것보다 선택할 것인지 이해하고 설명하는 것이 핵심입니다.       During the Interview: Best Practices  FAANG 회사의 시스템 설계 면접에서 후보자들은 기술적 실력뿐만 아니라 명확한 의사소통과 전략적 사고도 보여줘야 합니다. 성과를 향상시키고 면접관에게 긍정적인 인상을 남기기 위해 아래 나열된 베스트 프랙티스를 따르세요:          요구사항 명확화: 해결책으로 뛰어들기 전에 문제 진술을 명확히 하기 위한 질문을 하는 것으로 시작하세요. 문제의 범위와 제약사항을 이해하는 것이 중요합니다.           접근법 개요: 세부사항을 다루기 전에 제안된 시스템 아키텍처나 해결책을 개요로 설명하세요. 이는 면접관이 사고 과정을 따르고 큰 그림을 보는 데 도움이 됩니다.           생각을 소리내어 말하기: 문제를 해결하면서 사고 과정을 말로 표현하세요. 이는 면접관이 접근법을 이해하고 필요시 가이드할 기회를 제공합니다.           확장성과 유연성에 집중: 설계에서 확장성과 유연성을 강조하세요. 시스템 수요가 증가할 수 있는 다양한 시나리오와 설계가 그러한 도전을 어떻게 처리할 것인지 논의하세요.           피드백을 긍정적으로 처리: 피드백에 열린 마음을 갖고 면접관의 입력에 따라 접근법을 적응시킬 준비를 하세요. 이는 협업적으로 일할 수 있는 능력과 학습에 대한 개방성을 보여줍니다.           설계 요약: 설계 요약으로 마무리하며, 요구사항을 어떻게 충족하는지 재강조하고 고려한 트레이드오프에 대해 논의하세요.       50가지 시스템 설계 면접 질문  1. Bit.ly와 같은 URL 단축 서비스를 어떻게 설계하시겠습니까?  답변:  핵심 기능인 긴 URL로 리디렉션하는 짧은 링크 생성을 고려하는 것부터 시작하겠습니다. 원본 URL에서 짧은 경로를 생성하기 위해 해시 함수를 사용하겠습니다. 저장을 위해서는 키가 해시이고 값이 원본 URL인 키-값 저장소가 효율적일 것입니다. 확장성은 로드 밸런서와 서로 다른 지역에 서버를 복제함으로써 해결할 수 있습니다.  2. WhatsApp과 같은 확장 가능한 메시징 앱을 어떻게 설계하시겠습니까?  답변:  주요 도전은 대량의 메시지와 사용자를 처리하는 것입니다. 부하를 관리하기 위해 데이터 샤딩이 있는 분산 시스템을 사용하겠습니다. 각 샤드는 사용자의 하위 집합에 대한 메시지를 처리할 것입니다. 실시간 메시징을 위해서는 서버와 클라이언트 간의 지속적인 연결을 유지하기 위해 WebSockets을 사용하겠습니다. 또한 사용자 프라이버시를 위해 종단간 암호화가 중요합니다.  3. Amazon과 같은 글로벌 전자상거래 사이트를 어떻게 아키텍처하시겠습니까?  답변:  이 시스템은 복잡한 사용자 상호작용과 높은 트랜잭션 볼륨을 처리해야 합니다. 결제 처리, 재고 관리, 사용자 프로필과 같은 다양한 기능을 별도의 서비스로 분리하는 마이크로서비스 아키텍처를 설계하겠습니다. 이는 확장성과 유지보수성을 향상시킵니다. 자주 액세스되는 데이터를 캐싱하면 데이터베이스 부하가 줄어들고, 콘텐츠 전송 네트워크(CDN)는 전 세계에 정적 콘텐츠를 빠르게 제공하는 데 중요할 것입니다.  4. Netflix와 같은 스트리밍 서비스에서 중요한 시스템 설계 고려사항은 무엇입니까?  답변:  대역폭과 지연시간이 중요한 요소입니다. 지연시간을 최소화하기 위해 사용자에게 더 가까운 곳에 콘텐츠를 배포하는 CDN을 사용하겠습니다. 대용량 비디오 파일을 효율적으로 저장하고 스트리밍하기 위해서는 각 파일을 더 작은 청크로 나누어 사용자의 인터넷 속도에 따라 더 나은 버퍼링과 품질 조정을 가능하게 하겠습니다. 머신러닝을 사용하는 추천 엔진은 관련 콘텐츠를 제안하여 사용자 참여를 높일 수 있습니다.  5. Uber와 같은 신뢰할 수 있고 효율적인 차량 공유 서비스 플랫폼을 어떻게 설정하시겠습니까?  답변:  주요 고려사항에는 지리적 위치 추적, 실시간 데이터 처리, 확장성이 포함됩니다. 추적을 위해 GPS 데이터를 사용하고 위치 데이터를 효율적으로 쿼리하기 위해 PostGIS와 같은 지리공간 데이터베이스를 사용하겠습니다. 백엔드는 위치, 교통 데이터, 사용자 기본 설정을 고려하는 강력한 알고리즘으로 승객과 근처 운전자를 효율적으로 매칭해야 합니다. 신뢰성과 확장성을 보장하기 위해 청구, 운전자 관리, 사용자 관리, 알림과 같은 다양한 기능에 대해 마이크로서비스를 사용하겠습니다.  6. Twitter 같은 고트래픽 소셜 미디어 플랫폼을 어떻게 구축하시겠습니까?  답변:  Twitter와 같은 소셜 미디어 플랫폼은 대량의 데이터와 높은 사용자 동시성을 처리해야 합니다. 트위팅, 팔로잉, 알림과 같은 관심사를 분리하기 위해 마이크로서비스 아키텍처를 사용하겠습니다. 데이터 저장을 위해서는 Cassandra와 같은 NoSQL 데이터베이스가 높은 쓰기 및 읽기 처리량을 효율적으로 처리할 수 있습니다. 피드 생성을 관리하고 트윗에 대한 빠른 액세스를 보장하기 위해 캐싱 전략과 실시간 데이터 처리를 위한 메시지 큐잉 시스템을 사용하겠습니다.  7. 모바일 게임 회사를 위해 수백만 개의 동시 게임 세션을 처리하는 시스템을 설계하세요.  답변:  핵심은 모든 활성 세션에서 실시간 상태 동기화를 관리하는 것입니다. 실시간 게임에 충분히 빠른 전이중 통신 채널을 유지하기 위해 WebSocket을 사용하겠습니다. 백엔드는 컨테이너화된 게임 세션 인스턴스를 관리하기 위해 Kubernetes를 사용하여 확장 가능한 클라우드 기반 환경으로 구조화될 수 있습니다. 또한 게임 상태의 빠른 읽기/쓰기를 위해 Redis와 같은 분산 인메모리 데이터 저장소를 구현하겠습니다.  8. 실시간 협업 텍스트 에디터에는 어떤 아키텍처를 사용하시겠습니까?  답변:  이는 충돌 없이 동시 편집을 처리하기 위해 운영 변환(operational transformation) 또는 충돌 없는 복제 데이터 타입(CRDT)이 필요합니다. 백엔드 서비스의 경우, 실시간 애플리케이션에 적합한 논블로킹 I/O 모델을 위해 Node.js를 선택하겠습니다. 데이터 지속성은 MongoDB와 같은 문서 지향 데이터베이스로 처리할 수 있으며, 상당한 지연 없이 모든 클라이언트의 뷰를 동기화하기 위해 WebSockets을 사용하겠습니다.  9. 대규모 소매업체를 위한 재고 시스템을 어떻게 설계하시겠습니까?  답변:  시스템은 재고 수준, 판매, 배송을 효율적으로 추적해야 합니다. 판매 및 재입고 이벤트가 발생할 때 실시간으로 재고 수준을 업데이트하기 위해 이벤트 주도 아키텍처를 사용하겠습니다. 잘 정의된 스키마가 있는 관계형 데이터베이스는 재고 항목에 대한 일관되고 신뢰할 수 있는 데이터를 유지하는 데 도움이 됩니다. 특히 세일과 같은 고트래픽 이벤트 중 확장성을 위해 데이터베이스 파티셔닝과 읽기 복제본을 구현하겠습니다.  10. 수천 개의 작업을 처리할 수 있는 확장 가능한 작업 스케줄러 시스템을 설계하세요.  답변:  스케줄러는 작업을 효율적으로 우선순위를 매기고 리소스를 할당해야 합니다. 작업 요구사항에 따라 우선순위를 동적으로 조정할 수 있는 우선순위 큐를 중심으로 설계하겠습니다. Celery와 같은 분산 작업 큐를 사용하면 여러 워커 노드에서 작업 분배를 관리하는 데 도움이 됩니다. 작업 상태와 메타데이터 저장을 위해서는 지속적인 데이터베이스가 필수적이며, 스케줄링 중에 일반적으로 필요한 읽기 작업을 가속화하기 위해 인메모리 캐싱으로 보완됩니다.  11. 웹 애플리케이션을 위한 확장 가능한 로깅 시스템을 어떻게 설계하시겠습니까?  답변:  로깅 시스템은 여러 소스에서 로그를 효율적으로 수집, 저장, 분석해야 합니다. 다양한 서비스에서 로그를 집계하기 위해 Fluentd나 Logstash와 같은 분산 로그 수집 시스템을 사용하겠습니다. 저장을 위해서는 Elasticsearch가 대용량 로그 데이터를 검색하고 분석할 수 있는 확장 가능한 솔루션을 제공합니다. Kafka는 고트래픽 중에 로그를 버퍼링하여 내구성과 내결함성을 보장하는 데 사용할 수 있습니다. 로그 데이터는 실시간 모니터링과 문제 해결을 위해 Kibana를 사용하여 시각화할 수 있습니다.  12. 이미지와 비디오와 같은 사용자 생성 콘텐츠를 효율적으로 저장하고 검색하는 시스템을 설계하세요.  답변:  미디어의 저장과 검색은 비용, 속도, 확장성의 균형을 맞추는 시스템이 필요합니다. 내구성과 확장성으로 인해 Amazon S3와 같은 객체 저장소를 미디어 파일에 사용하고, 전 세계 최종 사용자의 지연시간을 줄이기 위해 CDN을 사용하겠습니다. 메타데이터는 빠른 검색을 위해 DynamoDB와 같은 NoSQL 데이터베이스에 저장할 수 있습니다. 처리 및 전송을 위해서는 주문형 또는 지연 로딩 전략이 리소스 사용량과 성능을 최적화할 수 있습니다.  13. 금융 서비스 회사를 위한 사기 탐지 시스템을 어떻게 아키텍처하시겠습니까?  답변:  사기 탐지 시스템은 실시간으로 높은 정확도로 거래를 처리해야 합니다. 패턴을 분석하고 이상을 플래그하기 위해 머신러닝 모델을 활용하는 마이크로서비스 아키텍처를 구축하겠습니다. Kafka는 분석 서비스로 거래를 스트리밍하는 메시징 백본 역할을 할 수 있습니다. 거래 데이터의 저장과 쿼리를 위해서는 높은 쓰기 부하와 시간 기반 쿼리를 처리할 수 있는 시계열 데이터베이스를 사용하겠습니다.  14. 전자상거래 플랫폼을 위한 추천 시스템을 설계하세요.  답변:  추천 시스템은 사용자 행동과 선호도를 기반으로 개인화된 제안을 제공해야 합니다. 사용자 선호도를 예측하기 위해 행렬 분해 기법을 포함하는 협업 필터링 접근법을 사용하겠습니다. 실시간 추천 업데이트를 위해서는 Spark와 그 머신러닝 라이브러리 MLlib이 강력하고 확장 가능한 솔루션을 제공합니다. 사용자 프로필과 항목 속성은 빠른 읽기와 쓰기를 제공하는 Cassandra와 같은 데이터베이스에 저장할 수 있습니다.  15. 대기업을 위한 확장 가능한 이메일 알림 시스템을 어떻게 개발하시겠습니까?  답변:  이메일 알림 시스템은 신뢰성과 전달 가능성을 보장해야 합니다. 이메일 작성, 전송, 추적 구성 요소를 분리하기 위해 마이크로서비스 아키텍처를 사용하겠습니다. RabbitMQ는 대규모로 전송을 처리하기 위해 이메일 작업을 큐잉하는 데 사용할 수 있습니다. 이메일은 템플릿화되어 데이터베이스에 저장될 수 있으며, 각 이메일의 상태(전송됨, 열림 등)는 확장성과 유연성을 위해 NoSQL 데이터베이스에서 추적됩니다.  16. 안전한 사용자 인증 시스템을 어떻게 설계하시겠습니까?  답변:  안전한 인증 시스템은 사용자 자격 증명을 보호하고 데이터 무결성을 보장해야 합니다. 제3자 인증을 위해 OAuth를 구현하고 사용자 세션을 안전하게 유지하기 위해 JSON Web Tokens(JWT)를 구현하겠습니다. 비밀번호 저장을 위해서는 데이터베이스에 저장하기 전에 bcrypt와 같은 강력한 암호화 해시 함수를 사용하여 해시해야 합니다. 또한 다중 인증(MFA)을 구현하면 보안을 크게 향상시킬 수 있습니다. 모든 통신은 차단을 방지하기 위해 HTTPS를 통해 이루어져야 합니다.  17. 확장 가능한 온라인 투표 시스템을 설계하세요.  답변:  온라인 투표 시스템은 높은 트래픽을 처리하고 높은 데이터 무결성과 보안을 제공해야 합니다. 투명성과 변조 방지 기록을 보장하기 위해 블록체인 기반 시스템을 사용하겠습니다. 시스템은 수요 급증을 관리하기 위해 자동 스케일링과 로드 밸런서가 있는 확장 가능한 클라우드 인프라에 배포될 수 있습니다. 데이터는 전송 중과 저장 중에 암호화되어야 하며, 유권자 신원을 확인하기 위해 강력한 인증 조치가 마련되어야 합니다.  18. 주차장 관리 시스템을 어떻게 설계하시겠습니까?  답변:  주차장 관리 시스템은 여러 출입구를 처리하고, 주차 점유율을 추적하며, 결제 처리를 지원해야 합니다. 주차 공간의 상태를 추적하는 중앙 데이터베이스로 시스템을 설계하고, 실시간으로 공간 점유율을 모니터링하기 위해 IoT 센서를 사용하겠습니다. 실시간 가용성과 온라인 결제를 위한 모바일 앱과의 통합을 위해 API를 제공할 수 있습니다. 시스템은 높은 가용성으로 피크 트래픽을 효율적으로 처리할 수 있어야 합니다.  19. 실시간 대중교통 추적 시스템의 시스템을 설계하세요.  답변:  이 시스템은 실시간 업데이트를 제공하고 수많은 사용자의 동시 요청을 처리해야 합니다. 대중교통 차량에 설치된 GPS 장치를 사용하여 셀룰러 네트워크를 통해 중앙 서버로 실시간 위치 데이터를 전송하겠습니다. RabbitMQ와 같은 메시지 큐는 들어오는 데이터를 처리한 다음 실시간 업데이트를 위해 WebSockets을 통해 사용자 인터페이스로 푸시할 수 있습니다. 데이터 저장은 위치 기반 쿼리를 효율적으로 지원하는 지리공간 데이터베이스에서 관리할 수 있습니다.  20. Google Docs와 같은 문서 협업 도구를 어떻게 설계하시겠습니까?  답변:  시스템은 여러 사용자가 동시에 같은 문서를 편집하고 실시간으로 업데이트를 볼 수 있도록 해야 합니다. 동시 편집을 처리하기 위해 운영 변환(OT) 또는 충돌 없는 복제 데이터 타입(CRDT)을 사용하겠습니다. 백엔드는 문서 데이터를 저장하기 위한 확장 가능한 NoSQL 데이터베이스와 클라이언트와의 지속적이고 실시간 연결을 유지하기 위한 WebSocket 서버를 기반으로 할 수 있습니다. 충돌과 문서 기록을 처리하기 위해 적절한 버전 제어와 롤백 기능이 구현되어야 합니다.  21. 콘텐츠 전송 네트워크(CDN)를 어떻게 구축하시겠습니까?  답변:  CDN은 전 세계에 걸쳐 콘텐츠를 빠르고 안정적으로 배포해야 합니다. 지연시간을 최소화하기 위해 전략적 지리적 위치에 서버를 배치하는 것부터 시작하겠습니다. 각 서버는 요청을 더 효율적으로 처리하기 위해 이미지와 비디오와 같은 정적 콘텐츠를 캐시합니다. DNS 기반 로드 밸런싱 시스템은 사용자 요청을 가장 가까운 서버로 보냅니다. 서버 간 동기화를 위해서는 콘텐츠 인기도와 업데이트 빈도에 따라 푸시와 풀 캐싱 전략의 조합을 사용하겠습니다.  22. 분산 인프라를 위한 상태 모니터링 시스템을 설계하세요.  답변:  강력한 상태 모니터링 시스템의 핵심은 실시간 데이터 수집과 알림입니다. CPU 사용량, 메모리 소비, 디스크 I/O와 같은 상태 메트릭을 수집하고 시계열 데이터베이스를 사용하여 효율적인 저장과 쿼리를 위해 중앙 모니터링 서버로 이 데이터를 전송하는 각 서버에 에이전트를 구현하겠습니다. 이러한 메트릭의 임계값을 기반으로 알림이 구성되고, 알림을 위해 Slack이나 이메일과 같은 도구와 통합됩니다. Grafana와 같은 시각화 도구를 사용하여 시스템 상태의 대시보드 뷰를 제공할 수 있습니다.  23. 안전한 온라인 백업 시스템을 어떻게 아키텍처하시겠습니까?  답변:  온라인 백업 시스템에는 보안과 데이터 무결성이 중요합니다. 데이터가 사용자의 장치를 떠나기 전에 암호화되도록 클라이언트 사이드 암호화를 사용하겠습니다. 백업 데이터는 중복성과 높은 가용성을 위해 분산 파일 시스템을 사용하여 여러 데이터 센터에 저장됩니다. 저장소를 최적화하기 위해 데이터 중복 제거 기법이 적용됩니다. 또한 정기적인 보안 감사와 규정 준수 검사를 통해 시스템이 필요한 데이터 보호 규정을 준수하도록 합니다.  24. 확장 가능한 API 속도 제한 시스템을 설계하세요.  답변:  속도 제한은 API를 남용으로부터 보호하고 리소스 할당을 관리하는 데 필수적입니다. 사용자나 IP 주소당 API 요청을 추적하기 위해 Redis와 같은 분산 키-값 저장소를 사용하겠습니다. 각 요청은 처리 전에 미리 정의된 제한에 대해 확인됩니다. 확장성을 위해서는 트래픽 버스트를 허용하고 요청 부하를 부드럽게 하는 토큰 버킷 또는 리키 버킷 알고리즘을 구현하겠습니다. API 게이트웨이와의 통합은 중앙 집중식 관리와 배포를 가능하게 합니다.  25. 글로벌 이벤트 티켓팅 플랫폼을 어떻게 개발하시겠습니까?  답변:  이 플랫폼은 높은 수요 급증을 처리하고 실시간 가용성 업데이트를 제공해야 합니다. 사용자 관리, 예약, 결제 처리, 알림을 위한 서비스가 있는 마이크로서비스 아키텍처를 사용하겠습니다. 티켓 재고를 처리하고 초과 예약을 방지하기 위해 Redis와 같은 고성능 인메모리 데이터 저장소가 원자적 연산으로 좌석 예약을 관리할 수 있습니다. 로드 밸런서는 서버 간에 사용자 요청을 분산하고, 메시지 큐는 확인 및 알림 전송과 같은 비동기 작업을 처리합니다.  26. 디지털 구독 및 결제 관리 시스템을 어떻게 설계하시겠습니까?  답변:  디지털 구독 관리 시스템은 안전하고 유연하며 사용자 친화적이어야 합니다. 보안과 규정 준수를 보장하기 위해 거래 처리를 위한 제3자 결제 게이트웨이를 통합하겠습니다. 구독 관리를 위해서는 관계형 데이터베이스가 사용자 구독과 결제 기록을 추적합니다. 또한 결제 이벤트의 실시간 알림을 위해 웹훅 콜백을 구현하겠습니다. 마이크로서비스 아키텍처는 사용자 관리, 청구, 알림 서비스와 같은 다양한 구성 요소의 독립적인 스케일링을 허용합니다.  27. Zoom과 같은 확장 가능한 화상 회의 시스템을 설계하세요.  답변:  이러한 시스템은 실시간 비디오와 오디오 데이터를 효율적으로 처리해야 합니다. 클라이언트 간의 피어 투 피어 통신을 위해 WebRTC를 사용하겠습니다. WebSocket을 사용할 수 있는 신호 서버는 연결과 세션 시작을 관리합니다. 확장성을 위해서는 미디어 서버가 다자간 통화를 처리하고 대역폭 할당을 제어합니다. 사용자 계정과 통화 기록과 같은 데이터는 신뢰성을 위한 중복 메커니즘과 함께 확장 가능한 클라우드 데이터베이스 서비스에 저장됩니다.  28. 실시간 스포츠 베팅 시스템을 어떻게 아키텍처하시겠습니까?  답변:  실시간 스포츠 베팅 시스템은 즉각적인 응답성과 높은 거래 무결성이 필요합니다. 구성 요소 간의 신뢰할 수 있는 메시지 전달을 위해 Kafka와 같은 메시지 지향 미들웨어를 사용하겠습니다. 빠른 쓰기와 읽기를 위한 NoSQL과 거래를 위한 전통적인 SQL 데이터베이스의 조합이 성능과 데이터 일관성을 보장합니다. 실시간 분석을 수행하여 사용자에게 실시간 배당률과 잠재적 지불금을 제공할 수 있습니다.  29. 대규모 뉴스 집계 서비스를 위한 확장 가능한 시스템을 설계하세요.  답변:  시스템은 다양한 소스에서 뉴스 기사를 효율적으로 집계, 분류, 제공해야 합니다. API와 웹 피드에서 뉴스를 가져오기 위해 분산 크롤러 시스템을 사용하고, 유연성을 위해 MongoDB와 같은 NoSQL 데이터베이스에 원시 데이터를 저장하겠습니다. Apache Spark와 같은 배치 처리 시스템이 뉴스 콘텐츠를 분석하고 분류합니다. 사용자 전달을 위해서는 Redis와 같은 빠른 인메모리 캐시가 인기 뉴스를 제공하고, 강력한 전문 검색 엔진이 상세한 쿼리를 가능하게 합니다.  30. 스마트 홈에서 IoT 장치를 관리하는 시스템을 어떻게 개발하시겠습니까?  답변:  IoT 장치 관리는 여러 장치 유형과 높은 데이터 볼륨을 처리할 수 있는 시스템이 필요합니다. 소형 센서와 모바일 장치를 위한 경량 메시징 프로토콜인 MQTT를 사용하여 통신을 촉진하겠습니다. 장치 데이터는 IoT 워크로드에 최적화된 시계열 데이터베이스를 사용하여 처리되고 저장됩니다. 사용자 상호작용은 인증 및 권한 부여 메커니즘을 통해 보안을 보장하는 API 게이트웨이를 통해 장치와 통신하는 중앙 애플리케이션을 통해 관리됩니다.  31. 클라우드 호스팅 제공업체를 위한 고가용성 클러스터 시스템을 설계하세요.  답변:  호스팅 서비스에는 고가용성이 중요합니다. 자동 장애 조치가 있는 여러 데이터 센터를 포함하여 모든 수준에서 중복성이 있는 시스템을 설계하겠습니다. 로드 밸런싱은 서버 간에 트래픽을 균등하게 분산하고, 글로벌 DNS 서비스는 사용자를 가장 가까운 사용 가능한 서버로 라우팅합니다. 가상화 또는 컨테이너화는 빠른 스케일링과 복구를 허용합니다. 모니터링 서비스는 시스템 상태를 지속적으로 확인하여 이상에 대한 알림과 자동화를 트리거합니다.  32. 고트래픽 웹사이트를 위한 동적 광고 서빙 시스템을 어떻게 아키텍처하시겠습니까?  답변:  광고 서빙 시스템은 다양한 플랫폼에서 개인화된 광고를 빠르게 전달해야 합니다. 빠른 검색을 위해 사용자 프로필과 광고 기준을 저장하는 분산 캐시를 사용하겠습니다. 머신러닝 모델은 백그라운드에서 실행되어 광고 타겟팅을 조정하기 위해 사용자 행동을 처리합니다. 실시간 입찰 시스템은 들어오는 요청의 빠른 처리를 위해 Node.js와 같은 기술을 사용하여 빠르고 확장 가능한 백엔드로 처리됩니다.  33. 마케팅 목적의 대규모 이메일 캠페인을 처리하는 시스템을 설계하세요.  답변:  이 시스템은 수백만 개의 이메일을 효율적으로 관리하고 전송해야 합니다. 이메일 생성, 전송, 추적을 처리하는 별도의 서비스가 있는 세분화된 아키텍처를 구현하겠습니다. 대량 이메일 서비스는 SMTP를 통해 이메일 전송을 관리하고, 전송 일정을 처리하기 위해 RabbitMQ와 같은 큐잉 시스템을 사용합니다. 사용자 참여 데이터는 다양한 캠페인의 효과를 분석하기 위해 데이터 웨어하우스에 수집됩니다.  34. Asana나 Trello와 같은 확장 가능한 프로젝트 관리 도구를 어떻게 설계하시겠습니까?  답변:  시스템은 다양한 프로젝트에서 동시에 작업하는 여러 사용자를 지원해야 합니다. 트랜잭션 무결성을 위해 데이터가 SQL 데이터베이스에 저장되는 백엔드와 API를 통해 통신하는 웹 기반 프론트엔드를 사용하겠습니다. 실시간 업데이트는 실시간 협업을 위해 WebSocket으로 관리할 수 있습니다. 확장성을 위해서는 마이크로서비스 접근법이 작업 관리, 알림, 사용자 분석과 같은 다양한 기능의 독립적인 스케일링을 허용합니다.  35. 사용자가 도서를 탐색하고 구매할 수 있는 가상 도서 박람회 시스템을 설계하세요.  답변:  가상 도서 박람회에는 사용자 친화적인 인터페이스와 강력한 백엔드가 필요합니다. 반응형 대화형 사용자 경험을 위해 React와 같은 프론트엔드 프레임워크를 사용하겠습니다. 백엔드에는 검색 가능한 데이터베이스가 있는 카탈로그 서비스와 제3자 결제 프로세서와 통합된 구매를 처리하는 트랜잭션 시스템이 포함됩니다. 추천 엔진에 의해 구동되는 추천과 탐색 기록이 사용자 참여를 향상시킬 수 있습니다.  36. 피크 시간을 효율적으로 처리하기 위해 차량 공유 앱 시스템을 어떻게 설계하시겠습니까?  답변:  피크 시간 처리에는 확장 가능하고 효율적인 리소스 할당이 필요합니다. 사용자 부하를 관리하기 위해 수요에 따라 실시간으로 가격을 조정하는 동적 가격 모델을 구현하겠습니다. 백엔드는 확장성과 빠른 액세스를 위해 분산 데이터베이스를 사용하여 사용자 및 승차 데이터를 저장합니다. 실시간 위치 추적은 지리공간 데이터베이스로 처리됩니다. 효율적인 매칭 알고리즘이 운전자와 근처 승객을 빠르게 연결하고, 마이크로서비스 아키텍처는 결제 및 승차 매칭과 같은 개별 구성 요소가 독립적으로 확장되도록 합니다.  37. 극장과 콘서트를 위한 확장 가능한 티켓 예약 시스템을 설계하세요.  답변:  이 시스템은 높은 수요 급증을 처리하고 좌석 가용성에 대한 즉각적인 피드백을 제공해야 합니다. 실시간으로 좌석 예약을 관리하기 위해 Redis와 같은 고성능 인메모리 저장소를 사용하겠습니다. 메인 데이터베이스는 트랜잭션과 사용자 데이터를 관리하기 위한 강력한 일관성 보장이 있는 관계형 데이터베이스일 수 있습니다. 로드 밸런서는 판매 이벤트 중 대량의 사용자 볼륨을 처리하기 위해 여러 서버에 들어오는 트래픽을 분산합니다. 좌석이 사용 가능해지면 추가 요청을 큐에 넣고 처리하는 대체 메커니즘이 있습니다.  38. 다국적 기업을 위한 데이터 웨어하우징 솔루션을 어떻게 아키텍처하시겠습니까?  답변:  데이터 웨어하우징 시스템은 다양한 소스의 데이터를 분석과 보고를 위한 통합 형식으로 통합해야 합니다. 다양한 사업부에서 데이터를 수집하고 준비하기 위해 ETL(Extract, Transform, Load) 프로세스를 사용하겠습니다. 웨어하우스 자체는 대용량 데이터셋과 복잡한 쿼리를 효율적으로 처리하기 위해 Amazon Redshift나 Google BigQuery와 같은 확장 가능한 클라우드 플랫폼에 구축됩니다. 기업 데이터를 보호하기 위해 암호화와 액세스 제어를 포함한 데이터 보안 조치가 엄격할 것입니다.  39. 전자상거래 플랫폼을 위한 실시간 분석 엔진을 설계하세요.  답변:  실시간 분석 엔진은 발생하는 대용량 트랜잭션 데이터를 처리하고 시각화해야 합니다. 실시간 데이터 처리를 위해 Apache Flink와 결합된 Apache Kafka와 같은 스트림 처리 프레임워크를 사용하겠습니다. 이 설정은 구매 트렌드와 고객 행동과 같은 통찰력을 위해 데이터 스트림을 분석합니다. 결과는 높은 동시성 쿼리와 실시간 데이터 피드 처리에 최적화된 Apache Druid와 같은 빠르고 쿼리 가능한 데이터베이스에 저장됩니다.  40. 미디어 회사를 위한 디지털 권리 및 콘텐츠 배포 관리 시스템을 어떻게 개발하시겠습니까?  답변:  디지털 권리 관리(DRM)에는 디지털 미디어를 안전하게 배포하고 액세스를 제어하는 시스템이 필요합니다. 권리 거래를 투명하고 안전하게 관리하기 위해 블록체인 기반 솔루션을 구현하겠습니다. 미디어 파일은 암호화되고, 복호화 키는 승인된 사용자에게만 배포됩니다. 시스템에는 사용자 인증, 콘텐츠 배포, 트랜잭션 관리를 위한 마이크로서비스가 포함되어 확장성과 유연성을 보장합니다.  41. 글로벌 사용자를 위한 구직 및 지원 플랫폼을 설계하세요.  답변:  이 플랫폼은 여러 구인 게시물, 지원서, 사용자 상호작용을 효율적으로 처리해야 합니다. 다양한 기준에 따른 구인 목록의 빠른 검색을 위해 Elasticsearch를 사용하겠습니다. 사용자 데이터와 지원서는 높은 읽기 볼륨을 처리하기 위해 읽기 복제본이 있는 관계형 데이터베이스에 저장할 수 있습니다. 마이크로서비스 아키텍처는 사용자 프로필, 구인 게시물, 지원서 처리와 같은 기능의 분리를 허용하여 관리 가능성과 확장성을 향상시킵니다.  42. 수천 명의 동시 사용자를 서비스할 수 있는 온라인 학습 플랫폼을 어떻게 아키텍처하시겠습니까?  답변:  온라인 학습 플랫폼에는 강력한 비디오 스트리밍, 대화형 도구, 확장 가능한 사용자 관리 시스템이 필요합니다. 효율적인 비디오 배포를 위해 CDN을 사용하겠습니다. 퀴즈와 포럼과 같은 대화형 기능은 Firebase나 WebSockets과 같은 실시간 서비스를 통해 관리됩니다. 사용자 데이터는 확장 가능한 클라우드 데이터베이스로 처리되고, 마이크로서비스 접근법은 플랫폼의 다양한 측면이 수요에 따라 확장될 수 있도록 보장합니다.  43. 교통 관리, 공공 안전, 유틸리티 서비스를 통합하는 스마트 시티 프로젝트 시스템을 설계하세요.  답변:  다양한 서비스 통합에는 고도로 연결되고 반응성이 뛰어난 시스템이 필요합니다. 신호등, 카메라, 센서에서 실시간 데이터를 수집하기 위해 IoT 기술을 사용하겠습니다. 이 데이터는 지연시간을 줄이기 위해 엣지 컴퓨팅 인프라로 처리되고, 데이터 집계와 분석을 위한 중앙 클라우드 시스템으로 뒷받침됩니다. 이 데이터를 기반으로 공공 안전 알림과 유틸리티 관리 명령을 발행할 수 있으며, AI 알고리즘이 도시 관리를 개선하기 위한 예측 분석을 제공합니다.  44. 소매 체인을 위한 확장 가능한 로열티 보상 시스템을 어떻게 설계하시겠습니까?  답변:  로열티 보상 시스템은 포인트, 보상, 사용자 트랜잭션을 원활하게 관리해야 합니다. 포인트 트랜잭션을 안전하고 투명하게 추적하기 위해 분산 장부를 사용하겠습니다. 마이크로서비스 아키텍처는 포인트 적립, 보상 카탈로그 관리, 사용자 계정 관리와 같은 다양한 측면을 처리하여 확장성과 유연성을 보장합니다. POS 시스템과 전자상거래 플랫폼과의 통합은 원활한 사용자 경험을 보장합니다.  45. 대형 대학에서 도서관 자원과 사용자 상호작용을 관리하는 시스템을 설계하세요.  답변:  이 시스템은 자원 카탈로그, 대출, 반납을 효율적으로 처리해야 합니다. 카탈로그와 사용자 트랜잭션을 관리하기 위해 중앙집중식 데이터베이스를 구현하겠습니다. 온라인 예약 시스템은 학생들이 가용성을 확인하고 도서를 예약할 수 있게 합니다. 기한과 연체 항목에 대한 알림은 이메일이나 모바일 앱을 통해 자동화됩니다. 확장성은 많은 수의 사용자와 데이터를 수용하기 위해 클라우드 서비스를 사용하여 해결할 수 있습니다.  46. 대도시에서 응급 전화를 처리하는 시스템을 어떻게 설계하시겠습니까?  답변:  응급 전화를 위한 강력한 시스템은 신뢰성과 속도를 우선시해야 합니다. 높은 가용성과 내결함성을 보장하기 위해 분산 시스템 아키텍처를 사용하겠습니다. 단일 장애점의 과부하를 방지하기 위해 여러 디스패치 센터를 통해 전화를 라우팅합니다. 실시간 데이터 동기화가 중요하므로, 센터 간 메시지 스트리밍을 위해 Apache Kafka와 같은 기술을 사용하여 모든 위치가 최신 정보를 갖도록 합니다. 또한 GPS 데이터를 통합하면 발신자를 빠르게 위치 파악하고 가장 가까운 응급 서비스를 배치하는 데 도움이 됩니다.  47. 온라인 설문조사와 투표를 수행하기 위한 확장 가능한 플랫폼을 설계하세요.  답변:  이 플랫폼은 성능 지연 없이 대량의 사용자 제출을 효율적으로 관리해야 합니다. 백엔드를 처리하기 위해 Django나 Flask와 같은 웹 애플리케이션 프레임워크를, 반응형 사용자 경험을 위해 프론트엔드에 React나 Vue.js를 사용하겠습니다. 데이터는 Amazon RDS와 같은 확장 가능한 클라우드 데이터베이스에 저장되고, 자주 액세스되는 설문조사의 데이터 검색을 가속화하기 위해 Redis와 같은 캐싱 레이어가 있습니다. 로드 밸런싱은 사용자 트래픽을 서버에 균등하게 분산하여 성능이 사용자 수요에 따라 확장되도록 합니다.  48. 글로벌 통신을 위한 실시간 언어 번역 시스템을 어떻게 아키텍처하시겠습니까?  답변:  실시간 언어 번역 시스템에는 빠른 처리와 낮은 지연시간이 필요합니다. 빠른 번역을 위해 GPU 지원 서버에서 호스팅되는 머신러닝 모델을 사용하겠습니다. 이러한 모델은 다양한 언어 쌍을 처리하는 마이크로서비스를 통해 액세스됩니다. 실시간 통신을 위해서는 WebSockets이 사용자의 장치와 번역 서비스 간의 지속적인 연결을 제공합니다. 강력한 API 게이트웨이가 트래픽을 관리하고 번역이 효율적이고 안전하게 전달되도록 보장합니다.  49. Dropbox나 Google Drive와 같은 클라우드 기반 파일 저장 서비스 시스템을 설계하세요.  답변:  클라우드 저장 서비스는 고가용성, 보안성, 확장성이 있어야 합니다. Amazon S3와 같은 서비스를 사용하여 다양한 지리적 위치에 각 파일의 여러 복사본을 저장함으로써 데이터 중복성이 있는 시스템을 구현하겠습니다. 빠른 액세스와 동기화를 위해서는 블록 수준 동기화와 메타데이터 인덱싱 서비스의 조합이 변경 사항을 감지하고 파일의 변경된 부분만 동기화합니다. 보안은 암호화된 데이터 저장과 사용자 인증을 위한 OAuth와 같은 보안 액세스 프로토콜을 통해 시행됩니다.  50. 확장 가능한 레스토랑 예약 시스템을 어떻게 설계하시겠습니까?  답변:  시스템은 피크 예약 시간을 처리하고 실시간 가용성 업데이트를 제공해야 합니다. 원활한 사용자 경험을 제공하기 위해 Angular과 같은 프론트엔드 프레임워크가 있는 웹 기반 애플리케이션을 사용하겠습니다. 백엔드는 예약, 사용자 관리, 알림 처리 전용 서비스가 있는 마이크로서비스 아키텍처로 구동됩니다. Firebase와 같은 실시간 데이터베이스는 테이블 가용성의 즉각적인 업데이트를 촉진합니다. SMS와 이메일 서비스와의 통합은 예약에 관한 고객과의 직접적인 의사소통을 가능하게 합니다.    결론  FAANG 회사의 시스템 설계 면접은 기술적 깊이, 확장성 사고, 그리고 명확한 의사소통 능력을 종합적으로 평가하는 중요한 과정입니다. 성공적인 면접을 위해서는:          핵심 개념 마스터: 확장성, 로드 밸런싱, 데이터베이스 설계, 캐싱 전략 등의 기본기를 탄탄히 다져야 합니다.           실제 시스템 연구: 기존 대형 서비스들의 아키텍처를 분석하고 설계 결정의 이유를 이해해야 합니다.           체계적 접근: 요구사항 명확화 → 고수준 설계 → 세부 구성요소 설계 → 확장성 고려 → 트레이드오프 논의의 순서로 체계적으로 접근합니다.           의사소통: 사고 과정을 명확히 설명하고, 피드백을 수용하며, 설계 결정을 논리적으로 정당화할 수 있어야 합니다.           지속적 연습: 다양한 시스템 설계 문제를 반복 연습하고, 모의 면접을 통해 실전 감각을 기를 필요가 있습니다.      이 가이드에서 제시된 50가지 질문과 답변은 FAANG 시스템 설계 면접에서 자주 출제되는 핵심 주제들을 다룹니다. 각 답변을 참고하되, 자신만의 접근법을 개발하고 다양한 시나리오에 대해 깊이 있게 사고하는 연습을 지속해야 합니다. "
  },
  
  {
    "title": "Claude Code 사용기",
    "url": "/posts/Claude-Code-%EC%82%AC%EC%9A%A9%EA%B8%B0/",
    "categories": "기술",
    "tags": "claude code",
    "date": "2025-08-06 03:24:38 +0900",
    "content": "   들어가며   최근 화제가 된 Claude Code를 직접 써보기로 했다. 복잡한 작업보다는 간단한 노가다성 작업부터 시작해서 어떤 느낌인지 파악해보고 싶었다.    Claude Code란? Claude Code는 개발자가 터미널에서 바로 Claude AI에게 코딩 작업을 위임할 수 있는 도구입니다. 복잡한 웹 인터페이스 없이도 명령줄에서 바로 AI의 도움을 받을 수 있어 개발 워크플로우에 자연스럽게 통합할 수 있습니다.  설치 및 초기 설정    첫 실행 시 API 키를 입력하라고 나오는데, Anthropic 콘솔에서 발급받은 키를 입력하면 됩니다.  이렇게 명령어를 입력하면 자연스럽게 auth 페이지로 연결되며 로그인 되어있다면 자동으로 연결됩니다.      보안을 꽤 신경쓰는 것 같다. 파일을 읽고 실행할 수 있다는 경고와 함께 Security 문서 링크 도 제공해주었다. Yes, proceed 를 선택해서 계속 진행했다.    간단명료한 환영 메시지와 함께 도움말이 나왔다. 특히 인상적이었던 것은 저 문장이다.  실용적인 팁들:     /init으로 CLAUDE.md 파일 생성하기   파일 분석, 편집, bash 명령어, git 작업에 활용하기   다른 엔지니어에게 하듯이 구체적으로 요청하기      “Start with small features or bug fixes, tell Claude to propose a plan, and verify its suggested edits”   작은 것부터 시작하라는 조언이 와닿았다.    첫 번째 작업 “Dr. Pick” 프로젝트의 Spring Boot application.yml 설정을 정리하는 작업을 해보기로 했다.  claude-code \"Dr. Pick 프로젝트의 application.yml 설정 파일을 만들어줘. PostgreSQL과 Redis 연결 설정, JPA 설정을 포함해서. 개발환경으로 만들어줘\"   Claude Code가 바로 작업을 시작했다.  수행된 작업들은     기존 application.properties 파일 확인   application.yml 파일 생성 (PostgreSQL, Redis, JPA 설정 포함)   총 78줄의 설정 파일 생성         두 번째 작업  기존 application.properties 파일을 삭제하고 yml만 사용하도록 정리해달라고 요청했다:  claude-code \"application.properties 파일을 삭제하고 application.yml만 사용하도록 정리해줘\"   Claude Code의 처리 과정:     Update Todos - application.properties 파일 삭제 계획   Bash 명령 실행 - rm 명령으로 파일 삭제   완료 메시지 - “application.properties 파일을 삭제했습니다. 이제 application.yml 파일만 사용하여 설정이 관리됩니다.”   IDE에서 확인해보니 실제 파일과 코드가 변경되었다.   마무리 첫 사용 경험으로는 나쁘지 않았다. 복잡한 로직보다는 이런 설정 파일 정리, 파일 구조 변경 같은 노가다성 작업에 정말 유용할 것 같다. 조언대로 작은 것부터 시작하는 게 맞는 것 같다. 다음에는 좀 더 복잡한 Java 코드 작업도 시켜보고 싶다. 무엇보다 터미널에서 바로 AI와 협업할 수 있다는 점이 새로웠다. 개발 플로우를 크게 바꿀 수도 있겠다는 생각이 든다. 하지만 여기 의존하면 생각없이 단순한 코더가 될 것 같아 토론식으로 사용하면 좋을 것 같다. "
  },
  
  {
    "title": "BOJ_7579_앱 (Java)",
    "url": "/posts/BOJ7579%EC%95%B1-Java/",
    "categories": "알고리즘",
    "tags": "sql, 프로그래머스",
    "date": "2025-08-06 02:34:53 +0900",
    "content": "[Gold III] 앱 - 7579  문제 링크  성능 요약  메모리: 24228 KB, 시간: 184 ms  분류  다이나믹 프로그래밍, 배낭 문제  제출 일자  2025년 8월 6일 01:51:06  문제 설명  우리는 스마트폰을 사용하면서 여러 가지 앱(App)을 실행하게 된다. 대개의 경우 화면에 보이는 ‘실행 중’인 앱은 하나뿐이지만 보이지 않는 상태로 많은 앱이 '활성화'되어 있다. 앱들이 활성화 되어 있다는 것은 화면에 보이지 않더라도 메인 메모리에 직전의 상태가 기록되어 있는 것을 말한다. 현재 실행 중이 아니더라도 이렇게 메모리에 남겨두는 이유는 사용자가 이전에 실행하던 앱을 다시 불러올 때에 직전의 상태를 메인 메모리로부터 읽어 들여 실행 준비를 빠르게 마치기 위해서이다.  하지만 스마트폰의 메모리는 제한적이기 때문에 한번이라도 실행했던 모든 앱을 활성화된 채로 메인 메모리에 남겨두다 보면 메모리 부족 상태가 오기 쉽다. 새로운 앱을 실행시키기 위해 필요한 메모리가 부족해지면 스마트폰의 운영체제는 활성화 되어 있는 앱들 중 몇 개를 선택하여 메모리로부터 삭제하는 수밖에 없다. 이러한 과정을 앱의 ‘비활성화’라고 한다.  메모리 부족 상황에서 활성화 되어 있는 앱들을 무작위로 필요한 메모리만큼 비활성화 하는 것은 좋은 방법이 아니다. 비활성화된 앱들을 재실행할 경우 그만큼 시간이 더 필요하기 때문이다. 여러분은 이러한 앱의 비활성화 문제를 스마트하게 해결하기 위한 프로그램을 작성해야 한다  현재 N개의 앱, A1, ..., AN이 활성화 되어 있다고 가정하자. 이들 앱 Ai는 각각 mi 바이트만큼의 메모리를 사용하고 있다. 또한, 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우, 추가적으로 들어가는 비용(시간 등)을 수치화 한 것을 ci 라고 하자. 이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여, 추가로 M 바이트의 메모리가 필요하다고 하자. 즉, 현재 활성화 되어 있는 앱 A1, ..., AN 중에서 몇 개를 비활성화 하여 M 바이트 이상의 메모리를 추가로 확보해야 하는 것이다. 여러분은 그 중에서 비활성화 했을 경우의 비용 ci의 합을 최소화하여 필요한 메모리 M 바이트를 확보하는 방법을 찾아야 한다.  입력  입력은 3줄로 이루어져 있다. 첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다. 둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며, 셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다  단, 1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000,000이며, 1 ≤ m1, ..., mN ≤ 10,000,000을 만족한다. 또한, 0 ≤ c1, ..., cN ≤ 100이고, M ≤ m1 + m2 + ... + mN이다.  출력  필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다.      문제 풀이     dp와 냅색으로 풀었다.  dp[i] = i 비용으로 확보할 수 있는 최대 메모리 양  역순 탐색으로 같은 앱을 중복으로 선택하는 것을 방지했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st; \tstatic int N, M; \tstatic int[] memory, cost;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_7579_앱/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken());  \t\tmemory = new int[N]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tmemory[i] = Integer.parseInt(st.nextToken()); \t\t}  \t\tcost = new int[N]; \t\tint maxCost = 0; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tcost[i] = Integer.parseInt(st.nextToken()); \t\t\tmaxCost += cost[i]; \t\t}  \t\tint[] dp = new int[maxCost + 1]; // dp[i]= i비용으로 확보가능한 최대 메모리 \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfor(int j=maxCost; j&gt;=cost[i]; j--){ \t\t\t\tdp[j] = Math.max(dp[j], dp[j-cost[i]] + memory[i]); \t\t\t} \t\t}  \t\tfor(int i=0; i&lt;=maxCost; i++) { \t\t\tif(dp[i] &gt;= M) { \t\t\t\tSystem.out.println(i); \t\t\t\tbreak; \t\t\t} \t\t}           bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "PGMS_연간 평가점수에 해당하는 평가 등급 및 성과금 조회하기",
    "url": "/posts/PGMS%EC%97%B0%EA%B0%84-%ED%8F%89%EA%B0%80%EC%A0%90%EC%88%98%EC%97%90-%ED%95%B4%EB%8B%B9%ED%95%98%EB%8A%94-%ED%8F%89%EA%B0%80-%EB%93%B1%EA%B8%89-%EB%B0%8F-%EC%84%B1%EA%B3%BC%EA%B8%88-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-08-06 02:31:16 +0900",
    "content": "[level 4] 연간 평가점수에 해당하는 평가 등급 및 성과금 조회하기 - 284528  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 08월 06일 02:30:06  문제 설명  HR_DEPARTMENT 테이블은 회사의 부서 정보를 담은 테이블입니다. HR_DEPARTMENT 테이블의 구조는 다음과 같으며 DEPT_ID, DEPT_NAME_KR, DEPT_NAME_EN, LOCATION은 각각 부서 ID, 국문 부서명, 영문 부서명, 부서 위치를 의미합니다.           Column name Type Nullable            DEPT_ID VARCHAR FALSE   DEPT_NAME_KR VARCHAR FALSE   DEPT_NAME_EN VARCHAR FALSE   LOCATION VARCHAR FLASE          HR_EMPLOYEES 테이블은 회사의 사원 정보를 담은 테이블입니다. HR_EMPLOYEES 테이블의 구조는 다음과 같으며 EMP_NO, EMP_NAME, DEPT_ID, POSITION, EMAIL, COMP_TEL, HIRE_DATE, SAL은 각각 사번, 성명, 부서 ID, 직책, 이메일, 전화번호, 입사일, 연봉을 의미합니다.           Column name Type Nullable            EMP_NO VARCHAR FALSE   EMP_NAME VARCHAR FALSE   DEPT_ID VARCHAR FALSE   POSITION VARCHAR FALSE   EMAIL VARCHAR FALSE   COMP_TEL VARCHAR FALSE   HIRE_DATE DATE FALSE   SAL NUMBER FALSE          HR_GRADE 테이블은 2022년 사원의 평가 정보를 담은 테이블입니다. HR_GRADE의 구조는 다음과 같으며 EMP_NO, YEAR, HALF_YEAR, SCORE는 각각 사번, 연도, 반기, 평가 점수를 의미합니다.           Column name Type Nullable            EMP_NO VARCHAR FALSE   YEAR NUMBER FALSE   HALF_YEAR NUMBER FALSE   SCORE NUMBER FALSE            문제  HR_DEPARTMENT, HR_EMPLOYEES, HR_GRADE 테이블을 이용해 사원별 성과금 정보를 조회하려합니다. 평가 점수별 등급과 등급에 따른 성과금 정보가 아래와 같을 때, 사번, 성명, 평가 등급, 성과금을 조회하는 SQL문을 작성해주세요.  평가등급의 컬럼명은 GRADE로, 성과금의 컬럼명은 BONUS로 해주세요. 결과는 사번 기준으로 오름차순 정렬해주세요.           기준 점수 평가 등급 성과금(연봉 기준)            96 이상 S 20%   90 이상 A 15%   80 이상 B 10%   이외 C 0%            예시  HR_DEPARTMENT 테이블이 다음과 같고           DEPT_ID DEPT_NAME_KR DEPT_NAME_EN LOCATION            D0001 법무팀 Law Dep 그렙타워 4층   D0002 인사팀 Human resources 그렙타워 4층   D0003 총무팀 General Affairs 그렙타워 4층          HR_EMPLOYEES 테이블이 다음과 같고           EMP_NO EMP_NAME DEPT_ID POSITION EMAIL COMP_TEL HIRE_DATE SAL            2017002 정호식 D0001 팀장 hosick_jung@grep.com 031-8000-1101 2017-03-01 65000000   2018001 김민석 D0001 팀원 minseock_kim@grep.com 031-8000-1102 2018-03-01 60000000   2019001 김솜이 D0002 팀장 somi_kim@grep.com 031-8000-1106 2019-03-01 60000000   2020002 김연주 D0002 팀원 yeonjoo_kim@grep.com 031-8000-1107 2020-03-01 53000000   2020005 양성태 D0003 팀원 sungtae_yang@grep.com 031-8000-1112 2020-03-01 53000000          HR_GRADE 테이블이 다음과 같을 때           EMP_NO YEAR HALF_YEAR SCORE            2017002 2022 1 92   2018001 2022 1 89   2019001 2022 1 94   2020002 2022 1 90   2020005 2022 1 92   2017002 2022 2 84   2018001 2022 2 89   2019001 2022 2 81   2020002 2022 2 91   2020005 2022 2 81          다음과 같이 사원별 성과금 정보를 출력해야 합니다.           EMP_NO EMP_NAME GRADE BONUS            2017002 정호식 B 6500000   2018001 김민석 B 6000000   2019001 김솜이 B 6000000   2020002 김연주 A 7950000   2020005 양성태 B 5300000              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   여러 집계 함수를 알아야 하며 JOIN도 사용해야한다. 특히 CASE WHEN 으로 작성이 필요하다.  사용한 필드들은 GROUP BY 에 추가해줘야한다.      코드   SELECT hg.EMP_NO, he.EMP_NAME,     CASE         WHEN AVG(SCORE) &gt;= 96 THEN 'S'         WHEN AVG(SCORE) &gt;= 90 THEN 'A'         WHEN AVG(SCORE) &gt;= 80 THEN 'B'         ELSE 'C'     END AS GRADE,     CASE         WHEN AVG(SCORE) &gt;= 96 THEN 0.2 * he.SAL         WHEN AVG(SCORE) &gt;= 90 THEN 0.15 * he.SAL         WHEN AVG(SCORE) &gt;= 80 THEN 0.1 * he.SAL         ELSE 0     END AS BONUS         FROM HR_GRADE AS hg             JOIN HR_EMPLOYEES he on hg.EMP_NO = he.EMP_NO                 GROUP BY hg.EMP_NO, he.EMP_NAME, he.SAL;  "
  },
  
  {
    "title": "System Design Interview",
    "url": "/posts/System-Design-Interview/",
    "categories": "시스템, 디자인",
    "tags": "system-design",
    "date": "2025-08-02 01:50:19 +0900",
    "content": "  위치 기반 서비스(Proximity Service)는 무엇이며, 어떤 기능을 제공하나요?     위치 기반 서비스는 Yelp나 Google Places와 같은 앱에서 주변의 식당이나 가장 가까운 주유소 등을 찾는 데 사용되는 백엔드 구성 요소이며, 사용자 위치와 검색 반경을 입력받아 해당 반경 내의 모든 비즈니스를 반환하고, 비즈니스 소유자가 비즈니스를 추가, 삭제, 업데이트할 수 있도록 합니다.     위치 기반 서비스의 핵심 비기능 요구사항은 무엇인가요?     낮은 지연 시간: 사용자가 주변 비즈니스를 빠르게 찾을 수 있어야 합니다.   높은 가용성: 피크 시간 동안 트래픽 급증을 처리할 수 있어야 합니다.   이 동영상에서는 주변 비즈니스 검색에 초점을 맞춰 Yelp나 Google Places와 같은 위치 기반 서비스를 설계하는 방법을 설명합니다. 핵심 주제는 사용자 위치의 지정된 반경 내에 있는 업체를 효율적으로 검색하는 시스템을 만드는 것입니다. 검색 성능을 최적화하기 위해 지오해시와 같은 지리공간 인덱싱 기술을 사용하는 것을 포함해 기능적 및 비기능적 요구사항, API 설계, 데이터 스키마에 대해 다룹니다. 이 동영상에서는 또한 읽기 복제본과 같은 데이터베이스 확장 전략과 높은 읽기 부하를 처리하기 위한 캐싱에 대한 고려 사항에 대해서도 설명합니다. 시청자는 이 동영상을 통해 수백만 명의 사용자와 비즈니스를 처리할 수 있는 확장 가능하고 반응성이 뛰어난 근접 서비스를 구축하는 데 필요한 인사이트를 얻을 수 있습니다.    1. 근접 서비스(Proximity Service) 및 비즈니스 리뷰 앱의 핵심 요구사항          근접 서비스는 주변 식당이나 가까운 주유소 등 사용자의 위치 주변 최적의 장소를 찾는 데 사용되는 백엔드 서비스이다           이 영상에서는 Yelp와 같은 비즈니스 리뷰 앱을 위한 근접 서비스 설계를 다룬다           다양한 앱마다 근접 서비스에 요구하는 기능이 다를 수 있으나, 본 영상에서는 주요 기능 요구사항에 초점을 맞춘다           핵심 기능 첫 번째는 사용자의 위치와 검색 반경을 입력받아 해당 반경 내 모든 비즈니스를 반환하는 것이다           두 번째로, 비즈니스 오너는 비즈니스를 추가, 삭제, 수정할 수 있으며, 이 변경사항은 실시간이 아닌 익일에도 반영되어도 된다           세 번째는 사용자가 비즈니스의 상세 정보를 조회할 수 있도록 하는 것이다        2. 비기능적 요구사항의 중요성          비기능적 요구사항은 시스템 설계에 다양한 제약조건을 부과하며, 설계를 더 흥미롭고 도전적이게 만든다           예를 들어, 대규모 사용자와 비즈니스 데이터를 고려할 때 요구되는 주요 비기능적 조건이 존재한다           첫째, 지연 시간이 낮아야 하며, 사용자가 빠르게 주변 상점을 검색할 수 있어야 한다           둘째, 서비스의 높은 가용성이 필요하며, 이는 업무 시간 피크 동안 트래픽 급증도 감당할 수 있어야 함을 의미한다        3. 검색 용량과 요청량 산출          일일 활성 사용자(DUA)가 1억 명이고, 사용자당 평균 검색 요청은 5개이기 때문에, 초당 검색 요청 수는 약 5,000개이다           이를 통해 서비스의 검색 처리량과 서버의 부하를 대략적으로 예측할 수 있다           사용자당 검색 쿼리 수는 5개로 가정하며, 이는 적절하다고 판단된다      데이터 저장량 예상    2억 개에 달하는 비즈니스 데이터를 저장하려면, 데이터 스키마를 더 명확히 할 필요가 있다   저장 용량 산정을 위해 데이터 구조와 저장 방식에 대한 구체적인 정보가 필요하다   요구사항에 따른 서비스 설계 방향    서비스 설계 시, 높은 요청량과 막대한 데이터 저장에 대한 효율성과 확장성을 고려해야 한다   설계 개요를 수립할 때, 요청 처리 속도와 데이터 용량 관리가 중요하다     4. API 설계 및 구조         서비스의 API는 RESTful 방식으로 설계되어 간결함을 유지한다.           검색 기능을 위한 API는 사용자 위치의 위도와 경도, 선택적 검색 반경을 입력받아 주변 업체 목록을 반환한다.           검색 결과는 업체 객체 배열과 전체 개수를 포함하며, 페이지네이션은 생략되었지만 실제 적용 시 필수적이다.           API 응답의 업체 객체는 검색 결과를 표시하는 데 필요한 최소한의 정보를 포함하며, 상세 페이지를 위해 별도의 API 엔드포인트가 필요하다.           두 번째 API 카테고리는 업체 객체의 CRUD(생성, 읽기, 수정, 삭제)를 관리하며, 이는 표준적이며 자세한 설명은 생략한다.        5. 데이터 스키마 개요 및 구성요소         서비스에는 두 개의 핵심 데이터베이스 테이블이 존재하며, 하나는 사업체(비즈니스) 정보를 저장하는 테이블이고, 다른 하나는 근처 검색을 위한 위치 정보를 저장하는 테이블이다.           사업체 테이블은 비즈니스 ID를 기본키로 하며, 상세 정보를 저장하고 CRUD 연산을 지원한다.           근처 검색용 테이블은 사업체 ID와 위치(위도, 경도)를 빠르게 검색할 수 있도록 효율적으로 인덱싱되어야 한다.           위치 인덱싱은 지리적 검색(geospatial search) 지식을 요구하며, 이후 자세히 다루어진다.           전체 데이터 크기 추정을 위해, 200 million(2억) 개 사업체를 기준으로 각각의 상세 정보는 약 1~10KB, 평균은 1KB로 예상되어 데이터 총량은 테라바이트 범위로 보인다.           위치 데이터는 사업체 수와 같거나 적으며, 각각 8바이트로 저장되어 총 약 5GB로 계산되어 매우 작은 크기를 가진다.           데이터셋이 매우 작기 때문에, 인메모리 방식 등 다양한 설계 옵션이 가능하다.           최종적으로 이 시스템은 두 개의 핵심 API 범주에 대응하는 두 부분으로 구성될 것으로 예상된다.        6. 위치 기반 검색을 위한 데이터베이스와 인덱싱 전략          이 시스템은 읽기 중심의 위치 검색 서비스로, 높은 QPS(초당 요청 수)에 적합한 설계가 필요하다.           위치 검색을 위해 지리 정보 데이터베이스와 지오스페이셜 인덱스(예: Redis GEOHASH, PostGIS 확장 사용)가 적합하다.           가장 직관적이지만 비효율적인 방법은 원을 그려 내부의 비즈니스를 찾는 것인데, 이는 테이블 스캔이 필요하여 200백만 엔트리 기준 속도가 느리다.           더 효율적으로 하려면 위도와 경도에 인덱스를 생성하되, 2차원 데이터를 1차원으로 매핑하는 지오해시(Geohash)를 사용하는 것이 좋다.                Geohash는 지구를 사분면으로 나누고, 반복적으로 더 작은 구역으로 세분화하며, 문자열로 인코딩하는 방식으로, 검색 범위에 따라 길이를 조정한다.           Geohash를 이용한 검색은 단순한 문자열 검색으로 가능하므로, 별도 지리 정보 데이터베이스 없이 관계형 데이터베이스에서도 사용할 수 있다.           근접 검색을 위해 이웃하는 8개 지오해시를 포함하여 검색 범위를 확장하는 것이 일반적이며, 라이브러리를 통해 빠르게 처리 가능하다.                Geohash의 단점은 경계에 위치한 지역의 경우 인접 구역 또는 경계선 문제가 발생할 수 있으며, 이를 위해 앱레벨에서 주변 구역도 함께 조회하는 방법이 사용된다.      Geohash의 정밀도(길이)는 검색 반경에 따라 결정되며, 4~6 길이로 사용하는 것이 적당하다.        데이터 크기와 읽기 요청 수를 고려했을 때, 모든 위치 정보는 하나의 데이터베이스에 저장하고, 필요 시 읽기 복제본으로 확장하는 것이 좋다.           비즈니스 정보(200M 개)의 크기가 수 테라바이트에 달하더라도, 최신 하드웨어에선 하나의 서버에 저장 가능하며, 샤딩은 필요하지 않다고 추정된다.           검색 요청 처리를 위해, 위치 정보, 검색 반경 및 인접 구역 정보를 활용하여 데이터를 빠르게 조회한다.      최종적으로, 검색 프로세스는 클라이언트 요청→ 로드 밸런서→ 위치 서비스→ 적절한 Geohash 길이 산출→ 인접 geohashes 계산→ 데이터베이스 조회→ 거리 계산과 정렬 순으로 진행된다.        6.1. 로드 밸런서와 서비스 분배 구조   로드 밸런서는 수신된 트래픽을 API 라우트에 따라 위치 기반 서비스와 비즈니스 서비스에 분배한다.  두 서비스는 무상태(stateless) 구조이기 때문에 로드 밸런서 뒤에서 배포하는 것이 일반적이며, 이는 쉽게 수평 확장이 가능하게 한다.  실제 환경에서는 Kubernetes의 Envoy, AWS의 API Gateway 등 다양한 방법으로 트래픽을 분배할 수 있으며, 구체적인 방식은 중요하지 않다.    위치 기반 서비스의 특성 및 역할         위치 기반 서비스는 특정 위치와 반경 내 주변 비즈니스를 빠르게 찾는 핵심 컴포넌트이다.           이 서비스는 읽기 중심(read-heavy)이며, 쓰기 요청이 거의 없다, QPS는 약 5000에 이를 것으로 추정된다.           데이터는 자주 변경되지 않으며, 따라서 수평 확장 및 캐싱이 용이하다.           장소 검색 데이터세트는 크지 않으며, 이를 고려해 최적화가 가능하다.        비즈니스 서비스와 데이터 관리         비즈니스 서비스는 CRUD 요청을 처리하는 서비스로, 읽기보다 쓰기 요청이 적으며 즉각적인 반영이 필요 없기 때문에 유연한 설계가 가능하다.           읽기 요청은 피크 시간대에 QPS가 높아질 수 있어, 캐싱 활용이 적합하다.           데이터의 크기와 읽기 요청량에 따라, 초기 설계는 primary-secondary 데이터베이스 클러스터 구성이 적합하다.        데이터베이스 구조와 고려사항         primary 데이터베이스는 쓰기 요청을 처리하며, 읽기 요청은 복제본에서 담당한다.           데이터는 먼저 primary에 저장되고, 이후 복제본으로 복제되어, 일부 데이터 불일치가 발생할 수 있다; 그러나 이는 장소 데이터 변경이 즉각적일 필요 없기 때문에 문제가 되지 않는다.           이러한 구조는 높은 읽기 요청량을 효율적으로 처리하는 데 적합하다.           6.2. 지리 데이터베이스와 지리공간 인덱스의 기본 개념   지리 기반 검색을 지원하는 데이터베이스는 지리공간 데이터베이스(geospatial databases)라고 하며, 위치 데이터를 저장하고 쿼리하는 데 최적화되어 있다.  대표적인 지리공간 데이터베이스로 Redis GEOHASH와 PostGIS 확장된 Postgres가 있다.  이러한 데이터베이스들은 공통된 지리공간 인덱스 알고리즘을 사용하며, 이를 이해하면 적합한 솔루션 선택에 도움을 줄 수 있다.    가장 직관적이지만 비효율적인 방법은 원(circle)을 그리고 내부의 비즈니스 정보를 찾는 것이다.  이 방법은 경계 박스(bounding box)를 이용하지만, 속도가 느리고 큰 테이블 스캔이 필요하여 200만 이상의 엔트리에서는 비효율적이다.  인덱스 생성만으로는 한계가 있으며, 특히 경도(longitude)와 위도(latitude) 각각에 인덱스를 만들어도 큰 성능 향상은 기대하기 어렵다.  데이터는 2차원(위도, 경도)에 분포하며, 이를 1차원으로 맵핑하여 인덱스를 하나만 만들어 성능을 개선하는 것이 가능하다.    두 가지 지리공간 인덱싱 방법과 문제점         두 가지 인덱싱 방법은 해시 기반(hash-based)과 트리 기반(tree-based)로 나뉘며, 각각 Even Grid, Geohash, Quadtree, Google S2 등이 대표적이다.           두 방법 모두 맵을 작은 영역으로 분할해 빠른 검색을 위한 인덱스를 만든다.           해시 기반 방법은 세계를 균일하게 그리드로 나누는 방식으로, 각 그리드에 속하는 비즈니스를 저장한다.           그러나 이 방식의 문제는 비즈니스 분포가 고르게 분포되지 않으며, 밀집 지역과 희소 지역 간 그리드 크기를 조절하지 못하는 점이다.           따라서 밀집 지역에는 세분화된 작은 그리드, 희소 지역에는 큰 그리드를 사용하는 것이 이상적이다.           6.3. Geohash의 구조와 작동 방식   지구를 4개의 사분면으로 나눈 후, 각 사분면은 2비트로 표시되며, 이 과정을 반복하여 하위 그리드를 생성한다.  여러 단계의 세분화를 통해, 특정 위치와 크기에 맞는 그리드 크기를 정한다; 이때, 문자열 길이(precisions 또는 levels)가 그리드 크기를 결정한다.  예를 들어, 구글 본사 위치는 1,200m×600m 크기의 그리드에 해당하며, base32 문자열로 인코딩된 길이로 그 정밀도를 알 수 있다.  위치 검색 시, 보통 4~6 길이의 geohash를 사용하며, radius에 따라 적절한 길이를 선택한다.  geohash는 문자열 형태로 되어 있어, 검색이 매우 간단하며 특히 관계형 데이터베이스에서도 효율적이다.    지오해시의 경계 문제와 해결 방안         서로 긴 접두사를 공유하는 포인트는 가까운 위치를 암시하지만,반대는 성립하지 않으며, 이는 지구의 위도/경도 경계에서 발생한다.           두 위치가 긴 접두사를 공유하더라도 다른 그리드에 속할 수 있으며, 이는 그리드 경계가 불완전하기 때문이다.           이 문제를 해결하기 위해, 현재 그리드와 8개 인접 그리드까지 포함하여 검색하는 방법이 일반적이다.           라이브러리를 이용하여 인접 geohash를 손쉽게 계산할 수 있다.        트리 기반 인덱스와 상대적 특징         대표적 트리 구조인 quadtree는 2차원 공간을 재귀적으로 4개 분할하는 방식으로 작동한다.           quadtree는 인메모리 데이터 구조로, 데이터베이스가 아니며 서버 내에서 구축된다.           트리 인덱스는 특정한 비즈니스 수에 따라 계속 세분화하는 방식이며, 운영 및 배포 측면이 geohash와 다르다.           본 설계에서는 geohash 방식을 선택하여 위치 검색에 활용한다.           6.4. ️ 지리정보 인덱스로서의 Geohash와 테이블 구조   Geohash는 위치 검색 속도를 높이기 위해 지리적 인덱스로 사용되며, 그래프 데이터베이스가 아닌 관계형 데이터베이스에서도 활용 가능하다.  테이블은 geohash와 사업 ID 두 컬럼으로 구성되며, 이 두 컬럼이 복합 키를 형성한다.  geohash 컬럼에는 각 사업의 적합한 정밀도를 갖는 geohash 값이 저장되며, 위치를 위경도로 변환하는 작업은 라이브러리로 간단히 처리할 수 있다.  여러 비즈니스가 동일 geohash를 공유하므로, 같은 geohash 내의 다양한 사업 ID는 각각 다른 행에 저장된다.  검색 시에는 SQL의 LIKE 연산자를 사용하여 prefix 길이를 조절하여 주변 검색이 가능하다.    Geohash 정밀도와 검색 범위         geohash 정밀도는 4에서 6 사이로 설정되며, 이는 각각 0.5km에서 20km의 검색 반경에 대응한다.           테이블의 geohash 컬럼은 모두 정밀도 6으로 저장되어, 더 긴 prefix를 활용한 검색이 이뤄진다.        💾 테이블 크기와 저장/확장 전략         각 행은 약 30바이트이며, 200백만 비즈니스 데이터를 저장 시 총 크기는 약 6GB로, 이는 현대 서버에서 충분히 수용 가능하다.           초기에는 하나의 데이터베이스 서버로 충분하지만, 높은 읽기 요청 (QPS 5000 이상)으로 인해 성능 저하가 발생할 수 있다.           읽기 부하 분산을 위해, 읽기 복제본을 활용하거나, 샤딩(sharding) 방식을 사용할 수 있으나, 샤딩은 애플리케이션 로직이 복잡해지기 때문에 복제본 방식이 더 적합하다.           6.5. 캐시 층 도입 여부와 그 영향   캐시 층이 필요할지 여부는 명확하지 않으며, 캐시로 인한 이점이 확실하지 않다.  읽기 중심의 워크로드에서, 지리공간 데이터셋은 크지 않기 때문에 성능 향상에 큰 도움이 되지 않을 수 있다.  읽기 성능이 병목일 경우, 읽기 복제본을 추가하는 것도 고려할 수 있다.    비즈니스 테이블 데이터 크기와 샤딩 전략          비즈니스 테이블은 약 2억 개의 비즈니스를 포함하며, 크기는 테라바이트 수준으로 추정된다.           최신 하드웨어에서는 이 크기가 크지 않으며, 샤딩이 필요할지 판단할 수 있는 경계선에 있다.           이 테이블의 갱신 빈도는 낮고, 읽기 위주이기 때문에 캐시를 사용하는 게 유리하며, 이를 통해 성장 여력을 확보할 수 있다.           읽기 부하 분산을 위해 읽기 복제본 도입도 한 방법이다.           초기에는 단일 데이터베이스로 시작하고, 성장과 모니터링 결과에 따라 샤딩, 읽기 복제, 캐시 도입 등을 결정하는 것이 권장된다.        검색 요청 처리 과정 요약         클라이언트는 위치와 반경 정보를 로드 밸런서에 전달한다.           요청은 위치기반 서비스로 전달되며, 검색 반경에 맞는 지오해시정밀도를 산출한다(여기서는 500미터 ≈ 지오해시길이 6).           주변 지오해시들을 계산한 후, 지리정보 인덱스 테이블에 9개 지오해시를 쿼리한다.           쿼리 결과로 비즈니스 ID와 위경도 쌍을 받아오고, 이를 이용해 사용자와 비즈니스 간 거리 및 순위를 계산한다.           이 과정을 통해 근접한 식당 정보를 반환한다.        References    FAANG System Design Interview: Design A Location Based Service (Yelp, Google Places)  "
  },
  
  {
    "title": "BOJ_16562_친구비 (Java)",
    "url": "/posts/BOJ16562%EC%B9%9C%EA%B5%AC%EB%B9%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-08-01 20:19:46 +0900",
    "content": "[Gold IV] 친구비 - 16562  문제 링크  성능 요약  메모리: 20460 KB, 시간: 212 ms  분류  그래프 이론, 자료 구조, 그래프 탐색, 분리 집합  제출 일자  2025년 8월 1일 20:17:14  문제 설명  19학번 이준석은 학생이 N명인 학교에 입학을 했다. 준석이는 입학을 맞아 모든 학생과 친구가 되고 싶어한다. 하지만 준석이는 평생 컴퓨터랑만 대화를 하며 살아왔기 때문에 사람과 말을 하는 법을 모른다. 그런 준석이에게도 희망이 있다. 바로 친구비다!  학생 i에게 Ai만큼의 돈을 주면 그 학생은 1달간 친구가 되어준다! 준석이에게는 총 k원의 돈이 있고 그 돈을 이용해서 친구를 사귀기로 했다. 막상 친구를 사귀다 보면 돈이 부족해질 것 같다는 생각을 하게 되었다. 그래서 준석이는 “친구의 친구는 친구다”를 이용하기로 했다.  준석이는 이제 모든 친구에게 돈을 주지 않아도 된다!  위와 같은 논리를 사용했을 때, 가장 적은 비용으로 모든 사람과 친구가 되는 방법을 구하라.  입력  첫 줄에 학생 수 N (1 ≤ N ≤ 10,000)과 친구관계 수 M (0 ≤ M ≤ 10,000), 가지고 있는 돈 k (1 ≤ k ≤ 10,000,000)가 주어진다.  두번째 줄에 N개의 각각의 학생이 원하는 친구비 Ai가 주어진다. (1 ≤ Ai ≤ 10,000, 1 ≤ i ≤ N)  다음 M개의 줄에는 숫자 v, w가 주어진다. 이것은 학생 v와 학생 w가 서로 친구라는 뜻이다. 자기 자신과 친구일 수도 있고, 같은 친구 관계가 여러 번 주어질 수도 있다.  출력  준석이가 모든 학생을 친구로 만들 수 있다면, 친구로 만드는데 드는 최소비용을 출력한다. 만약 친구를 다 사귈 수 없다면, “Oh no”(따옴표 제거)를 출력한다.     문제 풀이   union-find를 바로 떠올렸다.  이후 그 그룹마다 최솟값을 더해 k와 비교했다     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st; \tstatic int N, M, k; \tstatic int[] price, p;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_16562_친구비/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tk = Integer.parseInt(st.nextToken());  \t\tprice = new int[N]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tprice[i] = Integer.parseInt(st.nextToken()); \t\t}  \t\tp = new int[N+1]; \t\tfor(int i = 0; i &lt; N+1; i++) { \t\t\tp[i] = i; \t\t} \t\tfor(int i=0; i&lt;M; i++){ \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint a = Integer.parseInt(st.nextToken()); \t\t\tint b = Integer.parseInt(st.nextToken()); \t\t\tif(find(a) != find(b)){ \t\t\t\tunion(a ,b); \t\t\t} \t\t}  \t\tMap&lt;Integer, Integer&gt; group = new HashMap&lt;&gt;(); \t\tfor(int i=1; i&lt;=N; i++){ \t\t\tint pi = find(i); \t\t\tgroup.put(pi, Math.min(group.getOrDefault(pi, Integer.MAX_VALUE), price[i-1])); \t\t}  \t\tint res = 0; \t\tfor(int n : group.values()){ \t\t\tres += n; \t\t}  \t\tif(res &lt;= k) System.out.println(res); \t\telse System.out.println(\"Oh no\");          bw.flush();         bw.close();         br.close();     }  \tprivate void union(int x, int y) { \t\tint px = find(x); \t\tint py = find(y); \t\tif(px != py) p[py] = px; \t}  \tprivate int find(int x) { \t\tif(p[x] != x) p[x] = find(p[x]); \t\treturn p[x]; \t} }  "
  },
  
  {
    "title": "PGMS_멸종위기의 대장균 찾기",
    "url": "/posts/PGMS%EB%A9%B8%EC%A2%85%EC%9C%84%EA%B8%B0%EC%9D%98-%EB%8C%80%EC%9E%A5%EA%B7%A0-%EC%B0%BE%EA%B8%B0/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-07-30 09:52:35 +0900",
    "content": "[level 5] 멸종위기의 대장균 찾기 - 301651  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SELECT  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 07월 30일 09:50:50  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  각 세대별 자식이 없는 개체의 수(COUNT)와 세대(GENERATION)를 출력하는 SQL문을 작성해주세요. 이때 결과는 세대에 대해 오름차순 정렬해주세요. 단, 모든 세대에는 자식이 없는 개체가 적어도 1개체는 존재합니다.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 10 2019/01/01 5   2 NULL 2 2019/01/01 3   3 2 100 2020/01/01 4   4 2 16 2020/01/01 4   5 2 17 2020/01/01 6   6 4 101 2021/01/01 22   7 4 101 2022/01/01 23   8 6 1 2022/01/01 27          각 세대별 대장균의 ID는 다음과 같습니다.  1 세대 : ID 1, ID 2 2 세대 : ID 3, ID 4, ID 5 3 세대 : ID 6, ID 7 4 세대 : ID 8  이 때 각 세대별 자식이 없는 대장균의 ID는 다음과 같습니다.  1 세대 : ID 1 2 세대 : ID 3, ID 5 3 세대 : ID 7 4 세대 : ID 8  따라서 결과를 세대에 대해 오름차순 정렬하면 다음과 같아야 합니다.           COUNT GENERATION            1 1   2 2   1 3   1 4              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges        코드   WITH RECURSIVE generations AS (     SELECT ID, 1 AS generation         FROM ECOLI_DATA             WHERE PARENT_ID IS NULL          UNION ALL          SELECT e.ID, g.generation + 1         FROM ECOLI_DATA e             JOIN generations g ON e.PARENT_ID = g.ID )  SELECT COUNT(*) AS COUNT, generation AS GENERATION     FROM generations g         WHERE g.ID NOT IN(             SELECT DISTINCT PARENT_ID             FROM ECOLI_DATA             WHERE PARENT_ID IS NOT NULL         )         GROUP BY generation             ORDER BY generation ASC;  "
  },
  
  {
    "title": "PGMS_수식복원하기 (Java)",
    "url": "/posts/PGMS%EC%88%98%EC%8B%9D%EB%B3%B5%EC%9B%90%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-07-30 09:41:48 +0900",
    "content": "[level 3] [PCCP 기출문제] 4번 / 수식 복원하기 - 340210  문제 링크  성능 요약  메모리: 96.1 MB, 시간: 3.00 ms  구분  코딩테스트 연습 &gt; PCCP 기출문제  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 07월 30일 09:38:25  문제 설명  당신은 덧셈 혹은 뺄셈 수식이 여러 개 적힌 고대 문명의 유물을 찾았습니다. 이 수식들을 관찰하던 당신은 이 문명이 사용하던 진법 체계가 10진법이 아니라는 것을 알아냈습니다. (2 ~ 9진법 중 하나입니다.)  수식들 중 몇 개의 수식은 결괏값이 지워져 있으며, 당신은 이 문명이 사용하던 진법에 맞도록 지워진 결괏값을 채워 넣으려 합니다.  다음은 그 예시입니다.  &lt;수식&gt; 14 + 3 = 17 13 - 6 = X 51 - 5 = 44   X로 표시된 부분이 지워진 결괏값입니다.   51 - 5 = 44에서 이 문명이 사용하던 진법이 8진법임을 알 수 있습니다. 따라서 13 - 6 = X의 지워진 결괏값을 채워 넣으면 13 - 6 = 5가 됩니다.  다음은 또 다른 예시입니다.  &lt;수식&gt; 1 + 1 = 2 1 + 3 = 4 1 + 5 = X 1 + 2 = X  주어진 수식들에서 이 문명에서 사용한 진법이 6 ~ 9진법 중 하나임을 알 수 있습니다.  1 + 5 = X의 결괏값은 6진법일 때 10, 7 ~ 9진법일 때 6이 됩니다. 이와 같이 결괏값이 불확실한 수식은 ?를 사용해 1 + 5 = ?와 같이 결괏값을 채워 넣습니다.  1 + 2 = X의 결괏값은 6 ~ 9진법에서 모두 3으로 같습니다. 따라서 1 + 2 = X의 지워진 결괏값을 채워 넣으면 1 + 2 = 3이 됩니다.  덧셈 혹은 뺄셈 수식들이 담긴 1차원 문자열 배열 expressions가 매개변수로 주어집니다. 이때 결괏값이 지워진 수식들의 결괏값을 채워 넣어 순서대로 문자열 배열에 담아 return 하도록 solution 함수를 완성해 주세요.    제한사항   2 ≤ expressions의 길이 ≤ 100   expressions의 원소는 \"A + B = C\" 혹은 \"A - B = C\" 형태의 문자열입니다. A, B, C와 연산 기호들은 공백 하나로 구분되어 있습니다. A, B는 음이 아닌 두 자릿수 이하의 정수입니다. C는 알파벳 X 혹은 음이 아닌 세 자릿수 이하의 정수입니다. C가 알파벳 X인 수식은 결괏값이 지워진 수식을 의미하며, 이러한 수식은 한 번 이상 등장합니다.  결괏값이 음수가 되거나 서로 모순되는 수식은 주어지지 않습니다.      입출력 예           expressions result            [\"14 + 3 = 17\", \"13 - 6 = X\", \"51 - 5 = 44\"] [\"13 - 6 = 5\"]   [\"1 + 1 = 2\", \"1 + 3 = 4\", \"1 + 5 = X\", \"1 + 2 = X\"] [\"1 + 5 = ?\", \"1 + 2 = 3\"]   [\"10 - 2 = X\", \"30 + 31 = 101\", \"3 + 3 = X\", \"33 + 33 = X\"] [\"10 - 2 = 4\", \"3 + 3 = 10\", \"33 + 33 = 110\"]   [\"2 - 1 = 1\", \"2 + 2 = X\", \"7 + 4 = X\", \"5 - 5 = X\"] [\"2 + 2 = 4\", \"7 + 4 = ?\", \"5 - 5 = 0\"]   [\"2 - 1 = 1\", \"2 + 2 = X\", \"7 + 4 = X\", \"8 + 4 = X\"] [\"2 + 2 = 4\", \"7 + 4 = 12\", \"8 + 4 = 13\"]            입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.  입출력 예 #2  문제 예시와 같습니다.  입출력 예 #3  30 + 31 = 101에서 이 문명이 사용하던 진법이 6진법임을 알 수 있습니다. 따라서 10 - 2 = X, 3 + 3 = X, 33 + 33 = X의 지워진 결괏값을 채워 넣으면 10 - 2 = 4, 3 + 3 = 10, 33 + 33 = 110이 됩니다.  따라서 [\"10 - 2 = 4\", \"3 + 3 = 10\", \"33 + 33 = 110\"]을 return 해야 합니다.  입출력 예 #4  수식에 등장하는 숫자들을 통해 이 문명이 사용하던 진법이 8진법 혹은 9진법임을 알 수 있습니다. 2 + 2 = X와 5 - 5 = X의 지워진 결괏값을 채워 넣으면 8진법, 9진법에 관계없이 2 + 2 = 4, 5 - 5 = 0이 됩니다. 7 + 4 = X의 결괏값은 불확실하므로 지워진 결괏값을 채워 넣으면 7 + 4 = ?가 됩니다.  따라서 [\"2 + 2 = 4\", \"7 + 4 = ?\", \"5 - 5 = 0\"]을 return 해야 합니다.  입출력 예 #5  네 번째 예시와 같지만 5 - 5 = X가 8 + 4 = X로 바뀌었습니다. 이 문명이 사용하던 진법이 9진법임을 알 수 있으므로 7 + 4 = X와 8 + 4 = X의 지워진 결괏값을 채워 넣으면 7 + 4 = 12, 8 + 4 = 13이 됩니다.  따라서 [\"2 + 2 = 4\", \"7 + 4 = 12\", \"8 + 4 = 13\"]을 return 해야 합니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이           진법 후보를 찾아야한다. 모든 수식(X 포함)에서 나타나는 최대 숫자를 찾아 최소 진법을 결정할 수 있다.  ex) ‘7’이 등장하면 최소 8진법 이상이어야 함.           유효한 진법 필터링: X가 없는 완전한 수식들이 해당 진법에서 성립하는지 확인           코드   import java.util.*;  class Solution {     static List&lt;String&gt; ansList = new ArrayList&lt;&gt;();     static List&lt;Integer&gt; ableRadix = new ArrayList&lt;&gt;();     public String[] solution(String[] expressions) {                 int maxN = 0;         for(String e : expressions){             maxN = Math.max(maxN, getMaxFromExpression(e));         }         int minRadix = maxN + 1; // 최소 가능한 진법                  for(int i=minRadix; i&lt;=9; i++){             boolean flag = true;             for(String e : expressions){                 if(!e.contains(\"X\")){                     if(!isValid(e, i)){                         flag = false;                         break;                       }                 }             }                          // i진법이 유효할때             if(flag) ableRadix.add(i);         }                  for(String e : expressions){             if(e.contains(\"X\")){                 String res = makeAns(e);                 ansList.add(res);             }         }                  return ansList.toArray(new String[0]);     }          // 전체식에서 최대숫자찾기     private int getMaxFromExpression(String e){         int m = 0;         String[] arr = e.split(\" \");                  m = Math.max(m, getMaxFromNumber(arr[0]));         m = Math.max(m, getMaxFromNumber(arr[2]));         if(!arr[4].equals(\"X\")){             m = Math.max(m, getMaxFromNumber(arr[4]));         }                  return m;     }          // 각 숫자 String에서 최대 숫자(0~9) 찾기     private int getMaxFromNumber(String str){         if(str.equals(\"X\")) return 0;                  int max = 0;         for(char c : str.toCharArray()){             int digit = c - '0';             max = Math.max(max, digit);         }         return max;     }          private boolean isValid(String e, int i){         String[] arr = e.split(\" \");                  // 숫자가 i진법에서 유효한지 체크 ex) 2진법에선 0,1 만 가능         if(!canParse(arr[0], i) || !canParse(arr[2], i) || !canParse(arr[4], i)) return false;                  // a (+/-) b = c         int a = getNum(arr[0], i);         int b = getNum(arr[2], i);         int c = getNum(arr[4], i);                  int cal = 0;         if(arr[1].equals(\"+\")) cal = a + b;         else cal = a - b;                  return c == cal;     }          private String makeAns(String e){ // X 채우기         String[] arr = e.split(\" \");                  Set&lt;String&gt; cals = new HashSet&lt;&gt;();                  for(int i : ableRadix){             // i진법에서 숫자들이 유효한지 체크             if(!canParse(arr[0], i) || !canParse(arr[2], i)) continue;                          int a = getNum(arr[0], i);             int b = getNum(arr[2], i);                          int cal = 0;             if(arr[1].equals(\"+\")) cal = a + b;             else cal = a - b;                          cals.add(Integer.toString(cal, i));         }                  if(cals.size() == 1) return e.replace(\"X\", cals.stream().findFirst().orElse(null));         else return e.replace(\"X\", \"?\");     }          private int getNum(String str, int radix){         if(str.equals(\"X\")) return 0;         return Integer.parseInt(str, radix);     }          private boolean canParse(String str, int i){         if(str.equals(\"X\")) return true;                  for(char c : str.toCharArray()){             int digit = c - '0';             if(digit &gt;= i) return false;         }         return true;     } }  "
  },
  
  {
    "title": "Operating System Concepts - Page Replacement",
    "url": "/posts/Operating-System-Concepts-Page-Replacement/",
    "categories": "운영체제",
    "tags": "OS",
    "date": "2025-07-21 20:27:31 +0900",
    "content": "   가상 메모리     10.4 페이지 교체    Over Allocating (메모리 과할당)  전체 10 페이지 중 실제로는 5페이지만을 사용하는 프로세스가 있다면, 요구 페이징을 통해 사용되지 않는 나머지 5페이지를 로드하는 I/O를 피할 수 있다.  ex) 40 프레임을 사용할 수 있는 시스템이 있다고 할 때, 10페이지를 모두 로드해야 하는 상황이였다면 4개의 프로세스를 사용할 수 있겠지만, 요구 페이징을 사용한다면 10개 중 5개는 사용되지 않으므로 8개의 프로세스를 사용할 수 있다.    그보다 더 많은 프로세스를 실행하게 되면 메모리 과할당(over-allocating) 발생  만약 10개의 페이지 중 5개만을 사용하는 6개의 프로세스를 실행시킨다면, 10개의 프레임은 남겨놓으면 높은 CPU 활용률과 처리율을 얻을 수 있다.    Q) 10 페이지를 모두 사용해야 하는 상황이 일어나면? 시스템에서는 40 프레임만 사용할 수 있는데 60 프레임을 필요로 하게 된다.      메모리 과할당은 발생 순서     프로세스가 실행하는 동안 페이지 폴트 발생   운영체제가 필요로 하는 페이지가 보조 저장장치에 저장된 위치를 알아냄   가용할 수 있는 프레임이 없음을 발견   이 시점에서 운영체제는 몇 가지 선택을 할 수 있다.     10.4.1 기본적인 페이지 교체  페이지 교체   만약 빈 프레임이 없다면 현재 사용되고 있지 않은 프레임을 찾아서 그것을 비운다.  그 프레임의 내용을 스왑 공간에 쓰고 그 페이지가 메모리에 이제는 존재하지 않는다는 것을 나타내기 위해, 페이지 테이블을 변화시킴으로써 프레임을 비어 있게 한다.  이후 비워진 프레임을 페이지 폴트를 발생시킨 프로세스에서 사용할 수 있게 된다.            보조저장장치에서 필요한 페이지의 위치를 알아낸다.           빈 페이지 프레임을 찾는다.   a. 비어 있는 프레임이 있다면 그것을 사용한다.   b. 비어 있는 프레임이 없다면 희생될 프레임(victim)을 선정하기 위하여 페이지 교체 알고리즘을 수행한다.   c. 희생될 페이지를 보조저장장치에 기록하고(필요한 경우), 관련 테이블을 수정한다.           빼앗은 프레임에 새 페이지를 읽어오고 테이블을 수정한다.           페이지 폴트가 발생한 시점에서부터 프로세스를 계속한다.        이때 빈 프레임이 없는 경우 디스크에 두 번 접근해야 한다. (한 번은 프레임을 비울 때, 다른 한 번은 읽어 들일 때) 따라서 페이지 폴트 처리 시간이 2배 소요되며 그에 따라 실질 접근 시간도 증가한다.  페이지 폴트 처리 시간이 2배인 이유는 비어 있는 프레임이 있었다면 읽어들이는 작업만 하면 되지만, 그렇지 않았을 경우 비우는 작업도 필요하기 때문이다.    이러한 오버헤드는 변경 비트(modify bit 또는 dirty bit)를 사용해서 감소시킬 수 있다. 페이지가 변경되지 않았다면, 메모리로 읽혀 들어온 후 변경되지 않았다는 것이다.  따라서 해당 페이지를 보조저장장치에 기록할 필요가 없다. 이 기법은 읽기 전용 페이지들에도 적용된다. 이렇게 처리하면 I/O 시간을 반으로 줄일 수 있으므로 페이지 폴트 처리 시간을 많이 줄일 수 있다.    요구 페이징 시스템이 해결할 두 가지 문제     프레임 할당 알고리즘 : 얼마나 프레임을 할당할지   페이지 교체 알고리즘 : 어떤 기준으로 페이지를 교체할지   페이지 교체 알고리즘의 성능은 특정 메모리 참조 나열에 대해 알고리즘을 적용하여 페이지 폴트 발생 횟수를 계산하여 평가한다. 이때 사용되는 메모리 주소 나열을 참조열(reference string)이라 부른다. 참조열은 인공적으로 생성할 수도 있고, 주어진 시스템을 추적하여 매 메모리 참조 시의 주소를 기록할 수도 있다.     10.4.2 FIFO 페이지 교체  FIFO(First-In First-Out) 알고리즘     메모리에 올라온 지 가장 오래된 페이지를 내쫓는다.     위 예시로 보면 처음 7, 0, 1번 페이지에 대해 페이지 결함이 발생하고, 이들 페이지는 순서대로 프레임이 할당된다.  다음으로 2번 페이지의 요청에서 페이지 결함이 발생하고, FIFO 알고리즘에서는 가장 먼저 프레임을 할당받았던 7번 페이지를 Victim으로 선택해, 7번 페이지를 디스크에 기록하고 원래 7번이 할당받은 프레임을 2번 페이지에 새로 할당한다.  Belady의 모순    프로세스에 프레임을 더 주었는데 오히려 페이지 폴트가 더 증가하는 현상   1,2,3,4,1,2,5,1,2,3,4,5  이러한 참조열이 있을때 프레임이 3개 일 경우에는 페이지 폴트가 9번 발생하지만, 프레임이 4개 일 경우에는 페이지 폴트가 10번 발생한다.  더 많은 프레임을 할당하였지만 오히려 페이지 폴트율이 증가하는 현상을 의미한다. 프레임을 할당하면 성능이 좋아질 것으로 생각하지만 항상 옳지는 않다.       10.4.3 Optimal Page Replacement (최적 페이지 교체)    앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다.     이 알고리즘은 할당된 프레임 수가 고정된 경우 가장 낮은 페이지 폴트율을 보장한다.  위 예시를 비교하면 fifo 알고리즘은 15번의 page fault가 발생하지만, opt 알고리즘은 9번의 page fault를 발생시킨다.    최적 페이지 교체 알고리즘은 프로세스가 앞으로 메모리를 어떻게 참조할 것인지 미리 알아야 하기 때문에 실제 구현이 어렵다.  (따라서 주로 비교 연구 목적을 위해 사용됨)     10.4.4 LRU Page Replacement (LRU 페이지 교체)    LRU(least recently used) 알고리즘은 가장 오래 사용되지 않은 페이지를 교체한다.     페이지마다 마지막 사용 시간을 유지한다.  이를 통해 페이지 교체 시에 가장 오랫동안 사용되지 않은 페이지를 선택한다.    3개의 프레임이 비어있는 상태로 시작한다면 처음 3개(7, 0, 1)의 참조는 페이지 폴트를 발생시키고 빈 프레임에 적재된다.  이후부터는 어떤것이 가장 오래 사용되지 않았는지 확인한 후 교체한다. 그 다음의 참조(2)는 페이지 7을 교체한다. (7은 세 프레임 중 가장 이전에 사용되었다.)  그 다음의 참조(0)은 이미 메모리 속에 있기 때문에 페이지 폴트를 발생하지 않는다. (마지막 사용 시간은 갱신한다.)  그 다음의 참조(3)은 페이지 1을 교체한다. (1은 세 프레임 중 가장 이전에 사용되었다.)    LRU 구현     Counter      각 페이지 항목마다 사용 시간 필드를 넣고 CPU에 논리적인 시계나 계수기를 추가   메모리가 접근될 때마다 시간은 증가   페이지에 대한 참조가 일어날 때마다 페이지의 사용 시간 필드에 시간 레지스터의 내용이 복사됨   이 방식을 통해 각 페이지의 마지막 참조 시간을 유지      Stack      페이지가 참조될 때 마다 페이지 번호는 스택의 중간에서 제거되어 스택 꼭대기에 놓임   스택의 꼭대기 : 항상 가장 최근에 사용된 페이지   스택의 밑바닥 : 항상 가장 오랫동안 이용되지 않은 페이지   스택의 중간 항목을 제거할 필요가 있으므로 doubly linked list 로 구현       10.4.5 LRU Approximation Page Replacement (LRU 근사 페이지 교체)    LRU가 지원되지 않는 하드웨어를 위한 방식, 참조 비트(Referenct bit) 를 사용하여 페이지 사용 정보를 관리   참조 비트는 페이지 테이블 항목에 존재하며, 페이지가 참조될 때 하드웨어에 의해 설정된다.  참조 비트는 최초 0으로 초기화되어 있으며, 사용자 프로세스가 실행되면 각 참조되는 페이지들에 대한 참조 비트는 1로 설정된다.    이 참조 비트를 통해 어떤 페이지가 프레임에 할당된 후 사용되지 않았는지 알 수 있지만, 페이지가 사용된 순서는 알 수 없다. 이 정보가 많은 LRU-Approximation 페이지 교체 알고리즘 의 기반이 된다.     10.4.5.1 부가적 참조 비트 알고리즘 (Aging)     각 페이지에 대해 8비트의 참조 비트를 할당한다.   일정한 시간 간격마다 타이머 인터럽트를 걸어서 운영체제가 참조 비트를 8비트 정보의 최상위 비트로 이동시키고 나머지 비트들은 하나씩 오른쪽으로 이동시킨다.  이 8비트 시프트 레지스터는 가장 최근 8구간 동안의 그 페이지의 사용 기록을 담고 있다.    ex)          만약 시프트 레지스터 값이 00000000 이라면 페이지를 8번의 구간동안 한 번도 사용하지 않았다는 뜻이고, 구간마다 최소한 한 번 이상 사용된 페이지는 11111111의 시프트 레지스터 값을 가진다.           레지스터 값이 11000100인 페이지는 01110111인 페이지보다 더 최근에 사용되었다. (맨 왼쪽 1이 더 빠르므로)      이 8비트 값을 이용하여 가장 작은 수를 갖는 페이지가 LRU 페이지가 되고 이를 교체할 수 있다.    10.4.5.2 2차 기회 알고리즘    FIFO 교체 알고리즘이 베이스. 페이지가 선택될 때마다 참조 비트를 확인한다.  참조 비트가 0이면 페이지를 교체하고 1이면 다시 한번 기회를 주고 다음 페이지로 넘어간다. 한 번 기회를 받게 되면 참조 비트는 해제된다.     2차 기회 알고리즘은 순환 큐로 구현할 수 있다.      10.4.5.3 개선된 2차 기회 알고리즘    참조 비트와 변경 비트 두 가지를 함께 사용한다. ( 참조비트 , 변경비트 ) 의 형태           0,0 : 최근에 사용되지도 변경되지도 않은 경우 - 교체하기 가장 좋음.           0,1 : 최근에 사용되지는 않았지만 변경은 된 이유 - 이 페이지는 뺏어 오려면 디스크에 내용을 기록해야 하므로 교체에 적당하지 않음.           1,0 : 최근에 사용되었으나 변경은 되지 않은 경우 - 이 페이지는 곧 다시 사용될 가능성이 높음.           1,1 : 최근에 사용도되었고 변경도 된 경우, 아마 곧 다시 사용될 것이며 뺏으려면 역시 디스크에 그 내용을 먼저 기록해야 함.      2차 기회 알고리즘과의 차이는 I/O 횟수를 줄이기 위해 변경된 페이지에 대해 우선순위를 준다는 것    10.4.6 NRU (Not Recently Used) 페이지 교체    NRU 알고리즘은 최근에 사용된 페이지를 메모리에 유지하는 것을 선호하는 알고리즘이다.   각 페이지마다 두 개의 비트를 사용한다     참조 비트(Reference bit): 페이지가 참조될 때 설정   수정 비트(Modified bit): 페이지가 수정될 때 설정   일정한 시간 간격마다 타이머 인터럽트가 발생하여 모든 페이지의 참조 비트를 클리어한다.    4가지 클래스 분류 운영체제는 페이지들을 네 가지 클래스로 나누고 가장 낮은 클래스에서 무작위로 페이지를 선택해서 교체한다.     Class 0 : 참조 안됨, 수정 안됨 (최우선 교체 대상)   Class 1 : 참조 안됨, 수정됨   Class 2 : 참조됨, 수정 안됨   Class 3 : 참조됨, 수정됨 (최후순위)      10.4.7 NFU (Not Frequently Used) 페이지 교체    NFU 알고리즘은 각 페이지마다 카운터를 유지하여 사용 빈도를 추적한다.   각 페이지의 카운터는 초기에 0으로 설정한다.  클록 간격마다 해당 간격 내에 참조된 모든 페이지의 카운터를 1씩 증가하고, 페이지 교체가 필요할 때 가장 낮은 카운터를 가진 페이지를 교체한다.  문제점 : 사용 시점을 고려하지 않고 단순히 빈도만 추적  ex) 첫 번째 패스에서 많이 사용된 페이지들이 두 번째 패스에서 불필요해져도 높은 빈도 카운터 때문에 메모리에 남아있게 됨.   10.4.8 Random 페이지 교체    메모리에서 무작위로 페이지를 선택하여 교체한다.      장점: 페이지 참조를 추적하는 오버헤드 비용을 완전히 제거        성능: 일반적으로 FIFO보다 우수하며, 루프 메모리 참조에서는 LRU보다 나은 경우도 있음      실제 특정 워크로드에서 복잡한 알고리즘의 오버헤드가 이익을 상쇄할 때 사용:            OS/390에서 LRU 근사치를 사용하다가 LRU 성능이 저하될 때 Random으로 전환             References     Page replacement algorithm  "
  },
  
  {
    "title": "Java String.format vs 문자열 연결: 성능 차이를 알아보기",
    "url": "/posts/Java-String.format-vs-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EA%B2%B0-%EC%84%B1%EB%8A%A5-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/",
    "categories": "공부",
    "tags": "Spring",
    "date": "2025-07-19 02:03:05 +0900",
    "content": "  Java 개발을 하다 보면 문자열을 조합해야 하는 상황이 자주 발생한다. 이때 두 가지 주요한 방법이 있는데  // 방법 1: 문자열 연결 String result = \"Hello \" + World + \"!\";  // 방법 2: String.format 사용 String result = String.format(\"Hello %s!\", World);   이 두 가지를 사용한다.  둘 다 같은 결과를 만들어내지만, 내부적으로는 어떤 차이가 있을까? 성능상 차이도 있지 않을까?  이런 궁금증에서 시작해 실제 Spring Boot 프로젝트 개선 사항에 오픈소스 기여 PR을 생성하기 까지의 과정을 담았다.    Stack Overflow에서 얻은 답변들  엄청 예전에 작성된 두 글이다.    String.format() vs “+” operator   Is it better practice to use String.format over string Concatenation in Java?   다양한 사람들의 토론과 테스트가 진행되었는데 여기서 퍼포먼스 관련 테스트를 한 댓글을 보면  public static void main(String[] args) throws Exception {         long start = System.currentTimeMillis();   for(int i = 0; i &lt; 1000000; i++){     String s = \"Hi \" + i + \"; Hi to you \" + i*2;   }   long end = System.currentTimeMillis();   System.out.println(\"Concatenation = \" + ((end - start)) + \" millisecond\") ;    start = System.currentTimeMillis();   for(int i = 0; i &lt; 1000000; i++){     String s = String.format(\"Hi %s; Hi to you %s\",i, + i*2);   }   end = System.currentTimeMillis();   System.out.println(\"Format = \" + ((end - start)) + \" millisecond\"); }   를 통해 다음과 같은 결과를 얻었다고 한다.  // 1백만 번 반복 테스트 결과 Concatenation = 265 millisecond Format = 4141 millisecond  즉, Concatenation 문자열 연결이 String.format 보다 약 15배 빠른 결과를 보여준다.     (이 성능 테스트 결과는 특정 환경에서의 측정값이며, 실제 애플리케이션에서는 다양한 요인이 성능에 영향을 줄 수 있다.)     왜 이런 차이가 발생하는가?  먼저 내부 동작을 비교해보자  1. String.format 내부동작    새로운 Formatte 객체 생성   정규식을 사용한 포맷 문자열 파싱   StringBuilder 생성 및 변환   2. Concatenation 문자열 연결의 내부 동작    컴파일러가 자동으로 StringBuilder 로 변환   직접적인 문자열 조합    String str = \"A\" + var + \"B\";  // 이 코드는 컴파일러에의해 아래처럼 변환됨  String str = new StringBuilder(\"A\").append(var).append(\"B\").toString();     JDK 소스코드 분석  String 클래스 내부 코드를 보자  public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence {     @Stable     private final byte[] value;          private final byte coder;  // LATIN1 또는 UTF16          static final boolean COMPACT_STRINGS;     static final byte LATIN1 = 0;     static final byte UTF16 = 1; }   Java 9부터 String은 더 이상 char[]가 아닌 byte[]로 문자를 저장합니다. 이는 메모리 효율성을 위한 것으로, Latin-1 문자들은 1바이트로, 그 외는 UTF-16으로 저장됩니다.    StringConcatHelper JDK 소스코드 주석에 이런것이 적혀있다. /**  * @implNote The implementation of the string concatenation operator is left to  * the discretion of a Java compiler, as long as the compiler ultimately conforms  * to The Java Language Specification. For example, the javac compiler  * may implement the operator with StringBuffer, StringBuilder,  * or java.lang.invoke.StringConcatFactory depending on the JDK version.  */  즉, + 연산자의 구현은 컴파일러에 따라 다르며, 최신 버전에서는 StringConcatFactory 를사용할 수도 있다는 것이다.    concat() 메서드 vs + 연산자 String 클래스에는 concat()  메서드도 있다. public String concat(String str) {     if (str.isEmpty()) {         return this;     }     return StringConcatHelper.simpleConcat(this, str); }  StringConcatHelper.simpleConcat() 을 사용하여 최적화된 연결을 수행한다.    String.format의 실제 구현 public static String format(String format, Object... args) {     return new Formatter().format(format, args).toString(); }   매번 새로운 Formatter 객체를 생성하고, 이 객체는 내부적으로 복잡한 파싱 로직을 수행하는데, 이것이 이것이 성능 차이의 주요 원인이다.     언제 무엇을 사용해야할까?  String.format을 사용하는 경우     복잡한 포맷팅이 필요할 때 (숫자, 날짜 등)   국제화(i18n)를 고려해야 할 때   가독성이 중요하고 성능이 크리티컬하지 않을 때   문자열 연결을 사용하는 경우     단순한 문자열 조합   성능이 중요한 경우   실제 포맷팅이 필요하지 않은 경우     String 클래스의 최적화 기법들 JDK 소스코드를 보면 여러 최적화 기법들도 볼 수 있다.     Compact Strings: Latin-1 문자는 1바이트로 저장   String Interning: intern() 메서드로 메모리 절약   Intrinsic Methods: JIT 컴파일러 최적화를 위한 어노테이션들   @IntrinsicCandidate public String(String original) {     this.value = original.value;     this.coder = original.coder;     this.hash = original.hash;     this.hashIsZero = original.hashIsZero; }      JIT 컴파일러와 성능 최적화   JDK 소스코드에서 발견한 @IntrinsicCandidate 어노테이션은 JIT 컴파일러가 해당 메서드를 특별히 최적화한다는 의미다. 이는 문자열 연산이 얼마나 중요하게 여겨지는지를 보여준다.      Spring Boot 소스코드  실제 오픈소스에서는 어떻게 사용되고 있는지도 살펴보고자 github를 찾아가봤다.  Spring Boot의 CorrelationIdFormatter 클래스에서 흥미로운 코드를 발견했다. // 기존 코드 this.blank = String.format(\"[%s] \",      parts.stream().map(Part::blank).collect(Collectors.joining(\" \")));   이 코드를 보았을 때 특징을 몇가지 적자면    단순한 문자열 조합만 한다   &amp;s 하나만 사용하는 간단한 케이스다   포맷팅의 장점활용이 딱히 없다   Formatter 객체 생성과 정규식 파싱이라는 불필요한 오버헤드를 줄이는게 나아보인다.   이를 바탕으로 개선을 제안해보았다  변경 PR      References     Release Note: JEP 254: Compact Strings : 내용: JDK 9에서 java.lang.String, StringBuilder, StringBuffer 클래스의 내부 문자 저장이 UTF-16 char 배열에서 byte 배열 + 1바이트 인코딩 플래그 필드로 변경됨. 새로운 저장 표현은 문자열 내용에 따라 ISO-8859-1/Latin-1(문자당 1바이트) 또는 UTF-16(문자당 2바이트)으로 문자를 저장/인코딩함  "
  },
  
  {
    "title": "Windows에서 클론 시 'Filename too long' 오류 해결하기",
    "url": "/posts/Windows%EC%97%90%EC%84%9C-%ED%81%B4%EB%A1%A0-%EC%8B%9C-Filename-too-long-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/",
    "categories": "오류, 해결",
    "tags": "git",
    "date": "2025-07-18 23:42:44 +0900",
    "content": "   문제 상황   spring boot 프로젝트를 fork 한 레포지토리를 클론하는 중 예상치 못한 오류를 발견했다.    클론은 성공했지만 체크아웃이 실패했다는 메시지가 보인다.     원인   이 오류는 Windows의 파일 경로 길이 제한 때문이다.  찾아보니     Windows는 기본적으로 260자의 파일 경로 제한이 있다.   이는 과거 MS-DOS 시절부터 내려온 레거시 제한사항이다.   Spring Boot 같은 대형 프로젝트는 깊은 디렉토리 구조와 긴 파일명을 가지고 있어 이 제한에 걸리기 쉽다.      해결방법   가장 간단한 방법으로 git 명령어를 사용했다. Git에서 긴 경로를 지원하도록 설정을 변경했다.  git config --global core.longpaths true   결론  다양한 대형 프로젝트는 긴 디렉토리명을 거의 무조건 가질텐데 이런 오류를 간단히 해결할 수 있었다.    References     Maximum Path Length Limitation  "
  },
  
  {
    "title": "제9회 천하제일 코딩대회 본선 Open Contest 후기",
    "url": "/posts/%EC%A0%9C9%ED%9A%8C-%EC%B2%9C%ED%95%98%EC%A0%9C%EC%9D%BC-%EC%BD%94%EB%94%A9%EB%8C%80%ED%9A%8C-%EB%B3%B8%EC%84%A0-Open-Contest-%ED%9B%84%EA%B8%B0/",
    "categories": "Code, Contests",
    "tags": "cp, 백준",
    "date": "2025-07-18 17:20:05 +0900",
    "content": "  우연히 빈 시간에 PS 감각을 잃지 않을 겸 제9회 천하제일 코딩대회 본선 Open Contest 에 참여했다.  풀었던 순서로 기록하고자 한다.    A번 [Gold I] OPS 분석 - 34063  문제 링크  성능 요약  메모리: 15164 KB, 시간: 688 ms  분류  수학, 다이나믹 프로그래밍, 조합론  제출 일자  2025년 7월 15일 15:22:10  문제 설명  야구선수의 성적을 평가하는 기준 중 하나로 $OPS$가 있다.    $A$는 타자가 친 1루타의 개수, $B$는 타자가 친 2루타의 개수, $C$는 타자가 친 3루타의 개수, $D$는 타자가 친 홈런의 개수, $E$는 타자가 얻은 볼넷의 개수, $F$는 타자가 당한 아웃의 개수라 하자. 타자가 타석에 들어섰을 때 이 6개의 결과 중 정확히 1개를 받는다.    $OPS$는 성적을 평가하는 다른 기준인 $OBP$와 $SLG$의 합으로 정의되고, $OBP=(A+B+C+D+E) \\div (A+B+C+D+E+F)$, $SLG=(A+2 \\times B+3 \\times C+4 \\times D) \\div (A+B+C+D+F)$이다.  $OBP, SLG$ 분모 중 하나라도 0일 때 $OPS$는 정의되지 않는다.  현재 태환이 응원하는 타자는 $X$번 타석에 들어서 $Y$의 $OPS$를 기록하고 있다. 이 선수의 성적을 분석하기 위해, 타자가 타석에 $X$번 들어서서 얻을 수 있는 $6^X$ 가지 결과 중, $OPS$가 $Y$ 이상이 되는 경우의 수를 구하자.  입력 첫째 줄에 타자가 타석에 들어선 횟수 $X$와 $OPS$ $Y$가 공백으로 구분되어 주어진다.  출력 타자가 타석에 $X$번 들어서서 얻을 수 있는 $6^X$가지 결과 중, $OPS$가 $Y$ 이상이 되는 경우의 수를 $20\\, 150\\, 116$으로 나눈 나머지를 출력한다.     문제 풀이   야구 통계인 OPS를 계산하는 문제로, 주어진 타석 수 X에서 가능한 모든 조합을 확인해야 했다. 조합 계산을 위해 파스칼의 삼각형을 미리 구성하고, 각 경우에 대해 다항계수를 계산했다.  원리가 궁금하면 이 글 참고해보자. 쉽게 설명해준다.  이후 반복문과 구현으로 풀었다.     코드   package 제9회천하제일코딩대회본선OpenContest;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class A_OPS분석 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int X;     static double Y;     static long[][] comb;     static final int MOD = 20150116;     public static void main(String[] args) throws Exception {         new A_OPS분석().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/제9회천하제일코딩대회본선OpenContest/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         X = Integer.parseInt(st.nextToken());         Y = Double.parseDouble(st.nextToken());          comb = new long[X+1][X+1];         for(int i=0; i&lt;=X; i++){             comb[i][0] = 1;             for(int j=1; j&lt;=i; j++){                 comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;             }         }          long res = 0;          for(int a=0; a&lt;=X; a++){             for(int b=0; b&lt;=X-a; b++){                 for(int c=0; c&lt;=X-a-b; c++){                     for(int d=0; d&lt;=X-a-b-c; d++){                         for(int e=0; e&lt;=X-a-b-c-d; e++){                             int f = X-a-b-c-d-e;                              if(a+b+c+d+e+f == 0 || a+b+c+d+f == 0) continue;                              double OBP = (double) (a+b+c+d+e)/(a+b+c+d+e+f);                             double SLG = (double) (a+2*b+3*c+4*d)/(a+b+c+d+f);                             double OPS = OBP + SLG;                              if(OPS &gt;= Y){                                 long num = getNum(a, b, c, d, e);                                 res = (res + num) % MOD;                             }                         }                     }                 }             }         }          System.out.println(res);          bw.flush();         bw.close();         br.close();     }      private long getNum(int a, int b, int c, int d, int e) {         long tmp = 1;         int x = X;         tmp = (tmp * comb[x][a]) % MOD;         x-=a;         tmp = (tmp * comb[x][b]) % MOD;         x-=b;         tmp = (tmp * comb[x][c]) % MOD;         x-=c;         tmp = (tmp * comb[x][d]) % MOD;         x-=d;         tmp = (tmp * comb[x][e]) % MOD;         x-=e;         // f는 빈자리채우기라 *1         return tmp;     } }     B번 [Gold IV] 밤(Time For The Moon Night) - 34064  문제 링크  성능 요약  메모리: 56120 KB, 시간: 468 ms  분류  수학, 그래프 이론, 자료 구조, 그래프 탐색, 너비 우선 탐색, 조합론, 분리 집합, 격자 그래프, 플러드 필  제출 일자  2025년 7월 15일 15:45:54  문제 설명  떨려오는 별빛 반짝이는데  넌 어디를 보고 있는지  금방이라도 사라질 것 같은데  나는 밤하늘을 달려 너에게 가려고 한다. 밤하늘은 $N\\times M$ 크기의 격자로 표현되며, 각 칸은 $(1,1)$부터 $(N,M)$까지의 좌표로 나타낼 수 있다. 나는 밤하늘에서 상하좌우 방향으로 한 칸씩 이동할 수 있다.  이 격자에는 $K$개의 별이 존재하며, 이중 $i$번째 별은 격자의 특정 칸 $(X_i,Y_i)$를 온전히 차지하고 있다. 따라서 별이 있는 칸으로는 이동할 수 없다.  나는 $(a_1,b_1)$과 $(a_2,b_2)$를 각각 왼쪽 아래와 오른쪽 위 꼭짓점으로 하는 축에 평행한 직사각형 안에서, 별이 위치하지 않은 원하는 좌표에서 출발할 수 있다. 마찬가지로, 너는 $(a_3,b_3)$와 $(a_4,b_4)$를 각각 왼쪽 아래와 오른쪽 위 꼭짓점으로 하는 축에 평행한 직사각형 안에서 별이 위치하지 않은 원하는 좌표에서 시작할 수 있다.  내가 상하좌우로 인접한 칸으로 이동해 가며 너를 만나러 갈 수 있는 시작 위치의 조합의 수를 구해야 한다. 시작 위치 조합이 다르다는 것은 나의 시작 위치와 너의 시작 위치 중 하나 이상이 다르다는 것을 의미한다. 두 사람이 같은 위치에서 시작할 수 있다는 점에 유의하라.  입력 첫째 줄에 격자의 크기를 나타내는 두 정수 $N,M$과 별의 개수 $K$가 공백으로 구분되어 주어진다.  둘째 줄부터 $K$개의 줄에 걸쳐, 그중 $i$번째 줄에는 $i$번째 별의 위치를 나타내는 $X_i,Y_i$가 공백으로 구분되어 주어진다.  그다음 4개의 줄에 걸쳐, 그중 $i$번째 줄에는 $a_i,b_i$가 공백으로 구분되어 주어진다.  출력 상하좌우로 이동해서 두 사람이 만날 수 있는 시작 위치 조합의 수를 출력하라.     문제 풀이   BFS를 이용해 연결된 영역(별이 없는 칸들)을 찾았고 각 연결에서 첫번째 직상각형이랑 두번째 직사각형에서 노드로 가능한 칸 개수를 각각 찾고 두 값을 곱해줬다.     코드   package 제9회천하제일코딩대회본선OpenContest;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class B_밤 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int[] dr = {-1, 1, 0 ,0}, dc = {0, 0, -1, 1};     static boolean[][] star, visited;     static int N, M, K, a1, b1, a2, b2, a3, b3, a4, b4;      public static void main(String[] args) throws Exception {         new B_밤().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/제9회천하제일코딩대회본선OpenContest/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());          star = new boolean[N+1][M+1];         visited = new boolean[N+1][M+1];          for(int i=0; i&lt;K; i++){             st = new StringTokenizer(br.readLine());             int x = Integer.parseInt(st.nextToken());             int y = Integer.parseInt(st.nextToken());             star[x][y] = true;         }          st = new StringTokenizer(br.readLine());         a1 = Integer.parseInt(st.nextToken());         b1 = Integer.parseInt(st.nextToken());          st = new StringTokenizer(br.readLine());         a2 = Integer.parseInt(st.nextToken());         b2 = Integer.parseInt(st.nextToken());          st = new StringTokenizer(br.readLine());         a3 = Integer.parseInt(st.nextToken());         b3 = Integer.parseInt(st.nextToken());          st = new StringTokenizer(br.readLine());         a4 = Integer.parseInt(st.nextToken());         b4 = Integer.parseInt(st.nextToken());          long res = 0;          for(int i=1; i&lt;=N; i++){             for(int j=1; j&lt;=M; j++){                 if(!star[i][j] &amp;&amp; !visited[i][j]){                     List&lt;int[]&gt; list = bfs(i, j);                      long cnt1 = 0, cnt2 = 0;                      for(int[] l : list){                         int x = l[0], y = l[1];                          if(x &gt;= a1 &amp;&amp; x &lt;= a2 &amp;&amp; y &gt;= b1 &amp;&amp; y &lt;= b2) cnt1++;                          if(x &gt;= a3 &amp;&amp; x &lt;= a4 &amp;&amp; y &gt;= b3 &amp;&amp; y &lt;= b4) cnt2++;                     }                      res += cnt1 * cnt2;                 }             }         }          System.out.println(res);          bw.flush();         bw.close();         br.close();     }      private static List&lt;int[]&gt; bfs(int x, int y){         List&lt;int[]&gt; list = new ArrayList&lt;&gt;();         Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();          queue.offer(new int[] {x, y});         visited[x][y] = true;          while(!queue.isEmpty()){             int[] curr = queue.poll();             list.add(new int[] {curr[0], curr[1]});              for(int k=0 ; k&lt;4; k++){                 int nx = curr[0] + dr[k];                 int ny = curr[1] + dc[k];                  if(!isValid(nx, ny)) continue;                  if(star[nx][ny]) continue;                  if(visited[nx][ny]) continue;                  visited[nx][ny] = true;                 queue.offer(new int[] {nx, ny});             }         }          return list;     }      private static boolean isValid(int x, int y){         return x &gt;= 1 &amp;&amp; x &lt;= N &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= M;     } }     G번 [Bronze IV] 첫 번째 문제는 정말 쉬운 문제일까? - 34071  문제 링크  성능 요약  메모리: 14212 KB, 시간: 104 ms  분류  구현  제출 일자  2025년 7월 15일 16:00:55  문제 설명  천하제일 코딩대회 본선은 전통적으로 문제가 난이도순으로 정렬되어 있지 않다. 이는 올해 열리는 제9회 천하제일 코딩대회도 마찬가지다. 하지만 규칙 설명을 열심히 듣지 않은 준호는 첫 번째 문제가 가장 쉬운 문제일 것이라고 생각했다.  천하제일 코딩대회에는 $N$개의 문제가 출제되었다. 각 문제의 난이도가 주어질 때, 첫 번째 문제가 가장 쉬운 문제인지, 가장 어려운 문제인지, 또는 둘 다 아닌지 판단해 보자.  입력 첫째 줄에 문제의 수 $N$이 주어진다.  둘째 줄부터 총 $N$개의 줄에 문제의 난이도가 주어진다.  $i+1(1\\le i\\le N)$번째 줄에 $i$번째 문제의 난이도를 의미하는 정수 $X_i$가 주어진다.  출력 첫 번째 문제가 가장 쉬운 문제라면 ez를, 가장 어려운 문제라면 hard를, 둘 다 아니라면 ?를 출력한다.     문제 풀이   가장 간단한 문제였다. 첫번째 문제 난이도가 최소값인지 최대값인지 둘 다 아닌지 판단만 하면 됐다. 간단한 산수 계산 문제.     코드   package 제9회천하제일코딩대회본선OpenContest;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class G_첫번째문제는정말쉬운문제일까 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new G_첫번째문제는정말쉬운문제일까().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/제9회천하제일코딩대회본선OpenContest/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  int N = Integer.parseInt(br.readLine());         int[] arr = new int[N];          for(int i=0; i&lt;N; i++){             arr[i] = Integer.parseInt(br.readLine());         }          int first = arr[0];          int min = first;         int max = first;          for(int i=1; i&lt;N; i++){             min = Math.min(min, arr[i]);             max = Math.max(max, arr[i]);         }          if(first == min) System.out.println(\"ez\");         else if(first == max) System.out.println(\"hard\");         else System.out.println(\"?\");          bw.flush();         bw.close();         br.close();     } }     C번 [Gold II] 공통 순서쌍 찾기 - 34065  문제 링크  성능 요약  메모리: 111640 KB, 시간: 984 ms  분류  자료 구조, 집합과 맵, 해 구성하기  제출 일자  2025년 7월 15일 16:35:55  문제 설명    $1$부터 $N$까지의 수가 정확히 한 번씩 등장하는 수열 $A$와 $B$가 주어진다. 아래 조건을 만족하는 두 정수의 순서쌍 $(x,y)$를 $K$개 찾으시오.    $1\\leq x,y\\leq N$ 수열 $A$에서 $x$가 $y$보다 먼저 등장한다. 수열 $B$에서 $x$가 $y$보다 먼저 등장한다.  입력 첫째 줄에 정수 $N$과 $K$가 공백으로 구분되어 주어진다.  둘째 줄에 수열 $A$의 원소 $A_1, A_2, \\cdots, A_N$이 공백으로 구분되어 주어진다.  셋째 줄에 수열 $B$의 원소 $B_1, B_2, \\cdots, B_N$이 공백으로 구분되어 주어진다.  수열 $A$와 $B$는 각각 $1$부터 $N$까지의 정수가 정확히 한 번씩 등장하는 길이가 $N$인 수열이다.  출력 조건을 만족하는 순서쌍이 $K$개 이상 있다면 첫째 줄에 Yes를 출력하고, 이후 $K$개의 줄에 걸쳐 순서쌍 $(x, y)$의 원소를 한 줄에 한 쌍씩 공백으로 구분하여 출력한다.  조건을 만족하는 순서쌍이 $K$개 미만이라면 No를 출력한다.  만약 가능한 답이 여러 개 있다면, 그중 하나를 아무 것이나 출력해도 정답으로 인정된다.     문제 풀이   두 순열에서 공통된 순서 관계를 가지는 순서쌍을 K개 찾는 문제였다. B 배열을 뒤에서부터 순회하면서, 현재 원소보다 A 배열에서 뒤에 나오는 원소들을 TreeSet으로 관리할 수 있는데 여기서 tailSet을 이용해 효율적으로 조건을 만족하는 쌍을 찾는다 (NlogN)  여기서 특징으로 treeSet의 tailSet메서드를 꼽을 수 있다.  TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(); NavigableSet&lt;Integer&gt; larger = ts.tailSet(currPosA + 1, true);   A 배열에서 currPosA(현재 B[i] 값이 A 배열에서 등장하는 위치)보다 뒤에 있는 값들을 뽑기 위해 TreeSet의 tailSet() 메서드를 사용한다. 이 메서드는 기준값 이상인 요소들을 반환하며, true 옵션을 주면 해당 기준값도 포함하여 탐색한다. 반환값은 NavigableSet 타입이며, 이는 SortedSet 인터페이스를 확장한 구조다.    코드   package 제9회천하제일코딩대회본선OpenContest;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class C_공통순서쌍찾기 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K;     static int[] A, B;     static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {         new C_공통순서쌍찾기().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/제9회천하제일코딩대회본선OpenContest/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());          A = new int[N];         B = new int[N];          st = new StringTokenizer(br.readLine());         for(int i=0; i&lt;N; i++) {             A[i] = Integer.parseInt(st.nextToken());         }         st = new StringTokenizer(br.readLine());         for(int i=0; i&lt;N; i++) {             B[i] = Integer.parseInt(st.nextToken());         }          int[] posA = new int[N+1];         for(int i=0; i&lt;N; i++) {             posA[A[i]] = i;         }          List&lt;int[]&gt; pairs = new ArrayList&lt;&gt;();          TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();         for(int i=N-1; i&gt;=0 &amp;&amp; pairs.size() &lt; K; i--) {             int curr = B[i];             int currPosA = posA[curr];              NavigableSet&lt;Integer&gt; larger = ts.tailSet(currPosA + 1, true);              for(int l : larger) {                 if(pairs.size() &gt;= K) break;                  int num = A[l];                 pairs.add(new int[] {curr, num});             }              ts.add(currPosA);          }          if (pairs.size() &gt;= K) {             System.out.println(\"Yes\");             for (int i = 0; i &lt; K; i++) {                 sb.append(pairs.get(i)[0]).append(\" \").append(pairs.get(i)[1]).append(\"\\n\");             }             bw.write(sb.toString());         } else {             System.out.println(\"No\");         }          bw.flush();         bw.close();         br.close();     } }     F번 [Silver IV] 자리 바꾸기 - 34069  문제 링크  성능 요약  메모리: 44360 KB, 시간: 564 ms  분류  구현, 애드 혹, 해 구성하기, 홀짝성  제출 일자  2025년 7월 15일 16:50:58  문제 설명  준혁이는 여름방학을 맞아 교실에 작은 장난을 계획하고 있다. 바로 학생들의 자리를 살짝 바꿔 놓는 것이다.  교실은 $N$개의 행과 $M$개의 열로 구성된 2차원 격자 형태로, $i$행 $j$열에는 출석번호 $A_{i,j}$번 학생이 앉아 있다. 모든 학생의 출석번호는 다르다.  자리를 너무 멀리 바꾸면 선생님에게 들킬 수 있기 때문에, 학생은 자신의 자리에서 상하좌우로 인접한 칸으로만 이동할 수 있다. 즉, $i$행 $j$열에 있는 학생은 $|i-i'|+|j-j'|=1$이 성립할 때만 $i'$행 $j'$열로 이동할 수 있다. 또한, 자리가 전혀 바뀌지 않은 학생이 생기면 소외감을 느낄 수 있으므로, 모든 학생은 반드시 정확히 한 번만 자리를 바꿔야 한다.  준혁이를 위해 위의 조건들을 모두 만족하는 새로운 자리 배치가 가능한지 판단하고, 가능하다면 그중 하나를 출력해 보자.  입력  첫째 줄에 두 정수 $N,M$이 공백으로 구분되어 주어진다.  둘째 줄부터 $N$개의 줄에 걸쳐 $M$개의 정수가 공백으로 구분되어 주어진다. $i+1(1\\leq i\\leq N)$번째 줄의 $j(1\\leq j\\leq M)$번째 수는 $A_{i,j}$를 의미한다.  출력  조건을 만족하는 배치가 가능하다면 첫째 줄에 Yes를 출력한다.  이어 둘째 줄부터 $N$개의 줄에 걸쳐 $M$개의 정수를 공백으로 구분하여 출력한다. $i+1(1\\leq i\\leq N)$번째 줄의 $j(1\\leq j\\leq M)$번째 수는 조건을 만족하는 배치에서 $i$번째 행 $j$번째 열에 위치하는 학생의 출석번호를 의미한다.  조건을 만족하는 배치가 불가능하다면 첫째 줄에 No를 출력한다.     문제 풀이   2x1짜리 타일을 꽉 채울 수 있는지 묻는 문제라고 생각했다. 체스판으로 따지면 흑칸과 백칸의 개수가 같아야 한다는 것. 그리고 붙어있는 2x1을 swap하는 식으로 결과를 만든다.     코드   package 제9회천하제일코딩대회본선OpenContest;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class F_자리바꾸기 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static int[][] board;     static int[][] res;     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new F_자리바꾸기().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/제9회천하제일코딩대회본선OpenContest/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         if((N*M)%2 == 1) {             System.out.println(\"No\");             return;         }          board = new int[N][M];         res = new int[N][M];          for(int i=0; i&lt;N; i++){             st = new StringTokenizer(br.readLine());             for(int j=0; j&lt;M; j++){                 board[i][j] = Integer.parseInt(st.nextToken());             }         }          int cnt1 = 0, cnt2 = 0;         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;M; j++){                 if((i+j)%2 == 0) cnt1++;                 else cnt2++;             }         }          if(cnt1 != cnt2) {             System.out.println(\"No\");             return;         }          for (int i = 0; i &lt; N; i++) {             System.arraycopy(board[i], 0, res[i], 0, M);         }          boolean[][] visited = new boolean[N][M];          for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;M; j++){                 if(!visited[i][j]){                     for(int k=0; k&lt;4; k++){                         int nr = i+dr[k];                         int nc = j+dc[k];                         if(isValid(nr, nc) &amp;&amp; !visited[nr][nc]){                             visited[i][j] = true;                             visited[nr][nc] = true;                              int tmp = res[i][j];                             res[i][j] = res[nr][nc];                             res[nr][nc] = tmp;                             break;                         }                     }                 }             }         }                  System.out.println(\"Yes\");         for (int i = 0; i &lt; N; i++) {             for (int j = 0; j &lt; M; j++) {                 sb.append(res[i][j]);                 if (j &lt; M - 1) sb.append(\" \");             }             sb.append(\"\\n\");         }          bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private boolean isValid(int r, int c) {         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     } }     E번 [Silver III] 오디션 - 34068  문제 링크  성능 요약  메모리: 59812 KB, 시간: 400 ms  분류  수학, 그리디 알고리즘, 정렬  제출 일자  2025년 7월 15일 17:55:54  문제 설명  알고 있는가? 선린 1호관 엘리베이터의 비밀을. 매일 밤, 그 엘리베이터를 타면 지하로 향하는 길이 열린다. 그리고 그곳에선 아무도 모르게, 비밀의 오디션이 개최된다.  이 오디션엔 총 $N$명의 참가자가 있다. 오디션의 방식은 간단하다. 두 사람이 결투를 벌이고, 이긴 사람은 $1$점을 얻는다. 매번 한 명은 승자, 한 명은 패자로 결정되고 무승부는 없다. 지금까지 총 $M$번의 결투가 진행되었고, 그 결과는 모두 기록되어 있다.  당신은 참가자들의 순위를 $1$위부터 $N$위까지 정확히 결정하고 싶다. 단, 동점자가 있다면 순위는 결정되지 않는다. 참가자들의 순위를 모두 결정짓기 위해 추가로 치러야 할 결투의 최소 횟수는 몇 번인가?  입력 첫째 줄에 참가자의 수 $N$과 지금까지 진행된 결투의 횟수 $M$이 공백으로 구분되어 주어진다.  둘째 줄부터 $M$개의 줄에 걸쳐, $i+1(1\\leq i\\leq M)$번째 줄에는 $i$번째 결투의 결과가 주어진다. 각 줄에는 두 사람의 번호 $A_i,B_i$가 공백으로 구분되어 주어지며, 이는 $A_i$가  $B_i$와의 결투에서 승리했다는 뜻이다.  출력 참가자들의 순위를 모두 결정짓기 위해 추가로 치러야 할 결투의 최소 횟수를 출력하라.     문제 풀이   현재 점수를 정렬한 후, 각 순위가 구별되도록 최소한의 점수를 추가한다. 즉, 그리디하게 i번째 순위는 최소 (i-1)번째 순위보다 1점 높도록 설정한다.     코드   package 제9회천하제일코딩대회본선OpenContest;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class E_오디션 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     public static void main(String[] args) throws Exception {         new E_오디션().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/제9회천하제일코딩대회본선OpenContest/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          int[] score = new int[N + 1];          for (int i = 0; i &lt; M; i++) {             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             score[a]++;         }          int[] currScore = new int[N];         for (int i = 1; i &lt;= N; i++) {             currScore[i - 1] = score[i];         }          Arrays.sort(currScore);          long res = 0;          for (int i = 0; i &lt; N; i++) {             int curr = currScore[i];             int min;              if (i == 0) min = curr;             else min = Math.max(curr, currScore[i-1] + 1);               currScore[i] = min;              if (min &gt; curr) res += (min - curr);          }          System.out.println(res);          bw.flush();         bw.close();         br.close();     } }   소감  다양한 알고리즘과 자료구조를 활용할 수 있는 좋은 기회였고 PS 감각을 유지하는 데 도움이 되었다. "
  },
  
  {
    "title": "BOJ_16890_창업 (Java)",
    "url": "/posts/BOJ16890%EC%B0%BD%EC%97%85-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-07-08 16:59:05 +0900",
    "content": "[Gold I] 창업 - 16890  문제 링크  성능 요약  메모리: 47068 KB, 시간: 1076 ms  분류  그리디 알고리즘, 문자열, 정렬, 게임 이론  제출 일자  2025년 7월 8일 16:47:38  문제 설명  구사과와 큐브러버는 공동 창업을 하려고 한다. 두 사람은 회사 이름을 아직 결정하지 못했고, 서로가 생각한 회사 이름이 상대방을 설득하지 못해 일을 시작하지 못하고 있었다. 더 이상 일정을 늦출 수 없는 두 사람은 게임을 통해 회사 이름을 정하기로 했다. 다행히도 두 사람은 회사 이름의 길이에 대한 의견이 일치하고, N개의 글자로 이루어져 있어야 한다.  두 사람은 각자 사용할 N개의 문자를 정했다. 같은 문자가 여러 번 포함되었을 수도 있다. 가장 처음에 회사의 이름은 물음표(?) N개이다. 이제, 서로 턴을 번갈아 가지면서 게임을 진행하려고 한다. 게임은 구사과가 먼저 시작한다.  각 턴이 되었을 때, 각 사람은 미리 정해놓은 문자 중 하나를 고르고, 물음표 하나를 고른 문자로 변경한다. 고른 문자는 더 이상 사용할 수 없다. 게임은 모든 물음표가 문자로 바뀌면 끝난다.  예를 들어, 정보를 좋아하는 구사과가 고른 문자가 [i, o, i] 이고, 수학을 좋아하는 큐브러버가 고른 문자가 [i, m, o]인 경우가 있다면, 게임은 다음과 같이 진행될 수 있다.   \t가장 처음에 회사 이름은 ???이다. \t구사과가 두 번째 물음표를 i로 변경해 회사 이름을 ?i?로 변경한다. 이제 구사과의 고른 문자는 [i, o] 이다. \t큐브러버가 세 번째 물음표를 o로 변경해 회사 이름을 ?io로 변경한다. 이제 큐브러버의 고른 문자는 [i, m] 이다. \t마지막으로, 구사과가 첫 번째 물음표를 o로 변경해 회사 이름을 oio로 변경한다. \t최종적으로 회사의 이름은 oio가 된다.   구사과는 회사 이름을 사전 순으로 가장 앞서게 만들고 싶어하고, 큐브러버는 회사 이름을 사전 순으로 가장 뒤에 오게 만들고 싶어한다.  두 사람이 게임을 최적의 방법으로 진행했을 때, 회사 이름이 무엇인지 알아내는 프로그램을 작성하시오.  입력  입력은 길이가 N(1 ≤ N ≤ 300,000)인 문자열 두 개로 이루어져 있다. 모든 문자열은 알파벳 소문자로만 이루어져 있다. 첫 번째 줄에 주어지는 문자열은 구사과가 고른 문자이고, 두 번째 줄에 주어지는 문자열은 큐브러버가 고른 문자이다.  출력  두 사람이 창업한 회사의 이름을 출력한다.     문제 풀이   반드시 N길이 만큼 정해져있고 서로 최적의 방안을 고려하면 서로가 서로의 패를 알고 있어야 한다.  항상 맨 앞에 본인의 턴에 알파벳을 넣는게 디폴트다. (당연히 사람별로 koo는 가장 작은걸 맨앞, cube는 가장 큰걸 맨앞) 하지만 뒤에 넣어야 할 경우도 생기는데, 그래서 여러 경우의 수가 생긴다     남은 ? 자리 중맨 앞에 넣는 경우 (koo: [A, B, C] , cube: [D, E, F])            koo는 자신의 가장 작은걸 넣는다 -&gt; A??       cube는 자신의 가장 큰걸 넣는다 -&gt; AF?           남은 ? 자리 중 맨 뒤에 넣는 경우 (koo: [D, E, F] , cube: [A, B, C])            koo의 최소가 cube의 최대값보다 크면 koo본인껄 맨 앞에 넣는게 손해니까 일단 이후 상황을 고려해 최적의 방안인 본인의 최대값을 맨 뒤에 넣는다. -&gt; ??F       cube의 최대가 koo의 최소값보다 작으면 cube본인껄 맨 앞에 넣는게 손해니까 일단 이후 상황을 고려해 최적의 방안인 본인의 최소값을 맨 뒤에 넣는다. -&gt; ?AF           이렇게 고려해야할 여러 경우의 수를 나누어 진행해주면 된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static String s1, s2;     static Character[] koo, cube;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_16890_창업/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          s1 = br.readLine();         s2 = br.readLine();          koo = new Character[s1.length()];         cube = new Character[s2.length()];          for (int i = 0; i &lt; s1.length(); i++) {             koo[i] = s1.charAt(i);         }          for (int i = 0; i &lt; s2.length(); i++) {             cube[i] = s2.charAt(i);         }          int N = s1.length();          Arrays.sort(koo);         Arrays.sort(cube);          Deque&lt;Character&gt; dq_half_koo = new ArrayDeque&lt;&gt;();         for (int i = 0; i &lt; (N + 1) / 2; i++) {             dq_half_koo.offer(koo[i]);         }          Deque&lt;Character&gt; dq_half_cube = new ArrayDeque&lt;&gt;();         for (int i = N - N / 2; i &lt; N; i++) {             dq_half_cube.offer(cube[i]);         }          char[] res = new char[N];         Arrays.fill(res, '?');          int left = 0, right = N - 1;          for (int i = 0; i &lt; N; i++) {             //koosaga턴             if (i % 2 == 0) {                 if (!dq_half_cube.isEmpty() &amp;&amp; dq_half_cube.peekLast() &lt;= dq_half_koo.peekFirst()) {                     // [D, E, F]                     res[right--] = dq_half_koo.pollLast(); // ??'F'                 } else {                     // [A, B, C]                     res[left++] = dq_half_koo.pollFirst(); // 'A'??                 }             }             //cubelover턴             else {                 if (!dq_half_koo.isEmpty() &amp;&amp; dq_half_cube.peekLast() &lt;= dq_half_koo.peekFirst()) {                     // [A, B, C]                     res[right--] = dq_half_cube.pollFirst(); // ?'A'F                 } else {                     // [D, E, F]                     res[left++] = dq_half_cube.pollLast(); // A'F' ?                 }             }         }         System.out.println(new String(res));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "PGMS_입양 시각 구하기(1) (SQL)",
    "url": "/posts/PGMS%EC%9E%85%EC%96%91-%EC%8B%9C%EA%B0%81-%EA%B5%AC%ED%95%98%EA%B8%B01-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-07-08 15:55:33 +0900",
    "content": "[level 2] 입양 시각 구하기(1) - 59412  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  Empty  제출 일자  2025년 07월 08일 15:52:53  문제 설명  ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_OUTCOME VARCHAR(N) FALSE          보호소에서는 몇 시에 입양이 가장 활발하게 일어나는지 알아보려 합니다. 09:00부터 19:59까지, 각 시간대별로 입양이 몇 건이나 발생했는지 조회하는 SQL문을 작성해주세요. 이때 결과는 시간대 순으로 정렬해야 합니다.  예시  SQL문을 실행하면 다음과 같이 나와야 합니다.           HOUR COUNT            9 1   10 2   11 13   12 10   13 14   14 9   15 7   16 10   17 12   18 16   19 2            본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   HOUR() 로 DATETIME에서 시간을 뽑아냈다.     코드   SELECT HOUR(DATETIME) AS HOUR, COUNT(*) AS COUNT     FROM ANIMAL_OUTS         WHERE HOUR(DATETIME) &gt;= 9 AND HOUR(DATETIME) &lt;= 19             GROUP BY HOUR(DATETIME)                 ORDER BY HOUR(DATETIME);  "
  },
  
  {
    "title": "Operating System Concepts - Mutex, Semaphore 그리고 Java의 동기화 기법",
    "url": "/posts/Operating-System-Concepts-Mutex-Semaphore-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Java%EC%9D%98-%EB%8F%99%EA%B8%B0%ED%99%94-%EA%B8%B0%EB%B2%95/",
    "categories": "운영체제",
    "tags": "OS",
    "date": "2025-07-06 05:43:52 +0900",
    "content": "  Mutex와 Semaphore 이전의 배경  Race Condition (경쟁 상태)    여러 개의 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과값이 달라질 수 있는 현상   공유 자원에 여러 프로세스/쓰레드가 동시에 접근 -&gt; 의도치 않은 동작 발생 가능  따라서 프로세스나 쓰레드를 공유자원에 동시에 접근하지 못하도록 접근 순서를 제어하는 방법 (동기화) 가 필요하다    동기화    여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것      임계영역 (Critical Section) : 공유 데이터의 일관성을 보장하기 위해 특정 프로세스/쓰레드만 진입해서 실행 가능한 코드 영역   상호 배제 (Mutual Exclusion) : 특정 프로세스/쓰레드만 진입해서 실행 가능     Mutex Locks    하드웨어 기반 해결책은 응용 프로그래머가 사용할 수 없기 떄문에 대신 상위 수준 소프트웨어 도구들이 존재 -&gt; 그 중 가장 간단한 도구가 바로 Mutex 락     Mutex ( MUT ual + EX clusion )    여러개의 프로세스/쓰레드가 공유 자원에 동시에 접근하는 것을 제한하기 위한 락   프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야 하고, 임계구역을 빠져나올 때 락을 반환해야 한다.    의사 코드  while(true){ \t// acquire lock     critical section          //release lock     remainder section }    먼저 acquire() 함수가 락을 획득하고, release() 함수가 락을 반환하는 구조  Mutex 락은 available 이라는 boolean 변수를 가지는데, 이 변수 값이 락의 가용 여부를 표시한다.    특징     Boolean 타입의 Lock 변수   한 개의 프로세스/쓰레드 만 소유,해제   Non-Busy-Wait 방식 (대기큐에서 CPU 자원을 내려놓고 대기함)     바쁜 대기(busy waiting)  한 프로세스가 임계 구역에 있는 동안에 다른 프로세스들은 계속해서 acquire() 함수를 호출하는 반복문을 실행  이런 mutex 락 유형을 스핀락(spinlock) 이라고도 한다.    프로세스가 락을 기다려야하거나 문맥교환에 많은 시간이 소요되는 상황이라면, spin lock은 문맥 교환이 필요하지 않는다는 장점이 있다.  따라서 스핀락은 멀티 프로세서 환경에서 많이 사용된다.     세마포(Semaphores)    동기화 도구의 가장 간단한 형태. mutex lock과 유사하게 동작하지만 각 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공한다.   세마포는 여러개의 프로세스/쓰레드가 공유 자원에 동시 접근하는 것을 제한하기 위한 정수 변수로서, 초기화를 제외하고는 wait() 와 signal() 로만 접근할 수 있다.    세마포 사용법 (Semaphore Usage)  운영체제는 카운팅(counting)과 이진(binary) 세마포를 구분한다.     카운팅 세마포 : 제한 없는 영역(domain)을 갖는다.            유한한 개수를 가진 자원에 대한 접근을 제어하는 데 사용될 수 있다.           이진 세마포 : 0과 1 사이의 값만 가능하다. (mutex lock과 유사하게 동작)             먼저 세마포는 가용한 자원의 개수로 초기화           각 자원을 사용하려는 프로세스는 세마포에 wait() 연산을 수행하고, 세마포의 값은 감소한다.           자원을 방출할 때는 signal() 연산을 수행하고, 세마포는 증가하게 된다.      만약 세마포의 값이 0이면 모든 자원이 사용 중임을 나타내는 것이다.   특징     세마포어 정수 : 정수가 N이라면 최대 N개의 프로세스/쓰레드만이 공유 자원에 접근 가능   여러개의 프로세스/쓰레드가 접근 가능   Wait(P), Signal(V)   Non-Busy-Wait 방식     세마포 구현 (Semaphore Implementation)     이전 상황) mutex 락 구현은 바쁜 대기(Busy Waiting)를 해야 했다.   이를 극복하기 위해, wailt() 와 signal() 세마포 연산의 정의를 다음과 같이 변경할 수 있다.    코드 typedef struct{ \tint value;     struct process *list; }   void wait(semaphore *S){ \tS-&gt;value--;     if(S-&gt;value &lt; 0){     \tadd this process to S-&gt;list;         sleep();     } }   void signal(semaphore *S){ \tS-&gt;value++;     if(S-&gt;value &lt;= 0){     \tremove a process P from S-&gt;list;         wakeup(P);     } }   wait()  프로세스는 바쁜 대기(busy waiting) 대신 자신을 일시 중지시킬 수 있다.  세마포의 value가 0보다 작은 경우, 모든 자원이 사용 중이고 절댓값만큼 프로세스가 대기중이기 때문에 프로세스를 세마포에 연관된 프로세스 list에 추가하고 sleep() 으로 자신을 호출한 프로세스를 일시 중지 시킨다.    signal()  세마포 값을 1 증가시키고, 대기중인 프로세스가 있는지 확인한다.  만약 세마포의 value가 0 이하인 경우, 세마포 값이 음수였던 상태기 때문에 대기중인 프로세스가 있음을 알 수 있다. 따라서 일시중지한 P라는 프로세스를 리스트로부터 꺼내고 wakeup() 으로 일시중지된 프로세스 P의 실행을 재개시킨다.  Q. 음수 Semaphore 값?  원래 바쁜 대기를 하는 세마포의 경우 세마포의 값이 음수가 될 수 없지만, 위 코드 구현상으로는 세마포를 대기하는 프로세스의 수가 많은 경우 가능하다.  이 경우 자연스럽게 음수 값은 세마포를 대기하고 있는 프로세스들의 수를 나타낸다.      Java에서의 쓰레드 안정성 자바에서는 멀티쓰레딩 환경에서 synchronized 또는 ReentrantLock 를 사용한다.  synchronized 는 monitor 잠금방식을 이용한다.  Monitor(모니터)란?    Monitor는 동기화를 위한 고수준 추상화 개념   구성 요소     상호 배제(Mutual Exclusion): 한 번에 하나의 스레드만 모니터 내부에 진입 가능   조건 변수(Condition Variables): 특정 조건을 기다리는 스레드들을 관리   진입 큐(Entry Queue): 모니터 진입을 대기하는 스레드들의 대기열   동작 원리 스레드1 → [진입 큐] → [모니터 내부] → 작업 완료 → 다음 스레드에게 양보 스레드2 → [진입 큐] → 대기... 스레드3 → [진입 큐] → 대기...    1. synchronized    특정 메서드나 코드 블록에 대한 동시 접근을 제한한다. 여러 쓰레드 사이의 동기화 지원. synchronized 는 메서드 시그니처에 명시하거나 코드 블록으로 사용할 수 있다.      synchronized 키워드가 들어간 메서드를 사용할 때 획득된 객체 잠금은 사용하는 클래스 객체   synchronized 코드 블록인 경우 획득한 잠금 개체는 동기화 코드 블록안의 개체   ❗ notify(), wait(), notifyAll() 메서드는 synchronized 내에서 호출해야함  // 메서드 수준 동기화 -&gt; 여러 쓰레드가 메서드 호출 불가 public synchronized void method() {      }  // 블록 수준 동기화 -&gt; 코드 블록 내부만 동기화 public void method(){          synchronized (object) {         //do something     } }   JVM 내부 구현(OpenJDK 소스코드)  1. 고유락(Intrinsic Lock) 획득 과정 bool ObjectSynchronizer::enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread) {     // 객체의 mark word 읽기     markWord mark = obj-&gt;mark();          if (mark.is_unlocked()) {         // CAS로 락 획득 시도         lock-&gt;set_displaced_header(mark);         if (mark == obj()-&gt;cas_set_mark(markWord::from_pointer(lock), mark)) {             return true;  // 빠른 경로 성공         }     }     return false;  // 느린 경로로 이동 }     2. Monitor 객체 생성 (Inflation)  ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* locking_thread, oop object, const InflateCause cause) {     // Stack-lock을 ObjectMonitor로 확장     ObjectMonitor* m = new ObjectMonitor(object);          // 객체 헤더에 Monitor 정보 저장     object-&gt;release_set_mark(markWord::encode(m));          // Monitor를 전역 리스트에 추가     _in_use_list.add(m);     return m; }    3. Monitor 리스트 관리 void MonitorList::add(ObjectMonitor* m) {     ObjectMonitor* head;     do {         head = Atomic::load(&amp;_head);         m-&gt;set_next_om(head);     } while (Atomic::cmpxchg(&amp;_head, head, m) != head);  // CAS로 안전하게 추가      size_t count = Atomic::add(&amp;_count, 1u, memory_order_relaxed); }     2. ReentrantLock    CAS로 동시에 하나의 쓰레드만 잠금을 획득할 수 있도록 상태값을 관리해서 쓰레드 안전을 보장 경쟁에 실패한 다른 쓰레드는 작업이 일시 중단되고, 노드 안에 캡슐화되어 FIFO 대기열에 저장된다.   synchronized와 달리 reentrantLock은 Java로 구현되어있다.  JDK 표준 라이브러리 내부 구현 // 1. 기본 패턴 class X {    private final ReentrantLock lock = new ReentrantLock();    // ...     public void m() {      lock.lock();  // block until condition holds      try {        // ... method body      } finally {        lock.unlock();      }    } }   // 2. tryLock 조합 패턴 - 즉시 시도 후 시간 제한 시도를 조합 if (lock.tryLock() ||     lock.tryLock(timeout, unit)) {   // ... }   // 3. 재진입 검증 패턴 - 특정 코드가 락 없이 진입되어야 할 때 검증(디버깅/테스트 용) class X {   final ReentrantLock lock = new ReentrantLock();   // ...   public void m() {     assert lock.getHoldCount() == 0;     lock.lock();     try {       // ... method body     } finally {       lock.unlock();     }   } }     synchronized vs ReentrantLock 비교 | 특징       | synchronized                | ReentrantLock                      | |————|——————————-|————————————–| | 구현       | JVM 내장 (C++, 네이티브)       | Java 라이브러리 (AQS 기반)           | | 사용성     | 간편 (키워드만 추가)           | 복잡 (명시적 lock/unlock 필요)       | | 기능       | 기본적인 락/언락만              | 고급 기능 (timeout, 인터럽트, 공정성 등) | | 성능       | JDK 1.6 이후 최적화로 우수     | 경합이 심한 상황에서 우수             | | 예외 처리  | 자동 해제                      | 수동 해제 필요                        |     JDK 21 Virtual Thread와의 호환성     Virtual Thread의 Pinning 문제    Virtual Thread의 동작 방식 // 예시: 3개의 Virtual Thread, 1개의 Carrier Thread VThread1: 작업1 → 대기(park) → 다른 작업 VThread2: 작업2 → 대기(park) → 다른 작업   VThread3: 작업3 → 대기(park) → 다른 작업  Carrier Thread: VThread1 실행 → VThread2 실행 → VThread3 실행 (번갈아가며)   park/unpark    park() - 대기 상태로 전환     // I/O 작업이나 sleep 등에서 자동 발생 Thread.sleep(1000);  // Virtual Thread가 park됨 socket.read();       // Virtual Thread가 park됨           unpark() - 실행 상태로 복귀     // 대기 조건이 해소되면 자동 발생 // 다른 Carrier Thread에서 실행될 수 있음             synchronized에서 Pinning이 발생 이유  // monitor_enter(object) {     // OS 수준의 mutex 사용     // JVM이 직접 스레드 제어     pthread_mutex_lock(&amp;mutex); }   문제 상황: public synchronized void method() {     count++; // 간단한 작업 예시 }  // 두 개의 Virtual Thread가 동시 호출 시: // Thread1: 락 획득하고 실행 // Thread2: 락 대기 → Pinning 발생    synchronized 사용 시:    Thread2가 락 대기 상태 진입   JVM의 네이티브 코드(C++)가 스레드 제어   OS 수준 함수 직접 호출 (pthread_mutex_lock)   Virtual Thread 스케줄러가 개입 불가   Thread2가 Carrier Thread에 고착(Pinned)   ReentrantLock 사용 시:     Thread2가 락 대기 상태 진입   Java 코드가 스레드 제어   Virtual Thread 스케줄러가 제어 가능   Thread2가 자유롭게 park/unpark   결론 synchronized 키워드에서 Virtual Thread와 호환이 되지 않는 이유는 synchronized 는 JVM 내부적으로 구현이 되어있어 캐리어 스레드가 잠금 로직 관련 동작을 직접하도록 되어있어 Virtual Thread 활용에 대한 대응을 하지 못하기 때문이다.  반면 ReentrantLock은 Java 로 구현되어있고 락을 유연하게 사용할 수 있는 방식이기 때문에 Virtual Thread에 바로 대응할 수 있다.  지금 단계에서는 Virtual Thread를 사용하기 위해서는 ReentrantLock 를 사용하는 선택이 추천된다.     Practice with Java  import java.util.concurrent 패키지 사용 import java.util.concurrent.Semaphore;              // 세마포어: N개의 자원을 여러 스레드가 공유할 때 사용 import java.util.concurrent.ExecutorService;        // 스레드 풀 관리 인터페이스: 작업을 비동기적으로 실행 import java.util.concurrent.Executors;              // 스레드 풀 팩토리 클래스: 다양한 종류의 스레드 풀 생성 import java.util.concurrent.locks.Lock;             // 락 인터페이스: synchronized보다 유연한 동기화 제공 import java.util.concurrent.locks.ReentrantLock;    // 재진입 가능한 락: 같은 스레드가 중복으로 락 획득 가능 import java.util.concurrent.locks.ReentrantReadWriteLock; // 읽기/쓰기 분리 락: 읽기는 동시에, 쓰기는 독점적으로     주의사항) 멀티스레딩 환경에서는 스레드 실행 순서가 비결정적이므로, 매번 실행할 때마다 순서가 달라질 수 있다. 아래는 가능한 출력 예시 중 하나다.     1️⃣ 세마포어 (Semaphore)    동시에 접근할 수 있는 스레드의 개수를 제한하는 동기화 메커니즘      개념: N개의 허가권(Permit)을 가지고 있는 관리자   동작 원리:            acquire(): 허가권 하나를 가져감 (없으면 대기)       release(): 허가권 하나를 반납           사용 사례: 커넥션 풀, 스레드 풀, 제한된 자원 관리    예제 코드  class ParkingLot {     private final Semaphore semaphore;     private final int totalSpaces;          public ParkingLot(int spaces) {         this.totalSpaces = spaces;         this.semaphore = new Semaphore(spaces); // 3개의 허가권     }          public void parkCar(String carName) {         try {             System.out.println(carName + \" 주차 공간 대기 중... (사용가능: \"                  + semaphore.availablePermits() + \"/\" + totalSpaces + \")\");             semaphore.acquire(); // 허가권 획득                          System.out.println(\"✓ \" + carName + \" 주차 완료! (남은 공간: \"                  + semaphore.availablePermits() + \"/\" + totalSpaces + \")\");             Thread.sleep(2000); // 주차된 시간                      } catch (InterruptedException e) {             Thread.currentThread().interrupt();         } finally {             semaphore.release(); // 허가권 반납             System.out.println(\"→ \" + carName + \" 출차 완료\");         }     } }   // 세마포어 테스트: 주차장 (3개 공간에 5대 차량)     private static void testParkingLot() throws InterruptedException {         ParkingLot parkingLot = new ParkingLot(3); // 주차 공간 3개         ExecutorService executor = Executors.newFixedThreadPool(5);          String[] cars = {\"차량A\", \"차량B\", \"차량C\", \"차량D\", \"차량E\"};          for (String car : cars) {             executor.submit(() -&gt; parkingLot.parkCar(car));         }          executor.shutdown();         Thread.sleep(6000);     }   실행 결과  차량A 주차 공간 대기 중... (사용가능: 3/3) 차량B 주차 공간 대기 중... (사용가능: 3/3) 차량C 주차 공간 대기 중... (사용가능: 3/3) 차량D 주차 공간 대기 중... (사용가능: 2/3) 차량E 주차 공간 대기 중... (사용가능: 1/3) ✓ 차량A 주차 완료! (남은 공간: 2/3) ✓ 차량B 주차 완료! (남은 공간: 1/3) ✓ 차량C 주차 완료! (남은 공간: 0/3) → 차량A 출차 완료 (사용가능: 1/3)  ✓ 차량D 주차 완료! (남은 공간: 0/3) → 차량B 출차 완료 (사용가능: 1/3)  ✓ 차량E 주차 완료! (남은 공간: 0/3) → 차량C 출차 완료 (사용가능: 1/3)  → 차량D 출차 완료 (사용가능: 2/3)  → 차량E 출차 완료 (사용가능: 3/3)     분석: 3대까지는 즉시 주차되고, 4번째부터는 대기하다가 다른 차량이 출차하면 바로 주차된다.     2️⃣ 뮤텍스 (Mutex) - synchronized     상호 배제(Mutual Exclusion)의 줄임말로, 한 번에 하나의 스레드만 임계 영역에 접근하도록 보장하는 동기화 메커니즘      개념: Binary Semaphore (0 또는 1)   동작 원리:            락을 획득한 스레드만 실행       다른 스레드들은 락이 해제될 때까지 대기           Race Condition 방지: 여러 스레드가 동시에 공유 자원에 접근하는 문제 해결     예제 코드  class Counter {     private int count = 0;          public synchronized void increment(String threadName) {         try {             int currentValue = count; // 1단계: 현재 값 읽기             System.out.println(threadName + \" - 읽은 값: \" + currentValue);                          Thread.sleep(100); // 2단계: 연산 시뮬레이션 (다른 스레드 끼어들 가능 구간)                          count = currentValue + 1; // 3단계: 값 증가 후 저장             System.out.println(threadName + \" - 저장한 값: \" + count);                      } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }          public synchronized int getCount() {         return count;     } }   // 뮤텍스 테스트: 카운터 증가     private static void testCounter() throws InterruptedException {         Counter counter = new Counter();         ExecutorService executor = Executors.newFixedThreadPool(3);          for (int i = 1; i &lt;= 5; i++) {             final int threadNum = i;             executor.submit(() -&gt; {                 counter.increment(\"스레드\" + threadNum);             });         }          executor.shutdown();         Thread.sleep(2000);         System.out.println(\"최종 카운터 값: \" + counter.getCount() + \"\\n\");     }   실행 결과  🔢 2. 뮤텍스 - 카운터 (Race Condition 방지) 스레드1 - 읽은 값: 0 스레드1 - 저장한 값: 1 스레드2 - 읽은 값: 1 스레드2 - 저장한 값: 2 스레드3 - 읽은 값: 2 스레드3 - 저장한 값: 3 스레드4 - 읽은 값: 3 스레드4 - 저장한 값: 4 스레드5 - 읽은 값: 4 스레드5 - 저장한 값: 5 최종 카운터 값: 5     분석: synchronized 덕분에 각 스레드가 순차적으로 실행되어 정확한 결과(5)가 나왔다. 동기화가 없었다면 Race Condition으로 예상보다 작은 값이 나올 수 있다.     3️⃣ ReentrantLock     ReentrantLock은 재진입 가능한 락으로, 이미 락을 획득한 스레드가 같은 락을 다시 획득할 수 있는 동기화 메커니즘이다. Lock 인터페이스의 가장 일반적인 구현체      개념: 같은 스레드의 중첩된 락 호출 허용   동작 원리:            lock(): 락 획득 (재진입 시 카운트 증가)       unlock(): 락 해제 (카운트 감소, 0이 되면 완전 해제)           장점: 데드락 방지, 유연한 락 제어    락 인터페이스  package java.util.concurrent.locks;  import java.util.concurrent.TimeUnit;  public interface Lock {  \tvoid lock(); \t// \"락을 얻을 때까지 무한 대기\"  \tvoid lockInterruptibly() throws InterruptedException; \t// \"락 대기 중 인터럽트되면 예외 발생\"  \tboolean tryLock(); \t// \"락이 있으면 true, 없으면 즉시 false 리턴\"  \tboolean tryLock(long time, TimeUnit unit) throws InterruptedException; \t// \"지정 시간만 기다려보고 포기\"  \tvoid unlock(); \t// \"락 반납\"  \tCondition newCondition(); \t// \"wait/notify 같은 조건 대기용\"      }    예제 코드   class BankAccount {     private final ReentrantLock lock = new ReentrantLock();     private double balance = 1000.0;          public void withdraw(String accountHolder, double amount) {         lock.lock(); // 첫 번째 락 획득         try {             System.out.println(accountHolder + \" - 출금 요청: \" + amount + \"원 [Lock 획득]\");             checkBalance(); // 재진입 발생!                          if (balance &gt;= amount) {                 Thread.sleep(1000);                 balance -= amount;                 System.out.println(\"✓ \" + accountHolder + \" - 출금 완료: \" + amount + \"원\");                 System.out.println(\"✓ 남은 잔액: \" + balance + \"원\");             } else {                 System.out.println(\"✗ \" + accountHolder + \" - 잔액 부족\");             }                      } catch (InterruptedException e) {             Thread.currentThread().interrupt();         } finally {             lock.unlock(); // 첫 번째 락 해제             System.out.println(\"→ \" + accountHolder + \" - 거래 완료 [Lock 해제]\\n\");         }     }          private void checkBalance() {         lock.lock(); // 같은 스레드에서 재진입!         try {             System.out.println(\"  💰 잔액 확인: \" + balance + \"원 [재진입 Lock 획득]\");         } finally {             lock.unlock(); // 재진입 락 해제             System.out.println(\"  💰 잔액 확인 완료 [재진입 Lock 해제]\");         }     } }   // Lock 테스트: 은행 계좌 출금     private static void testBankAccount() throws InterruptedException {         BankAccount account = new BankAccount();         ExecutorService executor = Executors.newFixedThreadPool(3);          String[] holders = {\"김철수\", \"이영희\", \"박민수\"};         double[] amounts = {300, 500, 400};          for (int i = 0; i &lt; holders.length; i++) {             final int index = i;             executor.submit(() -&gt; {                 account.withdraw(holders[index], amounts[index]);             });         }          executor.shutdown();         Thread.sleep(4000);     }    실행 결과  🏦 3. ReentrantLock - 은행 계좌 (재진입 가능한 락) 김철수 - 출금 요청: 300.0원 [Lock 획득]   💰 잔액 확인: 1000.0원 [재진입 Lock 획득]   💰 잔액 확인 완료 [재진입 Lock 해제] ✓ 김철수 - 출금 완료: 300.0원 ✓ 남은 잔액: 700.0원 → 김철수 - 거래 완료 [Lock 해제]  이영희 - 출금 요청: 500.0원 [Lock 획득]   💰 잔액 확인: 700.0원 [재진입 Lock 획득]   💰 잔액 확인 완료 [재진입 Lock 해제] ✓ 이영희 - 출금 완료: 500.0원 ✓ 남은 잔액: 200.0원 → 이영희 - 거래 완료 [Lock 해제]  박민수 - 출금 요청: 400.0원 [Lock 획득]   💰 잔액 확인: 200.0원 [재진입 Lock 획득]   💰 잔액 확인 완료 [재진입 Lock 해제] ✗ 박민수 - 잔액 부족 (요청: 400.0원, 잔액: 200.0원) → 박민수 - 거래 완료 [Lock 해제]     분석: 각 스레드가 withdraw() 메서드에서 락을 획득한 후, checkBalance() 메서드에서 같은 락을 재진입으로 다시 획득한다. 재진입이 불가능한 락이었다면 데드락이 발생했을 것이다.     4️⃣ ReadWriteLock     ReadWriteLock은 읽기와 쓰기를 구분하여 성능을 최적화하는 동기화 메커니즘입니다.      개념:            ReadLock: 여러 스레드 동시 획득 가능       WriteLock: 한 번에 하나의 스레드만 획득 가능           동작 원리:            읽기 중에는 다른 읽기 허용, 쓰기 차단       쓰기 중에는 모든 읽기/쓰기 차단           성능 이점: 읽기가 많은 환경에서 동시성 향상     예제 코드  class SharedData {     private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();     private final Lock readLock = lock.readLock();     private final Lock writeLock = lock.writeLock();     private String data = \"초기 데이터\";     private int version = 1;          public void readData(String readerName) {         readLock.lock(); // 읽기 락 (동시 접근 가능)         try {             System.out.println(\"📖 \" + readerName + \" - 데이터 읽기 시작\");             Thread.sleep(500);             System.out.println(\"📖 \" + readerName + \" - 읽은 데이터: \\\"\"                  + data + \"\\\" (버전: \" + version + \")\");         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         } finally {             readLock.unlock();         }     }          public void writeData(String writerName, String newData) {         writeLock.lock(); // 쓰기 락 (독점 접근)         try {             System.out.println(\"✏️ \" + writerName + \" - 데이터 쓰기 시작\");             Thread.sleep(1000);             data = newData;             version++;             System.out.println(\"✏️ \" + writerName + \" - 데이터 업데이트 완료: \\\"\"                  + data + \"\\\" (버전: \" + version + \")\");         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         } finally {             writeLock.unlock();         }     } }   // ReadWriteLock 테스트: 공유 데이터 읽기/쓰기     private static void testSharedData() throws InterruptedException {         SharedData sharedData = new SharedData();         ExecutorService executor = Executors.newFixedThreadPool(5);          // 4개의 읽기 작업 (동시 실행 가능)         for (int i = 1; i &lt;= 4; i++) {             final int readerNum = i;             executor.submit(() -&gt; {                 sharedData.readData(\"Reader\" + readerNum);             });         }          // 1개의 쓰기 작업 (독점적 실행)         executor.submit(() -&gt; {             sharedData.writeData(\"Writer\", \"업데이트된 데이터\");         });          executor.shutdown();         Thread.sleep(3000);     }   실행 결과  💾 4. ReadWriteLock - 공유 데이터 (읽기 4개, 쓰기 1개) 📖 Reader1 - 데이터 읽기 시작 📖 Reader2 - 데이터 읽기 시작 📖 Reader3 - 데이터 읽기 시작 📖 Reader4 - 데이터 읽기 시작 📖 Reader1 - 읽은 데이터: \"초기 데이터\" (버전: 1) 📖 Reader2 - 읽은 데이터: \"초기 데이터\" (버전: 1) 📖 Reader3 - 읽은 데이터: \"초기 데이터\" (버전: 1) 📖 Reader4 - 읽은 데이터: \"초기 데이터\" (버전: 1) ✏️ Writer - 데이터 쓰기 시작 ✏️ Writer - 데이터 업데이트 완료: \"업데이트된 데이터\" (버전: 2)  Process finished with exit code 0    분석: 4개의 Reader가 동시에 데이터를 읽고 있으며, 모든 읽기가 완료된 후에 Writer가 독점적으로 데이터를 수정한다. 일반 synchronized였다면 Reader들도 하나씩 순차적으로 실행되어 성능이 떨어졌을 것이다.     언제 어떤 것을 사용할까?                  동기화 메커니즘       사용 시기       대표 사례                       Semaphore       제한된 개수의 자원을 여러 스레드가 공유할 때       커넥션 풀, 다운로드 제한                 Mutex (synchronized)       한 번에 하나의 스레드만 접근해야 할 때       카운터, 상태 변경                 ReentrantLock       재진입이 필요하거나 세밀한 제어가 필요할 때       복잡한 비즈니스 로직                 ReadWriteLock       읽기는 많고 쓰기는 적을 때       캐시, 설정 데이터, 통계               References    Taming the Virtual Threads: Embracing Concurrency With Pitfall Avoidance   Replacing all synchronized methods with ReentrantLock #92  "
  },
  
  {
    "title": "PGMS_특정 물고기를 잡은 총 수 구하기 (SQL)",
    "url": "/posts/PGMS%ED%8A%B9%EC%A0%95-%EB%AC%BC%EA%B3%A0%EA%B8%B0%EB%A5%BC-%EC%9E%A1%EC%9D%80-%EC%B4%9D-%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-07-02 03:41:01 +0900",
    "content": "[level 2] 특정 물고기를 잡은 총 수 구하기 - 298518 Add commentMore actions  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SELECT  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 07월 02일 03:41:06  문제 설명  낚시앱에서 사용하는 FISH_INFO 테이블은 잡은 물고기들의 정보를 담고 있습니다. FISH_INFO 테이블의 구조는 다음과 같으며 ID, FISH_TYPE, LENGTH, TIME은 각각 잡은 물고기의 ID, 물고기의 종류(숫자), 잡은 물고기의 길이(cm), 물고기를 잡은 날짜를 나타냅니다.            Column name Type Nullable            ID INTEGER FALSE   FISH_TYPE INTEGER FALSE   LENGTH FLOAT TRUE   TIME DATE FALSE          단, 잡은 물고기의 길이가 10cm 이하일 경우에는 LENGTH 가 NULL 이며, LENGTH 에 NULL 만 있는 경우는 없습니다.  FISH_NAME_INFO 테이블은 물고기의 이름에 대한 정보를 담고 있습니다. FISH_NAME_INFO 테이블의 구조는 다음과 같으며, FISH_TYPE, FISH_NAME 은 각각 물고기의 종류(숫자), 물고기의 이름(문자) 입니다.           Column name Type Nullable            FISH_TYPE INTEGER FALSE   FISH_NAME VARCHAR FALSE            문제  FISH_INFO 테이블에서 잡은 BASS와 SNAPPER의 수를 출력하는 SQL 문을 작성해주세요.   컬럼명은 'FISH_COUNT`로 해주세요.    예시  예를 들어 FISH_INFO 테이블이 다음과 같고           ID FISH_TYPE LENGTH TIME            0 0 30 2021/12/04   1 0 50 2020/03/07   2 0 40 2020/03/07   3 1 20 2022/03/09   4 1 NULL 2022/04/08   5 2 13 2021/04/28   6 0 60 2021/07/27   7 0 55 2021/01/18   8 2 73 2020/01/28   9 2 73 2021/04/08   10 2 22 2020/06/28   11 2 17 2022/12/23          FISH_NAME_INFO  테이블이 다음과 같다면           FISH_TYPE FISH_NAME            0 BASS   1 SNAPPER   2 ANCHOVY          'BASS' 는 물고기 종류 0에 해당하고, 'SNAPPER' 는 물고기 종류 1에 해당하므로 잡은 'BASS' 와 'SNAPPER' 수는 7마리입니다.           FISH_COUNT            7  Add commentMore actions            출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   서브쿼리로 해당 FISH_TYPE을 찾고 IN으로 조건검색하였다      코드   SELECT COUNT(*) AS FISH_COUNT     FROM FISH_INFO         WHERE FISH_TYPE IN(             SELECT FISH_TYPE                 FROM FISH_NAME_INFO                     WHERE FISH_NAME LIKE 'SNAPPER' OR FISH_NAME LIKE 'BASS')               "
  },
  
  {
    "title": "Operating System Concepts - 실시간 CPU 스케줄링",
    "url": "/posts/Operating-System-Concepts-%EC%8B%A4%EC%8B%9C%EA%B0%84-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/",
    "categories": "운영체제",
    "tags": "OS",
    "date": "2025-07-01 20:08:19 +0900",
    "content": "   Operating System 공룡책 5.6절의 실시간 CPU 스케줄링에 대해 정리해보았다       실시간 CPU 스케줄링    실시간 CPU 스케줄링은 연성(soft) 실시간 시스템과 경성(hard) 실시간으로 구분           연성 실시간 시스템 중요한 실시간 프로세스가 스케줄 되는 시점에 관해 아무런 보장을 하지 않는다. 오직 중요 프로세스가 그렇지 않은 프로세스들에 비해 우선권을 가진다는 것만 보장           경성 실시간 시스템 태스크는 반드시 마감시간까지 서비스를 받아야 한다. → 더 엄격한 요구 조건을 만족해야 함 마감시간이 지난 이후에 서비스를 받는 것은 서비스를 받지 않는 것과 같다.        1. 지연시간 최소화 (Minimizing Latency) 실시간 시스템의 이벤트-중심 특성     시스템은 일반적으로 실시간으로 발생하는 이벤트를 기다린다.   이벤트가 발생하면 시스템은 가능한 한 빨리 그에 응답하고 그에 맞는 동작을 수행해야 한다.            이벤트의 소프트웨어적 발생 → ex) 타이머 만료 등       이벤트의 하드웨어적 발생 → ex) 원격으로 제어되던 장치가 방해물을 만났을 때             이벤트 지연 시간    이벤트가 발생해서 그에 맞는 서비스가 수행될 때까지의 시간    이벤트가 다르면 그에 따른 지연시간 역시 다르다.  2가지 유형의 지연시간     인터럽트 지연시간   디스패치 지연시간     1. 인터럽트 지연시간    CPU에 인터럽트가 발생한 시점부터 해당 인터럽트 처리 루틴이 시작하기까지의 시간     인터럽트 발생 시 과정     수행 중인 명령어를 완수   발생한 인터럽트의 종류를 결정   결정한 인터럽트 서비스 루틴(ISR)을 사용하여 인터럽트를 처리하기 전에 현재 수행 중인 프로세스의 상태를 저장   → 이러한 작업을 모두 수행하는 데 걸리는 시간이 인터럽트 지연 시간    실시간 태스크의 즉시 수행을 위해 인터럽트 지연시간을 최소화하는 것은 실시간 운영체제의 핵심  경성(hard) 실시간 시스템 (엄격한 요구조건) 에서는 인터럽트 지연시간을 최소화 + 정해진 시간보다 작아야 함    인터럽트 지연시간에 영향을 주는 요인     커널 데이터 구조체를 갱신하는 동안 인터럽트가 불능케 되는 시간 → 실시간 운영체제는 인터럽트 불능 시간을 매우 짧게 해야 함     2. 디스패치 지연시간    스케줄링 디스패처가 하나의 프로세스를 블록 시키고 다른 프로세스를 시작하는 데까지 걸리는 시간     CPU를 즉시 사용해야 하는 실시간 태스크가 있다면, 이 지연시간을 최소화해야 함  디스패치 지연시간을 최소화하는 가장 효과적인 방법 → 선점형 커널    디스패치 지연시간의 충돌 단계     커널에서 동작하는 프로세스에 대한 선점   높은 우선순위의 프로세스가 필요한 자원을 낮은 우선순위 프로세스 자원이 방출   충돌 단계에 이어 디스패치 단계는 우선순위가 높은 프로세스를 사용 가능한 CPU에 스케줄 한다.     2. 우선순위 기반 스케줄링 (Priority-Based Scheduling)    실시간 운영체제에서 가장 중요한 기능        실시간 프로세스에 CPU가 필요할 때 바로 응답해 주는 것     따라서 실시간 운영체제의 스케줄러는 선점을 이용한 우선순위 기반의 알고리즘을 지원해야 한다.      선점 및 우선순위 기반의 스케줄링 알고리즘          각각의 프로세스의 중요성에 따라 우선순위를 부여           더 중요한 태스크가 그렇지 않은 태스크들보다 더 높은 우선순위를 갖게 됨           스케줄러가 선점 기법을 제공하는 경우, 현재 CPU를 이용하고 있는 프로세스가 더 높은 우선순위를 갖는 프로세스에 선점될 수 있다.        연성 실시간 스케줄링 사례     Linux, Windows, Solaris 운영체제   실시간 프로세스에게 가장 높은 스케줄링 우선권을 부여   Windows에는 32개의 우선순위가 존재함            가장 높은 순위인 16 ~ 31 의 값이 실시간 프로세스들에 할당             경성 실시간 시스템에 적합한 스케줄링 알고리즘     선점 및 우선순위 기반의 스케줄러를 통해 제공할 수 있는 것은 연성 실시간 기능뿐   경성 실시간 시스템에서의 마감시감 내에 확실히 수행되는 것을 보장하지 못한다. → 경성 실시간 시스템에 맞는 부가적인 스케줄링 기법이 필요하다.     개별 스케줄러에 스케줄 될 프로세스의 특성    프로세스들은 주기적이다. 즉, 프로세스들은 일정한 간격으로 CPU가 필요하다.   각각의 주기 프로세스들은 CPU 사용권을 얻을 때마다 t, d, p가 정해져 있다. t : 고정된 수행시간 d : CPU로부터 반드시 받아야 하는 마감시간 p : 주기 (주기 태스크의 실행 빈도는 1/p) 0 ≤ t ≤ d ≤ p   스케줄러는 이들의 주기, 마감시간, 수행 시간 사이의 관계를 이용하여 마감시간을 정한다.  스케줄러는 주기적 프로세스의 실행 빈도에 따라서 우선순위를 정함    승인 제어(admission-control)  위와 같은 형식의 스케줄링에서 일반적이지 않을 때 프로세스가 자신의 마감시간을 스케줄러에게 알려줘야 할 수도 있음 → 승인 제어 알고리즘  승인 제어를 통해 스케줄러는 마감시간 이내에 완수할 수 있는 프로세스는 실행을 허락하고, 그렇지 못한 경우에는 요구를 거절한다.     3. Rate-Monotonic 스케줄링 (Rate-Monotonic Scheduling)    선점 가능한 정적 우선순위 정책을 이용하여 주기 태스크들을 스케줄 한다.   낮은 우선순위의 프로세스가 실행 중이고 높은 우선순위의 프로세스가 실행 준비하면 높은 우선순위의 프로세스가 낮은 우선순위의 프로세스를 선점    각각의 주기 태스크들은 시스템 진입 시 주기에 따라 우선순위가 정해짐 주기가 짧을수록 높은 우선순위에 배정  (CPU를 더 자주 필요로 하는 태스크에 더 높은 우선순위를 주려는 원리)    rate-monotonic 스케줄링은 주기 프로세스들의 처리 시간은 각각의 CPU 버스트와 같다고 가정 즉, 프로세스가 CPU를 차지한 시간 = 각각의 CPU 버스트 시간    ex) 우선순위 P2 &gt; P1  2개의 프로세스 P1, P2    P1의 주기 = 50, 수행 시간 = 20   P2의 주기 = 100, 수행 시간 = 35   Q) 두 프로세스가 마감시간을 충족시키도록 스케줄링이 가능한가?  → CPU 이용률, 즉 주기에 대한 수행 시간을 계산     P1의 CPU 이용률 = 2/5 = 0.4   P2의 CPU 이용률 = 35/100 = 0.35   총 CPU 이용률 75% → 마감시간을 모두 충족시킬것이라 예상    Case 1) Rate-Monotonic 스케줄링을 사용하지 않은 경우   (P2 &gt; P1라 가정)  P1의 마감시간이 50인데 P1은 55에 끝나기 때문에 스케줄러 P1의 마감시간을 충족시키지 못한다.    Case 2) Rate-Monotonic 스케줄링을 사용한 경우   P1의 주기가 P2의 주기보다 짧음 → P1 &gt; P2  수행 과정     P1이 먼저 수행이 시작하여 시간 20에 수행이 종료 → P1의 마감시간 만족   바로 P2가 수행을 시작해서 시간 50까지 수행을 끝낸다. (P1에게 선점됨) 이때 아직 5ms의 CPU 할당 시간이 남아있는 상태   P1은 시간 70까지 수행을 하고, 스케줄러는 다시 P2를 수행시킴   P2는 남은 5ms의 시간의 수행을 75에 끝낸다. → P2의 마감시간 만족   시스템은 시간 100까지 유휴시간을 갖다가 P1이 다시 스케줄 된다.     Rate-monotonic 스케줄링 기법이 스케줄 할 수 없는 프로세스 집합 해당 스케줄링 기법이 스케줄링할 수 없다면 정적 우선순위를 이용하는 다른 알고리즘 역시 스케줄링할 수 없다.     N개의 프로세스를 스케줄 하는 데 있어 허용하는 CPU 이용률    예시 2개의 프로세스 p1, p2    p1의 주기 = 50, 수행시간 = 25   p2의 주기 = 80, 수행시간 = 35 전체 CPU 이용률 → 25/50 + 35/80 = 0.94 = 94%   2개의 프로세스를 스케줄 하는데 허용하는 CPU 이용률 = 2 * (1.414 - 1) = 0.828 = 약 83% → 스케줄 불가능    4. Earliest-Deadline-First 스케줄링 (EDF)    마감시간에 따라서 우선순위를 동적으로 부여 마감시간이 빠를수록 우선순위가 높아진다.   프로세스가 실행 가능하게 되면 자신의 마감시간을 시스템에 알려야 함  우선순위는 새로 실행 가능하게 된 프로세스의 마감시간에 맞춰 다시 조정 → 우선순위가 고정되어 있는 rate-monotonic 스케줄링과는 다름    ex) 2개의 프로세스 p1과 p2    p1의 주기 = 50, 수행시간 = 25   p2의 주기 = 80, 수행시간 = 35     스케줄링 과정          P2는 P1의 CPU 버스트가 끝난 후 수행을 시작 처음에는 프로세스 P1의 마감시간이 더 빠르기 때문에 P1의 우선순위가 P2보다 높다.           시간 50에서 P2의 마감시간은 80, P1의 마감시간은 100이다. → EDF에 의해 우선순위는 P2 &gt; P1, P2를 계속 수행 (rate-monotonic 스케줄링에서는 시간 50에서 P1이 선점했다.)           시간 60에 P2의 CPU 버스트가 끝난다. → P1과 P2 모두 첫 번째 마감시간을 만족           프로세스 P1은 시간 60에 다시 수행을 시작하여 시간 85에 두 번째 CPU 버스트가 종료           P2는 다시 수행을 시작하고 다음 주기인 시간 100에 P1에게 선점된다. P1 &gt; P2 ( P1의 마감시간 = 150, P2의 마감시간 = 165 )           시간 125에서 P1은 CPU 할당량을 완수하고 P2가 수행을 시작하여 시간 145에 끝난다. → 둘 다 마감시간 만족           시간 150까지 유휴시간을 가지고 다시 P1이 스케줄 되어 수행을 시작  …        EDF 스케줄링 알고리즘 특징     프로세스들이 주기적일 필요 없다.   CPU 할당 시간이 상수 값으로 정해질 필요가 없다.   중요한 것은 프로세스가 실행 가능해질 때 자신의 마감시간을 스케줄러에게 알려주는 것   이론적으론 최적의 알고리즘: 모든 프로세스가 마감시간을 만족할 수 있고, CPU 이용률 100% 하지만 프로세스 사이, 인터럽트 핸들링 때의 문맥교환 비용에 의해 100% CPU 이용은 불가능      5. 일정 비율의 몫 스케줄링 (Proportional share)    모든 응용들에게 T개의 시간 몫을 할당하여 동작 한 개의 응용이 N개의 시간 몫을 할당받으면 그 응용은 모든 프로세스 시간 중 N/T를 할당받는 것   승인 제어 정책과 함께 동작    사용 가능한 충분한 몫이 존재할 때 그 범위 내의 몫을 요구하는 클라이언트에게만 실행을 허락해죽, 몫을 초과하면 시스템 진입을 거부     References    real-time-scheduling   Task scheduling with a real time operating system  "
  },
  
  {
    "title": "BOJ_4485_녹색 옷 입은 애가 젤다지? (Java)",
    "url": "/posts/BOJ4485%EB%85%B9%EC%83%89-%EC%98%B7-%EC%9E%85%EC%9D%80-%EC%95%A0%EA%B0%80-%EC%A0%A4%EB%8B%A4%EC%A7%80-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-06-29 16:21:36 +0900",
    "content": "[Gold IV] 녹색 옷 입은 애가 젤다지? - 4485 Add commentMore actions  문제 링크  성능 요약  메모리: 20540 KB, 시간: 192 ms  분류  그래프 이론, 그래프 탐색, 최단 경로, 데이크스트라, 격자 그래프  제출 일자  2025년 6월 29일 16:16:25  문제 설명  젤다의 전설 게임에서 화폐의 단위는 루피(rupee)다. 그런데 간혹 '도둑루피'라 불리는 검정색 루피도 존재하는데, 이걸 획득하면 오히려 소지한 루피가 감소하게 된다!  젤다의 전설 시리즈의 주인공, 링크는 지금 도둑루피만 가득한 N x N 크기의 동굴의 제일 왼쪽 위에 있다. [0][0]번 칸이기도 하다. 왜 이런 곳에 들어왔냐고 묻는다면 밖에서 사람들이 자꾸 \"젤다의 전설에 나오는 녹색 애가 젤다지?\"라고 물어봤기 때문이다. 링크가 녹색 옷을 입은 주인공이고 젤다는 그냥 잡혀있는 공주인데, 게임 타이틀에 젤다가 나와있다고 자꾸 사람들이 이렇게 착각하니까 정신병에 걸릴 위기에 놓인 것이다.  하여튼 젤다...아니 링크는 이 동굴의 반대편 출구, 제일 오른쪽 아래 칸인 [N-1][N-1]까지 이동해야 한다. 동굴의 각 칸마다 도둑루피가 있는데, 이 칸을 지나면 해당 도둑루피의 크기만큼 소지금을 잃게 된다. 링크는 잃는 금액을 최소로 하여 동굴 건너편까지 이동해야 하며, 한 번에 상하좌우 인접한 곳으로 1칸씩 이동할 수 있다.  링크가 잃을 수밖에 없는 최소 금액은 얼마일까?  입력  입력은 여러 개의 테스트 케이스로 이루어져 있다.  각 테스트 케이스의 첫째 줄에는 동굴의 크기를 나타내는 정수 N이 주어진다. (2 ≤ N ≤ 125) N = 0인 입력이 주어지면 전체 입력이 종료된다.  이어서 N개의 줄에 걸쳐 동굴의 각 칸에 있는 도둑루피의 크기가 공백으로 구분되어 차례대로 주어진다. 도둑루피의 크기가 k면 이 칸을 지나면 k루피를 잃는다는 뜻이다. 여기서 주어지는 모든 정수는 0 이상 9 이하인 한 자리 수다.  출력  각 테스트 케이스마다 한 줄에 걸쳐 정답을 형식에 맞춰서 출력한다. 형식은 예제 출력을 참고하시오.  문제 풀이  간단한 다익스트라 문제다.  코드  /**Add commentMore actions  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {      class Cell implements Comparable&lt;Cell&gt; {         int r, c, cost;          public Cell(int r, int c, int cost) {             this.r = r;             this.c = c;             this.cost = cost;         }          @Override         public int compareTo(Cell o) {             return this.cost - o.cost;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int tc, N;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static int[][] board, minDist;     static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_4485_녹색옷입은애가젤다지/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         while (true) {             tc++;             N = Integer.parseInt(br.readLine());             if (N == 0) break;             else {                 int res = tour();                 makeAns(res);             }         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private int tour() throws IOException {         board = new int[N][N];         minDist = new int[N][N];         for (int i = 0; i &lt; N; i++) {             Arrays.fill(minDist[i], Integer.MAX_VALUE);         }          for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; N; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());             }         }          int cnt = 0;         PriorityQueue&lt;Cell&gt; pq = new PriorityQueue&lt;&gt;();         pq.offer(new Cell(0, 0, board[0][0]));         minDist[0][0] = board[0][0];          while (!pq.isEmpty()) {             Cell curr = pq.poll();             if (curr.cost &gt; minDist[curr.r][curr.c]) continue;              for (int k = 0; k &lt; 4; k++) {                 int nr = curr.r + dr[k];                 int nc = curr.c + dc[k];                 if (isValid(nr, nc) &amp;&amp; curr.cost + board[nr][nc] &lt; minDist[nr][nc]) {                     minDist[nr][nc] = curr.cost + board[nr][nc];                     pq.offer(new Cell(nr, nc, minDist[nr][nc]));                 }             }         }          return minDist[N - 1][N - 1];     }      private boolean isValid(int r, int c) {         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; N;     }      private void makeAns(int res) {         sb.append(\"Problem \").append(tc).append(\": \").append(res).append(\"\\n\");     } }Add comment  "
  },
  
  {
    "title": "Operating System Concepts - 운영체제부터 프로그램이 실행되기까지",
    "url": "/posts/Operating-System-Concepts-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%B6%80%ED%84%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%B4-%EC%8B%A4%ED%96%89%EB%90%98%EA%B8%B0%EA%B9%8C%EC%A7%80/",
    "categories": "운영체제",
    "tags": "OS",
    "date": "2025-06-24 20:19:43 +0900",
    "content": "     컴퓨터에서 프로그램이 실행되기까지 과정을 정리해보고자 한다. 개발자 입장에서 직접 작성한 고급언어 코드 프로그램이 어떻게 작동하게 되는지 알아보자. 운영체제별 차이점까지 깊게 다루진 않았다. 특히 Java 개발자 측면에서 찾아보며 정리해보았다.   프로그램 실행 과정 전체 개요  C/C++ 실행 과정  소스 코드(.c, .cpp) -&gt; 컴파일 -&gt; 링킹 -&gt; 실행 파일 -&gt; 로딩 -&gt; 프로세스 생성 -&gt; 실행 -&gt; 종료   Java 실행 과정 소스코드(.java) → javac → 바이트코드(.class) → JVM 로딩 → JVM 프로세스 → 바이트코드 실행     1. 소스 코드 작성 및 컴파일  개발자는 C, C++, Java, Python 등 고급 프로그래밍 언어로 사람이 이해할 수 있는 형태의 소스 코드를 작성한다.  이 소스코드는 컴파일러 에 의해 기계어 or 중간 언어로 번역된다. 컴파일 과정에서 코드 최적화, 오류 검사 등이 수행된다. 컴파일 오류가 발생하지 않으면 실행 가능한 프로그램 (실행 파일) 이 생성된다.  Java의 경우 바이트코드와 같은 중간 형태로 컴파일되어, 가상 머신에서 실행될 수 있다.    2. 링킹 컴파일된 코드는 필요한 라이브러리나 다른 모듈과 함께 링킹된다.     정적 링킹 : 컴파일 시간에 외부 코드나 라이브러리를 실행 파일에 포함시킴   동적 링킹 : 프로그램이 실행될 때 필요한 코드를 불러오는 방식   최종적으로, 링킹 과정을 거쳐 완전한 실행 파일이 완성된다.  3. 실행 파일 로딩 사용자가 프로그램을 실행시키면, 운영 시스템은 실행 파일을 메모리로 로드한다.  이 과정에서 운영 시스템은 파일 시스템에서 실행 파일을 찾아 메모리에 적재한다.  4. 프로세스 생성 메모리에 로드 된 실행 파일은 프로세스(실행중인 프로그램의 인스턴스)로 생성된다. 프로세스는 고유 메모리 공간(code, data, stack 등) 과 운영 시스템 자원(파일 핸들, 스레드 등) 을 할당받는다.  운영 시스템은 프로세스를 관리하고, CPU 스케줄링을 통해 프로세스가 실행될 수 있도록 한다.  5. 실행 프로세스가 CPU 시간을 할당받으면, 프로세스의 코드가 실행된다. 이때 명령어 실행 사이클 (Fetch, Decode, Execute 등) 이 반복되며, 프로그램의 로직에 따라 처리가 수행된다.  프로그램 실행중에는 메모리 접근, 입출력 작업, 네트워크 통신 등 다양한 시스템 호출이 이루어질 수 있다.  6. 종료 프로그램이 완료되면 운영 시스템은 프로세스를 종료시키고 사용했던 자원을 회수한다. 프로세스 종료는 정상 종료, 사용자에 의한 강제 종료, 오류로 인한 비정상 종료 등 여러 방식이 있다.      Java 예시를 통한 자세한 과정  int res = a + b; 라는 java 코드가 어떻게 실행되는지 살펴보자.  컴파일 단계 (javac) 1. 소스코드 -&gt; 바이트 코드      public class APlusB {     public static void main(String[] args) {         int a = 5;         int b = 3;         int res = a + b;         System.out.println(res);     } }   javac 컴파일러가 .java 파일을 .class 파일(바이트코드)로 변환한다.  이 바이트코드는 특정 OS에 종속되지 않는 중간 코드로, JVM만 있으면 어디서든 실행 가능하다.  javac APlusB.java  # APlusB.class 생성    2. JVM 프로세스 시작  java APlusB    java 명령어를 실행하면 JVM이라는 프로세스가 OS에서 시작된다. JVM 자체는 C/C++로 만들어진 네이티브 프로그램이므로 일반적인 프로세스 생성 과정을 거친다.    3. 클래스 로딩 - JVM 내부의 과정 JVM 내부에서 클래스 로더가 3단계 작업          로딩(Loading)             첫번째로 로딩 단계는 .class 파일을 읽어와 JVM 내부에서 사용할 수 있는 자료구조인 메모리에 적재한다.       읽어온 .class 파일은 바이트코드(Bytecode) 형태로 변환된다.                링크(Linking)             링크 단계는 클래스가 메모리에 로딩된 후에 실행되는 단계다. 클래스 파일의 정보를 분석하여 해당 클래스가 참조하고 있는 다른 클래스, 메서드, 변수 등의 레퍼런스(참조)를 연결하는 과정이다.       링크단계는 검증(Verification), 준비(Preparation), 해석(Resolution) 세 가지 단계로 나뉜다.                    검증 : 로딩된 클래스 파일이 올바른 자바 클래스 파일인지 검증하는 과정           준비 : 클래스가 필요로 하는 메모리 공간을 할당           해석 : 클래스의 상수 풀(constant pool)에서 필요한 심볼릭 참조(symbolic reference)를 실제 메모리상의 레퍼런스로 교체하는 과정                                - 상수 풀:                클래스 파일 내부에 있는 상수들을 모아 놓은 것          클래스 파일 내부에서 사용되는 모든 상수들이 저장되어 있다.            - 심볼릭 참조:                클래스나 인터페이스의 이름, 필드의 이름, 메서드의 이름 등을 나타내는 것입니다.          일종의 자바 코드 상의 식별자 (예시 APlusB 같은것)                 초기화                      초기화 단계는 클래스의 정적변수(static variable)와 클래스의 정적블록(static block)이 초기화 되는 단계다.              정적변수는 클래스가 로딩되는 과정에서 메모리에 할당된다. 이 변수들은 초기화 전에 기본값으로 초기화 된다.                    정수형 변수는 0, boolean 타입의 변수는 false                       정적블록은 클래스가 로딩될 때 실행되는 코드 블록이다. 이 블록에서는 클래스의 정적 변수를 초기화하거나, 클래스의 정적 메소드를 호출하거나, 예외 처리 등의 작업을 수행할 수 있다.             4. 바이트코드 실행 - 인터프리터 + JIT JVM 실행엔진이 바이트코드를 실행하는 두 가지 방식:     인터프리터 방식: 바이트코드를 한 줄씩 해석해서 실행       int res = a + b;  →  iload_1, iload_2, iadd, istore_3           JIT 컴파일러: 자주 실행되는 코드를 기계어로 컴파일해서 캐시에 저장       // 반복문 같은 자주 실행되는 코드   for(int i = 0; i &lt; 1000000; i++) {    res = a + b;  // JIT 컴파일 대상   }                5. 메모리 구조 - JVM 내부 영역들 JVM 프로세스 내부의 여러 메모리 영역:  JVM 프로세스 ├── Method Area: 클래스 정보, static 변수 ├── Heap: new로 생성한 객체들 ├── Stack: 지역변수, 메서드 호출 정보 └── PC Register: 현재 실행 중인 명령어 위치  @RestController public class UserController {  // Method Area에 클래스 정보          @GetMapping(\"/users/{id}\")     public User getUser(@PathVariable Long id) {  // Stack에 id 변수         User user = new User(id);  // Heap에 User 객체 생성         return user;     } }     6. GC와 메모리 관리  Java의 가장 큰 특징은 자동 메모리 관리  C/C++ char* buffer = malloc(1024);  // 수동 할당(size_t size; 입력 인자로 필요한 형식의 메모리 크기)  ...   free(buffer);  // 수동 해제 (없으면 메모리 누수)   Java List&lt;String&gt; list = new ArrayList&lt;&gt;();  // 자동 할당  ...  // 자동으로 GC가 메모리 해제 (개발자가 신경 쓸 필요 없음)     References    The Java® Virtual Machine Specification   "
  },
  
  {
    "title": "Operating System Concepts - 운영체제의 작동",
    "url": "/posts/Operating-System-Concepts-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%9E%91%EB%8F%99/",
    "categories": "운영체제",
    "tags": "OS",
    "date": "2025-06-10 19:39:52 +0900",
    "content": "Operating System 작동  컴퓨터의 전원을 켜거나 재부팅 할 때와 같이 컴퓨터를 실행하려면 초기 프로그램을 실행해야 한다.  이 초기 프로그램(부트스트랩 프로그램)은 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다.    부트스트랩 프로그램은 운영체제를 적재하는 방법과 해당 시스템 실행을 시작하는 방법을 알아야한다.  부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재한다.    일부 서비스는 커널이 실행되는 전체 시간 동안 실행되는 시스템 데몬 이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다.  시스템 데몬 : 백그라운드에서 계속 실행되면서 특정 서비스를 제공하는 프로그램   Linux에서 첫 번째 시스템 프로그램은 “systemd” 이며 다른 많은 데몬을 시작한다.    시스템이 완전히 부팅되면 어떤 이벤트가 발생할 때까지 기다린다.  이벤트는 거의 인터럽트를 발생시켜 신호를 보내고, 이 인터럽트의 종류로는 하드웨어 인터럽트, 트랩, 오류, 소프트웨어 인터럽트등이 있다.    다중 프로그래밍과 다중 태스킹 (multiprogramming and multitasking)  다중 프로그래밍    CPU가 항상 하나 이상의 프로그램을 실행할 수 있도록하여 CPU 이용률을 높이고 사용자의 만족도를 높이는 프로그래밍. 이런 시스템에서 실행 중인 프로그램을 프로세스 라고 한다.   다중 프로그래밍 시스템을 위한 메모리 배치   운영체제는 이러한 프로세스 중 하나를 선택하여 실행하기 때문에 특정 프로세스가 다른 프로세스의 작업이 완료되기를 기다려야 할 수도 있다.    다중 태스킹     다중 프로그래밍의 논리적 확장이다. 멀티태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공하게 된다.   보통 사람이 사용하는 마우스, 키보드 등을 통한 입출력은 사람의 속도로 수행되므로, 완료까지 상당한 시간이 걸릴 수 있다.  이러한 대화식 입력 이 진행되는 동안 CPU를 쉬게 하지 않고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.    이중-모드와 다중모드 운용 (Dualmode and Multimode Operation)  운영체제와 사용자는 컴퓨터 시스템의 하드웨어 및 소프트웨어 자원을 공유하기 때문에 올바르게 설계된 운영체제는 잘못된 (또는 악의적인) 프로그램으로 인해 다른 프로그램 또는 운영체제 자체가 잘못 실행될 수 없도록 보장해야 한다.  따라서 시스템을 올바르게 실행하려면 운영체제 코드 실행과 사용자 정의 코드 실행을 구분할 수 있어야 한다.  사용자 모드에서 커널 모드로의 전환   운영체제는 두 개의 독립된 연산 모드, 사용자 모드와 커널 모드를 필요로 한다.  모드 비트 라고 하는 하나의 비트가 현재의 모드를 나타내기 위해 컴퓨터의 하드웨어에 추가되었다. 이 비트는 커널 모드(0) 또는 사용자 모드(1)를 나타낸다.            시스템 부트 시 하드웨어는 커널 모드에서 시작한다.           이후 운영체제가 적재되고 사용자 모드에서 사용자 프로세스가 시작된다.           트랩이나 인터럽트가 발생할 때마다, 하드웨어는 사용자 모드에서 커널 모드로 전환한다.(모드 비트를 0으로 변경)      그러므로 운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 된다.        타이머 (Timer)  사용자 프로그램이 무한루프에 빠지거나 시스템 서비스 호출에 실패하여 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야 한다.  이를 위해 타이머 로 지정된 시간 후 컴퓨터를 인터럽트 하도록 설정할 수 있다.     타이머 시간은 고정 혹은 가변 일 수 있으며, 가변 타이머는 일반적으로 고정률의 클록(fixed-rate clock)과 계수기로 구현된다.   사용자에게 제어를 양도하기 전에 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되었는지를 확인한다.  타이머의 값을 변경하는 명령은 명백히 특권 명령이다.  특권 명령 : 커널 모드에서만 실행 가능한 특별한 명령어. 사용자 모드에서 실행하려고 하면 OS로 트랩을 건다.  "
  },
  
  {
    "title": "BOJ_7412_환상의 듀엣 (Java)",
    "url": "/posts/BOJ7412%ED%99%98%EC%83%81%EC%9D%98-%EB%93%80%EC%97%A3-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-06-03 04:23:15 +0900",
    "content": "[Platinum V] 환상의 듀엣 - 11570 Add commentMore actions  문제 링크  성능 요약  메모리: 52332 KB, 시간: 296 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 6월 3일 04:12:42  문제 설명  상덕이와 희원이는 소문난 환상의 듀엣으로, 노래방에 가서 노래를 자주 부르곤 한다. 어느 날 상덕이는 백준이에게 선물 받은 악보를 가져왔다. 악보에는 그 노래를 표현하는데 필요한 음의 높이가 순서대로 N개 적혀져 있었다. 둘은 악보에 적혀 있는 모든 음들을 노래해야 하며, 각 음은 둘 중 한 사람에 의해서만 불러져야 한다. 예를 들어 악보에 {3, 6, 2, 5, 4}가 적혀져 있을 때, 상덕이가 {3, 2, 4}을 노래하면 희원이는 {6, 5}를 노래할 것이고, 상덕이가 {6, 2, 5}을 노래하면 희원이는 {3, 4}를 노래할 것이다.  노래를 부르다 음의 높이를 변경하는 것은 힘든 일이다. 예를 들어 {4, 6}을 부르는 것은 {4, 4}를 부르는 것에 비해서 음의 변경이 발생하기 때문에 더 힘들다고 볼 수 있다. 희원이는 {a1, a2, ..., ak}라는 음들의 집합을 노래할 때 힘든 정도를 |a1 - a2| + |a2 - a3| + ... + |ak-1 - ak|로 정의했다. 노래를 부르는 사람은 상덕이와 희원이 둘 뿐이므로, 음들을 집합은 두 개가 있을 것이다. 따라서 두 사람이 해당 악보를 노래를 할 때 힘든 정도는 두 집합의 힘든 정도의 합으로 표현될 수 있다.  상덕이와 희원이는 해당 악보를 노래할 때 힘든 정도를 최소화하고 싶다. 예를 들어 악보가 {1, 3, 8, 12, 13}으로 주어진다하자. 앞의 2개를 상덕이가 부르고 뒤의 3개를 희원이가 부르게되면 상덕이의 힘든 정도는 |1 - 3| = 2, 희원이의 힘든 정도는 |8 - 12| + |12 - 13| = 5가 되며 합인 7이 총 힘든 정도가 되고, 이 값은 나올 수 있는 힘든 정도 중에 가장 최솟값이다. 상덕이와 희원이를 위해서 해당 악보를 노래할 때 힘들 수 있는 정도의 최솟값을 알려주는 프로그램을 작성해보자.  입력  첫 번째 줄에는 음의 개수 N (1 ≤ N ≤ 2,000)이 주어진다.  두 번째 줄에는 N개의 음의 높이가 공백(빈 칸)으로 구분되어 주어진다. 각 음의 높이의 범위는 1 이상 1,000,000 이하의 자연수이다.  출력  상덕이과 희원이가 해당 악보를 노래할 때 힘들 수 있는 정도의 최솟값을 출력한다.     문제 풀이   dp 설계가 중요.  dp[i][j] = 상덕이가 마지막으로 i까지 부르고 희원이가 마지막으로 j까지 불렀을 때 최솟값      코드   import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int[] music;     static long[][] dp;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         int N = Integer.parseInt(st.nextToken());          music = new int[N+1];         dp = new long[N+1][N+1];          st = new StringTokenizer(br.readLine());         for(int i=1; i&lt;=N; i++){             music[i] = Integer.parseInt(st.nextToken());         }          for(int i=0; i&lt;=N; i++){             for(int j=0; j&lt;=N; j++){                 dp[i][j] = 2_000_000_000;             }         }          dp[0][0] = 0;         dp[1][0] = 0;         dp[0][1] = 0;         for(int i=2; i&lt;=N; i++){             dp[i][0] = dp[i-1][0] + Math.abs(music[i] - music[i-1]);             dp[0][i] = dp[0][i-1] + Math.abs(music[i] - music[i-1]);         }          for(int i = 0; i &lt;= N; i++){             for(int j = 0; j &lt;= N; j++){                  if(i==j) continue;                  if((Math.max(i, j) + 1) &gt; N) continue;                  if(i==0 || j == 0) {                     music[0] = music[Math.max(i, j) + 1];                     dp[Math.max(i, j) + 1][j] = Math.min(dp[Math.max(i, j) + 1][j], dp[i][j] + Math.abs(music[Math.max(i, j) + 1] - music[i]));                     dp[i][Math.max(i, j) + 1] = Math.min(dp[i][Math.max(i, j) + 1], dp[i][j] + Math.abs(music[Math.max(i, j) + 1] - music[j]));                 }                 else {                     dp[Math.max(i, j) + 1][j] = Math.min(dp[Math.max(i, j) + 1][j], dp[i][j] + Math.abs(music[Math.max(i, j) + 1] - music[i]));                     dp[i][Math.max(i, j) + 1] = Math.min(dp[i][Math.max(i, j) + 1], dp[i][j] + Math.abs(music[Math.max(i, j) + 1] - music[j]));                 }             }         }          long res = 2_000_000_000;         for(int i = 0; i &lt; N; i++){             res = Math.min(res, dp[i][N]);  // 한명 N번째 곡까지             res = Math.min(res, dp[N][i]);  // 다른 한명 N번째 곡까지         }          System.out.println(res);  //        for(int i=0; i&lt;=N; i++){ //            System.out.println(Arrays.toString(dp[i])); //        }         br.close();     } }  "
  },
  
  {
    "title": "PGMS_특정 조건을 만족하는 물고기별 수와 최대 길이 구하기 (SQL)",
    "url": "/posts/PGMS%ED%8A%B9%EC%A0%95-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%A7%8C%EC%A1%B1%ED%95%98%EB%8A%94-%EB%AC%BC%EA%B3%A0%EA%B8%B0%EB%B3%84-%EC%88%98%EC%99%80-%EC%B5%9C%EB%8C%80-%EA%B8%B8%EC%9D%B4-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-06-03 03:13:59 +0900",
    "content": "[level 3] 특정 조건을 만족하는 물고기별 수와 최대 길이 구하기 - 298519  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 06월 03일 03:07:34  문제 설명  낚시앱에서 사용하는 FISH_INFO 테이블은 잡은 물고기들의 정보를 담고 있습니다. FISH_INFO 테이블의 구조는 다음과 같으며 ID, FISH_TYPE, LENGTH, TIME은 각각 잡은 물고기의 ID, 물고기의 종류(숫자), 잡은 물고기의 길이(cm), 물고기를 잡은 날짜를 나타냅니다.            Column name Type Nullable            ID INTEGER FALSE   FISH_TYPE INTEGER FALSE   LENGTH FLOAT TRUE   TIME DATE FALSE          단, 잡은 물고기의 길이가 10cm 이하일 경우에는 LENGTH 가 NULL 이며, LENGTH 에 NULL 만 있는 경우는 없습니다.    문제  FISH_INFO에서 평균 길이가 33cm 이상인 물고기들을 종류별로 분류하여 잡은 수, 최대 길이, 물고기의 종류를 출력하는 SQL문을 작성해주세요. 결과는 물고기 종류에 대해 오름차순으로 정렬해주시고, 10cm이하의 물고기들은 10cm로 취급하여 평균 길이를 구해주세요.  컬럼명은 물고기의 종류 'FISH_TYPE', 잡은 수 'FISH_COUNT', 최대 길이 'MAX_LENGTH'로 해주세요.    예시  예를 들어 FISH_INFO 테이블이 다음과 같다면           ID FISH_TYPE LENGTH TIME            0 0 30 2021/12/04   1 0 50 2020/03/07   2 0 40 2020/03/07   3 1 30 2022/03/09   4 1 NULL 2022/04/08   5 2 32 2020/04/28          물고기 종류가 0인 물고기들의 평균 길이는 (30 + 50 + 40) / 3 = 40cm 이고 물고기 종류가 1인 물고기들의 평균 길이는 (30 + 10) / 2 = 20cm 이며, 물고기 종류(가 2인 물고기들의 평균 길이는 (32) / 1 = 32cm 입니다. 따라서 평균길이가 33cm 인 물고기 종류는 0 이므로, 총 잡은 수는 3마리, 최대 길이는 50cm 이므로 결과는 다음과 같아야 합니다.            FISH_COUNT MAX_LENGTH FISH_TYPE            3 50 0              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   IFNULL(컬럼, 값) 으로 null 값을 10으로 치환     코드   SELECT COUNT(*) AS FISH_COUNT, MAX(IFNULL(LENGTH, 10)) AS MAX_LENGTH, FISH_TYPE     FROM FISH_INFO         GROUP BY FISH_TYPE             HAVING AVG(IFNULL(LENGTH, 10)) &gt;= 33                 ORDER BY FISH_TYPE;  "
  },
  
  {
    "title": "Subquery vs Join",
    "url": "/posts/Subquery-vs-Join/",
    "categories": "데이터베이스",
    "tags": "Database, mysql",
    "date": "2025-06-02 19:45:31 +0900",
    "content": "   개발을 하며 쿼리를 작성할 때 여러 테이블에서 데이터를 가져오기 위해 서브쿼리나 조인을 사용한 경험이 있을 것이다. 이때 어떤 방법을 선택하는것이 더 나은지에 대한 고찰을 해 보았다.     Subquery와 종류    쿼리 안에 또 다른 쿼리가 들어간 것 상황에 따라 메인 쿼리의 WHERE, FROM, SELECT 절에 새로운 쿼리를 넣을 수 있다.     예시 테이블들  galleries          idcity               1London           2New York           3Munich        paintings          idnamegallery_idprice               1Patterns35000           2Ringer14500           3Gift13200           4Violin Lessons26700           5Curiosity29800        sales_agents          id     name     gallery_id     price             1     Patterns     3     5000           2     Ringer     1     4500           3     Gift     1     3200           4     Violin Lessons     2     6700           5     Curiosity     2     9800        managers          id     gallery_id       1 2   2 3   4 1              가장 직관적인 서브쿼리 : WHERE 절에 서브쿼리를 포함하는 것.      ex) 평균 에이전시 비용보다 더 많은 비용을 받는 에이전트의 정보        SELECT *   FROM sales_agents   WHERE agency_fee &gt;   (SELECT AVG(agency_fee)    FROM sales_agents);            idlast_namefirst_namegallery_idagency_fee               2WhiteKate33120           4SmithHelen14500         서브쿼리는 단일 값을 반환할 수도 있고 여러 행과 열이 담긴 테이블을 반환할 수도 있다.    중첩 쿼리 (nested query) : 메인 쿼리의 결과를 필터링하고자 실행되는 내부 쿼리   상관관계가 있는 서브쿼리 : 내부 쿼리가 메인 쿼리의 열을 빌려와서 실행됨     단일 수치를 반환하는 스칼라 서브 쿼리    서브 쿼리가 단일 값을 반환하거나 정확히 1개의 행과 1개의 열을 반환           아까 위의 예시처럼 메인 쿼리를 필터링하고자 WHERE 절에서 자주 사용됨.           메인 쿼리의 SELECT문에서도 사용 가능 ex) 각각의 페인팅 금액 옆에 전체 페인팅의 평균 금액을 함께 보고 싶은 경우       SELECT name AS painting,      price,      (SELECT AVG(price)   FROM paintings) AS avg_price FROM paintings;                   paintingpriceavg_price               Patterns50005840           Ringer45005840           Gift32005840           Violin Lessons67005840           Curiosity98005840         여기서 살펴볼 점은 서브 쿼리(내부 쿼리)가 메인 쿼리(외부 쿼리)와는 별개로 독립적이라는 사실이다. 서브 쿼리만 가지고도 쿼리가 실행이 되고, 그 자체로도 유의미한 수치를 얻어낼 수 있기 때문이다.    여러 행을 반환하는 서브 쿼리 (Multiple-Row Subquery)    서브 쿼리가 하나보다 더 많은 행을 반환      Case 1) 여러 행이 존재하는 1개의 열을 반환   Case 2) 여러 행이 존재하는 다수의 열을 반환    Case 1) 여러 행이 존재하는 1개의 열을 반환    주로 WHERE 절에서 사용되어 메인 쿼리의 결과를 필터링하는데 사용됨   IN, NOT IN, ANY, ALL, EXISTS, NOT EXISTS 와 같은 연산자와 함께 사용해서 서브쿼리를 통해 반환된 여러값들을 특정 값과 비교할 수 있다.  ex) 매니저가 아닌 에이전트들의 평균 에이전시 비용 검색 SELECT  AVG(agency_fee) FROM sales_agents WHERE id NOT IN (SELECT id                                FROM managers);     내부 쿼리 -&gt; 매니저 아이디 전부 반환   외부 쿼리 -&gt; 해당 매니저 아이디 제외한 에이전트만 반환 후 평균 비용 계산 -&gt; 단일 값 반환     상관관계가 있는 서브 쿼리 (Correlated Subquery)    내부 쿼리가 외부 쿼리에서 얻은 정보에 의지해 실행됨   주로 SELECT, WHERE, FROM 문에 사용됨    ex) 각 미술관마다 보유하고 있는 페인팅의 개수를 계산 SELECT  city,  (SELECT count(*)   FROM paintings AS p   WHERE g.id = p.gallery_id) AS total_paintings FROM galleries AS g;   이 쿼리문에서 사용된 count(*) 에 집중해보자  서브쿼리는 각 미술관이 보유하고 있는 페인팅 개수 (단일 값!) 을 반환한다. galleries 에 gallery_id 가 3개 존재하므로 내부 쿼리는 3번 실행된다.          city     total_paintings       London 2   New York 2   Munich 1       이전 예시들과는 달리 이번 예시의 내부 쿼리는 외부 쿼리에 의존한다.  외부 쿼리의 테이블인 galleries 에 저장된 gallery_id 를 가져와서,  내부 쿼리인 paintings 테이블에 저장된 id와 연결해준다.  즉, 다른 서브쿼리와는 달리 내부 쿼리가 독립적으로 실행될 수 없다는 점이 중요한 차이점이다. (해봤자 에러만 발생할 것임)  상관관계가 있는 서브쿼리같은 경우엔 JOIN을 사용해서 같은 결과를 얻을 수 있다.  SELECT  g.city,  count(p.name) AS total_paintings FROM galleries AS g JOIN paintings AS p  ON g.id = p.gallery_id GROUP BY g.city;     JOIN은 보통 Subquery보다 빠르게 실행된다. 하지만 서브쿼리가 더 직관적이라면 서브쿼리를 쓰는것도 괜찮다.    상관관계가 있는 서브쿼리가 WHERE 문에 사용되는 경우  ex) 에이전트가 받는 에이전시 비용이 그 에이전트가 소속된 미술관의 평균 에이전시 비용과 같거나 더 많은 경우 검색  SELECT last_name,        first_name,        agency_fee FROM sales_agents sa1 WHERE sa1.agency_fee &gt;= (SELECT avg(agency_fee)                          FROM sales_agents sa2                          WHERE sa2.gallery_id = sa1.gallery_id);   여기서 내부 쿼리는 내부 쿼리의 테이블인 sales_agents (sa2) 내 5명의 에이전트가 있기 때문에 그들이 소속된 미술관의 평균 에이전시 비용을 반환할 것이다. 즉, 5명의 에이전트에 따른 각각의 평균 에이전시 비용(단일 값)을 총 5번 반환한다.(내부 쿼리 총 5번 실행)  외부 쿼리는 WHERE 문에 제시된 조건과 만족하는 에이전트에 관한 정보만 반환한다. 에이전트가 소속된 미술관의 평균 에이전시 비용보다 더 많이 받거나 똑같이 받는 에이전트의 정보를 반환할 것이다.           last_name     first_name     agency_fee       Brown Denis 2250   White Kate 3120   Smith Helen 4500       Join    2개 or 그 이상의 테이블을 연결하고, 필요한 열을 조회       2개의 테이블로 다양한 사례를 살펴보자.  product          idnamecostyearcity               1chair245.002017Chicago           2armchair500.002018Chicago           3desk900.002019Los Angeles           4lamp85.002017Cleveland           5bench2000.002018Seattle           6stool2500.002020Austin           7tv table2000.002020Austin         sale          id     product_id     price     year     city       1 2 2000.00 2020 Chicago   2 2 590.00 2020 New York   3 2 790.00 2020 Cleveland   5 3 800.00 2019 Cleveland   6 4 100.00 2020 Detroit   7 5 2300.00 2019 Seattle   8 7 2000.00 2020 New York       Subquery를 Join으로 대체할 수 있는 경우  1. 스칼라 서브 쿼리    내부 쿼리가 단일 값을 반환하거나 1개의 열과 1개의 행을 반환하는 경우   ex) 2,000 달러에 팔린 상품의 이름과 가격을 검색 SELECT  name,  cost FROM product WHERE id = ( SELECT product_id    FROM sale    WHERE price = 2000         AND product_id = product.id );            name     cost       armchair 500.00   tv table 2000.00       서브쿼리 동작\u001f     판매가 2000 달러인 상품 남겨둔다   외부 쿼리의 id 와 내부 쿼리의 product_id 를 비교해서 일치하는 상품 아이디만 반환한다.   주의할 점은 아이디 비교하는 과정에서 각 아이디를 비교할 때마다 내부 쿼리가 실행된다. 매번 단일한 값이 반환되므로 스칼라 서브 쿼리다. 또한 내부쿼리가 실행되기 위해 외부 쿼리에 의존하기 때문에 상관관계가 있는 서브쿼리다.  딱 봐도 비효율적임을 알 수 있다. 그렇다면 이를 Join을 사용해 개선해보자.  SELECT  p.name,  p.cost FROM product AS p JOIN sale AS s   ON p.id = s.product_id WHERE s.price = 2000;  JOIN을 통해 product 와 sale 테이블을 연결했고, p.id 와 s.product_id 로 매칭하였다.    2. IN 연산자 안에 있는 서브 쿼리    내부 쿼리, 즉, 서브 쿼리가 여러 개의 값을 반환   ex) 판매된 상품들의 이름과 가격 검색 SELECT  name,  cost FROM product WHERE id IN ( SELECT product_id FROM sale );           name     cost       armchair 500.00   lamp 85.00   bench 2000.00   desk 900.00      product 테이블에는 상품의 종류가 7개이지만, 결과를 보니 팔린 상품의 종류는 4개뿐인 것을 확인했다.  이를 JOIN으로 변환해보자  SELECT DISTINCT  p.name,  p.cost FROM product AS p JOIN sale AS s    ON p.id = s.product_id;   product_id 로 2개의 테이블은 연결한 후 그 테이블에서 상품 이름과 가격을 조회했다.  INNER JOIN 을 사용함으로써 sale 테이블에 아이디가 없는 상품들은 결과 테이블에 나타나지 않는다.    3. NOT IN 연산자 안에 있는 서브 쿼리  SELECT  name,  cost FROM product WHERE id NOT IN ( SELECT product_id FROM sale );           name     cost       chair 245.00   stool 2500.00       Join으로 하면 SELECT  DISTINCT p.name,  p.cost FROM product AS p LEFT JOIN sale AS s     ON p.id = s.product_id WHERE s.product_id IS NULL;   이번에는 LEFT JOIN 을 통해 상품의 판매 유무와는 상관없이 모든 상품들이 조인한 테이블 생긴다.  그 후, WHERE 절에서 product_id 가 존재하지 않는 경우를 찾음으로써 서브 쿼리의 아이디가 외부 쿼리 테이블에 존재하지 않는 경우를 찾았다.  IN 또는 NOT IN 연산자를 조인으로 바꿔 쓸 때 DISTINCT 키워드로 중복값을 제거하는 과정을 거친다.    4. EXISTS , NOT EXISTS 연산자 내부의 상관관계 서브 쿼리  ex) 2020년도에 팔리지 않은 상품들의 정보 검색 SELECT  name,  cost,  city FROM product WHERE NOT EXISTS  ( SELECT id     FROM sale     WHERE year = 2020 AND product_id = product.id );            name     cost     city       chair 245.00 Chicago   desk 900.00 Los Angeles   bench 2000.00 Seattle   stool 2500.00 Austin       결과는 판매 연도가 2020년이 아님과 동시에 sale 테이블에 아무런 정보가 존재하지 않는 상품들이다.  이제 조인으로 변환해보면 SELECT   p.name,  p.cost,  p.city FROM product AS p LEFT JOIN sale AS s   ON p.id = s.product_id WHERE s.year != 2020 OR s.year IS NULL;   순서는     LEFT JOIN 을 통해 product 테이블과 sale 테이블을 연결한다. LEFT JOIN 을 사용했기 때문에 팔리지 않은 상품도 결과 테이블에서 찾아볼 수 있다.   WHERE 절을 통해 sale 테이블에 아무런 정보가 없고(s.year IS NULL)   판매 연도가 2020년이 아닌 값(s.year != 2000)들만 남는다.     이렇게 서브쿼리를 조인으로 재작성하여 쿼리 수행력을 높일 수 있었다.    서브 쿼리를 조인으로 대체할 수 없는 경우     모든 서브쿼리가 조인으로 대체될 수 있는 건 아니다.   1. GROUP BY 를 사용한 서브쿼리가 FROM 절에 있을 때  SELECT city, sum_price   FROM  (   SELECT city, SUM(price) AS sum_price FROM sale   GROUP BY city ) AS s WHERE sum_price &lt; 2100;            city     sum_price     Chicago2000.00Detroit100.00Cleveland1590.00    여기서 서브 쿼리는 도시의 이름과 각 도시별 총 판매액을 반환한다. 각 도시별 총판매액은 SUM 집계 함수와 GROUP BY 를 통해 구했다.  서브 쿼리의 결과를 하나의 테이블로 간주한 외부 쿼리는 여기서 총판매액이 2100 달러 미만인 도시만 조회한다.  참고로, 서브 쿼리가 FROM 절에 사용될 경우 해당 서브 쿼리는 무조건 별칭이 있어야 된다. 그래서 예시에서도 sale 테이블의 s 를 서브 쿼리의 별칭으로 사용했다.    2. 집계된 값을 반환하는 서브 쿼리가 WHERE 절에 있을 때  1) 서브 쿼리가 집계된 하나의 값을 반환하고, 2) 그 값을 WHERE 절에서 외부 쿼리의 값과 비교할 때  SELECT name FROM product WHERE cost &lt; ( SELECT AVG(price) FROM sale );            name     chairarmchairdesklamp    결과는 전체 상품의 평균 판매가보다 가격이 낮은 상품명의 이름을 추출한다.     평균 판매가는 서브 쿼리 내에서 AVG 집계 함수를 사용하여 구한다.   서브 쿼리에서 구한 평균 판매가를 외부 쿼리의 각 상품의 가격마다 매번 비교하며 부등호를 만족하는 결과만 남는다.     3. 서브 쿼리가 ALL 연산자에 있을 때 SELECT name FROM product WHERE cost &gt; ALL( SELECT price FROM sale )           name        stool&lt;/table&gt;    서브쿼리는 `sale` 테이블의 모든 판매가를 반환합니다.   외부 쿼리는 서브 쿼리의 결과를 가지고 상품의 가격이 판매가보다 높은 값만 조회한다.  ### 마치며  대부분의 경우 JOIN이 SUBQUERY 보다 효율적인 것은 사실이다. 하지만 서브쿼리 구조만으로 해결해야 하는 상황도 있음을 주의해야 한다.  보기에는 JOIN이 복잡하고 작성하기 어려우므로 서브 쿼리가 훨씬 쉽다고 생각할 수 있지만 최대한 JOIN을 사용할 수 있는 상황에서는 JOIN을 채택하자.  ---  ### References - [What Are the Different Types of SQL Subqueries?](https://learnsql.com/blog/sql-subquery-types/) - [Subquery vs. JOIN](https://learnsql.com/blog/subquery-vs-join/)  "
  },
  
  {
    "title": "MySQL 옵티마이저 에러",
    "url": "/posts/MySQL-%EC%98%B5%ED%8B%B0%EB%A7%88%EC%9D%B4%EC%A0%80-%EC%97%90%EB%9F%AC/",
    "categories": "데이터베이스",
    "tags": "Database, mysql",
    "date": "2025-05-29 20:22:49 +0900",
    "content": "옵티마이저 에러 &amp; 힌트  옵티마이저는 제한된 정보를 이용해서 최적의 실행계획을 최대한 짧은 시간안에 수립해야한다. 따라서 빠르고 정확하게 실행되어야한다.  실제 실무에서 RDBMS사용할 때 옵티마이저 관련 오류가 많이 발생하고 이런 문제를 최대한 회피하고자 옵티마이저 힌트를 사용하고, 많은 힌트 기능들이 제공된다.   SQL문장에서 옵티마이저 힌트를 사용하면 RDBMS는 그 힌트를 매우 신뢰한다. 그래서 더 나은 실행계획이 있어도 여전히 SQL에 주어진 힌트를 사용하는 경향이 있다.  시간이 지나면서 데이터가 바뀌고 예전 실행계획이 최적이 아니게 될 수 있기 때문에 옵티마이저 힌트를 사용하지 않는것을 추천한다.   이 글에서 치명적인 옵티마이저 오류 케이스를 보고 왜 옵티마이저가 그런 잘못된 선택을 했는지 분석해보고자 한다.    실행 계획 오류 (ref vs range) 케이스   대상 테이블의 구조와 테이블 정보 CREATE TABLE tab (   id bigint NOT NULL AUTO_INCREMENT,   bid bigint NOT NULL,   created_at datetime DEFAULT NULL,   ...   PRIMARY KEY (id),   KEY ix_bid_id (bid,id),   KEY ix_bid_createdat (bid,created_at) );   mysql&gt; SHOW INDEXES FROM tab; +-------+------------+------------------+--------------+-------------+-------------+ | Table | Non_unique | Key_name         | Seq_in_index | Column_name | Cardinality | +-------+------------+------------------+--------------+-------------+-------------+ | tab   |          0 | PRIMARY          |            1 | id          |    11797584 | | tab   |          1 | ix_bid_id        |            1 | bid         |      581387 | | tab   |          1 | ix_bid_id        |            2 | id          |    11797584 | | tab   |          1 | ix_bid_createdat |            1 | bid         |      561151 | | tab   |          1 | ix_bid_createdat |            2 | created_at  |    11702179 | +-------+------------+------------------+--------------+-------------+-------------+     이제 ix_bid_createdat(bid, created_at) 인덱스와 ix_bid_id(bid, id) 인덱스를 사용할 것으로 예상되는 2개 쿼리의 실행 계획을 확인해보자.  실행계획 결과  mysql&gt; EXPLAIN SELECT COUNT(*) FROM tab WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR); +------+-----------+---------+-------+---------+----------+-------------+ | type | key       | key_len | ref   | rows    | filtered | Extra       | +------+-----------+---------+-------+---------+----------+-------------+ | ref  | ix_bid_id | 8       | const | 1632722 |    33.33 | Using where | +------+-----------+---------+-------+---------+----------+-------------+  mysql&gt; EXPLAIN SELECT COUNT(*) FROM tab WHERE bid=1198442 AND id&lt;14025956; +------+------------------+---------+-------+---------+----------+--------------------------+ | type | key              | key_len | ref   | rows    | filtered | Extra                    | +------+------------------+---------+-------+---------+----------+--------------------------+ | ref  | ix_bid_createdat | 8       | const | 1426712 |    50.00 | Using where; Using index | +------+------------------+---------+-------+---------+----------+--------------------------+     MySQL 옵티마이저가 뭔가 잘못된 인덱스를 선택한 것이 보인다.    첫번째 쿼리는 ix_bid_createdat(bid, created_at)인덱스를 사용하면 커버링 인덱스로 매우 빠르게 처리될 수 있다.   두번째 쿼리는 ix_bid_id(bid, id)인덱스를 사용하면 똑같이 커버링 인덱스로 빠르게 처리될 쿼리라는 것을 알수 있다.   하지만 MySQL 옵티마이저는 2개 쿼리에 대해서 거꾸로 인덱스를 선택한 상황이다.    간단한 해결 방법   옵티마이저 힌트 사용 -- 첫 번째 쿼리: 올바른 인덱스 강제 사용  SELECT /*+ INDEX(tab ix_bid_createdat) */ COUNT(*)  FROM tab WHERE bid=1198442    AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR);       -- 두 번째 쿼리: 올바른 인덱스 강제 사용  SELECT /*+ INDEX(tab ix_bid_id) */ COUNT(*)  FROM tab WHERE bid=1198442    AND id&lt;14025956;     힌트를 사용한 쿼리의 실행 계획  SELECT /*+ INDEX(tab ix_bid_createdat) */ COUNT(*)  FROM tab WHERE bid=1198442    AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR); +-------+------------------+---------+------+---------+----------+--------------------------+ | type  | key              | key_len | ref  | rows    | filtered | Extra                    | +-------+------------------+---------+------+---------+----------+--------------------------+ | range | ix_bid_createdat | 14      | NULL | 1490996 |   100.00 | Using where; Using index | +-------+------------------+---------+------+---------+----------+--------------------------+   Q) 왜 옵티마이저가 이런 판단을 했을까? 옵티마이저 힌트 없이 최적화 오류를 회피할 수 있는 방법은 없을까?   여기서 주의깊게 봐야 할 부분은 성능이 느린 실행 계획에서는 type 필드의 값이 ref 였었는데, 옵티마이저 힌트를 사용해서 성능이 개선된 쿼리의 실행 계획에서는 range로 바뀌었다는 것이다.  실제 이 쿼리의 최적화 오류는 ref 접근 방법의 비용 계산이 너무 낮게 계산되면서 발생한 문제인데, ref 접근 방법의 비용이 이렇게 낮게 계산된 이유를 살펴보자.    쿼리 비용 계산  우선 MySQL 서버의 쿼리 비용 계산 과정을 살펴보기 전에, MySQL 서버에서 사용하는 2가지 단위 작업에 대한 비용 상수( Cost Model )에 대해서 이해를 해야 하는데, MySQL 서버에서 단위 작업에 대한 비용 상수는 다음과 같다. (이 비용 상수에 대한 자세한 설명은 Real MySQL 1권 p.409 에 나와있다.) 우선 지금은 비용 상수는 변경없이 MySQL 서버의 기본 값을 그대로 사용중이라는 것을 기억하자.  mysql&gt; SELECT * FROM mysql.server_cost; +------------------------------+------------+---------------+ | cost_name                    | cost_value | default_value | +------------------------------+------------+---------------+ | disk_temptable_create_cost   |       NULL |            20 | | disk_temptable_row_cost      |       NULL |           0.5 | | key_compare_cost             |       NULL |          0.05 | | memory_temptable_create_cost |       NULL |             1 | | memory_temptable_row_cost    |       NULL |           0.1 | | row_evaluate_cost            |       NULL |           0.1 | +------------------------------+------------+---------------+  mysql&gt; SELECT * FROM mysql.engine_cost; +------------------------+------------+---------------+ | cost_name              | cost_value | default_value | +------------------------+------------+---------------+ | io_block_read_cost     |       NULL |             1 | | memory_block_read_cost |       NULL |          0.25 | +------------------------+------------+---------------+     이제 MySQL 서버에서 다음 쿼리가 ix_bid_id(bid, id)인덱스와 ix_bid_createdat(bid, created_at)인덱스를 사용할 때, 각각 쿼리 처리에 필요한 비용이 얼마일지 예측한 값을 비교.  mysql&gt; EXPLAIN FORMAT=JSON        SELECT /*+ INDEX(tab ix_bid_id) */ COUNT(*)         FROM tab        WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR); {   \"query_block\": {     \"select_id\": 1,     \"cost_info\": {       \"query_cost\": \"236946.95\"     },     \"table\": {       \"table_name\": \"tab\",       \"access_type\": \"ref\",       \"key\": \"ix_bid_id\",       \"used_key_parts\": [         \"bid\"       ],       \"key_length\": \"8\",       \"rows_examined_per_scan\": 1632722,       \"rows_produced_per_join\": 544186,       \"filtered\": \"33.33\",       \"cost_info\": {         \"read_cost\": \"73674.75\",         \"eval_cost\": \"54418.62\",         \"prefix_cost\": \"236946.95\",         \"data_read_per_join\": \"24M\"       },       ...     }   } }  mysql&gt; EXPLAIN FORMAT=JSON        SELECT /*+ INDEX(tab ix_bid_createdat) */ COUNT(*)         FROM tab        WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR); {   \"query_block\": {     \"select_id\": 1,     \"cost_info\": {       \"query_cost\": \"302192.75\"     },     \"table\": {       \"table_name\": \"tab\",       \"access_type\": \"range\",       \"key\": \"ix_bid_createdat\",       \"used_key_parts\": [         \"bid\",         \"created_at\"       ],       \"key_length\": \"14\",       \"rows_examined_per_scan\": 1490996,       \"rows_produced_per_join\": 1490996,       \"filtered\": \"100.00\",       \"using_index\": true,       \"cost_info\": {         \"read_cost\": \"153093.15\",         \"eval_cost\": \"149099.60\",         \"prefix_cost\": \"302192.75\",         \"data_read_per_join\": \"68M\"       },       ...     }   } }    ix_bid_id(bid, id) 인덱스를 사용한 경우 전체 쿼리 비용은 234128.51(query_cost)이며, ix_bid_createdat(bid, created_at) 인덱스를 사용한 경우 쿼리 비용은 302192.75(query_cost) 라는 것을 확인할 수 있다.  이 결과만 보면, 옵티마이저는 ix_bid_id 인덱스를 사용하는 실행 계획이 더 빠를 것이라고 예측했다는 것을 알 수 있다. 하지만 실제 쿼리 실행 결과는 10배나 더 걸렸다.   MySQL 의 쿼리 비용은 참조해야 하는 모든 테이블의(read_cost + eval_cost)의 합이다    read_cost는 CPU 기반 처리 작업의 비용   eval_cost 는 디스크 또는 메모리에서 데이터 페이지 읽기 작업의 비용   이 예제는 조인이 없기 때문에 단순히 read_cost와 eval_cost의 합이 전체 쿼리 비용(query_cost)이 된다.    그런데 ix_bid_createdat 인덱스의 경우 query_cost=(read_cost + eval_cost) 수식이 성립되지만,  ix_bid_id 인덱스의 경우 query_cost는 (read_cost + eval_cost)와 일치하지 않는다.  이는 ref 접근 방법의 비용 표현에서 일부가 누락되었기 때문이다.    또한 MySQL 8.0 버전부터는 테이블의 데이터 페이지가 메모리(InnoDB Buffer Pool)에 얼마나 적재되어 있는지 비율도 같이 계산되도록 개선되었는데, 이 비율은 다음과 같이 확인할 수 있다고 한다.  SELECT tables.NAME as table_name,     indexes.NAME as index_name,     stats.stat_value as n_total_pages,     cached.N_CACHED_PAGES as n_cached_pages,     (stats.stat_value - cached.N_CACHED_PAGES) as n_not_cached_pages,     (100.0*cached.N_CACHED_PAGES/stats.stat_value) as cached_ratio,     (100-(100.0*cached.N_CACHED_PAGES/stats.stat_value)) as not_cached_ratio   FROM information_schema.INNODB_TABLES AS tables     INNER JOIN information_schema.INNODB_INDEXES indexes ON indexes.TABLE_ID = tables.TABLE_ID     INNER JOIN information_schema.INNODB_CACHED_INDEXES cached ON cached.INDEX_ID = indexes.INDEX_ID     INNER JOIN mysql.innodb_index_stats stats ON stats.database_name=substring_index(tables.NAME,'/',1) AND stats.table_name=substring_index(tables.NAME,'/',-1) AND stats.index_name=indexes.NAME AND stats.stat_name='size'   WHERE tables.NAME='test/tab';    +------------+------------------+---------------+----------------+--------------------+--------------+------------------+ | table_name | index_name       | n_total_pages | n_cached_pages | n_not_cached_pages | cached_ratio | not_cached_ratio | +------------+------------------+---------------+----------------+--------------------+--------------+------------------+ | test/tab   | PRIMARY          |         47680 |          30829 |              16851 |     64.65814 |         35.34186 | | test/tab   | ix_bid_id        |         28672 |             11 |              28661 |      0.03836 |         99.96164 | | test/tab   | ix_bid_createdat |         36608 |             11 |              36597 |      0.03005 |         99.96995 | +------------+------------------+---------------+----------------+--------------------+--------------+------------------+    이제 각 인덱스를 사용하는 실행 계획의 비용 계산 과정을 살펴보자.  MySQL 서버 내부 코드 로직은 접근 방법에 따라서 매우 다양한 형태의 계산식을 활용한다.  아래의 계산식이 모든 쿼리의 비용 계산에 사용될 수 있는 공식은 아니고, 이 쿼리에만 적용된다는 것을 주의. 하지만 이 계산식을 통해서 MySQL 옵티마이저가 어떻게 쿼리의 비용을 예측하는지 대략적으로 살펴볼 수 있다.  MySQL에서 ref와 range는 모두 인덱스를 효율적으로 사용하는 실행 계획이긴 하지만, 두 접근 방법의 비용 계산 방식은 매우 다르게 구현되어 있다.   ix_bid_id 인덱스 활용 실행 계획   total_pages_of_table = 47680 estimated_rows = 1632722 pct_cached_pages(Primary) = 64.65814 % pct_not_cached_pages(Primary) = (100 - 64.65814) %  row_evaluate_cost = 0.10 memory_block_read_cost = 0.25 disk_block_read_cost = 1.00  -- 1️⃣ worst_seek_cost (최악의 랜덤 액세스 비용) worst_seek_cost(84095.62) = (estimated_rows/10 * pct_cached_pages * 0.25) + (estimated_rows/10 * pct_not_cached_pages * 1)  -- 2️⃣ total_scan_cost (전체 스캔 비용)   total_scan_cost(24558.25) = (total_pages_of_table * pct_cached_pages * 0.25) + (total_pages_of_table * pct_not_cached_pages * 1)  eval_cost(163272.2) = estimated_rows * row_evaluate_cost read_cost(73674.75) = MIN(worst_seek_cost, total_scan_cost*3)  query_cost(236946.95) = read_cost + eval_cost    ix_bid_createdat 인덱스 활용 실행 계획  estimated_rows = 1490996 pct_cached_pages(Index ix_bid_createdat) = 0.03005 % pct_not_cached_pages(Index ix_bid_createdat) = (100 - 0.03005) %  row_evaluate_cost = 0.10 memory_block_read_cost = 0.25 disk_block_read_cost = 1.00  -- 1️⃣ keys_per_block (한 페이지당 키 개수) keys_per_block(373.36) = 16 * 1024 / 2 / (8+5+1+8) + 1  -- 2️⃣ read_index_pages (읽어야 할 인덱스 페이지) read_index_pages(3994.45) = (estimated_rows + keys_per_block - 1) / keys_per_block  -- 3️⃣ read_time (인덱스 읽기 시간) read_time(3993.55) = (read_index_pages * pct_cached_pages * 0.25) + (read_index_pages * pct_not_cached_pages * 1)  eval_cost(149099.6) = estimated_rows * row_evaluate_cost read_cost(153093.15) = eval_cost + read_time  query_cost(302192.75) = read_cost + eval_cost   이 계산 과정에서 ix_bid_id 인덱스가 채택될 수밖에 없는 결정적인 이유는 이 인덱스를 사용할 때 실행 계획의 read_cost를 매우 낮은 수준으로 판단했기 때문이다.  read_cost를 계산할 때 MySQL 옵티마이저는 worst_seek_cost와 total_scan_cost 2개의 값중에서 최소값을 선택하는데, worst_seek_cost는 ix_bid_id 인덱스를 읽고 레코드 건수만큼 데이터 페이지를 읽는 비용을 의미하고, total_scan_cost는 테이블의 모든 데이터 페이지를 읽는 비용을 의미한다.  그런데 total_scan_cost가 너무 낮은 비용으로 평가되면서 쿼리의 실행 계획이 잘못되었다. total_scan_cost가 너무 낮은 비용으로 계산된 이유는 ref 실행 계획의 비용은 ix_bid_id 인덱스가 아닌 PRIMARY 인덱스의 데이터 페이지 읽기를 계산하는데, 일반적으로 인덱스보다 데이터 파일의 페이지가 메모리에 상주할 가능성이 높기 때문이다.    처음에 살펴보았던 아래 쿼리도 ix_bid_id 가 아닌 ix_bid_createdat 인덱스를 사용하게 되는 이유는  SELECT COUNT(*) FROM tab WHERE bid=1198442 AND id&lt;14025956;   range 접근 방식보다 ref 접근 방식의 비용이 낮게 계산되면서, 쿼리 조건에 딱 맞는 인덱스는 사용하지 못하고 조금 비슷한 패턴의 인덱스만 사용하도록 실행 계획이 수립되고 있었던 것이다.    비유하자면 MySQL :   ix_bid_id 쓰면 두 가지 방법  1. 인덱스 읽고 → 테이블 하나씩 찾아가기 (worst_seek_cost) 2. 아니면 그냥 테이블 전체 스캔하기 (total_scan_cost) 이 중에 더 싼 걸로 선택  read_cost = MIN(worst_seek_cost, total_scan_cost × 3) 문제의 원인 total_scan_cost가 너무 낮게 계산됨  MySQL의 오류 원인: \"PRIMARY 테이블은 메모리에 많이 올라와 있음 (64.65%)  전체 스캔해도 별로 안 비쌈  total_scan_cost = 24,558 (매우 낮음) worst_seek_cost = 84,096 (높음)  결과: MIN(84,096, 24,558×3) = 73,674 선택  현실: - bid=1198442 레코드가 160만 개 - 160만 개마다 테이블 액세스 필요 - 메모리에 있어도 160만 번 읽기는 느림     Cost Model 해결 방법 아래 쿼리가 ix_bid_id 인덱스가 아닌 ix_bid_createdat 인덱스를 사용하도록 하려면, 옵티마이저의 단위 비용 상수를 조정하여 ref 접근 방법의 비용을 더 높이거나 range 접근 방법의 비용을 더 낮춰야한다  SELECT COUNT(*)  FROM tab WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR);   이 쿼리가 ix_bid_createdat 을 사용하지 못하고 ix_bid_id 를 사용하게 되는 가장 큰 이유는 읽는 레코드에 대해서 eval_cost (row_evaluate_cost) 가 전체 비용에 두번이나 영향을 미치고 있기 때문이다.   그래서 우리는 row_evaluate_cost 비용 상수를 더 낮은 값으로 설정해서, ix_bid_createdat 의 실행 계획 비용을 상대적으로 더 낮출 수 있다.  UPDATE mysql.server_cost    SET cost_value=0.03 /* 데이터 분포도에 따라서 옵티마이저는 여전히 ix_bid_id 인덱스를 선호할 수 있음*/    WHERE cost_name='row_evaluate_cost';  FLUSH OPTIMIZER_COSTS; -- // 현재 세션은 종료하고, 새로 MySQL 서버에 로그인해야 변경된 비용으로 쿼리 실행 계획이 수립되는 것을 확인할 수 있음     다시 쿼리의 실행 계획 실행하면 mysql&gt; EXPLAIN SELECT COUNT(*) FROM tab WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR); +-------+------------------+---------+------+---------+----------+--------------------------+ | type  | key              | key_len | ref  | rows    | filtered | Extra                    | +-------+------------------+---------+------+---------+----------+--------------------------+ | range | ix_bid_createdat | 14      | NULL | 1490996 |   100.00 | Using where; Using index | +-------+------------------+---------+------+---------+----------+--------------------------+  쿼리의 실행 계획이 ix_bid_createdat 인덱스를 사용하도록 변경되었다.  mysql&gt; EXPLAIN FORMAT=JSON        SELECT /*+ INDEX(tab ix_bid_id) */ COUNT(*)         FROM tab        WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR);   ...   \"cost_info\": {     \"read_cost\": \"73429.79\",     \"eval_cost\": \"16325.59\",     \"prefix_cost\": \"122411.45\",     \"data_read_per_join\": \"24M\"   },  mysql&gt; EXPLAIN FORMAT=JSON        SELECT /*+ INDEX(tab ix_bid_createdat) */ COUNT(*)         FROM tab        WHERE bid=1198442 AND created_at&lt;DATE_SUB(NOW(), INTERVAL 9 HOUR);   ...   \"cost_info\": {     \"read_cost\": \"48727.16\",     \"eval_cost\": \"44729.88\",     \"prefix_cost\": \"93457.04\",     \"data_read_per_join\": \"68M\"   },   실제 쿼리의 비용을 한번 살펴보면,  ix_bid_id 인덱스를 사용하는 실행 계획은 전체 비용이 122411.45로 감소했고, ix_bid_createdat인덱스를 사용하는 실행 계획은 93457.04로 비용이 더 크게 감소했다.  References         Ref Access Cost 관련 주요 코드             find_worst_seeks()       Cost_estimate handler::table_scan_cost()                Range Access Cost 관련 주요 코드             if (tab-&gt;range_scan())       Cost_estimate handler::index_scan_cost       handler::index_only_read_time()          "
  },
  
  {
    "title": "BOJ_16920_확장 게임 (Java)",
    "url": "/posts/BOJ16920%ED%99%95%EC%9E%A5-%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-27 23:59:00 +0900",
    "content": "[Gold II] 확장 게임 - 16920  문제 링크  성능 요약  메모리: 57644 KB, 시간: 492 ms  분류  너비 우선 탐색, 그래프 이론, 그래프 탐색, 구현  제출 일자  2025년 5월 27일 23:54:02  문제 설명  구사과와 친구들이 확장 게임을 하려고 한다. 이 게임은 크기가 N×M인 격자판 위에서 진행되며, 각 칸은 비어있거나 막혀있다. 각 플레이어는 하나 이상의 성을 가지고 있고, 이 성도 격자판 위에 있다. 한 칸 위에 성이 두 개 이상인 경우는 없다.  게임은 라운드로 이루어져 있고, 각 라운드마다 플레이어는 자기 턴이 돌아올 때마다 성을 확장해야 한다. 제일 먼저 플레이어 1이 확장을 하고, 그 다음 플레이어 2가 확장을 하고, 이런 식으로 라운드가 진행된다.  각 턴이 돌아왔을 때, 플레이어는 자신이 가지고 있는 성을 비어있는 칸으로 확장한다. 플레이어 i는 자신의 성이 있는 곳에서 Si칸 만큼 이동할 수 있는 모든 칸에 성을 동시에 만든다. 위, 왼쪽, 오른쪽, 아래로 인접한 칸으로만 이동할 수 있으며, 벽이나 다른 플레이어의 성이 있는 곳으로는 이동할 수 없다. 성을 다 건설한 이후엔 다음 플레이어가 턴을 갖는다.  모든 플레이어가 더 이상 확장을 할 수 없을 때 게임이 끝난다. 게임판의 초기 상태가 주어졌을 때, 최종 상태를 구해보자.  입력  첫째 줄에 격자판의 크기 N, M과 플레이어의 수 P가 주어진다. 둘째 줄에는 S1, S2, ...SP가 주어진다.  다음 N개의 줄에는 게임판의 상태가 주어진다. '.'는 빈 칸, '#'는 벽, '1', '2', ..., '9'는 각 플레이어의 성이다.  모든 플레이어는 적어도 하나의 성을 가지고 있으며, 게임에 참가하지 않는 플레이어의 성이 있는 경우는 없다.  출력  플레이어 1이 가진 성의 수, 2가 가진 성의 수, ..., P가 가진 성의 수를 공백으로 구분해 출력한다.     문제 풀이   bfs문제로,  조금의 복잡함이 있지만 쭉 구현하면 풀 수 있다. 플레이어별 queue를 유지하는것으로 진행했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M, P;     static int[] S, res;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static char[][] board;     static Queue&lt;int[]&gt;[] players;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_16920_확장게임/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         P = Integer.parseInt(st.nextToken());         board = new char[N][M];         S = new int[P+1];         res = new int[P+1];         players = new ArrayDeque[P+1];         for(int i = 0; i &lt; P+1; i++) {             players[i] = new ArrayDeque&lt;&gt;();         }          st = new StringTokenizer(br.readLine());         for(int i=1; i&lt;=P; i++){             S[i] = Integer.parseInt(st.nextToken());         }         int cnt = 0;         for(int i=0; i&lt;N; i++){             String line = br.readLine();             for(int j=0; j&lt;M; j++){                 board[i][j] = line.charAt(j);                 if(board[i][j] != '.' &amp;&amp; board[i][j] != '#'){                     int pNum = board[i][j] - '0';                     players[pNum].add(new int[]{i, j});                     res[pNum]++;                 }                 else cnt++;             }         }         int pIdx = 1;         int fail = 0;          while(cnt&gt;0 &amp;&amp; fail &lt; P){             Queue&lt;int[]&gt; currQ = players[pIdx];             boolean flag = false;              for(int i=0; i&lt;S[pIdx]; i++){                 int size = currQ.size();                 if(size == 0) break;                  for(int j=0; j&lt;size; j++){                     int[] currCell = currQ.poll();                     for(int k=0; k&lt;4; k++){                         int nr = currCell[0] + dr[k];                         int nc = currCell[1] + dc[k];                          if(isValid(nr, nc) &amp;&amp; board[nr][nc] == '.'){                             board[nr][nc] = (char)(pIdx + '0');                             res[pIdx]++;                             currQ.add(new int[]{nr, nc});                             cnt--;                             flag = true;                         }                     }                 }             }              if(!flag) fail++;             else fail = 0;              pIdx = nextP(pIdx);         }          for(int i=1; i&lt;=P; i++){             sb.append(res[i]).append(\" \");         }         System.out.println(sb.toString());         bw.flush();         bw.close();         br.close();     }      private boolean isValid(int r, int c){         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     }      private int nextP(int pIdx){         return pIdx % P + 1;     } }  "
  },
  
  {
    "title": "BOJ_1943_동전 분배 (Java)",
    "url": "/posts/BOJ1943%EB%8F%99%EC%A0%84-%EB%B6%84%EB%B0%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-27 23:57:10 +0900",
    "content": "[Gold II] 동전 분배 - 1943  문제 링크  성능 요약  메모리: 20772 KB, 시간: 4420 ms  분류  다이나믹 프로그래밍, 배낭 문제  제출 일자  2025년 5월 27일 22:30:13  문제 설명  윤화와 준희는 솔선수범하여 쓰레기를 줍는 착한 일을 하였다. 원장선생님께서는 윤화와 준희를 칭찬하시고 과자나 사 먹으라고 하시며 동전 몇 개를 윤화와 준희에게 건네 주었다.  그런데 돈을 받은 윤화와 준희는 좋아하기보다 고민에 빠지고 말았다. 원장선생님께 받은 이 돈을 어떻게 나누어 할지 고민에 빠진 것이다. 두 사람 모두 상대방이 자기보다 1원이라도 더 받는 것은 도저히 인정할 수 없어 한다. 따라서 돈을 똑같이 둘로 나누어 가져야 두 사람이 모두 만족할 수 있게 된다.  하지만 두 사람에게 돈을 똑같이 나누는 것이 불가능한 경우도 있다. 예를 들어 500원짜리 1개와 50원짜리 1개를 받았다면, 이 돈을 두 사람이 똑같이 나누어 가질 수는 없다. 물론 동전을 반으로 잘라서 나누어 가질 수도 있겠지만 그러면 돈으로서의 가치를 잃기 때문에 그렇게 할 수는 없다.  이제 우리가 할 일은 다음과 같다. 원장 선생님께서 N가지 종류의 동전을 각각 몇 개씩 주셨을 때, 그 돈을 반으로 나눌 수 있는지 없는지 판단하는 것이다.  입력  세 개의 입력이 주어진다. 각 입력의 첫째 줄에 동전의 종류 N(1 ≤ N ≤ 100)이 주어진다. 각 입력의 둘째 줄부터 N+1째 줄까지 각각의 동전의 금액과 개수가 빈 칸을 사이에 두고 주어진다. 단, 원장선생님께서 주신 금액의 총 합은 100,000원을 넘지 않는다. 동전의 금액과 개수는 자연수이고, 같은 금액을 가진 동전이 두 번 이상 주어지는 경우는 없다.  출력  첫째 줄부터 세 줄에 걸쳐, 각 입력에 대하여 반으로 나누는 것이 가능하면 1, 불가능하면 0을 출력한다.     문제 풀이   냅색 문제다. 1차원 배열로 풀었고 역순으로 진행했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1943_동전분배/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          for(int t=0; t&lt;3; t++){             int N = Integer.parseInt(br.readLine());             int[] dp = new int[100001];             dp[0] = 1;             int total = 0;              for(int i=0; i&lt;N; i++){                 st = new StringTokenizer(br.readLine());                 int price = Integer.parseInt(st.nextToken());                 int number = Integer.parseInt(st.nextToken());                  total += price * number;                  for(int j = 0; j &lt; number; j++) {                     for(int k = 50000; k &gt;= price; k--) {                         if(dp[k - price] == 1) {                             dp[k] = 1;                         }                     }                     if(dp[total/2] == 1) break;                 }             }              if(total % 2 == 1){                 System.out.println(0);             }             else{                 if(dp[total/2]==1) System.out.println(1);                 else System.out.println(0);             }         }          bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1915_가장 큰 정사각형 (Java)",
    "url": "/posts/BOJ1915%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-27 21:46:24 +0900",
    "content": "[Gold IV] 가장 큰 정사각형 - 1915  문제 링크  성능 요약  메모리: 31372 KB, 시간: 364 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 5월 27일 21:30:36  문제 설명  n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.   \t \t\t \t\t\t0 \t\t\t1 \t\t\t0 \t\t\t0 \t\t \t\t \t\t\t0 \t\t\t1 \t\t\t1 \t\t\t1 \t\t \t\t \t\t\t1 \t\t\t1 \t\t\t1 \t\t\t0 \t\t \t\t \t\t\t0 \t\t\t0 \t\t\t1 \t\t\t0 \t\t \t   위와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다.  입력  첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.  출력  첫째 줄에 가장 큰 정사각형의 넓이를 출력한다.     풀이   핵심 아이디어 : dp[i][j]를 “(i,j)를 우하단 꼭짓점으로 하는 가장 큰 정사각형의 한 변의 길이”로 정의하는 것.  점화식: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1  (board[i][j] == 1일 때) dp[i][j] = 0  (board[i][j] == 0일 때)      첫 번째 행과 열은 기본값으로 초기화 (1이면 1, 0이면 0)   (1,1)부터 시작해서 현재 위치가 1이면, 왼쪽, 위쪽, 대각선 위쪽의 dp 값 중 최솟값에 1을 더함.   정사각형을 만들기 위해 세 방향 모두에서 최소 크기만큼만 확장 가능하기 때문.   최대 dp 값을 제곱하면 최대 정사각형의 넓이.      시간복잡도: $O(N×M)$      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int board[][], dp[][];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1915_가장큰정사각형/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         int n = Integer.parseInt(st.nextToken());         int m = Integer.parseInt(st.nextToken());         board = new int[n][m];         for(int i=0; i&lt;n; i++){             String line = br.readLine();             for(int j=0; j&lt;m; j++){                 board[i][j] = line.charAt(j) - '0';             }         }          dp = new int[n][m];         if(board[0][0] == 1) dp[0][0] = 1;         for(int i=1; i&lt;n; i++){             if(board[i][0] == 1) dp[i][0] = 1;         }         for(int j=1; j&lt;m; j++){             if(board[0][j] == 1) dp[0][j] = 1;         }          boolean flag = false;         for(int i = 0; i &lt; n; i++) {             for(int j = 0; j &lt; m; j++) {                 if(board[i][j] == 1) {                     flag = true;                     break;                 }             }             if(flag) break;         }         if(!flag) {             System.out.println(0);             return;         }          int max = 1;         for(int i = 1; i &lt; n; i++) {             for(int j = 1; j &lt; m; j++) {                 if(board[i][j] == 1) {                     dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i][j-1], dp[i-1][j])) + 1;                     max = Math.max(max, dp[i][j]);                 }                 else{                     dp[i][j] = 0;                 }             }         } //        for(int i = 0; i &lt; n; i++) { //            System.out.println(Arrays.toString(dp[i])); //        }         System.out.println(max * max);          bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "PGMS_조건에 부합하는 중고거래 상태 조회하기 (SQL)",
    "url": "/posts/PGMS%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%B6%80%ED%95%A9%ED%95%98%EB%8A%94-%EC%A4%91%EA%B3%A0%EA%B1%B0%EB%9E%98-%EC%83%81%ED%83%9C-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-05-27 21:42:33 +0900",
    "content": "[level 2] 조건에 부합하는 중고거래 상태 조회하기 - 164672  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; String， Date  채점결과  Empty  제출 일자  2025년 05월 27일 21:09:39  문제 설명  다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다.           Column name Type Nullable            BOARD_ID VARCHAR(5) FALSE   WRITER_ID VARCHAR(50) FALSE   TITLE VARCHAR(100) FALSE   CONTENTS VARCHAR(1000) FALSE   PRICE NUMBER FALSE   CREATED_DATE DATE FALSE   STATUS VARCHAR(10) FALSE   VIEWS NUMBER FALSE            문제  USED_GOODS_BOARD 테이블에서 2022년 10월 5일에 등록된 중고거래 게시물의 게시글 ID, 작성자 ID, 게시글 제목, 가격, 거래상태를 조회하는 SQL문을 작성해주세요. 거래상태가 SALE 이면 판매중, RESERVED이면 예약중, DONE이면 거래완료 분류하여 출력해주시고, 결과는 게시글 ID를 기준으로 내림차순 정렬해주세요.    예시  USED_GOODS_BOARD 테이블이 다음과 같을 때           BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS            B0007 s2s2123 커피글라인더 새상품처럼 깨끗합니다. 7000 2022-10-04 DONE 210   B0008 hong02 자전거 판매합니다 출퇴근용으로 구매했다가 사용하지 않아서 내놔요 40000 2022-10-04 SALE 301   B0009 yawoong67 선반 팝니다 6단 선반. 환불 반품 안됩니다. 12000 2022-10-05 DONE 202   B0010 keel1990 철제선반5단 철제선반 5단 조립식 팜 10000 2022-10-05 SALE 194          SQL을 실행하면 다음과 같이 출력되어야 합니다.           BOARD_ID WRITER_ID TITLE PRICE STATUS            B0010 keel1990 철제선반5단 10000 판매중   B0009 yawoong67 선반 팝니다 12000 거래완료              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      코드   SELECT BOARD_ID, WRITER_ID, TITLE, PRICE, (CASE                                              WHEN STATUS = 'DONE' THEN '거래완료'                                             WHEN STATUS = 'SALE' THEN '판매중'                                             WHEN STATUS = 'RESERVED' THEN '예약중'                                           END) AS STATUS     FROM USED_GOODS_BOARD         WHERE CREATED_DATE = '2022-10-05'             ORDER BY BOARD_ID DESC;  "
  },
  
  {
    "title": "PGMS_분기별 분화된 대장균의 개체 수 구하기 (SQL)",
    "url": "/posts/PGMS%EB%B6%84%EA%B8%B0%EB%B3%84-%EB%B6%84%ED%99%94%EB%90%9C-%EB%8C%80%EC%9E%A5%EA%B7%A0%EC%9D%98-%EA%B0%9C%EC%B2%B4-%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-05-27 21:41:20 +0900",
    "content": "[level 2] 분기별 분화된 대장균의 개체 수 구하기 - 299308  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; String， Date  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 05월 27일 21:02:21  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  각 분기(QUARTER)별 분화된 대장균의 개체의 총 수(ECOLI_COUNT)를 출력하는 SQL 문을 작성해주세요. 이때 각 분기에는 'Q' 를 붙이고 분기에 대해 오름차순으로 정렬해주세요. 대장균 개체가 분화되지 않은 분기는 없습니다.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 10 2019/01/01 5   2 NULL 2 2019/05/01 3   3 1 100 2020/01/01 4   4 2 17 2022/04/01 4   5 2 10 2020/09/01 6   6 4 101 2021/12/01 22          각 분기별로 분화된 대장균 개체는 다음과 같습니다.  1분기 : ID 1, ID 3 2분기 : ID 2, ID 4 3분기 : ID 5 4분기 : ID 6  따라서 결과는 다음과 같아야 합니다           QUARTER ECOLI_COUNT            1Q 2   2Q 2   3Q 1   4Q 1              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      코드   SELECT(         CASE          WHEN MONTH(DIFFERENTIATION_DATE) BETWEEN 1 AND 3 THEN '1Q'         WHEN MONTH(DIFFERENTIATION_DATE) BETWEEN 4 AND 6 THEN '2Q'         WHEN MONTH(DIFFERENTIATION_DATE) BETWEEN 7 AND 9 THEN '3Q'         WHEN MONTH(DIFFERENTIATION_DATE) BETWEEN 10 AND 12 THEN '4Q'     END) AS QUARTER, COUNT(*) AS ECOLI_COUNT     FROM ECOLI_DATA         GROUP BY QUARTER             ORDER BY QUARTER ASC;  "
  },
  
  {
    "title": "BOJ_4991_로봇 청소기 (Java)",
    "url": "/posts/BOJ4991%EB%A1%9C%EB%B4%87-%EC%B2%AD%EC%86%8C%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-27 21:39:27 +0900",
    "content": "[Gold I] 로봇 청소기 - 4991  문제 링크  성능 요약  메모리: 118492 KB, 시간: 540 ms  분류  그래프 이론, 브루트포스 알고리즘, 그래프 탐색, 너비 우선 탐색, 비트마스킹  제출 일자  2025년 5월 26일 11:03:27  문제 설명  오늘은 직사각형 모양의 방을 로봇 청소기를 이용해 청소하려고 한다. 이 로봇 청소기는 유저가 직접 경로를 설정할 수 있다.  방은 크기가 1×1인 정사각형 칸으로 나누어져 있으며, 로봇 청소기의 크기도 1×1이다. 칸은 깨끗한 칸과 더러운 칸으로 나누어져 있으며, 로봇 청소기는 더러운 칸을 방문해서 깨끗한 칸으로 바꿀 수 있다.  일부 칸에는 가구가 놓여져 있고, 가구의 크기도 1×1이다. 로봇 청소기는 가구가 놓여진 칸으로 이동할 수 없다.   로봇은 한 번 움직일 때, 인접한 칸으로 이동할 수 있다. 또, 로봇은 같은 칸을 여러 번 방문할 수 있다.  방의 정보가 주어졌을 때, 더러운 칸을 모두 깨끗한 칸으로 만드는데 필요한 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.  입력  입력은 여러 개의 테스트케이스로 이루어져 있다.  각 테스트 케이스의 첫째 줄에는 방의 가로 크기 w와 세로 크기 h가 주어진다. (1 ≤ w, h ≤ 20) 둘째 줄부터 h개의 줄에는 방의 정보가 주어진다. 방의 정보는 4가지 문자로만 이루어져 있으며, 각 문자의 의미는 다음과 같다.   \t.: 깨끗한 칸 \t*: 더러운 칸 \tx: 가구 \to: 로봇 청소기의 시작 위치   더러운 칸의 개수는 10개를 넘지 않으며, 로봇 청소기의 개수는 항상 하나이다.  입력의 마지막 줄에는 0이 두 개 주어진다.  출력  각각의 테스트 케이스마다 더러운 칸을 모두 깨끗한 칸으로 바꾸는 이동 횟수의 최솟값을 한 줄에 하나씩 출력한다. 만약, 방문할 수 없는 더러운 칸이 존재하는 경우에는 -1을 출력한다.     문제 풀이   핵심 아이디어 : 로봇이 어떤 더러운 칸들을 청소했는지를 비트마스크로 상태를 관리하는 것 더러운 칸이 최대 10개이므로 2^10 = 1024가지 상태를 표현할 수 있다.     로봇의 시작 위치를 찾고, 모든 더러운 칸의 좌표를 저장.   BFS로 탐색하면서 각 칸에 대해 (r, c, state) 형태로 방문 체크. 여기서 state는 어떤 더러운 칸들을 청소했는지를 나타내는 비트마스크   더러운 칸에 도달하면 해당 비트를 켜서 새로운 상태를 만들고, 모든 더러운 칸을 청소했는지 확인.   모든 더러운 칸을 청소한 상태가 되면 그때의 이동 횟수가 최솟값.      시간복잡도: $O(N × M × 2^{10})$ 이며, 각 칸마다 가능한 모든 청소 상태를 고려하여 탐색      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {      class Cell{         int r, c, state, dist;         public Cell(int r, int c, int state, int dist) {             this.r = r;             this.c = c;             this.state = state;             this.dist = dist;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static char[][] board;     static List&lt;int[]&gt; dirty; // 입력순서대로 더러운칸 번호     static Map&lt;Integer, Integer&gt; dirtyMap; // 더러운 곳 (r, c) 로 해싱해서 몇번째 더러운 칸인지 체크     static boolean[][][] visited;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_4991_로봇청소기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          while(true) {             st = new StringTokenizer(br.readLine());             M = Integer.parseInt(st.nextToken());             N = Integer.parseInt(st.nextToken());              if(N == 0 &amp;&amp; M == 0) break;             board = new char[N][M];             dirty = new ArrayList&lt;&gt;();             dirtyMap = new HashMap&lt;&gt;();             Cell start = new Cell(0,0,0,0);             int num = 0;             for(int i = 0; i &lt; N; i++) {                 String Line = br.readLine();                 for(int j = 0; j &lt; M; j++) {                     board[i][j] = Line.charAt(j);                     if(board[i][j] == '*') {                         dirty.add(new int[]{i, j});                         dirtyMap.put(j + i*M, num++);                     }                     else if(board[i][j] == 'o'){                         start.r = i;                         start.c = j;                     }                 }             }              Queue&lt;Cell&gt; queue = new ArrayDeque&lt;&gt;();             visited = new boolean[N][M][1&lt;&lt;10];             queue.add(start);             visited[start.r][start.c][0] = true;              boolean flag = false;             while(!queue.isEmpty() &amp;&amp; !flag) {                 Cell curr = queue.poll();                 for(int k=0; k&lt;4; k++) {                     int nr = curr.r + dr[k];                     int nc = curr.c + dc[k];                     if(isValid(nr, nc) &amp;&amp; board[nr][nc] != 'x') {                         if(board[nr][nc] == '*'){                             int n = dirtyMap.get(nc + nr*M); // 몇번째 더러운 칸인지                             int nstate = curr.state | (1 &lt;&lt; n); // 새로운 state값                              if(nstate == ((1&lt;&lt;dirty.size()) - 1)) {                                 sb.append(curr.dist + 1).append(\"\\n\");                                 flag = true;                                 break;                             }                             Cell nextCell = new Cell(nr, nc, nstate, curr.dist + 1);                             if(!visited[nr][nc][nstate]){                                 visited[nr][nc][nstate] = true;                                 queue.add(nextCell);                             }                         }                         else if(board[nr][nc] == '.' || board[nr][nc] == 'o') {                             Cell nextCell = new Cell(nr, nc, curr.state, curr.dist + 1);                             if(!visited[nr][nc][curr.state]){                                 visited[nr][nc][curr.state] = true;                                 queue.add(nextCell);                             }                         }                         else continue;                     }                 }             }              if(!flag){                 sb.append(\"-1\\n\");             }         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private boolean isValid(int r, int c){         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     } }  "
  },
  
  {
    "title": "MySQL vs Elasticsearch 검색 성능 비교 ",
    "url": "/posts/MySQL-vs-Elasticsearch-%EA%B2%80%EC%83%89-%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90/",
    "categories": "데이터베이스",
    "tags": "mysql",
    "date": "2025-05-21 20:17:38 +0900",
    "content": "Introduction  이 글에서는 전통적인 관계형 데이터베이스인 MySQL의 전문 검색(Full-Text Search)과 전문 검색 엔진인 Elasticsearch에 대해 알아보고자 한다.   MySQL의 Full-Text-Search     문장이나 문서 내용에서 키워드를 검색하는 기능     인덱싱 방식  1. 구분자(Stopword) 방식     MySQL 5.6 이전까지 사용된 기본 방식   띄어쓰기나 특정 기호를 기준으로 단어를 구분하여 인덱스 구축   “a”, “the”, “by”와 같이 의미 없는 단어는 제외   2. N-gram 방식     MySQL 5.7부터 InnoDB에서 지원   한국어/중국어/일본어(CJK)와 같이 공백만으로 단어를 파싱할 수 없는 언어에 효과적   텍스트를 일정 길이(기본값 2)로 나누어 인덱싱   예: “대한민국”를 2-gram(bi-gram)으로 분석하면 “대한”, “한민”, “민국” 으로 토큰화     설정 및 특징  ngram_token_size : 인덱싱할 토큰의 크기를 설정(기본값 2)     이 값보다 짧은 검색어는 검색 불가   값이 낮을수록 토큰 수가 많아져 인덱스 크기 증가     MySQL 5.7 이후 사용 방법:  CREATE TABLE articles (   id BIGINT AUTO_INCREMENT NOT NULL PRIMARY KEY,   title VARCHAR(100),   FULLTEXT INDEX ngram_idx(title) WITH PARSER ngram ) Engine=InnoDB;    검색 방법:  SELECT * FROM articles  WHERE MATCH(body) AGAINST('검색어' IN BOOLEAN MODE);     Elasticsearch 검색     Elasticsearch는 분산형 RESTful 검색 및 분석 엔진으로, 대용량 데이터를 실시간으로 검색하고 분석할 수 있는 시스템     핵심 특징 및 작동 방식  RDBMS에서 이렇게 저장된 데이터가 있을 때,   1. 역색인(Inverted Index) 구조      문서 내용을 분석하여 형태소 단위로 자르고 조사를 삭제해 의미 있는 데이터만 추출   검색어에 대해 유사도 점수 부여 가능   2. 랭킹 알고리즘  Elasticsearch 5.0부터 BM25 알고리즘 사용(이전에는 TF/IDF)    TF(Term Frequency): 검색어가 문서에 많이 있을수록 점수 상승   IDF(Inverse Document Frequency): 전체 문서에서 흔한 단어일수록 점수 하락   3. 텍스트 분석(Text Analysis) 과정     애널라이저(Analyzer): 0~3개의 캐릭터 필터, 1개의 토크나이저, 0~n개의 토큰 필터로 구성   토큰화: 텍스트를 분석해 검색에 용이한 단위로 분할     4. 분산 처리 아키텍처     클러스터, 노드, 샤드 개념으로 구성   노드는 Elasticsearch 클러스터에 포함된 단일 서버로, 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여   수평적 확장 가능     텍스트 처리 과정 실제 저장될때는 다음과 같은 과정을 거친다.   대소문자 변환   토큰 재정렬 (일반적으로 ASCII순서)   불용어(stopwords; 검색어로서 가치 없는 단어들) 를 제거 ( a, an, are, at, be, but, by, for, i, no, the, to, … 등등 )   형태소 분석 과정 ( ~s, ~ing, 등을 제거하는 과정; 한글은 의미분석때문에 더 복잡하다)   같아진 토큰들 병합   동의어 처리     검색 과정 검색어도 똑같이 텍스트 처리 과정을 거친다.  ex) “The lazy spiders” 라고 검색      검색엔진과 RDBMS 비교                         RDBMS       검색엔진                       데이터 저장 방식       정규화       역정규화                 전문(Full Text) 검색 속도       느림       빠름                 의미 검색       불가능       가능                 Join       가능       불가능                 수정 / 삭제       빠름       느림             Elasticsearch 클러스터링 과정     대용량 검색을 위해서는 클러스터링이 필요하다.   Elasticsearch는 데이터를 “샤드(Shard)” 단위로 분리해서 저장한다.   노드를 여러개 실행시키면 같은 클러스터로 묶인다.   샤드들이 각각의 노드들에 분배된다.   무결성과 가용성을 위해 샤드의 복제본을 만든다. (같은 내용의 복제본과 샤드는 서로 다른 노드에 저장된다)   시스템 다운이나 네트워크 단절 등으로 유실된 노드가 생기면   복제본이 없는 샤드들은 다른 살아있는 노드로 복제를 시작한다.   노드의 수가 줄어도 샤드의 수는 변함없이 무결성을 유지할 수 있다.      클러스터링 후…  검색 과정 (Query Phase)  1. 처음 쿼리 수행 명령을 받은 노드는 모든 샤드에게 쿼리를 전달한다.  1차적으로 모든 샤드(or 복제본) 검색을 실행   2. “from + size” 크기의 결과 큐를 처음 명령 받은 노드로 리턴한다.    리턴된 결과는 doc ID와 랭킹 점수만 포함하고 있다.   조정 노드는 이 결과들을 합치고, 랭킹 점수를 기준으로 정렬한다.       from: 결과 집합에서 시작할 위치(인덱스)를 지정. 0부터 시작하며, 기본값은 0아다.   size: 가져올 결과의 개수를 지정. 기본값은 10이다.   이후 문서 데이터를 가져오는 Fetch Phase 진행   검색 과정 (Fetch Phase)  1. 정렬된 값 기반으로 유효한 샤드들에 검색 결과를 요청.   2. 전체 문서 내용 (_source) 등의 정보가 리턴되어 클라이언트로 전달된다.     랭킹 알고리즘  TF/IDF     Term Frequency: 찾는 검색어가 문서에 많을수록 해당 문서의 정확도가 높다.   Inverse Document Frequency: 전체 문서에서 많이 출현한(흔한) 단어일수록 가중치가 낮다.     검색 랭킹이 중요한 이유     사용자들은 대부분 처음 나온 결과만 봄.   결과값이 큰 내용을 fetch하는 것은 상당히 부하가 큼 1 ~ 1,000을 fetch하는 것이나 990 ~ 1,000을 fetch하는 것이나 쿼리 작업 규모가 비슷하다.     루씬 세그먼트란?     루씬은 inverted index를 하나의 거대한 파일이 아니라 여러개의 작은 파일 단위로 저장   하나씩 데이터가 들어가거나, 1초 마다 하나씩 생성   한번 생성된 세그먼트는 변경되지 않습니다(immutable)     문서 변경/삭제 과정     한번 생성된 세그먼트는 변경되지 않습니다.   update는 없다. 모두 delete &amp; insert   문서를 삭제하면 삭제되었다는 상태만 표시하고 검색에서 제외   세그먼트 병합 과정은 비용이 큰 동작     세그먼트 병합(Segment Merge)   References     검색엔진이 데이터를 다루는 법  "
  },
  
  {
    "title": "BOJ_24552_올바른 괄호 (Java)",
    "url": "/posts/BOJ24552%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-16 01:02:13 +0900",
    "content": "[Gold IV] 올바른 괄호 - 24552  문제 링크  성능 요약  메모리: 15868 KB, 시간: 148 ms  분류  누적 합  제출 일자  2025년 5월 16일 00:43:59  문제 설명  $\\texttt{(, )}$로 구성된 문자열 $S$에서 정확히 하나의 괄호를 지워 올바른 괄호열을 만들 수 있는 경우의 수를 출력하자.  올바른 괄호열은 다음과 같이 정의된다.   \t()는 올바른 괄호열이다. \tA가 올바른 괄호열이면 (A)는 올바른 괄호열이다. \tA와 B가 올바른 괄호열이면 AB는 올바른 괄호열이다.   입력  첫번째 줄에 문자열 $S$가 공백 없이 주어진다. ($3 \\leq \\vert S \\vert \\leq 100\\,000$, $\\vert S \\vert$는 홀수이다.)  답은 $1$ 이상이다. 즉, 지웠을 때 올바른 괄호열이 되는 문자가 적어도 하나 존재한다.  출력  올바른 괄호열을 만들 수 있는 경우의 수를 출력한다.     문제 풀이     ( 가 1개 많거나 ) 가 1개 많을 수 밖에 없다.          ( 가 많을때 왼쪽에서 오른쪽으로 진행. 음수 나오면 x, 0이상 나오도록 진행           ) 가 많을때 오른쪽에서 왼쪽으로 진행. 음수 나오면 x, 0이상 나오도록 진행         코드   package BOJ_24552_올바른괄호;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_24552_올바른괄호/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          String str = br.readLine();         int N = str.length() / 2 + 1;         int cnt = 0;         for(int i=0; i&lt;str.length(); i++) {             if(str.charAt(i)=='(') cnt++;             else cnt--;         }          // 지워야 하는 문양을 +1, 나머지문양을 -1         // ( 가 많을때 왼쪽에서 오른쪽으로 진행. 음수 나오면 x, 0이상 나오도록 진행         if(cnt&gt;0){             int prev=0;             int toBeDeleted = 0;             if(str.charAt(0) == '(') prev++;             else if(str.charAt(0) == ')') prev--;              for(int i=1; i&lt;str.length(); i++) {                 int curr = prev;                 if(str.charAt(i) == '(') {                     curr++;                     toBeDeleted++;                 }                 else if(str.charAt(i) == ')') curr--;                  if(prev==0 &amp;&amp; curr==1) {                     N -= toBeDeleted;                     toBeDeleted = 0;                 }                 prev = curr;             }         }         // ) 가 많을때 오른쪽에서 왼쪽으로 진행. 음수 나오면 x, 0이상 나오도록 진행         else if(cnt&lt;0){             int prev = 0;             int toBeDeleted = 0;             if(str.charAt(str.length()-1) == ')') prev++;             else if(str.charAt(str.length()-1) == '(') prev--;  //            System.out.println(\"prev = \" + prev);              for(int i=str.length()-2; i&gt;=0; i--) {                 int curr = prev;                 if(str.charAt(i) == ')') {                     curr++;                     toBeDeleted++;                 }                 else if(str.charAt(i) == '(') curr--;                  if(prev==0 &amp;&amp; curr==1) {                     N -= toBeDeleted;                     toBeDeleted = 0;                 }                 prev = curr;             }         }         System.out.println(N);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "InnoDB 인덱스 잠금 실습해보기 (MySQL)",
    "url": "/posts/InnoDB-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%9E%A0%EA%B8%88-%EC%8B%A4%EC%8A%B5%ED%95%B4%EB%B3%B4%EA%B8%B0-MySQL/",
    "categories": "데이터베이스",
    "tags": "Database, mysql",
    "date": "2025-05-14 20:22:10 +0900",
    "content": "MySQL InnoDB의 인덱스 잠금 메커니즘 테스트 및 분석      들어가며   MySQL의 InnoDB 스토리지 엔진은 레코드 기반의 잠금 방식을 사용하지만, 흥미로운 점은 레코드 자체를 잠그는 것이 아니라 인덱스를 잠근다는 것입니다. 이 특성이 실제로 어떻게 동작하는지, 그리고 데이터베이스 설계와 성능에 어떤 영향을 미치는지 직접 테스트해보았습니다.      테스트 환경 준비  테스트를 위해 간단한 회원 정보 테이블을 만들고, last_name 컬럼에 인덱스를 설정했습니다. CREATE TABLE user (     first_name VARCHAR(30) CHARACTER SET utf8mb4,     last_name VARCHAR(30) CHARACTER SET utf8mb4,     age INT,     INDEX idx_last_name (last_name) );   그리고 다양한 성을 가진 회원 데이터를 삽입했습니다. INSERT INTO user (first_name, last_name, age) VALUES ('하늘', '김', 22), ('도현', '김', 28), ('유진', '김', 24), ('재현', '김', 33), ('수빈', '김', 27), ('지안', '김', 26), ('태현', '김', 31), ('나윤', '김', 29), ('예린', '김', 23), ('시우', '김', 30),  ('하람', '이', 25), ('연우', '이', 26), ('가온', '이', 32), ('서윤', '이', 28), ('예진', '이', 27),  ('주원', '박', 29), ('하진', '박', 31), ('수아', '박', 22),  ('채원', '최', 24), ('하린', '최', 30), ('도윤', '최', 33),  ('세아', '정', 26), ('민재', '정', 34),  ('라온', '조', 25), ('다은', '조', 29),  ('은우', '유', 28), ('지후', '유', 27),  ('하윤', '강', 30), ('시윤', '강', 26);    트랜잭션의 격리 수준은 테스트를 위해 REPEATABLE-READ로 변경했습니다.   이후 AUTO-COMMIT 옵션도 꺼주었습니다. SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;     테스트 시나리오    last_name 컬럼에 인덱스가 있는 상태에서 ‘김하늘’ 회원의 나이를 업데이트하는 트랜잭션을 시작   첫 번째 트랜잭션이 완료되지 않은 상태에서, 다른 세션에서 ‘김도현’ 회원의 나이를 업데이트 시도   트랜잭션과 락의 동작 방식 확인    테스트 진행  1. 첫 번째 세션에서 트랜잭션 시작  세션1 실행   세션1 설정된 잠금 확인     2. 두 번째 세션에서 업데이트 시도  세션2 무한 실행상태 (완료 안되고 진행아이콘 원이 계속 돌아감)   이후 에러코드    프로세스 목록 확인   트랜잭션 상태 확인   세션 2의 트랜잭션이 LOCK WAIT 상태에 들어갔습니다.  이는 세션 1이 ‘김’씨 성에 해당하는 인덱스에 대한 잠금을 보유하고 있어, 세션 2는 이 잠금이 해제될 때까지 기다려야 한다는 것을 의미합니다.   3. 잠금 해제와 트랜잭션 완료 세션1 커밋   커밋 후 다시 확인   결론          InnoDB는 레코드가 아닌 인덱스를 잠금             레코드 자체가 아닌, 해당 레코드를 찾는 데 사용된 인덱스에 잠금을 설정                ‘김하늘’ 한 명의 레코드만 업데이트했지만, ‘김’씨 성에 해당하는 인덱스가 잠겨 같은 성을 가진 ‘김도현’의 업데이트도 대기 상태에 진입했습니다.           서로 다른 인덱스 값은 독립적으로 작동             ‘김’씨 성에 대한 인덱스 잠금이 ‘박’씨 성에는 영향을 미치지 않습니다.           데이터베이스 설계 시 고려사항  수정 작업(UPDATE)이 많이 발생하는 테이블에서는 중복 값이 많은 컬럼에 인덱스 설정을 지양하고, ‘성’과 같이 중복 값이 많은 컬럼에 인덱스를 설정하면 동시성이 크게 저하될 수 있을것 같다. "
  },
  
  {
    "title": "BOJ_1208_부분수열의 합 2 (Java)",
    "url": "/posts/BOJ1208%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-12 00:39:09 +0900",
    "content": "[Gold I] 부분수열의 합 2 - 1208  문제 링크  성능 요약  메모리: 98592 KB, 시간: 672 ms  분류  이분 탐색, 중간에서 만나기  제출 일자  2025년 5월 10일 18:15:10  문제 설명  N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 40, |S| ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.  출력  첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.     문제 풀이   중간에서 만나기를 사용했다.  너무 길어 $2^{40}$이 되면 연산이 초과나므로 $2^{20}$으로 두 부분으로 나눴다. 이러면 10억보다 작아서 가능.  한쪽을 HashMap에 값과 개수를 저장하고,  나머지 배열에서 (N-S) 와 같은 느낌으로 합해서 N을 만들지만 이전에 S가 있었다면 이번에 N-S를 찾는 느낌으로 이런 값을 찾아서 있으면 그 개수만큼씩 반영.      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, S;     static int[] arr1, arr2;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1208_부분수열의합2/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         S = Integer.parseInt(st.nextToken());          st = new StringTokenizer(br.readLine());         arr1 = new int[N / 2];         arr2 = new int[N - arr1.length];          for (int i = 0; i &lt; arr1.length; i++) {             arr1[i] = Integer.parseInt(st.nextToken());         }         for (int i = 0; i &lt; arr2.length; i++) {             arr2[i] = Integer.parseInt(st.nextToken());         }          HashMap&lt;Integer, Long&gt; arr1CombCnt = new HashMap&lt;&gt;();         for (int i = 0; i &lt; (1 &lt;&lt; arr1.length); i++) {             int sum = 0;             for (int j = 0; j &lt; arr1.length; j++) {                 if ((i &amp; (1 &lt;&lt; j)) != 0) sum += arr1[j];             }             arr1CombCnt.put(sum, arr1CombCnt.getOrDefault(sum, 0L) + 1);         }          long res = 0;          for (int i = 0; i &lt; (1 &lt;&lt; arr2.length); i++) {             int sum = 0;             for (int j = 0; j &lt; arr2.length; j++) {                 if ((i &amp; (1 &lt;&lt; j)) != 0) sum += arr2[j];             }             int target = S - sum;             if (arr1CombCnt.containsKey(target)) res += arr1CombCnt.get(target);         }         if (S == 0) res--;         System.out.println(res);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "PGMS_ 성분으로 구분한 아이스크림 총 주문량 (SQL)",
    "url": "/posts/PGMS-%EC%84%B1%EB%B6%84%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EB%B6%84%ED%95%9C-%EC%95%84%EC%9D%B4%EC%8A%A4%ED%81%AC%EB%A6%BC-%EC%B4%9D-%EC%A3%BC%EB%AC%B8%EB%9F%89-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-05-10 17:36:33 +0900",
    "content": "[level 2] 성분으로 구분한 아이스크림 총 주문량 - 133026  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  Empty  제출 일자  2025년 05월 10일 17:34:09  문제 설명  다음은 아이스크림 가게의 상반기 주문 정보를 담은 FIRST_HALF 테이블과 아이스크림 성분에 대한 정보를 담은 ICECREAM_INFO 테이블입니다. FIRST_HALF 테이블 구조는 다음과 같으며, SHIPMENT_ID, FLAVOR, TOTAL_ORDER 는 각각 아이스크림 공장에서 아이스크림 가게까지의 출하 번호, 아이스크림 맛, 상반기 아이스크림 총주문량을 나타냅니다. FIRST_HALF 테이블의 기본 키는 FLAVOR입니다.           NAME TYPE NULLABLE            SHIPMENT_ID INT(N) FALSE   FLAVOR VARCHAR(N) FALSE   TOTAL_ORDER INT(N) FALSE          ICECREAM_INFO 테이블 구조는 다음과 같으며, FLAVOR, INGREDITENT_TYPE 은 각각 아이스크림 맛, 아이스크림의 성분 타입을 나타냅니다. INGREDIENT_TYPE에는 아이스크림의 주 성분이 설탕이면 sugar_based라고 입력되고, 아이스크림의 주 성분이 과일이면 fruit_based라고 입력됩니다. ICECREAM_INFO의 기본 키는 FLAVOR입니다. ICECREAM_INFO테이블의 FLAVOR는 FIRST_HALF 테이블의  FLAVOR의 외래 키입니다.           NAME TYPE NULLABLE            FLAVOR VARCHAR(N) FALSE   INGREDIENT_TYPE VARCHAR(N) FALSE            문제  상반기 동안 각 아이스크림 성분 타입과 성분 타입에 대한 아이스크림의 총주문량을 총주문량이 작은 순서대로 조회하는 SQL 문을 작성해주세요. 이때 총주문량을 나타내는 컬럼명은 TOTAL_ORDER로 지정해주세요.    예시  예를 들어 FIRST_HALF 테이블이 다음과 같고           SHIPMENT_ID FLAVOR TOTAL_ORDER            101 chocolate 3200   102 vanilla 2800   103 mint_chocolate 1700   104 caramel 2600   105 white_chocolate 3100   106 peach 2450   107 watermelon 2150   108 mango 2900   109 strawberry 3100   110 melon 3150   111 orange 2900   112 pineapple 2900          ICECREAM_INFO 테이블이 다음과 같다면           FLAVOR INGREDIENT_TYPE            chocolate sugar_based   vanilla sugar_based   mint_chocolate sugar_based   caramel sugar_based   white_chocolate sugar_based   peach fruit_based   watermelon fruit_based   mango fruit_based   strawberry fruit_based   melon fruit_based   orange fruit_based   pineapple fruit_based          상반기에 아이스크림의 주 성분이 설탕인 아이스크림들에 대한 총주문량을 구하면 3,200 + 2,800 + 1,700 + 2,600 + 3,100 = 13,400입니다.  아이스크림의 주 성분이 과일인 아이스크림들에 대한 총주문량을 구하면 3,100 + 2,450 + 2,150 + 2,900 + 3,150 + 2,900 + 2,900 = 19,550입니다. 따라서 총주문량이 작은 순서대로 조회하는 SQL 문을 실행하면 다음과 같이 나와야 합니다.            INGREDIENT_TYPE TOTAL_ORDER            sugar_based 13400   fruit_based 19550              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   JOIN하여 ingredient별 가격을 구한 뒤 group화 하고 합을 구했다.     코드        SELECT ii.INGREDIENT_TYPE, SUM(fh.TOTAL_ORDER) AS TOTAL_ORDER         FROM FIRST_HALF AS fh             JOIN ICECREAM_INFO AS ii                 ON fh.FLAVOR = ii.FLAVOR                     GROUP BY ii.INGREDIENT_TYPE   "
  },
  
  {
    "title": "Real MySQL - Ch 4",
    "url": "/posts/Real-MySQL/",
    "categories": "데이터베이스",
    "tags": "Database, RealMySQL 8.0",
    "date": "2025-05-10 17:15:23 +0900",
    "content": "     Ch 04. 아키텍처        MySQL 서버는 MySQL엔진 + 스토리지 엔진으로 구성된다.     4.1 MySQL 엔진 아키텍처  MySQL 서버는 다른 DBMS에 비해 구조가 독특하다.  MySQL 서버 전체 구조     MySQL 엔진: 프론트, 기획자, 옵티마이제이션 및 실행계획을 세움   스토리지 엔진: 백엔드, 실무자, 세워진 계획을 실제로 실행            스토리지 엔진에 따라 트랜잭션 처리 방법이 달라진다.       스토리지 엔진에서 보는 트랜잭션과, MySQL 엔진에서 보는 테이블락은 다르다.            4.1.1 MySQL 전체 구조     MySQL의 독특한 구조            MySQL 은 plugin 형태로 잘 나뉘어짐                    장점 : 유지보수 좋다           단점 : 예상과 다른 동작을 할 수 있는 복잡하다                           MySQL 엔진            SQL 인터페이스       SQL 파서       SQL 옵티마이저       캐시 &amp; 버퍼           스토리지 엔진            InnoDB       MyISAM       Memory       성능 향상을 위해서 키 캐시(MyISAM) 버퍼풀 (InnoDB)            4.1.1.1 MySQL 엔진     커넥션 핸들러 : 클라이언트로부터의 접속 및 쿼리 요청   SQL 파서   전처리기   옵티마이저 : 쿼리의 최적화된 실행   ANSI SQL (American Standard SQL 지원)    4.1.1.2 스토리지 엔진     실제 데이터를 디스크 스토리지에 저장하거나, 디스크 스토리지로부터 데이터를 읽어오는 부분을 담당   MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다. 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기 작업이나 변경 작업은 정의된 스토리지 엔진이 처리한다.     InnoDB 스토리지 엔진       CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB           캐싱하는 법            MyISAM 키캐시       InnoDB 버퍼 풀            4.1.1.3 핸들러 API     MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청, 이를 핸들러(Handler) 요청 이라고 함   핸들러 API : 핸들러 요청에 사용되는 API    SHOW GLOBAL STATUS LIKE 'Handler%' - 얼마나 많은 데이터(레코드) 작업이 있었는지 확인 가능    4.1.2 MySQL 스레딩 구조  MySQL 서버는 스레드 기반으로 작동.    Foregroud(포그라운드) 스레드   Background(백그라운드) 스레드  실행중인 스레드 목록     SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema, threads ORDER BY type, thread_id                4.1.2.1 포그라운드 스레드(클라이언트 스레드)     클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 스레드, 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재      기본적으론 클라이언트 당 thread   클라이언트 요청시 스레드가 한개씩 연결        쓰레드를 만드는 비용이 크기 때문에 쓰레드 캐시 라는 형태로 미리 만들어놓음 =&gt; 따라서 실제 접속한 클라이언트보다 살짝 더 많은 쓰레드가 존재할 수 있음           thread_cache_size : 쓰레드 캐시에 유지할 수 있는 최대 쓰레드 개수 설정 변수      쓰레드 풀과 쓰레드 캐시는 다르다!            쓰레드 캐시는 그냥 쓰레드를 미리 생성해 놓고, 연결해준다                    요청과 쓰레드가 1 대 1 매핑, 처리 종료 시에 쓰레드 캐시에 쓰레드가 max 개수를 넘어가면 해당 쓰레드를 종료           쓰레드 캐시에 max 보다 작으면 반환                       쓰레드 풀은 만들어 놓은 쓰레드를 재사용할 수 있다                    요청과 쓰레드가 1 대 1 매핑이 아니라, 요청이 큐 자료구조로 들어간다                            4.1.2.2 백그라운드 스레드  아래 여러 작업들이 백그라운드로 처리된다.     Insert Buffer(인서트 버퍼)를 병합하는 스레드   로그를 디스크로 기록하는 스레드   InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드   데이터를 버퍼로 읽어 오는 스레드   잠금이나 데드락을 모니터링하는 스레드    4.1.3 메모리 할당 및 사용 구조     MySQL 서버 내에 존재하는 많은 쓰레드가 공유해서 사용하는 공간인지 여부에 따라 글로벌 메모리 영역 과 로컬 메모리 영역 으로 구분   1. 글로벌 메모리 영역  클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.  모든 스레드에 의해 공유된다.  - InnoDB 버퍼 풀 - MyISAM 키 캐시 - Binary 로그 버퍼 - Redo 로그 버퍼 - 테이블 캐시   2. 세션(커넥션) 로컬 메모리 영역  MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역  각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.  - Join 버퍼 - 정렬(Sort) 버퍼 - 네트워크 버퍼 - Read 버퍼     4.1.4 플러그인 스토리지 엔진 모델     ex) 전문 검색 엔진을 위한 검색어 파서, 사용자 인증을 위한 Native Authentication, Caching SHA-2 Authentication     ‘데이터 읽기/쓰기’ 작업은 대부분 1건의 레코드 단위로 처리  MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 한다.     Handler_ 로 시작하는 상태변수 : ‘MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수’        MyISAM / InnoDB 와 같이 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하면 데이터 읽기/쓰기 영역의 차이 =&gt; GROUP BY , ORDER BY 등 복잡한 처리는 스토리지 영역이 아닌 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리      하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다.   mysql&gt; SHOW ENGIENS;   Support 컬럼  Yes : MySQL 서버에 해당 스토리지 엔진 포함, 사용 가능으로 활성화 상태 DEFAULT : YES 와 동일 = 필수 스토리지 엔진(없으면 MySQL 시작 안될 수 있음) NO : 현재 MySQL 서버에 포함 X, 사용하려면 MySQL 서버 다시 빌드(컴파일) 필요 DISABLED : 현재 MySQL 서버에 포함, 파라미터에 의해 비활성화 상태 플러그인 형태로 빌드된 스토리지 엔진 라이브러리 다운로드해서 사용 가능 -&gt; 손쉽게 업그레이드 가능   4.1.5 컴포넌트  MySQL 8.0 부터 기존의 플러그인 아키텍처를 컴포넌트 아키텍처로 대체함  플러그인 단점    오직 MySQL 서버와 인터페이스할 수 있고 플러그인끼리 통신 불가   MySQL 서버의 변수나 함수를 직접 호출하기 때문에 불안전(캡슐화 안됨)   상호 의존 관계를 설정할 수 없어 초기화 어려움   MySQL 5.7까지 비밀번호 검증 기능이 플러그인 형태 -&gt; MySQL 8.0은 컴포넌트로 개선   mysql&gt; INSTALL COMPONENT 'file://component_validate_password';     4.1.6 쿼리 실행 구조  쿼리 파서 사용자 요청으로 들어온 쿼리 문장을 토큰(MySQL이 인식할 수 있는 최소 단위의 어휘나 기호)으로 분리해 트리 형태의 구조로 만들어 내는 작업  쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지 전달  전처리기 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인  각 토큰을 테이블 이름, 칼럼 이름, 내장함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체 접근 권한 등을 확인하는 과정  실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러진다.  옵티마이저 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정  DBMS의 두뇌  실행 엔진 DBMS의 손과 발  만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행  ex) 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블 사용  \t1. 실행 엔진이 핸들러에게 임시 테이블 만들라고 요청     2. 다시 실행 엔진은 WHERE 절에 일치하는 레코드를 저장하라고 다시 핸들러에게 요청   핸들러(스토리지 엔진) MySQL 가장  4.1.7 복제(Replication)  4.1.8 쿼리 캐시(Query Cache) SQL 실행 결과를 메모리에 캐시, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과 반환  테이블의 데이터 변경 시 캐시에 저장된 결과 중에서 변경된 테이블과 관련된 것들은 모두 삭제(Invalidate) -&gt; 동시 처리 성능 저하 유발, 많은 버그 원인  MySQL 8.0 부터 제거   4.1.9 스레드 풀  MySQL 서버 엔터프라이즈 에디션에서만 제공하는 기능  내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많아도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게하여 서버 자원 소모를 줄이는 목적  스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우 쿼리 처리가 더 느려질 수도 있음  제한된 수의 스레드만으로 CPU가 처리하도록 유도하면 CPU의 프로세서 친화도 상승, 불필요한 컨텍스트 스위치를 줄여 오버헤드 감소 가능  CPU 코어 개수와 맞추는 것이 CPU 프로세서 친화도 상승 가능  MySQL 서버가 처리해야 할 요청이 생기면 스레드 풀로 처리를 이관하는데 이미 스레드 풀이 처리 중인 작업이 있는 경우, thread_pool_oversubscribe (기본값 3) 에 설정 된 개수만큼 추가로 더 받아들여 처리하는데 너무 크면 스케줄링 해야 할 스레드가 많아져 스레드 풀이 비효율적으로 작동 가능  스레드 그룹의 모든 스레드가 일을 처리하면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할 지 아니면 기존 작업 스레드가 처리를 완료할 때까지 기다릴 지 여부 판단     thread_pool_stall_limit 시스템 변수 에 정의된 밀리초만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성하여 스레드 그룹에 추가   전체 스레드 풀에 있는 스레드의 개수는 thread_pool_max_threads 시스템 변수에 설정된 개수를 넘을 수 없음   응답 시간에 민감한 서비스면 thread_pool_stall_limit 을 낮춰 설정하지만 0과 가까운 값으로 설정 비추천(스레드 풀 사용하는 이유 없음)   Percona Server = 플러그인 형태  선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능 제공  먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰서 전체적인 처리 성능 향상 가능   4.1.10 트랜잭션 지원 메타 데이터    데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보   MySQL 5.7 까지 테이블의 구조를 FRM 파일 에 저장하고 일부 스토어드 프로그램 또한 파일 기반 으로 관리          파일 기반 은 생성 및 변경 작업이 트랜잭션을 지원하지 않아 테이블의 생성 또는 변경 도중 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제 발생(데이터베이스나 테이블이 깨졌다)           MySQL 8.0 부터 InnoDB 테이블 에 저장      시스템 테이블(MySQL 서버가 작동하는 데 기본적으로 필요한 테이블)을 InnoDB 스토리지 엔진을 사용, 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아 mysqlDB 에 저장   mysql DB는 mysql.ibd 테이블 스페이스에 저장   InnoDB 스토리지 엔진 이외의 스토리지 엔진을 사용하는 테이블을 위해 SDI(Seriaized Dictionary Information) 파일 사용(기존의 *.FRM 파일과 동일)    4.2 InnoDB 스토리지 엔진 아키텍처  InnoDB 가 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공하여 높은 동시성 처리, 안정적, 뛰어난 성능 제공   4.2.1 프라이머리 키에 의한 클러스터링    InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장   프라이머리 키값의 순서대로 디스크에 저장, 모든 세컨데리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용  쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정  오라클 DBMS의 IOT(Index organized table)와 동일한 구조  MyISAM 스토리지 엔진    클러스터링 키 지원 안하여 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스일 뿐이다.   프라이머리 키를 포함한 모든 인덱스는 레코드의 주소 값(ROWID) 가지고 있다.    4.2.2 외래 키 지원     InnoDB 스토리지 엔진에서 지원하는 기능        다른 엔진에서는 지원하지 않음     데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터 베이스에서는 생성 안함      부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요하고 변경 시에는 반드시 부모/자식 테이블에 데이터가 있는 지 체크하는 작업 필요하여 잠금이 여러 테이블로 전파되고 데드락이 발생함  수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업 실패 가능  foreign_key_checks 시스템 변수를 OFF로 설정하면 체크 작업 일시적으로 멈출 수 있음 -&gt; 외래 키 관계의 부모 테이블에 작업도 무시     foreign_key_checks 시스템 변수는 적용 범위를 GLOBAl, SESSION 모두 설정 가능. 반드시 현재 작업을 실행하는 세션에서만 기능을 멈추는 것을 추천.   mysql&gt; SET foreign_key_checks=OFF; mysql&gt; SET SESSION foreign_key_checks=OFF;   SESSION 키워드 명시하지 않으면 자동으로 현재 세션의 설정만 변경 작업 완료 후, 반드시 현재 세션을 종료하거나 현재 세션의 외래 키 체크를 다시 활성화 처리 추천   4.2.3 MVCC(Multi Version Concurrency Control)    멀티 버전 = 하나의 레코드에 대해 여러 개의 버전이 동시에 관리   잠금을 사용하지 않는 일관된 읽기 제공  InnoDB는 Undo log를 이용  INSERT 문 실행시 아래와 같이 바뀜  mysql&gt; UPDATE member SET m_area='경기' WHER m_id=12;            UPDATE 문장이 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀은 새로운 값으로 업데이트되지만 디스크의 데이터 파일은 새로운 값으로 업데이트 될 수도 있고 아닐 수도 있음(InnoDB는 ACID를 보장하기 때문에 InnoDB의 버퍼 풀과 데이터 파일은 동일한 상태라고 가정해도 무방)           commit 이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 레코드 조회를 하면 MySQL 서버의 transaction_isolation에 설정된 Isolation level에 따라 다른 값이 나옴.           READ_UNCOMMITED인 경우, InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환           READ_COMMITTED나 그 이상의 격리 수준(REPEATABLE_READ, SERALIZABLE)인 경우 커밋 전이기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경 전 내용을 보관하고 있는 언두 영역의 데이터 반환 =&gt; MVCC           COMMIT 명령을 실행하면 InnoDB는 더 이상 변경 작업 없이 지금의 상태를 영구적인 데이터로 변환           롤백 실행하면 InnoDB는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구, 언두 영역의 내용을 삭제           커밋이 된다고 바로 언두 영역의 백업 데이터가 삭제되지 않고 필요로 하는 트랜잭션이 더는 없을 때 삭제       4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)    MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업 수행   격리 수준이 SERALIZABLE이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 인 경우 INSERT와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행  트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료 추천   4.2.5 자동 데드락 감지  내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리  주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그중 하나를 강제 종료  어느 것을 먼저 강제 종료할 것인지 판단하는 기준은 트랜잭션의 언두 로그 양, 언두 로그 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상  InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 볼 수 없어서 데드락 감지 불확실  =&gt; innodb_table_locks 활성화 하면 가능  동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐  =&gt; 더 많은 CPU 자원 소모          innodb_deadlock_detect=OFF 로 설정하면 작동 X  =&gt; 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황이 발생해도 누군가가 중재를 하지 않기 때문에 무한정 대기           innodb_lock_wait_timeout 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패 후 에러 메시지 반환, 초단위로 설정 가능, 50초보다 낮은 시간 추천       4.2.6 자동화된 장애 복구  손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘 탑재  MySQL 서버와 무관하게 디스크나 하드웨어 이슈로 자동 복구 못하는 경우 innodb_force_recovery 시스템 변수 설정해서 MySQL 서버 시작  MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 mysqldump 를 이용해 데이터를 가능한 만큼 백업하고 MySQL 서버의 DB와 테이블을 다시 생성 추천  만약 MySQL 서버가 시작되지 않으면 백업 이용하여 다시 구축    마지막 백업으로 데이터베이스를 새로 구축, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터 복구   InnoDB 복구보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 적음   백업은 있지만 복제의 바이너리 로그가 없거나 손실됐다면 마지막 백업 시점까지만 복구 가능   4.2.7 InnoDB 버퍼 풀    InnoDB 스토리지 엔진에서 가장 핵심적인 부분 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간   쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업 횟수 줄일 수 있음   버퍼 풀 크기 설정 운영체제와 각 클라이언트 스레드가 사용할 메모리 고려하여 설정  레코드 버퍼는 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간  커넥션이 많고 사용하는 테이블도 많으면 많이 필요  레코드 버퍼 공간은 별도 설정 불가, 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라서 결정     MySQL 5.7부터 동적조절 가능 크기를 줄이는 방법은 서비스의 영향도가 크기 때문에 비추천 128MB 청크 단위로 쪼개어 관리되어 줄이거나 늘릴 때 128MB 단위로 처리 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금 경합을 많이 유발했지만 여러개로 쪼개어 관리할 수 있게 개선 innodb_buffer_pool_instances로 여러 개로 분리해서 관리하고 각 버퍼 풀을 버퍼 풀 인스턴스 8개로 초기화, 메모리 크기가 1GB 미만이면 하나 생성   버퍼풀의 구조          페이지 크기(innodb_page_size)의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 읽어서 각 조각에 저장      프리 리스트 : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록   LRU 리스트 : LRU + MRU 리스트   디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기 최소화  자주 사용되면 MRU에 계속 있고, 아니면 LRU의 끝으로 밀려나서 InnoDB버퍼풀에서 제거    더티 페이지 : 디스크로 동기화되지 않은 데이터를 가진 페이지   플러시 리스트는 더티페이지의 변경 시점 기준의 페이지  목록 관리     데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에 반영(보장 X)    버퍼 풀과 리두 로그  ** 버퍼 풀**    서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링   메모리 공간 늘리면 캐시 기능 향상   ** 리두 로그 **    1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용   재사용 가능한 공간과 불가능한 공간을 구분(Active Redo Log)   체크 포인트 에이지는 활성 리두 로그 공간의 크기   더티 페이지는 특정 리두 로그 엔트리와 관계, 체크 포인트 발생하면 체크포인트 LSN(Long Sequence Number) 보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화    버퍼 풀 플러시(Buffer Pool Flush) InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 동기화 하기 위해 Flush list 플러시, LRU 리스트 플러시 실행  플러시 리스트 플러시         InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 리두 로그 앤트리가 사용하는 공간을 비워야하는데, 이 때 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화 필요           플러시 리스트 플러시 함수를 호출해 동기화           더티 페이지를 디스크로 동기화 하는 클리너 스레드가 하나의 버퍼 풀 인스턴스 처리하도록 자동으로 맞춰 줌           더티 페이지가 많으면 디스크 쓰기 폭발 현상 발생 가능           어뎁티브 플러시를 사용하면 버퍼 풀의 더티 페이지 비율이나 설정값 의존하지 않고 알고리즘 사용      LRU 리스트 플러시         LRU 리스트의 끝부분부터 시작해서 설정 개수의 페이지들 스캔하면서 더티 페이지는 디스크에 동기화           클린 페이지는 프리 리스트로 옮겨짐       버퍼 풀 상태 백업 및 복구          MySQL 5.6 부터 도입           백업된 내용을 각 테이블의 데이터 페이지를 다시 디스크에서 읽어와야 되서 시간이 많이 걸림      버퍼 풀의 적재 내용 확인     MySQL 5.6부터 innodb_buffer_page 테이블에서 적재 확인 가능   InnoDB 버퍼 풀이 큰 경우 조회가 느려져서 MySQL 8.0부터 innodb_cached_indexes 테이블 추가    4.2.8 Double Write Buffer  InnoDb 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록하고 더티페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생 가능     Partial-page, Torn-page 문제            페이지가 일부만 기록되는 현상       Redo 로그가 페이지 전체가 아니라 변경된 내용만 기록하기 때문에 발생           Double-Write 를 통해 문제를 해결            HDD 에서는 좋지만, SSD 에서는 Double-Write 를 비활성화하는게 좋음            4.2.9 언두 로그(Undo Log)  InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 Insert, Update, Delete 로 변경되기 이전 버전의 데이터를 별도로 백업  Transaction 과 Isolation Level 에 필요         트랜잭션 보장 트랜잭션이 롤백 되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해 둔 이전 버전 데이터를 이용해 복구           격리 수준 보장 특정 커넥션에서 데이터 변경하는 도중에 다르 커넥션에서 데이터 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.       언두 로그 레코드 모니터링  MySQL 8.0 에서 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이거나 MySQL 서버가 필요한 시점에 사용 공간을 자동으로 조절  언두 테이블스페이스 관리     언두로그가 저장되는 공간   MySQL 8.0부터 시스템 테이블 스페이스 외부의 별도 로그 파일에 기록  언두 로그 슬롯이 부족하면 트랜잭션을 시작 못하여 언두 테이블 스페이스와 롤백 세그먼트의 개수를 설정  자동/수동 모드를 통해 언두 테이블스페이스의 불필요한 공간을 잘라서 이용   4.2.10 체인지 버퍼  InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트 수행하지만 그렇지 않고 디스크로부터 읽어와서 업데이트 해야한다면 즉시 실행 안하고 임시 공간에 저장하여 사용자에게 반환하는 형태로 성능 향상     쿼리 속도를 빠르게 해줌    4.2.11 Redo 로그 및 로그 버퍼     ACID 중 D(Durable)   서버가 비정상적으로 종료시, 기록되지 못한 데이터를 잃지 않게 해줌   데이터 변경 내용을 Redo Log 로 기록해서, 변경실패시 재요청      리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정 권장    리두 로그 아카이빙  MySQL8.0 부터 가능  데이터 파일을 복사하는 동안 리두 로그에 쌓인 내용을 계속 추적하면서 새로 추가된 리두 로그 엔트리를 복사  리두 로그 활성화 및 비활성화  MySQL 8.0 부터 활성화 비활성화 처리 가능   4.2.12 어댑티브 해시 인덱스     사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스   인덱스 키 값은 B-Tree 인덱스의 고유 번호와 B-Tree 인덱스의 실제 키 값 조합으로 생성  데이터 페이지 주소는 실제 키 값이 저장된 데이터 페이지의 메모리 주소이며 InnoDB 버퍼 풀에 로딩괸 페이지의 주소  해시 인덱스 히트율과 어댑티브 해시 인덱스가 사용중인 메모리 공간, 서버의 CPU 사용량을 종합해서 판단    4.3 MyISAM 스토리지 엔진 아키텍처     InnoDB 가 압도적으로 우세하므로 간단하게만 정리   4.3.1 키 캐시  InnoDB 의 버퍼 풀과 비슷한 역할  인덱스만을 대상으로 작동   4.3.2 운영체제의 캐시 및 버퍼  데이터에 대해서는 어떠한 캐시나 버퍼링 기능도 없다.  데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기 or 쓰기 작업으로 요쳥될 수 밖에 없다.   4.3.3 데이터 파일과 프라이머리 키(인덱스) 구조     InnoDB 스토리지 엔진에서는 프라이머리 키에 의해 클러스터링 되었지만,   MyISAM 은** 클러스터링 없이 데이터파일이 힙(Heap) 공간처럼 활용된다.**      4.4 MySQL 로그 파일     서버 깊은 내부 지식 없이도 서버 상태나 부하 일으키는 원인 쉽게 찾을 수 있다.   4.4.1 에러 로그 파일     실행 도중 발생하는 에러나 경고 메시지의 로그 파일   my.cnf 에서 log_error 에 정의된 경로에 .err 확장자 파일로 생성됨    4.4.2 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)     실행된 쿼리가 무엇이 있었는지 확인가능한 로그   my.cnf 의 general_log_file 에 정의된 경로에 생성   로그를 파일이 아닌 테이블에 저장하도록 할 수도 있음    4.4.3 슬로우 쿼리 로그     long_query_time 으로 설정한 실행 시간을 초과한 쿼리들을 기록   쿼리 실행시간을 통계낼 때 편리한 로그  "
  },
  
  {
    "title": "트랜잭션과 격리 수준 (+ InnoDB Transaction Model )",
    "url": "/posts/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-InnoDB-Transaction-Model/",
    "categories": "데이터베이스",
    "tags": "Database, InnoDB, mysql",
    "date": "2025-05-07 19:47:20 +0900",
    "content": "   앞서, 그림들은 직접 제작했습니다. 사용할 때 출처 작성해주세요   트랜잭션      💡 여러 작업들을 하나로 묶은 단위로, 이렇게 묶인 작업들은 모두 실행되거나 모두 실행되지 않는다(all-or-nothing).   읽기와 쓰기를 하나의 논리적 단위로 묶는 방법이라고 정의할 수 있다.    하나의 트랜잭션 안에서 실패하면 트랜잭션 내부에서 했던 작업이 다시 진행하여도 동일한 결과를 얻을 수 있도록 트랜잭션의 처음으로 rollback 하여 내부에서 진행했던 작업을 초기화한다.  트랜잭션 내에서 실패하지 않고 정상적으로 동작을 하면 commit 을 통해 조작한 데이터를 실제적으로 적용한다.    ACID 특성           원자성(Atomicity)     트랜잭션의 모든 연산이 정상적으로 수행 완료되거나 아니면 어떠한 연산도 수행되지 않는 원래 상태가 되도록 해야한다.            일관성(Consistency)     고립(동시에 수행되는 트랜잭션이 없는)상태에서 트랜잭션이 데이터베이스의 일관성을 보존해야 한다.            고립성(Isolation)     여러 트랜잭션이 동시에 수행된다 하더라도, 임의의 트랜잭션 $T_1$과 $T_2$ 쌍이 있을때 시스템은 $T_1$ 에게 $T_1$이 시작되기 전에 $T_2$ 수행을 마쳤거나 $T_1$이 종료된 후에 $T_2$ 가 수행을 시작하는 것과 같이 되도록 보장해야 한다.      즉, 각각의 트랜잭션은 다른 트랜잭션이 동시에 수행되고 있는지 알지 못하는 것과 동일하게 해야한다.            지속성(Durability)     트랜잭션이 성공적으로 수행되면 시스템에 오류(정전, 네트워크 이슈 등등)가 발생한다 하더라도 영구적으로 반영되어야 한다.       다음 글 참조    트랜잭션 격리 수준     💡 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 여부를 결정하는 것.   트랜잭션의 격리 수준은 격리(고립) 수준이 높은 순서대로 SERIALIZABLE, REPEATABLE READ, READ COMMITTED, READ UNCOMMITED가 존재한다. 참고로 아래의 예제들은 모두 자동 커밋(AUTO COMMIT)이 false인 상태에서만 발생한다.    1️⃣ SERIALIZABLE    가장 엄격한 격리수준. 이름 그대로 트랜잭션을 순차적으로 진행시킨다.   여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없으므로, 어떠한 데이터 부정합 문제도 발생하지 않는다. 하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어진다.   MySQL에서 SELECT ... FOR SHARE , SELECT ... FOR UPDATE 는 대상 레코드에 각각 읽기 잠금 / 쓰기 잠금을 거는 것이다.  일반 SELECT 문은 아무 레코드 잠금 없이 실행되고, 이를 잠금 없는 일관된 읽기(Non-locking consistent read) 라고 한다.   하지만 SERIALIZABLE 격리 수준에서는 일반 SELECT 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유락, Shared Lock)으로 건다. 따라서 한 트랜잭션에서 넥스트 키 락이 걸린 레코드를 다른 트랜잭션에서는 절대 추가/수정/삭제할 수 없다.  SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안된다.    2️⃣ REPEATABLE READ     MVCC ( Multi Version Concurrency Control )   일반 RDBMS에서는 변경 전 레코드를 언두 공간에 백업해둔다. 이를 통해 변경 전/후 데이터가 모두 존재하므로, 동일한 레코드에 대해 여러 버전이 존재한다.      트랜잭션이 롤백된 경우에 데이터를 복원   서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어    각각의 트랜잭션은 순차 증가하는 고유한 트랜잭션 번호가 존재하며, 백업 레코드에는 어느 트랜잭션에 의해 백업되었는지 트랜잭션 번호를 함께 저장한다.  해당 데이터가 불필요해진다고 판단하는 시점에 주기적으로 백그라운드 쓰레드를 통해 삭제한다.      REPEATABLE READ는 MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있다.     Ex) 트랜잭션을 시작하고, id = 10 이상인 레코드를 조회시 1건 조회되는 상황      다른 사용자 A의 트랜잭션에서 id=10인 레코드를 갱신하면 MVCC를 통해 기존 데이터는 변경되지만, 백업된 데이터가 언두 로그에 남게 된다.    이전에 사용자 B가 데이터를 조회했던 트랜잭션은 아직 종료되지 않은 상황에서, 사용자 B가 다시 한번 동일한 SELECT 문을 실행하면 어떻게 될까? 그 결과는 아래와 같다.    사용자 B의 트랜잭션은(5) 사용자 A의 트랜잭션(10)이 시작하기 전에 이미 시작된 상태다.  이때 REPEATABLE READ는 트랜잭션 번호를 참고하여 자신보다 먼저 실행된 트랜잭션의 데이터만을 조회한다. 만약 테이블에 자신보다 이후에 실행된 트랜잭션의 데이터가 존재한다면 언두 로그를 참고해서 데이터를 조회한다.   사용자 A의 트랜잭션이 시작되고 커밋까지 되었지만, 해당 트랜잭션(10)는 현재 트랜잭션(5)보다 나중에 실행되었기 때문에 조회 결과로 기존과 동일한 데이터를 얻게 된다.     즉, REPEATABLE READ는 어떤 트랜잭션이 읽은 데이터를 다른 트랜잭션이 수정하더라도 동일한 결과를 반환할 것을 보장해준다.     앞서 설명하였듯 REPEATABLE READ는 새로운 레코드의 추가 까지는 막지 않는다고 하였다. 따라서 SELECT로 조회한 경우 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견될 수 있는데, 이를 Phantom Read(유령 읽기)라고 한다.  하지만 MVCC 덕분에 일반적인 조회에서 유령 읽기(Phantom Read)는 발생하지 않는다. 왜냐하면 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기 때문이다. 이러한 상황을 그림으로 표현하면 다음과 같다.    Q. 그렇다면 언제 유령 읽기가 발생하는 것일까?     잠금이 사용되는 경우이다.   MySQL은 다른 RDBMS와 다르게 특수한 갭 락이 존재하기 때문에, 동작이 다른 부분이 있으므로 일반적인 RDBMS 경우부터 살펴보도록 하자.     Ex) 사용자 B가 데이터 조회하는 경우 ( 잠금 사용 )   사용자B가 먼저 데이터를 조회하는데, 이번에는 SELECT … FOR UPDATE 를 이용해 쓰기 잠금을 걸었다.   여기서 SELECT … FOR UPDATE 구문은 베타적 잠금(비관적 잠금, 쓰기 잠금)을 거는 것이다. 읽기 잠금을 걸려면 SELECT ... FOR SHARE 구문을 사용해야 한다. 락은 트랜잭션이 커밋 또는 롤백될 때 해제된다.   읽기 잠금 : 데이터를 읽는 동안 다른 트랜잭션이 해당 데이터를 변경하지 못하도록 보호 쓰기 잠금 : 데이터를 독점적으로 사용하기 위해, 다른 트랜잭션의 읽기/쓰기 모두 차단      이후 사용자 A가 새로운 데이터를 INSERT하는 상황   일반적인 DBMS에서는 갭락이 존재하지 않으므로 id = 10인 레코드만 잠금이 걸린 상태이고, 사용자 A의 요청은 잠금 없이 즉시 실행된다.     이때 사용자 B가 동일한 쓰기 잠금 쿼리로 다시 한번 데이터를 조회하면, 이번에는 2건의 데이터가 조회된다. 동일한 트랜잭션 내에서도 새로운 레코드가 추가되는 경우에 조회 결과가 달라지는데, 이렇듯 다른 트랜잭션에서 수행한 작업에 의해 레코드가 안보였다 보였다 하는 현상을 Phantom Read(유령 읽기)라고 한다. 이는 다른 트랜잭션에서 새로운 레코드를 추가하거나 삭제하는 경우 발생할 수 있다.    이 경우에도 MVCC를 통해 해결될 것 같지만, 두 번째 실행되는 SELECT ... FOR UPDATE 때문에 그럴 수 없다. 왜냐하면 잠금있는 읽기는 데이터 조회가 언두 로그가 아닌 테이블에서 수행되기 때문이다. 잠금있는 읽기는 테이블에 변경이 일어나지 않도록 테이블에 잠금을 걸고 테이블에서 데이터를 조회한다.  잠금이 없는 경우처럼 언두 로그를 바라보고 언두 로그를 잠그는 것은 불가능한데, 그 이유는 언두 로그가 append only 형태이므로 잠금 장치가 없기 때문이다.  따라서 SELECT ... FOR UPDATE나 SELECT ... FOR SHARE로 레코드를 조회하는 경우에는 언두 영역의 데이터가 아니라 테이블의 레코드를 가져오게 되고, 이로 인해 Phantom Read가 발생하는 것이다.    하지만 MySQL에는 Gap Lock(갭 락) 이 존재하기 때문에 위의 상황에서 문제가 발생하지 않는다. 사용자 B가 SELECT ... FOR UPDATE로 데이터를 조회한 경우에 MySQL은 id가 10인 레코드에는 레코드 락, id가 10보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다.  따라서 사용자 A가 id가 11인 user를 INSERT 시도한다면, B의 트랜잭션이 종료(커밋 또는 롤백)될 때 까지 기다리다가, 대기를 지나치게 오래 하면 락 타임아웃이 발생하게 된다.    따라서 일반적으로 MySQL의 REAPEATABLE READ에서는 Phantom Read가 발생하지 않는다.    MySQL에서 Phantom Read가 발생하는 거의 유일한 케이스는 다음과 같다.    사용자 B는 트랜잭션을 시작하고, 잠금없는 SELECT 문으로 데이터를 조회하였다. 그리고 사용자 A는 INSERT 문을 사용해 데이터를 추가하였다. 이때 잠금이 없으므로 바로 COMMIT 된다. 하지만 사용자 B가 SELECT ... FOR UPDATE로 조회를 했다면, 언두 로그가 아닌 테이블로부터 레코드를 조회하므로 Phantom Read가 발생한다.     하지만 이러한 케이스는 거의 존재하지 않으므로, MySQL의 REPEATABLE READ에서는 PHANTOM READ가 발생하지 않는다고 봐도 된다.    3️⃣ READ COMMITTED     READ COMMITTED는 커밋된 데이터만 조회할 수 있다.   READ COMMITTED는 REPEATABLE READ에서 발생하는 Phantom Read에 더해 Non-Repeatable Read(반복 읽기 불가능) 문제까지 발생한다.     Ex) 사용자 A가 트랜잭션을 시작하여 어떤 데이터를 변경하였고, 아직 커밋은 하지 않은 상태   그러면 테이블은 먼저 갱신되고, 언두 로그로 변경 전의 데이터가 백업된다.     이때 사용자 B가 데이터를 조회하려고 하면, READ COMMITTED에서는 커밋된 데이터만 조회할 수 있으므로, REPEATABLE READ와 마찬가지로 언두 로그에서 변경 전의 데이터를 찾아서 반환하게 된다.  최종적으로 사용자 A가 트랜잭션을 커밋하면 그때부터 다른 트랜잭션에서도 새롭게 변경된 값을 참조할 수 있는 것이다.   하지만 READ COMMITTED는 Non-Repeatable Read(반복 읽기 불가능) 문제가 발생할 수 있다.    Ex) 사용자 B가 트랜잭션을 시작하고 name = “Grace”인 레코드를 조회하는 상황   해당 조건을 만족하는 레코드는 아직 존재하지 않으므로 아무 것도 반환되지 않는다.    그러다가 사용자 A가 UPDATE 문을 수행하여 해당 조건을 만족하는 레코드가 생겼다.  사용자 A의 작업은 커밋까지 완료된 상태이다. Q. 사용자 B가 다시 동일한 조건으로 레코드를 조회하면 어떻게 될까?  READ COMMITTED 는 커밋된 데이터는 조회할 수 있도록 허용하므로 결과가 나오게 된다.   READ COMMITTED에서 반복 읽기를 수행하면 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다. 따라서 이러한 데이터 부정합 문제를 Non-Repeatable Read(반복 읽기 불가능)라고 한다.   Non-Repeatable Read는 일반적인 경우에는 크게 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 생길 수 있다.  예를 들어 어떤 트랜잭션에서는 오늘 입금된 총 합을 계산하고 있는데, 다른 트랜잭션에서 계속해서 입금 내역을 커밋하는 상황이라고 하자.  그러면 READ COMMITTED에서는 같은 트랜잭션일지라도 조회할 때마다 입금된 내역이 달라지므로 문제가 생길 수 있는 것이다.    따라서 격리 수준이 어떻게 동작하는지, 그리고 격리 수준에 따라 어떠한 결과가 나오는지 예측할 수 있어야 한다.   READ COMMITTED 수준에서는 애초에 커밋된 데이터만 읽을 수 있기 때문에 트랜잭션 내에서 실행되는 SELECT와 트랜잭션 밖에서 실행되는 SELECT의 차이가 별로 없다.    4️⃣ READ UNCOMMITED     READ UNCOMMITTED는 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준이다.   READ UNCOMMITTED에서는 다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 보이게 된다.      Ex) 사용자 A의 트랜잭션에서 INSERT를 통해 데이터를 추가하는 상황.   아직 커밋 또는 롤백이 되지 않은 상태임에도 불구하고 READ UNCOMMITTED는 변경된 데이터에 접근할 수 있다.    이렇게 어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제를 Dirty Read(오손 읽기)라고 한다.  Dirty Read는 데이터가 조회되었다가 사라지는 현상을 초래하므로 시스템에 상당한 혼란을 주게 된다.  Q. 만약 위의 경우에 사용자 A가 커밋이 아닌 롤백을 수행한다면 어떻게 될까?   사용자 B의 트랜잭션은 id = 11인 데이터를 계속 처리하고 있을 텐데, 다시 데이터를 조회하니 결과가 존재하지 않는 상황이 생긴다. 이러한 Dirty Read 상황은 시스템에 상당한 버그를 초래할 것이다.  그래서 READ UNCOMMITTED는 RDBMS 표준에서 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다. 따라서 MySQL을 사용한다면** 최소한 READ COMMITTED 이상의 격리 수준을 사용**해야 한다.      +) 공식문서 번역본.      InnoDB Transaction Model      InnoDB transaction Model의 목적은 multi-versioning 데이터베이스의 속성을 전통적인 2 단계 잠금과 결합하는 것이다.  InnoDB는 행 수준에서 lock을 수행하고, 기본적으로 Oracle 스타일인 nonlocking consistent reads 방식으로 쿼리를 실행한다. InnoDB의 lock 정보는 공간적으로 효율적이게 저장되므로, ***** lock escalation이 필요하지 않다. 일반적으로 여러 사용자에게 InnoDB 메모리 낭비를 유발하지 않으면서, InnoDB 테이블의 모든 행, 임의의 행 하위 집합을 lock 할 수 있게 한다.  * Lock escalation 락 에스컬레이션이란 많은 작은 단위의 락(세밀한 락)을 더 적은 수의 큰 단위 락(넓은 범위의 락)으로 전환하는 과정.  Ex)  시작 상황: 데이터베이스가 테이블의 많은 개별 행들에 대해 각각 락을 걸고 있음 문제 발생: 락이 너무 많아져서 데이터베이스 메모리에 부담이 생김 해결 방법: 시스템이 자동으로 여러 개의 행 락을 하나의 테이블 락으로 변환함  장점:    - 메모리 사용량을 줄일 수 있음    - 락 부족으로 인한 오류(SQL0912N)를 방지할 수 있음  단점:    - 동시성이 떨어짐 (여러 사용자가 동시에 같은 테이블을 사용하기 어려워짐)    - 다른 애플리케이션의 테이블 접근을 방해할 수 있음  쉽게 비유하자면, 마치 개별 좌석에 대한 예약을 전체 구역 예약으로 바꾸는 것과 비슷하다. 관리는 쉬워지지만, 다른 사람들이 그 구역의 좌석을 사용할 수 없게 된다.     Transaction Isolation Levels   Isolation은 데이터베이스 작업의 기본 중 하나이다. ACID 약어 중 I는 isolation 이다. isolation level은 여러 트랜잭션이 동시에 데이터를 변경하고, 쿼리를 수행할 때, 결과의 성능, 안정성, 일관성, 재현성 간의 균형을 조정하는 단계이다.  InnoDB는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ 그리고 SERIALIZABLE의 4 가지 트랜잭션 isolation level을 모두 제공한다.  InnoDB의 기본 isolation level은 REPEATABLE READ 이다.    사용자는 SET TRANSACTION 문으로 단일 세션 또는 모든 후속 연결의 isolation level을 변경할 수 있다. 모든 연결에 대해 서버의 기본 isolation level을 설정하려면, command line 또는 옵션 파일에서 --transaction-isolation 옵션을 사용하면 된다. (isolation level 및 level 설정 문법에 대한 자세한 내용은 13.3.7 “SET TRANSACTION Statement”을 참조)    InnoDB는 여러 트랜잭션 isolation 레벨을 지원하는데, 각 레벨은 여기에 설명된대로 각각 다른 locking 전략을 사용한다.  ACID를 준수해야 하는 중요한 데이터라면, 일관성 정도를 기본적으로 REPEATABLE READ 레벨로 높이는 것이 좋다.  하지만 매우 정확할 필요가 없는 경우이거나 반복적 읽기를 할 때 일관성을 유지해야 것이 덜 중요한 bulk reporting과 같은 경우, 일관성 규칙을 완화하면서 locking에 의한 overhead를 최소화하기 위해 READ COMMITTED 또는 READ UNCOMMITTED를 사용하는 것도 좋다.  SERIALIZABLE은 REPEATABLE READ보다 더 엄격한 규칙을 적용하며, 주로 XA 트랜잭션과 같은 특수한 상황과 동시성, deadlock 문제를 해결하는 데 사용된다.  다음은 MySQL이 지원하는 트랜잭션 레벨에 대해 설명한다. 가장 일반적으로 사용되는 레벨에서 가장 적게 사용 되는 레벨 순으로 정렬되어 있다.    💡 REPEATABLE READ  InnoDB의 isolation 레벨 기본값이다. consistency reads는 같은 트랜잭션 내에서 첫 번째 읽기에서 설정된 스냅 샷을 읽는다. 이는 동일한 트랜잭션 내에서 (nonlocking) SELECT 문을 여러 번 사용하는 경우, SELECT 문의 결과가 일관성이 있음을 의미한다.  locking reads ( SELECT ... FOR UPDATE, SELECT ... FOR SHARE ), UPDATE 그리고 DELETE 문의 경우, locking은 명령문이 unique 한 검색 조건으로 unique index를 사용하는지, 범위 유형 검색 조건을 사용하는지에 따라 다르다.          unique 한 검색 조건을 가진 unique 인덱스의 경우, InnoDB는 검색된 인덱스 레코드만 lock 하고, 그 이전의 gap에 대해서는 lock 하지 않는다.           그렇지 않은 조건으로 검색하는 경우, InnoDB는 gap lock 또는 next-key lock을 사용하여 검색된 index 범위를 lock 해, 다른 세션이 해당 범위를 포함하는 gap으로 삽입되는 것을 차단한다.        💡 READ COMMITTED  각각의 consistent read는 동일한 트랜잭션 내에 있을 일지라도 자신만의 신선한 스냅샷을 설정하고 읽는다.  locking reads(SELECT ... FOR UPDATE, SELECT ... FOR SHARE), UPDATE 그리고 DELETE 문의 경우, InnoDB는 index record만 lock 하고, 이전의 gap은 하지 않는다. 그래서 lock 된 곳 다음에 새 레코드를 자유롭게 삽입 할 수 있다. gap lock은 foreign-key constraint 검사와 duplicate-key 검사에만 사용된다.  gap locking이 비활성화 되어 있기 때문에, 다른 세션에서 gap에 새로운 row를 삽입 할 수 있으므로, phantom 문제가 발생할 수 있다.  READ COMMITTED isolation level에서는 행 기반 binary 로깅만 지원된다. binlog_format = MIXED와 함께 READ COMMITTED를 사용하면 서버는 자동으로 행 기반 로깅을 사용한다.  READ COMMITTED를 사용하면 다음과 같은 효과가 있다.          UPDATE, DELETE 문의 경우, InnoDB는 업데이트하거나 삭제하는 행에 대해서만 lock을 유지한다. 행에 대한 레코드 lock은 MySQL이 WHERE 조건을 평가 했을 때 일치하지 않는 경우 해제된다. 이로써 deadlock이 발생할 가능성이 크게 줄어들지만 여전히 발생할 가능성이 있다.           UPDATE 문의 경우, 행이 이미 lock을 얻었다면 InnoDB는 행이 UPDATE문의 WHERE 조건과 일치하는지를 MySQL이 결정할 수 있게, 가장 최신의 커밋된 버전을 MySQL로 반환하는 “semi-consistent” 읽기를 수행한다. 일치하나는 경우(업데이트해야 한다) MySQL은 행을 다시 읽고 이번에는 InnoDB가 행을 lock 하거나 lock을 얻기위해 기다린다.        다음 예제를 보자.  CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB; INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);  COMMIT;   이 경우 테이블에 index가 없어서 검색과 index 스캔은 indexed columns 대신 record locking을 위해 hidden clustered index(Section 15.6.2.1, “Clustered and Secondary Indexes”를 참고)를 사용한다.  한 세션이 다음 명령문을 사용하여 UPDATE를 수행한다고 가정해보자.  # Session A  START TRANSACTION;  UPDATE t SET b = 5 WHERE b = 3;   이번에는 두 번째 세션이 다음의 명령문을 실행하여 UPDATE를 수행한다고 가정해보자.  # Session B  UPDATE t SET b = 4 WHERE b = 2;   InnoDB는 UPDATE를 실행할 때마다, 우선 각 행에 대해 exclusive lock을 획득 한 후, 수정할지 여부를 결정한다. InnoDB가 행을 수정하지 않으면, lock이 해제된다. 수정하는 경우 InnoDB는 트랜잭션이 끝날 때까지 lock을 유지한다. 이는 계속되는 설명과 같이 트랜잭션 처리에 영향을 주게된다.  isolation 레벨의 기본값인 REPEATABLE READ 사용하는 경우, 첫 번째의 UPDATE는 각 행에서 x-lock을 획득한 후, 행을 읽고 lock을 해제하지 않는다.  x-lock(1,2); retain x-lock  x-lock(2,3); update(2,3) to (2,5); retain x-lock  x-lock(3,2); retain x-lock  x-lock(4,3); update(4,3) to (4,5); retain x-lock  x-lock(5,2); retain x-lock   두 번째의 UPDATE는 lock을 획득하려고 시도 하자마자 (첫 번째 UPDATE가 모든 행에 대한 잠금을 유지하고 있기 때문에) 차단당한다. 첫 번째 UPDATE가 커밋되거나 롤백 될 때까지 진행되지 않는다.  x-lock(1,2); block and wait for first UPDATE to commit or roll back   READ COMMITTED를 사용하는 경우, 첫 번째 UPDATE는 각 행에서 x-lock을 획득하고 수정되지 않을 행에 대해 x-lock을 반환한다.  x-lock(1,2); unlock(1,2)  x-lock(2,3); update(2,3) to (2,5); retain x-lock  x-lock(3,2); unlock(3,2)  x-lock(4,3); update(4,3) to (4,5); retain x-lock  x-lock(5,2); unlock(5,2)   두 번째 UPDATE의 경우, InnoDB는 “semi-consistent” 읽기를 수행하여, MySQL이 UPDATE의 WHERE 조건과 행이 일치하는지 여부를 판별 할 수 있도록, MySQL로 읽는 각 행의 가장 최신의 커밋된 버전을 리턴합니다.  x-lock(1,2); update(1,2) to (1,4); retain x-lock  x-lock(2,3); unlock(2,3)  x-lock(3,2); update(3,2) to (3,4); retain x-lock  x-lock(4,3); unlock(4,3)  x-lock(5,2); update(5,2) to (5,4); retain x-lock   그러나 WHERE 조건에 indexed column이 포함되어 있고, InnoDB가 인덱스를 사용하는 경우, record lock을 수행하고 유지할 때 indexed column만 고려된다. 다음 예에서 첫 번째 UPDATE는 b = 2 인 각 행에서 x-lock을 가져와서 유지한다. 두 번째 UPDATE도 마찬가지로 column b에 정의된 index를 사용하므로 동일한 레코드에서 x-lock을 획득하려고 할 때 차단된다.  CREATE TABLE t (a INT NOT NULL, b INT, c INT, INDEX (b)) ENGINE = InnoDB;  INSERT INTO t VALUES (1,2,3),(2,2,4); COMMIT;   # Session A  START TRANSACTION;  UPDATE t SET b = 3 WHERE b = 2 AND c = 3;   # Session B  UPDATE t SET b = 4 WHERE b = 2 AND c = 4;   READ COMMITTED isolation level은 server를 시작할 때 설정하거나 런타임에 변경될 수 있다. 런타임시 모든 세션에 대해 전체적으로 설정하거나 개별적인 세션별로 설정할 수도 있다.    💡 READ UNCOMMITTED  SELECT 문은 nonlocking 방식으로 수행되지만, 이전 버전의 행이 사용될 가능성이 있다. 따라서 이 isolation 수준을 사용하면 일관성 있는 읽기를 하기 어렵다. 이 방식을 dirty read라고 부르기도 한다. 그 반대로의 isolation level은 READ COMMITTED와 같이 작동힌다.    💡 SERIALIZABLE  REPEATABLE READ와 비슷하지만 autocommit이 비활성화 된 경우 InnoDB는 모든 일반 SELECT 문을 암시적으로 SELECT ... FOR SHARE와 같이 변환시킨다. autocommit이 활성화 된 경우 SELECT는 자체적으로 트랜잭션이 된다. 따라서, 읽기 전용으로 알려져 있고, 일관된(nonlocking) 읽기로 수행되고 다른 트랜잭션을 차단할 필요가 없는 경우 직렬화 할 수 있습니다. (다른 트랜잭션이 선택한 행을 수정하는 경우 일반 SELECT를 강제로 차단하려면 자동 복제를 사용하지 않도록 설정하자.)       References        트랜잭션과 무결성     Lock escalation     트랜잭션의 격리 수준     InnoDB Locking and Transaction Model     "
  },
  
  {
    "title": "BOJ_2258_정육점 (Java)",
    "url": "/posts/BOJ2258%EC%A0%95%EC%9C%A1%EC%A0%90-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-06 15:21:56 +0900",
    "content": "[Gold III] 정육점 - 2258  문제 링크  성능 요약  메모리: 43920 KB, 시간: 492 ms  분류  그리디 알고리즘, 정렬  제출 일자  2025년 5월 6일 15:16:41  문제 설명  은혜는 정육점에서 고기를 사려고 한다. 보통 정육점에서는 자신이 원하는 양을 이야기하면 그 양만큼의 고기를 팔지만, 은혜가 방문한 정육점에서는 세일 행사를 하고 있었기 때문에 N 덩어리의 고기를 이미 잘라놓고 판매하고 있었다.  각각의 덩어리들은 이미 정해져 있는 무게와 가격이 있는데, 어떤 덩어리를 샀을 때에는 그 덩어리보다 싼 고기들은 얼마든지 덤으로 얻을 수 있다(추가 비용의 지불 없이). 또한 각각의 고기들은 부위가 다를 수 있기 때문에 비용과 무게와의 관계가 서로 비례하는 관계가 아닐 수도 있다. 은혜는 이러한 점을 고려하지 않고, 어느 부위든지 자신이 원하는 양만 구매하면 되는 것으로 가정한다. 또한 만약 가격이 더 싸다면 은혜가 필요한 양보다 더 많은 고기를 살 수도 있다.  각 덩어리에 대한 정보가 주어졌을 때, 은혜가 원하는 양의 고기를 구매하기 위해 필요한 최소 비용을 계산하는 프로그램을 작성하시오.  입력  첫째 줄에 두 정수 N(1 ≤ N ≤ 100,000), M(1 ≤ M ≤ 2,147,483,647)이 주어진다. N은 덩어리의 개수를 의미하고, M은 은혜가 필요한 고기의 양이다. 다음 N개의 줄에는 각 고기 덩어리의 무게와 가격을 나타내는 음 아닌 두 정수가 주어진다. 무게의 총 합과 가격의 총 합은 각각 2,147,483,647을 넘지 않는다.  출력  첫째 줄에 답을 출력한다. 불가능한 경우에는 -1을 출력한다.     문제 풀이     가격 기준으로 오름차순한다. 가격이 같으면 더해야하고 가격이 높아지면 그 가격으로도 아래가격 고기 다 살 수 있다. 그리고 고기 무게는 내림차순으로 무거운것부터 같은 가격으로 사면 좋으니 그렇게 정렬기준을 세운다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Meat implements Comparable&lt;Meat&gt;{         int w, p;         public Meat(int w, int p) {             this.w = w;             this.p = p;         }          @Override         public int compareTo(Meat o) {             if(this.p == o.p) return o.w - this.w;             return this.p - o.p;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static long res = Long.MAX_VALUE;     static Meat[] meat;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2258_정육점/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         meat = new Meat[N];         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             meat[i] = new Meat(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));         }          Arrays.sort(meat);          int prevP=0;         int Wsum=0;         int currP=0;         for(Meat m : meat) {             if(m.p &gt; prevP) {                 prevP = m.p;                 currP = m.p;             }             else if(m.p == prevP) currP+=m.p;              Wsum += m.w;              if(Wsum &gt;= M) res = Math.min(res, currP);         }          if (Wsum &lt; M || res &gt; 2_147_483_647) res = -1;          System.out.println(res);          br.close();     } }  "
  },
  
  {
    "title": "BOJ_8983_사냥꾼 (Java)",
    "url": "/posts/BOJ8983%EC%82%AC%EB%83%A5%EA%BE%BC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-06 13:26:05 +0900",
    "content": "[Gold IV] 사냥꾼 - 8983  문제 링크  성능 요약  메모리: 57164 KB, 시간: 608 ms  분류  이분 탐색, 정렬  제출 일자  2025년 5월 6일 03:32:53  문제 설명  KOI 사냥터에는 N 마리의 동물들이 각각 특정한 위치에 살고 있다. 사냥터에 온 사냥꾼은 일직선 상에 위치한 M 개의 사대(총을 쏘는 장소)에서만 사격이 가능하다. 편의상, 일직선을 x-축이라 가정하고, 사대의 위치 x1, x2, ..., xM은 x-좌표 값이라고 하자. 각 동물이 사는 위치는 (a1, b1), (a2, b2), ..., (aN, bN)과 같이 x,y-좌표 값으로 표시하자. 동물의 위치를 나타내는 모든 좌표 값은 양의 정수이다.  사냥꾼이 가지고 있는 총의 사정거리가 L이라고 하면, 사냥꾼은 한 사대에서 거리가 L 보다 작거나 같은 위치의 동물들을 잡을 수 있다고 한다. 단, 사대의 위치 xi와 동물의 위치 (aj, bj) 간의 거리는 |xi-aj| + bj로 계산한다.  예를 들어, 아래의 그림과 같은 사냥터를 생각해 보자. (사대는 작은 사각형으로, 동물의 위치는 작은 원으로 표시되어 있다.) 사정거리 L이 4라고 하면, 점선으로 표시된 영역은 왼쪽에서 세 번째 사대에서 사냥이 가능한 영역이다.    사대의 위치와 동물들의 위치가 주어졌을 때, 잡을 수 있는 동물의 수를 출력하는 프로그램을 작성하시오.  입력  입력의 첫 줄에는 사대의 수 M (1 ≤ M ≤ 100,000), 동물의 수 N (1 ≤ N ≤ 100,000), 사정거리 L (1 ≤ L ≤ 1,000,000,000)이 빈칸을 사이에 두고 주어진다. 두 번째 줄에는 사대의 위치를 나타내는 M개의 x-좌표 값이 빈칸을 사이에 두고 양의 정수로 주어진다. 이후 N개의 각 줄에는 각 동물의 사는 위치를 나타내는 좌표 값이 x-좌표 값, y-좌표 값의 순서로 빈칸을 사이에 두고 양의 정수로 주어진다. 사대의 위치가 겹치는 경우는 없으며, 동물들의 위치가 겹치는 경우도 없다. 모든 좌표 값은 1,000,000,000보다 작거나 같은 양의 정수이다.   출력  출력은 단 한 줄이며, 잡을 수 있는 동물의 수를 음수가 아닌 정수로 출력한다.     문제 풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int M, N, L;     static TreeSet&lt;Integer&gt; tset = new TreeSet&lt;&gt;();     static List&lt;int[]&gt; animals = new ArrayList&lt;&gt;();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_8983_사냥꾼/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         M = Integer.parseInt(st.nextToken());         N = Integer.parseInt(st.nextToken());         L = Integer.parseInt(st.nextToken());           st = new StringTokenizer(br.readLine());         for(int i=0; i&lt;M; i++) {             tset.add(Integer.parseInt(st.nextToken()));         }          for(int i=0; i&lt;N; i++) {             st = new StringTokenizer(br.readLine());             int x = Integer.parseInt(st.nextToken());             int y = Integer.parseInt(st.nextToken());             animals.add(new int[]{x, y});         }         int res = 0;         for(int[] a : animals) {             int v = L - a[1];             if(v&lt;0) continue;              int left, right;             left = 0;             right = 0;              left = Math.max(1, a[0] - v);             right = Math.min(1_000_000_000, a[0] + v);              if(tset.ceiling(left) != null &amp;&amp; tset.ceiling(left) &lt;= right) res++;         }         System.out.println(res);         br.close();     } }  "
  },
  
  {
    "title": "BOJ_15942_Thinkinh Heap (Java)",
    "url": "/posts/BOJ15942Thinkinh-Heap-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-05-05 02:16:24 +0900",
    "content": "[Gold II] Thinking Heap - 15942  문제 링크  성능 요약  메모리: 32644 KB, 시간: 288 ms  분류  해 구성하기, 그리디 알고리즘  제출 일자  2025년 5월 5일 01:58:41  문제 설명  Binary heap은 Heap을 구현하는 방법의 하나이며 Complete binary tree 형태로 만들어진다. Complete binary tree는 Binary tree의 종류 중 하나로, 마지막 레벨을 제외한 나머지 레벨에는 노드가 꽉 차 있고 마지막 레벨에는 노드들이 왼쪽으로 쏠려있는 모습을 하고 있다.    Complete binary tree는 1차원 배열을 이용하면 쉽게 구현할 수 있다. Complete binary tree의 각 노드에 아래 그림과 같은 식으로 번호를 붙이고 이를 1차원 배열에서의 index로 삼으면 자연스럽게 구현할 수 있다.    이를 이용하면 Binary min-heap에 원소를 삽입하는 알고리즘을 간단하게 구현할 수 있다. 아래 코드는 삽입 알고리즘을 C++로 구현한 코드이다(코드의 자잘한 문제들은 신경 쓰지 않기로 한다). 코드의 insert_heap() 함수를 호출하면 우리가 만든 Binary min-heap에 원소가 적절히 삽입된다.    비어있는 Binary min-heap에 1 이상 N 이하의 서로 다른 자연수 N개를 insert_heap() 함수를 이용해 삽입할 것이다. N개의 자연수를 전부 다 삽입한 후에, 자연수 k가 heap 배열의 p번째(배열의 맨 처음 공간을 0번째로 생각한다)에 위치하도록 하고 싶다. 이렇게 만드는 삽입 순서를 찾는 프로그램을 작성하시오.  입력  첫 번째 줄에 자연수 N(1 ≤ N ≤ 200,000)이 주어진다. 두 번째 줄에 자연수 k와 p(1 ≤ k, p ≤ N)가 공백으로 구분되어 주어진다.  출력  자연수 k가 heap 배열의 p번째에 위치하도록 하는 삽입 순서가 존재한다면 i번째 줄에 i번째로 삽입할 수를 출력한다. 가능한 삽입 순서가 여러 가지라면 그중 아무거나 하나를 출력해도 된다. 만약 그렇게 만드는 삽입 순서가 존재하지 않는다면 첫 번째 줄에 -1을 출력한다.  문제 풀이    minHeap의 작동원리상 특정 노드에 영향을 주려면 연결된 부모이거나 자식노드여야한다.  그러므로 p와 연결된 브랜치 중 부모와 자식을 결정지으면 된다.  먼저 p위치에 k를 넣고 1부터 적절한값을 부모노드에 넣고, N부터 작아지는 적절한 값을 자식노드에 넣은 뒤 상관없는(영향없는) 나머지 노드들을 채워주면 된다.    코드  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, k, p;     static int left, right;     static int[] minHeap; // 넣는 순서 배열     static List&lt;Integer&gt; ancestors = new ArrayList&lt;&gt;();     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15942_ThinkingHeap/input.txt\"))); //        bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         st = new StringTokenizer(br.readLine());         k = Integer.parseInt(st.nextToken());         p = Integer.parseInt(st.nextToken());          minHeap = new int[N+1];          minHeap[p] = k;          // p의 조상 채우기         int idx = p;         while(idx &gt; 1){             idx &gt;&gt;= 1;             ancestors.add(idx);         }         Collections.reverse(ancestors);          // 채워야할 개수가 k 값보다 크면 넘치므로         if(ancestors.size() &gt;= k){             System.out.println(-1);             return;         }          left = 0; // 위에서부터 조상 채우기         for(int a : ancestors){             minHeap[a] = ++left;         }          // p의 자식 채우기         right = N;          if(2*p &lt;= N) dfs(2*p); // 좌         if(2*p + 1 &lt;= N) dfs(2*p + 1); // 우          if(right &lt; k){             System.out.println(-1);             return;         }          // 나머지 빈 칸 적절히 최소힙 되도록 채우기         // 지금 트리는 p조상과 자손 부분을 채웠음 : (1~left) , ... , (k) , ... , (right+1 ~ N)         Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         for(int i=left+1; i&lt;=right; i++){             if(i==k) continue; // 이미 배치한 k값은 제외             queue.add(i);         }         for(int i=1; i&lt;=N; i++){             if(minHeap[i] != 0) continue;             minHeap[i] = queue.poll();         }          for(int i=1; i&lt;=N; i++){             sb.append(minHeap[i]).append(\"\\n\");         }         System.out.println(sb.toString());         br.close();     }      private void dfs(int node) {         minHeap[node] = right--;          if(2*node &lt;= N) dfs(2*node);         if(2*node + 1 &lt;= N) dfs(2*node + 1);     } }  "
  },
  
  {
    "title": "PGMS_물고기 종류 별 대어 찾기 (SQL)",
    "url": "/posts/PGMS%EB%AC%BC%EA%B3%A0%EA%B8%B0-%EC%A2%85%EB%A5%98-%EB%B3%84-%EB%8C%80%EC%96%B4-%EC%B0%BE%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-05-05 00:54:54 +0900",
    "content": "[level 3] 물고기 종류 별 대어 찾기 - 293261  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SUM， MAX， MIN  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 05월 05일 00:49:41  문제 설명  낚시앱에서 사용하는 FISH_INFO 테이블은 잡은 물고기들의 정보를 담고 있습니다. FISH_INFO 테이블의 구조는 다음과 같으며 ID, FISH_TYPE, LENGTH, TIME은 각각 잡은 물고기의 ID, 물고기의 종류(숫자), 잡은 물고기의 길이(cm), 물고기를 잡은 날짜를 나타냅니다.            Column name Type Nullable            ID INTEGER FALSE   FISH_TYPE INTEGER FALSE   LENGTH FLOAT TRUE   TIME DATE FALSE          단, 잡은 물고기의 길이가 10cm 이하일 경우에는 LENGTH 가 NULL 이며, LENGTH 에 NULL 만 있는 경우는 없습니다.  FISH_NAME_INFO 테이블은 물고기의 이름에 대한 정보를 담고 있습니다. FISH_NAME_INFO 테이블의 구조는 다음과 같으며, FISH_TYPE, FISH_NAME 은 각각 물고기의 종류(숫자), 물고기의 이름(문자) 입니다.           Column name Type Nullable            FISH_TYPE INTEGER FALSE   FISH_NAME VARCHAR FALSE            문제  물고기 종류 별로 가장 큰 물고기의 ID, 물고기 이름, 길이를 출력하는 SQL 문을 작성해주세요.  물고기의 ID 컬럼명은 ID, 이름 컬럼명은 FISH_NAME, 길이 컬럼명은 LENGTH로 해주세요. 결과는 물고기의 ID에 대해 오름차순 정렬해주세요. 단, 물고기 종류별 가장 큰 물고기는 1마리만 있으며 10cm 이하의 물고기가 가장 큰 경우는 없습니다.    예시  예를 들어 FISH_INFO 테이블이 다음과 같고           ID FISH_TYPE LENGTH TIME            0 0 30 2021/12/04   1 0 50 2020/03/07   2 0 40 2020/03/07   3 1 20 2022/03/09   4 1 NULL 2022/04/08   5 2 13 2021/04/28   6 0 60 2021/07/27   7 0 55 2021/01/18   8 2 73 2020/01/28   9 1 73 2021/04/08   10 2 22 2020/06/28   11 2 17 2022/12/23          FISH_NAME_INFO  테이블이 다음과 같다면           FISH_TYPE FISH_NAME            0 BASS   1 SNAPPER   2 ANCHOVY          'BASS' 중 가장 큰 물고기는 60cm 로 물고기 ID 가 6이고, 'SNAPPER' 중 가장 큰 물고기는 73cm 로 물고기 ID가 9입니다. 'ANCHOVY' 중 가장 큰 물고기는 73cm 로 물고기 ID가 8입니다. 따라서 물고기 ID(ID) 에 대해 오름차순 정렬한다면 결과는 다음과 같습니다.           ID FISH_NAME LENGTH            6 BASS 60   8 ANCHOVY 73   9 SNAPPER 73              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     JOIN과 더불어 WHERE 조건문에 서브쿼리를 사용해서 일치하는 부분을 선택하도록 구성했다.     코드   SELECT fi.ID, fni.FISH_NAME, fi.LENGTH     FROM FISH_INFO fi         JOIN FISH_NAME_INFO AS fni             ON fi.FISH_TYPE = fni.FISH_TYPE                 WHERE (fi.FISH_TYPE, fi.LENGTH) IN(                     SELECT FISH_TYPE, MAX(LENGTH)                         FROM FISH_INFO                             GROUP BY FISH_TYPE                 )                 ORDER BY fi.ID;  "
  },
  
  {
    "title": "InnoDB에 대한 탐구 - (2)",
    "url": "/posts/InnoDB%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%90%EA%B5%AC-2/",
    "categories": "데이터베이스",
    "tags": "Database, mysql",
    "date": "2025-04-28 19:05:13 +0900",
    "content": "   InnoDB     4. InnoDB 구조  각 구조에 대한 정보를 알기 위해서는 InnoDB In-Memory Structures 와 InnoDB On-Disk Structures 섹션을 확인하길 바란다.  InnoDB가 메모리 및 디스크 상에서 관리하는 데이터들의 구성   자세한 각 구조에 대해 이어서 작성하겠다.    5.1 Buffer Pool      버퍼 풀 (buffer pool)은 메인 메모리 내에서 데이터과 인덱스 데이터가 접근될 때 해당 데이터를 캐시하는 영역이다.    버퍼 풀을 통해서 자주 접근되는 데이터를 메모리에서 바로 획득할 수 있으며 전체 작업의 수행 속도를 증가 시킬 수 있다. MySQL을 위한 서버에서는 물리 메모리의 최대 80%까지를 InnoDB의 버퍼 풀로 할당하여 사용하는 경우가 많다.   대량의 읽기 요청을 효율적으로 처리하기 위해, 버퍼 풀은 데이터를 page 단위로 나누어 관리하며, 한 페이지에는 여러 로우 (row)가 속할 수 있다.  버퍼 풀 캐시의 효율적인 관리를 위해서, 버퍼풀 내의 페이지는 링크드리스트 (linked list) 로 관리한다. 일종의 LRU 알고리즘에 따라 잘 접근되지 않는 데이터 페이지는 캐시에서 제거하는 방식으로 버퍼풀을 관리한다.  실제 사용하고자 하는 애플리케이션에서 자주 사용되는 데이터를 버퍼풀에 어떤 방식으로 캐싱할지 알아 두는 것은 MySQL 튜닝의 중요한 부분이다.   버퍼풀의 LRU 알고리즘   위에서 언급했듯이 InnoDB의 버퍼풀은 링크드리스트를 이용하여 least recentrly used (LRU) 알고리즘을 통해 관리한다.  새로운 페이지를 버퍼풀에 추가하기 위한 페이지 공간이 필요한 경우, 접근이 가장 오래된 페이지를 선정하여 버퍼풀에서 제거하고, 새로운 페이지를 리스트의 중간지점에 삽입하는데 이를 midpoint insertion이라고 한다. 중간지점 삽입 전략을 통해 버퍼풀 전체 리스트를 아래에서 설명할 두가지 리스트로 나누어 관리한다.     전체 리스트의 head는, 최근에 접근된 (young) 페이지들의 리스트를 가리킨다.   전체 리스트의 tail은, 접근 시기가 가장 오래된 (old) 페이지를 가리킨다.       버퍼풀을 리스트 형태로 관리하는 구조      이러한 알고리즘을 통해 사용자 쿼리에서 가장 자주 접근 되는 데이터 페이지들을 new sublist에 보관한다. old sublist에는 잘 접근 되지 않은 데이터를 저장하며, 이후에 eviction 대상으로 선정된다.    알고리즘 전체 순서     버퍼 풀의 3/8 은 old sublist 로 사용된다.   버퍼 풀 전체의 midpoint 는 new sublist의 tail과 old sublist의 head가 만나는 지점이다.   InnoDB가 새로운 데이터 페이지를 버퍼 풀로 읽어오는 경우에는, midpoint (old sublist의 head)에 삽입한다. 여기서 읽어오는 데이터에는 실제 사용자 쿼리에 의해 요청된 데이터도 있을 수 있지만, read-ahead에 의해 자동적으로 읽어오는 데이터도 포함된다.   old sublist에 존재하는 페이지를 접근할 경우 해당 페이지는 “young”이라고 판단 되며, 버퍼풀 전체의 head (new sublist의 head)로 이동된다. 사용자 쿼리나 중간 작업에 의해 실제로 필요해서 접근된 페이지의 겨웅 곧바로 young으로 변경되지만, read-ahead 작업에 의해 접근된 페이지의 경우에는 young으로 취급하지 않는다.   데이터베이스의 작업이 계속 진행됨에 따라서, 버퍼풀에 상주하는 데이터 페이지들 중 자주 접근 되지 않는 페이지는 자연스럽게 리스트이 tail로 이동하게 된다. 이는 직접적으로 데이터를 tail로 옮기는 것이 아닌, young 이 되는 페이지가 앞으로 이동하면서 발생한다.   추가로 old sublist의 페이지들은 새로운 페이지가 midpoint에 삽입 되면서 tail에 가까워지게 된다. 페이지 eviction시점까지 접근되지 않고 tail에 남아있는 페이지는 결국 버퍼 풀에서 삭제되게 된다.   기본적으로 read 쿼리에 의해 직접 접근되는 페이지들은 곧바로 new sublist로 이동하여 더 오랜기간 버퍼 풀에 상주할 수 있게 된다. table scan 쿼리 (mysqldump, 나 WHERE가 없는 SELECT 쿼리) 에 대량의 데이터가 한번에 버퍼 풀에 삽입되는 경우, midpoint 삽입에 의해 old sublist의 대량 데이터들이 모두 버퍼풀에서 삭제되게 된다. 이와 유사하게, read-ahead 작업에 의해 midpoint에 삽입 되었던 데이터가, 단 1번만 접근되더라도 new sublist의 head로 이동하게 되어, 실제 자주 접근되는 데이터가 old tail에 가까워지는 일이 발생할 수도 있다. 이러한 현상을 최적화 하기 위해서는 Making the Buffer Pool Scan Resistant와 Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)를 읽어보길 바란다.  InnoDB의 기본 모니터링 아웃풋의 BUFFER POOL AND MEMORY 섹션에 LRU 알고리즘에 관한 정보가 있으므로, 자세히 보고싶은 경우 Monitoring the Buffer Pool Using the InnoDB Standard Monitor를 참조해보자.  버퍼 풀 관련 설정하기  InnoDB 전체 성능 향상을 위해서 여러가지 측면의 설정을 변경할 수 있다. 아래는 설정에 관한 설명이다.     이상적으로는, 같은 서버에서 동작하는 다른 프로세스들이 쓸만큼 충분한 공간을 남겨둔 채, 대부분의 메모리 공간을 InnoDB의 버퍼 풀로 할당하는 것이 가장 좋다. 버퍼풀의 크기가 클 수록 InnoDB는 in-memory 데이터베이스 처럼 동작하게 되고, 이는 데이터를 디스크에서 한번만 읽으면 되고 이후에는 계속 버퍼풀에서 읽을 수 있게 됨을 말한다. 이러한 설정을 위해서는 Configuring InnoDB Buffer Pool Size을 참조하길 바란다.   충분한 메모리가 있는 64비트 환경에서는 버퍼 풀을 여러 파트로 쪼개서 관리할 수 있다. 이를 통해서 다중 사용자 환경에서 하나의 버퍼풀에 발생하는 여러가지 경합 현상을 완화할 수 있다. 이와 관련된 설정은 Configuring Multiple Buffer Pool Instances를 참조하길 바란다.   테이블 스캔이나 read-ahead 같은 특정한 상황속에서 많은 데이터가 읽어져 버퍼 풀의 기존 데이터를 삭제하는 경우에도, 사용자가 원하는 데이터를 버퍼풀에 계속해서 상주하도록 만들 수 있다. 이와 관련된 설정은 Making the BUffer Pool Scan Resistant를 참조하길 바란다.   곧 요청될 데이터를 미리 예측하여 사용자의 실제요청과 관계없이 비동기적으로 미리 데이터 페이지를 읽어오는 read-ahead 작업을, 언제/어떤방식으로 수행할 지 직접 지정할 수 있다. 이와 관련된 설정은 Configuring InnoDB Buffer Pool Prefetching (Read-Ahear)를 참조하길 바란다.   버퍼풀의 데이터에 대한 백그라운드 플러시 작업을 얼마나 자주 수행할지, 혹은 플러시 주기를 자동적으로 조절할지 말지에 대한 설정을 할 수 있다. 이와 관련된 설정은 Configuring InnoDB Buffer Pool Flushing를 참조하기 바란다.   버퍼 풀 플러시와 관련하여 더 큰 성능 향상으로 위해 세밀하게 조절할 수 있다. 이와 관련된 설정은 Fine-tuning InnoDB Buffer Pool Flushing을 참조하기 바란다.   서버를 재시작 한 이후에 기존의 버퍼 풀 상태를 그대로 유지하여, 길어질 수 있는 warm-up 시간을 줄일 수 있다. 이와 관련된 설정은 [Saving and Restoring the Buffer Pool State]를 참조하기 바란다.   InnoDB Standard Monitor와 버퍼 풀 모니터링  SHOW ENGINE INNODB STATUS 쿼리를 통해 확인할 수 있는 InnoDB의 기본 모니터링 툴에는 버퍼 풀과 관련된 작업에 대한 통계도 제공한다. 버퍼 풀과 관련된 통계자료는 모니터링 아웃풋의 BUFFER POOL AND MEMORY 섹션에서 확인할 수 있으며, 아래의 내용과 유사하게 출력된다.  ---------------------- BUFFER POOL AND MEMORY ---------------------- Total large memory allocated 2198863872 Dictionary memory allocated 776332 Buffer pool size   131072 Free buffers       124908 Database pages     5720 Old database pages 2071 Modified db pages  910 Pending reads 0 Pending writes: LRU 0, flush list 0, single page 0 Pages made young 4, not young 0 0.10 youngs/s, 0.00 non-youngs/s Pages read 197, created 5523, written 5060 0.00 reads/s, 190.89 creates/s, 244.94 writes/s Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000 Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s LRU len: 5720, unzip_LRU len: 0 I/O sum[0]:cur[0], unzip sum[0]:cur[0]   아래의 표는 InnoDB 모니터링 쿼리를 통해 볼 수 있는 버퍼 풀 통계에 대한 설명이다.     출력 되는 정보중 초단위 정보들은 서버 시작부터 현재까지의 누적 자료가 아닌, 가장 마지막 모니터링 쿼리부터 현재까지의 측정 자료이다.   표. InnoDB 버퍼 풀 통계 자료 내용                 항목 이름       출력되는 내용                       Total memory allocated       버퍼 풀에 할당 된 전체 메모리의 바이트 단위 크기                 Dictionary memory allocated       InnoDB의 데이터 딕셔너리에 할당된 메모리의 바이트 단위 크기                 Buffer pool size       버퍼 풀에 할당된 페이지의 갯수                 Free buffers       버퍼 풀의 free list에 존재하는 페이지의 갯수                 Database pages       버퍼 풀의 LRU 전체 리스트에 존재하는 페이지의 갯수                 Old database pages       버퍼 풀의 old LRU sublist에 존재하는 페이지의 갯수                 Modified db pages       현재 버퍼 풀에서 dirty (변경)된 페이지의 갯수                 Pending reads       버퍼 풀에 삽입되길 기다리는 앞으로 read될 page  갯수                 Pending writes LRU       old sublist에 존재하는 페이지 들 중 disk로 플러시 되어야 하는 old page의 갯수                 Pending writes flush list       버퍼풀 전체 리스트 중 체크 포인트 시에 플러시 되어야 하는 페이지의 갯수                 Pending writes single page       버퍼풀의 전체 리스트 중에서 single page write를 기다리는 페이지 갯수                 Pages made young       버퍼풀 전체 LRU 리스트에서 “young”으로 변경된 (old sublist에서 new sublist로 이동 된) 페이지 갯수                 Pages made not young       버퍼풀 전체 LRU 리스트에서 “Young”으로 변경되지 못한 (old sublist에만 계속 상주하는) 페이지 갯수                 youngs/s       old sublist에 존재하는 페이지를 “young”으로 변경하는 페이지 접근 횟수를 초단위로 측정한 값. 자세한 내용은 표 아래의 note 참조                 non-youngs/s       old sublist에 접근은 하지만 “young”으로 만들지 않는 접근 횟수. 자세한 내용은 표 아래의 note 참조                 Pages read       버퍼 풀에서 read된 페이지 갯수 (hit 인듯)                 Pages created       버퍼 풀 내에 생성된 페이지 갯수                 Pages written       버퍼 풀에서 disk로 쓰여진 페이지의 갯수                 reads/s       초당 버퍼풀 페이지 읽기 횟수                 creates/s       초당 버퍼풀에 생성되는 페이지 갯수                 writes/s       초당 버퍼풀에서 disk로 write되는 페이지 갯수                 Buffer pool hit rate       버퍼 풀 히트율. 버퍼 풀 메모리 네에서 바로 읽히는 페이지 vs 디스크에서 읽어오는 페이지                 Young-making rate       페이지 접근이 young 페이지를 생성하는 작업을 유발하는 경우에 대한 비율                 not (young-making rate)       페이지를 접근 함에도 young 페이지 생성을 하지 않는 경우에 대한 비율. 위와 반대이다.                 Pages read ahead       초당 read ahead 작업 횟수                 Pages evicted without access       버퍼풀에서 접근되지 않은 데이터 페이지들의 초당 eviction 페이지 갯수                 Random read ahead       초당 random read ahead 작업 횟수                 LRU len       버퍼풀 전체 LRU 리스트의 페이지 갯수                 unzip_LRU len       버퍼풀 전체 unzip_LRU 리스트의 페이지 갯수                 I/O sum       최근 50초간 버퍼풀 전체 LRU 리스트에서 접근된 페이지 수                 I/O cur       전체 기간동안 버퍼풀 전체 LRU 리스트에서 접근된 페이지 수                 I/O unzip sum       최근 50초간 버퍼풀 전체 unzip_LRU 리스트에서 접근된 페이지 수                 I/O unzip cur       전체 기간동안 버퍼풀 전체 unzip_LRU 리스트에서 접근된 페이지 수           Notes:     youngs/s는 old sublist 에 있는 페이지들에 대해서만 측정된다. 평균값은 전체 페이지 갯수에 대한 평균이 아닌, 페이지 접근 횟수에 대한 평균값이다. 동일한 페이지에 여러번의 접근이 발생할 경우 해당 접근 횟수를 모두 계산한다. 대량 읽기 작업이 없음에도 불구하고 매우 적은 수의 youngs/s가 기록된 경우에는 young 판별을 위한 delay time을 줄이거나, old sublist가 버퍼 풀에서 차지 하는 비중을 늘릴 필요가 있다. old sublist의 비중을 늘릴 경우 페이지 들이 old tail까지 도달하는데 더 많은 시간이 걸리고, 그 추가된 기간동안 다시 접근 되어 young으로 변할 가능성을 늘릴 수 있다.   non-youngs/s는 old sublist에 있는 페이지들에 대해서만 측정된다. 평균값은 전체 페이지 갯수에 대한 평균이 아닌, 페이지 접근 횟수에 대한 평균값이다. 동일한 페이지에 여러번의 접근이 발생할 경우 해당 접근 횟수를 모두 게산한다. 대량의 테이블 스캔 (1번만 읽고 버리는 페이지를 대량 생성)을 수행함에도 불구하고 non-youngs/s가 작다면, young으로 판별을 위한 delay를 늘려서 불필요한 youngs를 방지할 수 있다.   young-making  비율 통계는 old sublist만이 아닌 버퍼 풀 전체 리스트를 대상으로 측정한 값이다. young-making 비율이나 not 비율은 버퍼 풀의 전체 히트 레이트보다는 거의 낮은 값을 갖는다. old sublist에 존재하는 페이지에 대한 히트는 해당 페이지를 new sublist로 옮기는 작업을 유발하고, new sublist에 존재하는 페이지에 대한 히트는 해당 페이지가 new head에서 일정 거리만큼 멀어진 경우에만 다시 new head로 옮기는 작업을 유발한다.   not (young-making rate)는 innodb_old_blocks_time 설정에 의해 정의된 delay 시간에 의해 페이지 접근이 young-making으로 판별되지 않는 접근이나 new sublist에 대한 접근 중 new head로 이동하는 작업을 유발하지 않는 접근의 비율을 나타낸다. 이 값은 위의 설명처럼 old sublist뿐만 아닌 버퍼풀의 전체 LRU 리스트에 대한 값을 측정한다.   버퍼 풀의 server status variables나 INNODB_BUFFER_POOL_STATS 테이블도 InnoDB의 기본 모니터링 아수풋에서 볼 수 있는 결과값들을 제공한다. 자세한 내용은 Querying the INNODB_BUFFER_POOL_STATS Table를 참조하기 바란다.  References    MySQL 8.0 Reference Manual  /  The InnoDB Storage Engine  "
  },
  
  {
    "title": "InnoDB에 대한 탐구 - (1)",
    "url": "/posts/InnoDB%EC%97%90-%EB%8C%80%ED%95%9C-%ED%83%90%EA%B5%AC/",
    "categories": "데이터베이스",
    "tags": "Database, mysql",
    "date": "2025-04-28 19:00:47 +0900",
    "content": "   InnoDB     Introduction to InnoDB in MySQL 8.0  MySQL에서 사용하는 InnoDB는 높은 가용성과 성능을 보장하기 위해 사용되는 다목적 $^*$스토리지 엔진이다. 스토리지 엔진 : 데이터베이스 시스템에서 데이터를 저장, 관리, 검색하는 방법을 담당하는 소프트웨어 컴포넌트다. 데이터베이스의 핵심 부분으로, 데이터가 실제로 디스크에 어떻게 저장되고 메모리에서 어떻게 처리되는지 결정한다. MySQL 8.0에서 기본 스토리지 엔진으로 InnoDB를 사용하며, CREATE TABLE 구문에 ENGINE= 옵션을 추가하여 다른 엔진을 사용하도록 설정할 수 있다.    InnoDB의 주요 장점           사용자의 데이터를 보호하기 위해 commit, rollback 및 crash recovery가 가능한 트랜잭션을 통해 ACID 모델을 지원하는 DML 오퍼레이션 ( 데이터베이스에서 데이터를 조작하기 위한 명령어 )을 제공한다.           Row-level locking과 오라클 스타일의 consistent read를 사용하여 다중 사용자 환경에서의 동시성(concurrency)과 성능을 높인다.           InnoDB 테이블은 디스크에 저장되며, 프라이머리 키에 최적화된 인덱스를 제공한다. 모든 InnoDB 테이블은 프라이머리 키 인덱스를 가지고 있으며, 이들은 모두 clustered index이다.      clustered index : 찾고자 하는 위치를 알기 때문에 바로 그 위치를 찾는것   Non clustered index : 뒤에 목차에서 찾고자 하는 내용의 위치를 찾고 그 위치로 이동하는 것   ##### clustered index           데이터의 진실성(integrity)을 보장하기 위해 Foreign key를 지원한다. Foreign key를 사용한 insert/update/delete와 같은 작업들은 연관된 모든 테이블들에 대해서 제약사항을 위반하지 않는 지 자동 검사된다.      | 기능                                      | 지원 여부                                                    | | ——————————– | ——————————– | | B-tree 인덱스                         | o 지원                                                       | | Backup/point-in-time recovery         | o 지원 (서버에서 지원함)                                     | | Cluster 데이터베이스                  | x 미지원                                                     | | Clustered 인덱스                      | o 지원                                                       | | 데이터 압축                           | o 지원                                                       | | 데이터 캐시                           | o 지원                                                       | | 데이터 암호화                         | o 지원 (서버에서 지원함)                                     | | Foreign key                           | o 지원                                                       | | Full-text search 인덱스               | o 지원 (MySQL 5.7 이상부터)                                  | | Geospatial 데이터 타입                | o 지원                                                       | | Geospatial 인덱싱                     | o 지원 (MySQL 5.7 이상부터)                                  | | Hash 인덱스                           | x 미지원 (내부적인 용도로 Adaptive Hash index를 사용하긴 함) | | Index 캐시                            | o 지원                                                       | | Locking 단위                          | Row (행 단위)                                                | | MVCC                                  | o 지원                                                       | | Replication (서버 단에서 구현)        | o 지원                                                       | | Storage 제한                          | 64TB                                                         | | T-tree 인덱스                         | x 미지원                                                     | | Transaction                           | o 지원                                                       | | Data dictionary 에 대한 통계 업데이트 | o 지원                                                       |   InnoDB 사용자를 위한 추가 자료 및 커뮤니티      InnoDB와 관련된 용어나 정의들을 알고 싶은 경우 [MySQL Glossary]를 참조   InnoDB 스토리지 엔진과 관련된 포럼/커뮤니티 사이트는 [MySQL Forums::InnoDB] 참조   InnoDB는 MySQL의 하위 프로젝트로 GNU GPL Licence Version 2를 따름. 이와 관련된 자세한 사항은 [MySQL Licensing] 참조      1.1 InnoDB 테이블의 장점           아래의 여러가지 이유로 인해서 InnoDB 테이블을 사용하길 권장한다.          데이터베이스를 사용하는 도중에 소프트웨어/하드웨어적인 어떠한 이유로 인해 서버가 강제 종료 될 경우, 데이터베이스를 다시 사용하기위해 특별한 조치를 취할 필요가 없다. InnoDB의 자체적인 crash recovery (장애 복구) 기술은, 종료 이전의 어떠한 커밋 트랜잭션에 대해서든지 모두 정상 완료됨을 보장한다. 종료 전에 커밋되지 않은 데이터들은 자연스럽게 원래 상태로 되돌린다.           InnoDB는 자체적인 buffer pool을 관리하며, 테이블이나 인덱스에 접근할 때 해당 데이터들을 메모리 내에 상주할 수 있도록 한다. 자주 사용되는 데이터의 경우 메모리에서 곧바로 획득할 수 있으며, 단순 데이터가 아닌 다양한 종류의 데이터및 정보들에 대해서도 캐싱을 적용하여 전체 서버의 성능을 높인다. MySQL을 가용하는 데이터베이스 서버의 경우, 실제 물리 메모리의 최대 80% 까지를 InnoDB의 buffer pool 설정하고 사용하는 것이 일반적이다.           관련있는 데이터의 집합을 서로다른 여러개의 테이블로 분리할 경우, foreign key를 사용하여 referential integrity (참조 무결성)을 강제할 수 있다. 데이터를 업데이트하거나 삭제할 경우 연관되어 있는 다른 테이블의 데이터도 적절히 업데이트/삭제한다. Secondary 테이블에 데이터를 삽입 하는 경우, primary table에 해당 데이터가 참조하는 키가 존재하지 않을 경우 자동적으로 삽입이 취소된다.           데이터가 어떠한 이유로 인해 메모리나 디스크 내에서 내용적인 변화 (오류)가 발생할 경우, checksum을 통해 데이터에 변조 위험이 있음을 사용자에게 알린다.           사용자가 적절한 primary key를 사용하여 테이블을 구성한 경우, 해당 컬럼을 참조하는 작업들의 성능이 크게 향상된다. WHERE 절, ORDER BY, GROUP BY 절 및 JOIN 구문에서 Primary key로 지정된 컬럼을 참조하는 경우 처리속도가 매우 빠르다.           INSERT, UPDATE, DELETE 는 change buffering 기술로 자동 최적화가 된다. InnoDB는 같은 테이블에 대해 동시 읽기/쓰기를 지원할 뿐만 아니라, 변경된 데이터를 캐싱하여 디스크 I/O를 최소화시킨다.           캐싱으로 인한 성능상의 이점은 long running 쿼리가 수행되는 대형 테이블에 대해서만 국한되지 않는다. 한 테이블의 같은 행(row)들이 반복적으로 접근 될 경우, Adaptive Hash Index 기법을 적용하여 반복된 lookup 작업을 해시테이블에서 곧바로 데이터를 가져와, 데이터 탐색작업을 더욱 빠르게 수행한다.           테이블과 인덱스들을 압축할 수 있다.           인덱스의 생성과 삭제 작업이 성능과 가용성에 미치는 영향을 최소화한다.           InnoDB가 직접 스페이스를 관리하는 system tablespace와 달리, file-per-table을 삭제하는 작업은 매우 빠르며, 운영체제의 다른 용도로 사용할 수 있도록 디스크 스페이스의 공간을 비워줄 수 있다.                      System Tablespace          정의: 하나의 큰 공유 데이터 파일(또는 파일 집합)로, 여러 테이블의 데이터를 저장한다. 파일명: 일반적으로 ibdata1, ibdata2 등          특징:   여러 테이블의 데이터가 하나의 파일에 저장됨        데이터 사전, 언두 로그, 변경 버퍼 등의 시스템 데이터도 저장        테이블을 삭제해도 파일 크기가 줄어들지 않음 (공간 반환 안 됨)        관리가 복잡할 수 있음                       File-Per-Table Tablespace          정의: 각 InnoDB 테이블이 자신만의 개별 테이블스페이스 파일을 가진다. 파일명: 테이블명.ibd 형식          특징:    테이블별로 별도 파일로 저장됨         테이블을 삭제하면 해당 파일도 완전히 삭제되어 디스크 공간이 운영체제에 즉시 반환됨         테이블별 백업과 복원이 더 쉬움         데이터 관리가 더 유연함         MySQL 8.0부터 기본값으로 설정됨                       DYNAMIC ROW FORMAT 을 사용할 경우, BLOB 데이터와 긴 문자열 필드에 대한 테이블의 스토리지 레이아웃을 더욱 최적화 할 수 있다.           INFORMATION_SCHEMA 쿼리를 사용하여 스토리지 엔진의 내부 동작 상황을 모니터링 할 수 있다.           Performance Schema 쿼리를 사용하여 스토리지 엔진 성능에 관련된 상세 사항을 모니터링 할 수 있다.           MySQL의 다른 스토리지 엔진과 InnoDB 엔진을 섞어서 사용할 수 있으며, 하나의 쿼리 문에 서로다른 엔진을 사용하는 테이블을 섞어 쓸 수도 있다. 예를 들어 JOIN 작업을 사용할 때, InnoDB 엔진을 사용하는 테이블과 MEMORY 엔진을 사용하는 테이블을 동시에 사용할 수 있다.           InnoDB는 대용량의 데이터를 사용할 때 최고의 성능을 제공하고, CPU를 효율적으로 사용하도록 설계되었다.           InnoDB는 파일 사이즈의 최댓값이 2GB로 제한된 환경의 운영체제에서도 그보다 훨씬 큰 대용량의 데이터를 처리할 수 있다.      InnoDB와 관련된 튜닝 기술은 Optimizing for InnoDB Tables를 참조    1.2 Best Practices for InnoDB Tables     InnoDB 테이블을 사용하는 가장 효율적인 방법      테이블을 생성할 때 해당 테이블에서 가장 많이 이용되는 컬럼에 대하여 Primary Key 를 지정한다.   해당하는 컬럼이 없을 경우 Auto-Increment 기능을 사용하여 인덱스를 생성한다.       같은 ID 값을 가진 데이터를 여러 테이블에서 가져오고 싶을 때에는 JOIN 을 사용하도록 한다.   조인 쿼리의 성능을 높이기 위해서는 조인 대상이 되는 컬럼을 Foreign key 로 지정하고, 해당 컬럼을 모든 테이블에 대해서 같은 데이터 타입을 갖도록 한다. Foreign key를 추가할 경우 해당 컬럼에 대해 인덱스를 생성하므로 접근 속도가 월등히 빨라지게 된다.  또한, Foreign Key가 존재하는 경우 DELETE / UPDATE 도 자동적으로 연관되어 모든 테이블에 대해 적용하게 되고, INSERT 할 때에는 제약조건 위반 여부를 자동 검사하므로 유용하게 쓰일 수 있다.          Autocommit을 끄고 사용해야 한다. 사용하는 저장장치의 쓰기 성능에 따라서 초당 수백번의 커밋은 성능에 안좋은 영향을 미칠 수 있고, 성능상에 한계점을 드러내게 한다.           START TRANSACTION 과 COMMIT SQL 구문을 활용하여 연관된 DML 쿼리들을 하나의 transaction으로 묶어서 사용해야 한다. 커밋을 너무 자주 발생시키지 않고 싶을 때 사용해도 좋으며, 정말 긴 시간동안 데이터의 변경을 수행하는 Long running INSERT, UPDATE, DELETE 구문에 대해서 사용해도 좋다.           LOCK TABLES 쿼리는 최대한 사용하지 말아야 한다. InnoDB는 가용성이나 성능상에 이슈 없이, 자체적으로 여러 세션에서 한 테이블로 요청하는 읽기/쓰기를 모두 알아서 처리 할 수 있다. 나중에 업데이트에 사용될 row들에 대해서 미리 exclusive lock을 걸고 싶은 경우에는 SELECT … FOR UPDATE 쿼리를 사용해서, 테이블이 아닌 해당 row에만 lock을 걸 수 있도록 하자.      ##### LOCK TABLES 쿼리 : MySQL에서 명시적으로 테이블 단위의 잠금을 설정하는 구문. 테이블 전체에 READ 또는 WRITE 잠금을 걸 수 있다.     LOCK TABLES 테이블명 READ|WRITE;           innodb_file_per_table 옵션을 사용하거나, general tablespace를 사용하여 데이터를 저장하고 별도의 파일에 인덱스를 저장하는 방식을 사용해야한다. System tablespace에 데이터를 저장하지 않도록 설정하자.      innodb_file_per_table 옵션은 기본적으로 on 되어 있다.           InnoDB를 통해 관리하려는 데이터의 접근 방식이 데이터 페이지의 compression 여부에 따라 영향을 받는지 확인해 보자. Compression이 읽기/쓰기 성능에 큰 영향을 주지 않을것이라고 판단되면 압축기술을 사용하여 공간 낭비를 줄일 수 있다.           CREATE TABLE 쿼리에서 사용하는 ENGINE =  옵션이 정상적으로 동작하지 않을 경우, 서버를 실행할 때 --sql_mode=NO_ENGINE_SUBSTITUTION 옵션을 사용해서 InnoDB가 아닌 다른 엔진이 선택되지 않도록 강제 한다.        1.3 InnoDB 다루기   InnoDB가 기본 엔진으로 설정되어 있는지 확인  SHOW ENGINE 쿼리를 사용할 경우 MySQL이 어떤 엔진을 지원하는지 볼 수 있다. InnoDB에 DEFAULT 표시가 되어있는지 확인해보자.  SHOW ENGINES;    또다른 방법으로는, INFORMATION_SCHEMA.ENGINES를 사용할 수 있다.  SELECT * FROM INFORMATION_SCHEMA.ENGINES;      InnoDB를 테스트, 벤치마킹 하는 방법   다른 스토리지 엔진을 사용하던 중 InnoDB로 변경을 고민 할 때, 기존에 사용하던 데이터베이스 서버가 InnoDB 엔진으로도 정상 동작하고 원하는 성능을 나타내는지 궁금할 수 있다.  이때 --default-storage-engine=InnoDB 옵션을 사용해서 서버를 재시작 하거나, MySQL 옵션 파일의 [mysqld] 섹션에 default-storage-engine=innodb 옵션을 추가 후 재시작 하면 InnoDB를 기본 엔진으로 사용할 수 있다.    사용하던 데이터베이스가 있는 상황에서 스토리지 엔진을 변경하면, 그 이후에 새롭게 생성되는 테이블에 대해서만 바뀐 스토리지 엔진이 적용된다. 모든 테이블을 InnoDB 엔진으로 변경하고 싶은 경우에는, MySQL과 연동되어 있던 모든 애플리케이션에 대한 셋업을 다시 진행해야 한다.  기존에 사용하던 테이블중 일부가 기존 스토리지 엔진의 특수 기능을 의존적으로 사용하는 중이었다면, 해당 테이블에 대한 생성 쿼리에 ENGINE=other_engine_name 옵션을 사용하여 원래 사용하던 스토리지 엔진으로 지정해야 한다.    성급하게 엔진 변경을 하고 싶지 않고, 미리 특정 테이블들이 InnoDB 상에서 어떻게 동작하는지 알아보고 싶은 경우에는 원하는 테이블에 대해서만 ALTER TABLE table_name ENGINE=InnoDB; 쿼리를 실행하여 엔진을 변경하고 테스트 해볼 수 있다.  또는, 기존의 테이블에 일체의 변화를 주지 않은 채로 테스트를 하고 싶은 경우에는 아래의 쿼리를 사용하여 테이블 복사본을 생성하고 InnoDB 엔진을 테스트해볼 수 있다.  CREATE TABLE InnoDB_Table (...) ENGINE=InnoDB AS SELECT * FROM other_engine_table;   전체 애플리케이션에 대해서 실제 사용되는 워크로드를 이용해 성능평가를 수행하고 싶은 경우에는 가장 최신 버전의 MySQL 서버를 설치하고 벤치마크를 수행해야 한다.  테스트에는 애플리케이션 전체 생애 주기에 따른 성능 (설치, 기본 셋업, 데이터 로딩 포함)과 과도한 워크로드가 주어졌을 때의 성능 및 서버 재시작이 포함된다. 특수상황에 대한 테스트를 위해서는 데이터베이스가 가동중에 강제로 서버를 종료시켜서 정전 상황에 대비한 테스트를 수행하여, 크래쉬 이후에 데이터베이스가 정상적으로 복구 되는지 확인할 수 있다.  MySQL의 master / slave 옵션을 사용하고 있는 경우에는 다양한 replication 옵션도 테스트해야 한다.     키워드 추가 설명   - Master/Slave (마스터/슬레이브):     마스터: 원본 데이터베이스로, 모든 쓰기 작업(INSERT, UPDATE, DELETE)이 이루어짐    슬레이브: 마스터의 복제본으로, 주로 읽기 작업에 사용됨   - Replication (복제):     마스터 데이터베이스의 변경사항을 슬레이브에 자동으로 복사하는 기능    데이터의 백업과 분산 처리를 위해 사용됨   - Binary Log (바이너리 로그):     마스터에서 발생한 모든 변경사항을 기록하는 로그 파일    슬레이브는 이 로그를 읽어 변경사항을 적용함   - Replication 옵션:     Row-based: 변경된 행 데이터 자체를 복제    Statement-based: SQL 문장을 복제    Mixed: 상황에 따라 두 방식을 혼합하여 사용   - Sync/Async (동기/비동기):     비동기 복제: 마스터는 슬레이브의 복제 완료를 기다리지 않음 (기본값)    반동기 복제: 최소 하나의 슬레이브가 복제할 때까지 기다림     2. InnoDB의 ACID      ACID 모델은 비즈니스 데이터나 사업의 핵심 응용 프로그램을 관리하는데 있어서 중요한 데이터베이스의 안정성을 강조하고 보장하는 일련의 데이터베이스 설계 원칙이다.   MySQL은 InnoDB 엔진과 같이 ACID 모델을 철저하게 준수하는 컴포넌트들을 사용해서, 소프트웨어 크래쉬나 하드웨어 오작동으로 인한 예외 상황에서 데이터가 손상되거나 작업 결과가 왜곡되지 않도록 방지한다. 이러한 ACID 모델은 철저히 준수하는 기능을 사용할 경우, 사용하고자 하는 응용프로그램을 위해 새로운 일관성 검사 기능 및 장애 복구 기술을 개발할 필요가 없다. 소프트웨어적인 안전장치, 극도로 신뢰할 수 있는 하드웨어 장치가 있거나 타겟 애플리케이션이 어느정도의 데이터 유실을 감수할수 있는 경우에는, MySQL의 옵션을 통해 ACID 모델 중 일부를 희생하고 응용프로그램의 성능이나 데이터 처리량을 늘릴 수도 있다.     A : atomicity (원자성)   C : Consistency (일관성)   i : isolation (고립성, 독립성)   D : durability (지속성)   Atomicity  ACID 모델의 atomicity 는 주로 InnoDB의 transaction의 구현을 포함한다. MySQL의 관련 기능들은 아래와 같다.     Autocommit 옵션   COMMIT 구문   ROLLBACK 구문   INFORMATION_SCHEMA 테이블의 데이터베이스 운영 관련 데이터   Consistency  ACID모델의 consistency는 주로 데이터가 손상되는것을 방지하기 위해 InnoDB의 내부의 동작방식을 포함한다. MySQL의 관련 기능들은 아래와 같다.     InnoDB의 doublewrite buffer   InnoDB의 crash recovery   Isolation  ACID모델의 isolation은 주로 InnoDB의 transaction의 구현을 포함하며, 특히 각 트랜잭션에 적용 되는 isolation level에 의해 정의된다. MySQL의 관련 기능들은 아래와 같다.     Autocommit 옵션   SET ISOLATION LEVEL 구문   InnoDB의 locking 상세 구현. 성능 테스트 중에 INFORMATION_SCHEMA 테이블을 통해 확인 가능함.   Durability  ACID모델의 durability는 사용중인 하드웨어와 상호작용하는 MySQL의 소프트웨어 기능을 포함한다. 하드웨어는 사용하는 서버의 CPU, 네트워크, 저장장치의 기능과 구성에 따라서 많은 경우의 수가 존재하므로, 구체적인 가이드라인을 제시하기에 가장 복잡한 기능이다. MySQL의 관련 기능들은 아래와 같다.     innodb_doublewrite 설정 옵션에 따라 조절되는 InnoDB의 doublewrite buffer   innodb_flush_log_at_trx_commit 옵션   sync_binlog 옵션   innodb_file_per_table 옵션   HDD, SSD 및 RAID의 저장장치 내부 쓰기 버퍼 (write buffer)   저장장치내의 배터리 지원 캐시 (정전으로 인한 데이터 유실 방지)   fsync() 시스템 콜을 지원하는 운영체제   UPS (Uninterruptible power supply, 무정전 전원 공급 장치)에 의해 보호되는 MySQL 서버 컴퓨터 및 데이터베이스 저장장치   데이터에 대한 다양한 백업 전략 (빈도, 유형, 보존 기간 등)   분산형 혹은 호스팅형 응용프로그램의 경우, MySQL서버를 구동하는 하드웨어가 잇는 데이터센터의 특정한 특성과 데이터 센터 간의 네트워크 연결 상태     3. InnoDB Multi-Versioning      InnoDB는 데이터의 멀티 버전을 지원하는 스토리지 엔진 (multi-versioned storage engine)이다. 변경된 row들에 대한 이전 버전의 정보들을 가지고 있으며, 이를 통해서 동시성 제어와 rollback과 같은 트랜잭션 기능들을 제공한다. 이러한 정보들은 테이블 스페이스 내의 rollback segment라고 불리는 자료구조에 저장된다. 트랜잭션 진행 도중 롤백이 필요할 경우 롤백 세그먼트의 데이터 정보를 이용하여 undo 작업을 수행한다. 또한, $^*$consistent read 기능을 제공하기 위해 이전 버전의 데이터를 만드는 데에도 사용한다.   consistent read 일관성 있는 읽기(consistent read)는 쉽게 말해서 \"타임머신 읽기\"다.  데이터베이스에서 여러 사람이 동시에 작업할 때도, 내가 조회를 시작한 시점의 데이터 상태를 그대로 볼 수 있게 해주는 기능이다.  다른 사람이 그 데이터를 변경하고 있어도, 내가 조회를 시작한 시점의 데이터를 InnoDB가 기억했다가 보여준다.  Ex)      1. 내가 오전 10시에 테이블 조회 시작     2. 다른 사용자가 10시 1분에 데이터 변경     3. 내가 10시 2분에 같은 데이터 다시 조회     4. InnoDB는 나에게 여전히 10시 시점의 원래 데이터를 보여줌  내 작업 도중에 데이터가 갑자기 바뀌는 혼란을 방지하고, 다른 사람의 작업을 기다릴 필요도 없어서 전체적인 성능이 향상된다.       InnoDB 는 내부적으로 데이터베이스에 저장되는 모든 row 각각에 대해 추가적인 3개의 필드를 같이 저장한다.           6 바이트 크기의 DB_TRX_ID 필드는 해당 row를 추가하거나 업데이트한 가장 마지막 트랜잭션의 ID를 저장한다. row의 삭제 작업 또한 해당 row의 특수 bit를 마크 하는 방식의 업데이트로 취급되므로 앞의 사례에 포함된다.           7 바이트 길이의 DB_ROLL_PTR 필드는 roll 포인터로 불리며, rollback segment내에서 해당 row에 할당된 undo 로그 레코드의 위치를 가리킨다. row가 업데이트된 상황이라면, undo 로그 레코드는 해당 row를 이전 버전으로 되돌리는데 필요한 정보를 포함하고 있다.           6바이트 길이의 DB_ROW_ID 필드는 각 row의 ID를 갖고 있으며, 이 값은 새로운 row가 추가될 때 마다 단순 증가 한다. 사용자가 특별한 인덱스 지정을 하지 않아 InnoDB가 직접 클러스터드 인덱스를 자동 생성 할 경우에 바로 이 DB_ROW_ID를 키로 사용한다. 그렇지 않은 경우에는 DB_ROW_ID가 지정되지 않는다.       Rollback segment내의 undo 로그들은 insert 로그와 update 로그로 분리된다.          Insert 로그는 트랜잭션의 롤백 시에만 필요한 로그이며, 트랜잭션이 커밋하는 순간 바로 삭제 해도 되는 로그이다.           Update 로그는 consistent read를 지원하기 위해서 계속 유지될 필요가 있다. Update 로그는 데이터베이스 전체에서 해당 로그가 포함된 스냅샷을 할당 받아서 이전 버전에 대한 consistent read를 요구하는 트랜잭션이 전혀 없는 경우에만 삭제가 가능하다.      다른 작업없이 consistent read를 수행하는 트랜잭션은 주기적으로 커밋을 수행해야 한다. 그렇지 않으면 위와 같은 이유로 update undo 로그를 삭제할수 없어, rollback segment가 매우 커지는 문제가 발생할 수 있다. 예시)  1. 데이터베이스에서 SELECT만 계속 실행하는 트랜잭션(읽기만 하는 트랜잭션)이 있다고 가정한다. 2. 이 트랜잭션이 시작된 후에 다른 트랜잭션들이 데이터를 많이 변경(UPDATE)했다. 3. 변경된 데이터의 이전 버전은 '언두 로그'라는 곳에 저장되어 있다. 4. 이 읽기 트랜잭션이 오랫동안 커밋하지 않고 계속 실행 중이면, 데이터베이스는 이 트랜잭션이 여전히 '옛날 데이터'를 볼 수 있어야 한다고 생각한다. 5. 따라서 관련된 모든 언두 로그(변경 전 데이터)를 계속 보관해야 한다. 6. 그 결과 롤백 세그먼트(언두 로그가 저장되는 공간)가 계속 커지게 된다.    Rollback segment 내의 undo 로그 레코드의 크기는 일반적으로 실제 insert/update된 row의 크기보다 작다. 이러한 정보를 활용하여 가동중인 데이터베이스에서 실제로 필요한 rollback segment 크기를 계산할 수 있다.   InnoDB의 멀티 버전 관리 체계에서, SQL 쿼리에 의해 삭제된 row는 실제 물리적으로 즉시 삭제되지 않는다. 물리적으로 해당 레코드를 삭제하는 시점은 해당 Delete 쿼리를 위한 undo 로그 레코드가 삭제되는 시점이다.  이러한 삭제 작업을 purge라고 부르며, 실제 Delete SQL 문을 수행했던 시간과 같은 속도로 매우 빠르게 처리된다.   거의 동일한 비율로 insert와 delete를 수행하는 작은 배치 쿼리를 계속해서 수행할 경우, purge를 담당하는 쓰레드가 insert 쓰레드에 뒤쳐지게 되고, 이는 계속해서 남겨지는 “dead” row들 (delete 마크만 되고 삭제되지 않은 row들) 로 인해서 테이블의 크기가 증가하고 모든 작업이 disk-bound가 되어 전체 성능 매우 떨어지는 문제를 일으킨다.  이러한 경우에는 insert에 의한 새로운 row를 생성하는 작업을 제한하고 purge 쓰레드에 더 많은 리소스를 할당하여, disk-bound를 제거해야 한다. 적절한 purge 쓰레드 조절을 위해서는 innodb_max_purge_lag 옵션을 사용하면 되고, “InnoDB Startup Options and System Variables” 문서를 참조하면 더 자세한 내용이 있다.    멀티버전 관리와 Secondary 인덱스      InnoDB의 MVCC (MultiVersion Concurrency Control, 다중 버전 동시성 제어 기법) 는 secondary 인덱스를 메인 클러스터드 인덱스와 다르게 처리한다.    메인 클러스터드 인덱스(기본키 인덱스) 의 경우 update 쿼리에 대한 작업을 in-place(같은 자리에서 바로 수정) 로 처리하고 해당 row에 대해 위에서 언급한 undo 로그 레코드를 가리키는 숨겨진 컬럼을 추가하여 이전 버전의 레코드를 재생성할 수 있도록 한다.  Secondary 인덱스의 경우에는 각 row 레코드들에 대해 숨겨진 컬럼을 사용하지도 않고, in-place 업데이트를 수행하지도 않는다.   쉽게 설명하자면,   클러스터드 인덱스: 책의 내용을 수정할 때 원래 페이지에 수정하고, 이전 내용은 별도 노트에 기록해두는 방식                 수정시 책의 내용과 변경 기록을 함께 보관                  세컨더리 인덱스: 색인에서 예전 항목을 지우고 새 항목을 완전히 새로 추가하는 방식                색인만 있고, 원본 기록은 책 본문에서 찾아야 함   Secondary 인덱스의 컬럼이 업데이트 된 경우, 이전 버전의 레코드에는 delete 마크를 표시해두고, 새로운 레코드는 인덱스에 새롭게 insert된다.  delete 마크가 표기된 이전 버전의 레코드는 향후에 purge 된다.  한 트랜잭션이 secondary index가 구성되어 있는 특정 컬럼에 대한 값을 얻어 오고자 할 때, 해당 트랜잭션 보다 이후에 시작된 트랜잭션에 의해 secondary 인덱스의 레코드가 delete 되거나 update 된 경우, 원래 자기 트랜잭션의 snapshot에 맞는 이전 버전의 레코드를 가져오기 위해서는 메인 클러스터드 인덱스를 거쳐야 한다.  클러스터드 인덱스에서는 row 레코드들이 DB_TRX_ID를 가지고 있으므로 해당 아이디를 통해, 자신이 원하는 버전의 데이터를 undo 로그 레코드에서 획득하여 이전 버전의 레코드를 재생성 할 수 있다. $^*$Covering index에 대해서도 동일하게 동작한다.    Covering Index   커버링 인덱스(Covering Index)란 쿼리가 요청한 모든 데이터가 인덱스 자체에 포함되어 있어서 테이블 본문을 찾아볼 필요 없이 인덱스만으로 쿼리를 처리할 수 있는 인덱스    Ex)  테이블에 name, age, address 컬럼이 있고 (name, age) 컬럼으로 인덱스를 만들었을 때 SELECT name, age FROM table WHERE name = '김철수' 쿼리는 인덱스만으로 모든 정보를 가져올 수 있어 더 빠름      ICP (Index condition pushdown) 최적화 (“가능하면 테이블 본문에 안 가고 인덱스만으로 필터링하자”는 최적화) 기술을 사용하는 경우, 원래 기술은 base 테이블을 참조하지 않는 것이지만, MVCC에 의해 secondary 인덱스의 레코드가 수정 (delete/update) 되었음이 확인된 경우에는 메인 클러스터드 인덱스를 추가적으로 접근하여 원하는 버전의 데이터를 재생성하는 작업이 추가된다.    4. InnoDB 구조  각 구조에 대한 정보를 알기 위해서는 InnoDB In-Memory Structures 와 InnoDB On-Disk Structures 섹션을 확인하길 바란다.  InnoDB가 메모리 및 디스크 상에서 관리하는 데이터들의 구성   자세한 각 구조에 대해서는 다음 글에서 이어서 작성하겠다.  References    MySQL 8.0 Reference Manual  /  The InnoDB Storage Engine   Clustered vs NonClustered (index 개념)   지식덤프 [MySQL Glossary]: https://dev.mysql.com/doc/refman/8.0/en/glossary.html [MySQL Forums::InnoDB]: http://forums.mysql.com/list.php?22 [MySQL Licensing]: http://www.mysql.com/company/legal/licensing/ [other engines]: https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html   3 - MySQL 8 InnoDB Storage Engine Architecture Part-1 | MySQL DBA Tutorial | #MySQL 8 DBA #InnoDB   "
  },
  
  {
    "title": "Real MySQL - Ch 1 , 2",
    "url": "/posts/Real-MySQL-Ch-1-2/",
    "categories": "데이터베이스",
    "tags": "Database, RealMySQL 8.0",
    "date": "2025-04-26 17:14:26 +0900",
    "content": "   Ch 01. 소개     1.1 MySQL 소개      MySQL은 1979년 스웨덴의 TcX라는 회사의 터미널 인터페이스 라이브러리인 UNIREG로부터 시작된다. 이후 MySQL 버전 1.0이 완성된 후 사내에서만 사용되다가, 1996년에 일반인에게 공개됐다.     1.2 왜 MySQL인가?      💡 MySQL의 경쟁력은 가격이나 비용이다.   방대한 양의 데이터를 저장하기에 오라클 RDBS는 너무 비싸다. MySQL도 100% 무료는 아니지만, 커뮤니티 에디션과 엔터프라이즈 에디션간의 큰 차이가 없기에 무료로 사용해도 큰 문제가 없다.  Q : 어떤 DBMS를 사용할 지 모르겠어요. 어떤 DBMS가 좋은가요?   이 질문에 대해 고민할 때 다음을 고려하자  1. 안정성 2. 성능과 기능 3. 커뮤니티나 인지도 - 필요한 경험이나 지식을 구할 수 있다.  가장 중요한 항목은 안정성 이다. 성능, 기능은 돈이나 노력으로 해결되지만 안정성은 그렇지 않다. 안정성 다음으로 성능과 기능을 고려하고, 그 다음으로 커뮤니티나 인지도를 고려해보자.    DB-Engines Ranking 사이트에서 DBMS 랭킹을 살펴보자. 상위 20개를 표와 차트로 나타내면 아래와 같다. (점수 부여 기준 : 웹사이트 언급 횟수, 검색 빈도, 기술 토론 빈도, DBMS별 구인, 전문가 인맥)       2025년 4월, 424개 DBMS 시스템 중 상위 20개         2025년 4월, DBMS 시스템 트렌드 차트          2. 설치와 설정     2.1 MySQL 서버 설치      💡 가능하다면 리눅스의 RPM이나 운영체제별 인스톨러를 이용하기를 권장   다양한 형태로 설치 가능한 MySQL 서버    Tar 또는 Zip으로 압축된 버전   리눅스 RPM 설치 버전 (윈도우 인스톨러 및 macOS 설치 패키지 )   소스코드 빌드   버전과 에디션 ( 엔터프라이즈와 커뮤니티 ) 선택      💡 다른 제약사항이 없다면 가능한 한 최신 버전을 설치하는 것이 좋다.   기존 버전에서 새로운 메이저 버전으로 업그레이드 하는 경우라면 최소 패치버전이 15~20번 이상 릴리스된 버전을 선택하는것이 안정적이다.  ex) 8.0.15 ~ 8.0.20  초기 버전의 MySQL 서버는 엔터프라이즈 에디션과 커뮤니티 에디션으로 나뉘어져 있었지만, 실제 기능에 차이가 있었던 것이 아니라 기술 지원의 차이만 있었다.    MySQL 5.5 버전부터는 커뮤니티와 엔터프라이즈 에디션의 기능이 달라지면서 소스코드도 달라졌고, MySQL 엔터프라이즈 에디션의 소스코드가 더이상 공개되지 않는다.        💡 오픈 코어 모델 (Open Core Model) :  핵심 내용은 엔터프라이즈 에디션과 커뮤니티 에디션 모두 동일하며, 특정 부가 기능들만 상용 버전인 엔터프라이즈 에디션에 포함되는 방식.   엔터프라이즈 에디션에서만 지원하는 기능    Thread Pool   Enterprise Audit   Enterprise TDE (Master Key 관리)   Enterprise Firewall   Enterprise Monitor   Enterprise Backup   MySQL 기술 지원     MySQL 설치   1. 리눅스 서버의 Yum 인스톨러 설치하는 방법  Yum 인트솔러를 이용하려면 MySQL 소프트웨어 레포지토리를 등록해야 하는데 MySQL Yum Repository 에서 RPM 설치 파일을 직접 받아서 설치해야 한다.     Yum 레포지토리 설치용 RPM 다운로드       Q : RPM이랑 YUM이 무엇인가요?  RPM, YUM은 리눅스의 패키지 인스톨 프로그램이라고 볼 수 있다. RPM은 필요한 패키지를 하나하나 수동으로 설치해야 하는 반면 YUM은 패키지를 받을 때 의존성을 찾아 자동으로 설치한다.  RPM ( Redhat Package Manager ) setup.exe와 비슷한 개념으로 프로그램 설치 후 바로 실행할 수 있는 패키지 설치 파일이다.    반드시 .rpm 파일이 있어야 한다.   의존성을 해결하지 못한다. 프로그램 B를 사용하기 위해 A가 필요하다면 수동으로 A를 미리 설치해야한다.   YUM ( Yellowdog Update Manager ) 인터넷을 통해 필요한 파일을 저장소 (레포지토리) 에서 자동으로 모두 다운로드해서 설치하는 방식이다.  RPM과 달리 YUM은 패키지가 의존성을 필요로 하면 자동으로 의존성을 같이 설치한다.    각 운영체제의 버전에 맞는 RPM 파일을 다운로드 해서 서버를 설치하고자 하는 리눅스 서버에서 다음과 같이 YUM 레포지토리 정보를 등록한다. linux&gt; sudo rpm -Uvh mysql84-community-release-el9-1.noarch.rpm  그러면 YUM 레포지토리 등록이 되고, MySQL 설치용 RPM 파일들이 저장된 경로를 가진 파일이 생성된다. linux&gt; ls -alh /etc/yum.repos.d/*mysql*    인스톨러 명령을 이용해 버전별로 설치 가능한 MySQL 소프트웨어 목록 확인 가능하다.  linux&gt; sudo yum search mysql-community # 어떤 RPM 패키지가 있는지 확인할 수 있다.  linux&gt; sudo yum --showduplicates list mysql-community-server # 설치 가능한 모든 버전을 확인할 수 있다.   마지막으로 특정 버전을 설치하면 된다. 설치하고자 하는 버전을 패키지 이름 뒤에 - 로 구분하면 된다.  linux&gt; sudo yum install mysql-community-server-[특정 버전]  ex)    sudo yum install mysql-community-server-9.3.0   Is this ok [y/d/N]: 이 프롬프트가 나오면 y를 눌러 나머지 설치를 진행하면 된다.     리눅스 서버에서는 Yum 인스톨러나 RPM 설치를 하더라도 MySQL 서버를 바로 시작할 수 없다. 서비스용 MySQL 서버는 리눅스 서버에서 많이 사용하므로 리눅스 서버에의 설정 파일과 시스템 테이블 준비가 필요하다.    리눅스 서버에서 Yum 인스톨러 없이 RPM 파일로 설치  Yum 인스톨러 없이 RPM 패키지로 직접 설치하려면 필요한 RPM 패키지를 수동으로 직접 다운로드해야 한다.  MySQL RPM 다운로드 페이지 에서 운영체제의 버전과 CPU 아키텍처를 선택한 후, 다운로드 하면 된다. 원하는 버전이 따로 있다면 선택도 가능하다.   RPM 패키지 다운로드 페이지에서 RPM 패키지 다운로드 한 후 의존 관계 순서대로 설치하면 된다.  Development Libraries 패키지는 C/C++ 언어로 MySQL 서버에 접속하는 프로그램 개발/빌드시 필요한 파일들을 가지고 있어서 굳이 설치하지 않아도 된다.  의존 관계 순서는 아래 표와 같다. 위에서부터 아래 순서로 설치하면 된다.  RPM 패키지 목록                 RPM 패키지       RPM 파일명                       Development Libraries       mysql-community-devel-9.3.0-1.el9.x86_64.rpm                 Shared Libraries       mysql-community-libs-9.3.0-1.el9.x86_64.rpm                 Compatibility       mysql-community-libs-compat-9.3.0-1.el9.x86_64.rpm                 MySQL Configuration       mysql-community-common-9.3.0-1.el9.x86_64.rpm                 MySQL Server       mysql-community-server-9.3.0-1.el9.x86_64.rpm                 Client Utilities       mysql-community-client-9.3.0-1.el9.x86_64.rpm             macOS용 DMG 패키지 설치  macOS에서 인스톨러로 설치하려면 설치에 필요한 DMG 패키지 파일을 직접 다운로드해야한다. DMG 파일을 실행하고 패키지 파일을 설치한다. 설치 옵션 변경창에서 설치위치는 기본 디렉토리로 유지하고, ‘설치’ 버튼을 누른다. 라이선스 동의 화면에서는 2가지 사용자 인증 방식이 있다.  Use Strong Password Encryption 을 선택하면 Caching SHA-2 Authentication을 사용한다. (권장) Use Legacy Password Encryption 을 선택하면 Native Authentication 방식을 사용한다.  MySQL 서버 설치시 기본 설정은 디렉토리와 로그 파일을 /usr/local/mysql 하위에 생성하고 관리자 모드 로 서버 프로세스를 기동하기 때문에 관리자 계정에 대한 비밀번호 설정이 필요하다.     kimhyeonjae@Ks-MacBook-Air  ~  ps -ef | grep mysqld      74   554     1   0  4 425  ??        43:34.22 /usr/local/mysql/bin/mysqld --user=_mysql     --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data     --plugin-dir=/usr/local/mysql/lib/plugin --log-error=/usr/local/mysql/data/mysqld.local.err     --pid-file=/usr/local/mysql/data/mysqld.local.pid --keyring-file-data=/usr/local/mysql/keyring/keyring     --early-plugin-load=keyring_file=keyring_file.so  MySQL 서버가 설치된 디렉토리는 /usr/local/mysql 이고, 하위 각 디렉토리 정보는 위 결과와 같다.  이 디렉토리 중 중요 항목들을 살펴보자.     bin : MySQL 서버와 클라이언트 프로그램, 유틸리티를 위한 디렉토리   data : 로그 파일과 데이터 파일들이 저장되는 디렉토리   include : C/C++ 헤더 파일들이 저장된 디렉토리   lib : 라이브러리 파일들이 저장된 디렉토리   share: 다양한 지원파일들이 저장돼 있으며, 에러 메시지나 샘플 설정 파일(my.cnf)가 있는 디렉토리     2.2 MySQL 서버의 시작과 종료   설정 파일 및 데이터 파일 준비   리눅스 서버에서 Yum 인스톨러나 RPM으로 MySQL 서버 설치하면 필요한 프로그램들과 디렉토리는 준비되지만, 트랜잭션 로그 파일과 시스템 테이블이 준비되지 않아서 서버를 시작할 수 없다.  MySQL 서버를 실행하는데 필요한 초기 데이터 파일(시스템 테이블 저장되는 데이터 파일) 과 트랜잭션 로그(리두 로그) 파일을 생성하자. 초기에 my.cnf 에는 기본적인 설정만 존재 ( 윈도우는 my.ini )    --initialilze-insecure  : 필요한 초기 데이터 파일과 로그 파일들 생성. 비밀번호가 없는 관리자 계정인 root 유저 생성 linux&gt; mysqld -- defaults-file=/etc/my.cnf --initialilze-insecure   --initialilze : 비밀번호를 가진 관리자 계정 생성하고자 할 때 사용. 생성된 관리자 계정의 비밀번호를 에러 로그 파일로 기록한다. linux&gt; mysqld -- defaults-file=/etc/my.cnf --initialilze    시작과 종료   UNIX 계열에서는 자동으로 usr/lib/systemd/system/mysqld.service 파일이 생성된다. systemctl 유틸리티를 이용해 MySQL을 기동하거나 종료하는 것이 가능하고, 상태도 확인 가능하다.  linux&gt; systemctl start mysqld # 시작 linux&gt; systemctl status mysqld # 서버 상태 확인 linux&gt; systemctl stop mysqld # 종료  원격으로 서버를 셧다운 하려면 서버에 로그인 한 상태에서 SHUTDOWN 명령을 실행하면된다.  이때 SHUTDOWN 권한 (Privileges) 을 가지고 있어야 한다. linux&gt; systemctl shutdown mysqld # 셧다운        mysqld_safe   mysqld_safe 스크립트를 이용해서 MySQL 서버 시작, 종료 가능하다. MySQL 설정파일 (my.cnf) 의 “[mysqld_safe]” 섹션의 설정들을 참조해서 MySQL 서버를 시작하게 된다. systemd 이용하는 경우에는 MySQL 설정파일의 “[mysqld_safe]” 섹션을 무시하게 된다.    “[mysqld_safe]” 섹션에만 설정가능한 “malloc-lib” 같은 시스템 설정 적용가능하다.   malloc-lib?        메모리 할당 라이브러리 지정.     장점                서버 성능 향상         메모리 단편화 감소         메모리 누수 디버깅                 ex)                jemalloc : 페이스북         tcmalloc (thread caching malloc) : 구글                   -&gt; 멀티스레드 환경에 최적화     서버 연결 테스트   mysql을 실행하고 명령행 인자로 접속할 수 있다. linux&gt; mysql -uroot -p --host=@localhost --socket=/tmp/mysql.sock # (a) 소켓 파일로 접속 linux&gt; mysql -uroot -p --host=127.0.0.1 --port=3306 # (b) TCP/IP 로 접속 (포트변호 명시) linux&gt; mysql -uroot -p # (c) 별도로 호스트 주소와 포트를 명시하지 않음   (a) 소켓 파일로 접속 --host=@localhost 옵션 사용하면 MySQL 클라이언트 프로그램은 항상 소켓 파일을 통해 MySQL 서버에 접속하게 되는데, 이는 ‘Unix domain socket’ 을 이용하는 방식으로 TCP/IP를 통한 통신이 아닌 유닉스의 프로세스 간 통신 (IPC; Inter Process Communication)의 일종이다.  (b) TCP/IP 로 접속 (포트변호 명시) 하지만 127.0.0.1 을 사용하는 경우에는 자기 서버를 가리키는 루프백 (loopback) IP 이기는 하지만 TCP/IP 통신 방식을 사용하는 것이다.  (c) 별도로 호스트 주소와 포트를 명시하지 않음 이 경우 기본값으로 호스트는 localhost 가 되며 소켓 파일을 사용하게 된다. 소켓 파일의 위치는 설정 파일에서 읽어서 사용한다.    MySQL 서버에 접속되면 MySQL 프롬프트가 mysql&gt; 로 표시된다. 간단한 telnet 명령이나 nc (Netcat) 명령을 이용해 원격지 MySQL 서버가 응답 가능한 상태인지 확인 가능하다. 서버가 보내준 메시지를 출력한다면 네트워크 수준의 연결이 정상적임을 판단할 수 있다.    2.3 MySQL 서버 업그레이드   업그레이드 방법으로 2가지 방법이 있다.  1. MySQL 서버의 데이터 파일을 그대로 두고 업그레이드하는 방법. (= In-Place Upgrade) 2. mysqldump 도구 등을 이용해 MySQL 서버의 데이터를 SQL 문장이나 텍트스 파일로 덤프한 후, 새로 업그레이드 된 버전의 MySQL 서버에서 덤프된 데이터를 적재하는 방법. (= Logical Upgrade)  1번 방법은 여러 제약사항이 있지만 시간을 크게 단축할 수 있고, 반대로 2번 방법은 버전간 제약 사항이 거의 없지만 오래 걸릴 수 있다.    인플레이스 업그레이드 제약 사항     메이저 버전 → 마이너 버전 간 업그레이드            대부분 데이터 파일의 변경 없이 진행된다.       여러 버전을 건너뛰는 것도 가능하다.       MySQL 서버 프로그램만 재설치하면 된다.           메이저 버전 → 메이저 버전 간 업그레이드            대부분 크고 작은 데이터 파일의 변경이 필요하기 때문에 반드시 직전 버전에서만 업그레이드 허용       데이터 파일의 패치가 필요한데, 직전 메이저 버전에서 사용하던 데이터 파일과 로그 포맷만 인식하도록 구현되기 때문.       ex)  5.1 에서 8.0 으로 업그레이드 하려면 5.1, 5.6, 5.7, 8.0 으로 한 단계씩 업그레이드 해야한다.           메이저 버전 업그레이드가 특정 마이너 버전에서만 가능한 경우도 있다.            새로운 버전의 MySQL 서버를 선택할 때 최소 GA ( General Availability ) 버전은 지나서 15~20번의 마이너 버전을 선택하는 것이 좋다.             MySQL 8.0 업그레이드 시 고려 사항         사용자 인증 방식 변경 : MySQL 8.0 버전부터 Caching SHA-2 Autentication 인증 방식이 기본 인증 방식으로 바뀌었다.           MySQL 8.0과의 호환성 체크 : 손상된 FRM 파일이나 호환되지 않는 데이터 타입 또는 함수가 있는지 mysqlcheck 유틸리티로 확인해볼 것을 권장한다.           외래키 이름의 길이 : 외래키 (Foreign Key) 의 이름이 64글자로 제한된다.           인덱스 힌트 : 인덱스 힌트가 있다면 MySQL 8.0에서 먼저 성능 테스트를 수행하자.      Q 인덱스힌트란?      : 특정 인덱스 사용하라고 강제하는 방법. 쿼리 성능 최적화.     FORCE INDEX, USE INDEX, IGNORE INDEX                GROUP BY에 사용된 정렬 옵션 : GROUP BY 절의 칼럼 뒤에 ‘ASC’ 나 ‘DESC’를 사용하고 있다면 먼저 제거하거나 다른 방식으로 변경하자.           파티션을 위한 공용 테이블스페이스 : 파티션의 각 테이블스페이스를 공용 테이블스페이스에 저장할 수 없다.        MySQL 8.0 업그레이드     크게 두가지 단계로 나뉘어서 처리된다.   1. 데이터 딕셔너리 업그레이드 데이터 딕셔너리 정보가 트랜잭션이 지원되는 InnoDB 테이블로 저장되도록 개선됐다. 데이터 딕셔너리 업그레이드는 기존의 FRM 파일의 내용을 InnoDB 시스템 테이블로 저장한다. MySQL 8.0 버전부터는 딕셔너리 데이터의 버전 간 호환성 관리를 위해 테이블이 생성될 때 사용된 MySQL 서버의 버전 정보도 함께 기록한다.  2. 서버 업그레이드 시스템 데이터베이스 ( performance_schema 와 information_schema, 그리고 mysql 데이터베이스 ) 의 테이블 구조를 MySQL 8.0 버전에 맞게 변경한다.    8.0.15 버전 이전 “데이터 딕셔너리 업그레이드” 작업은 MySQL 서버 (mysqld) 프로그램이 실행, “서버 업그레이드” 작업은 mysql_upgrade 프로그램이 실행했다.  예시)    MySQL 셧다운   MySQL 5.7 프로그램 삭제   MySQL 8.0 프로그램 설치   MySQL 8.0 서버(mysqld) 시작 (MySQL 서버가 데이터 딕셔너리 업그레이드를 자동 실행)   mysql_upgrade 프로그램 실행 (mysql_upgrade 프로그램이 시스템 테이블의 구조를 MySQL 8.0에 맞게 변경)   8.0.16 버전 이후    MySQL 셧다운   MySQL 5.7 프로그램 삭제   MySQL 8.0 프로그램 설치   MySQL 8.0 서버(mysqld) 시작 (MySQL 서버가 데이터 딕셔너리 업그레이드를 실행 후, 시스템 테이블 구조를 MySQL 8.0에 맞게 변경)   즉, MySQL 서버가 업그레이드 됐다면 MySQL 서버 프로그램 (mysqld)이 시작되면서 자동으로 필요한 작업을 수행하기 때문에 사용자 실수를 더 줄일 수 있다.     –upgrade 옵션을 이용해 데이터 딕셔너리 업그레이드를 수행할지 여부를 제어할 수 있다.                  파라미터 값       데이터 딕셔너리 업그레이드       서버 업그레이드                       AUTO       필요한 경우 실행       필요한 경우 실행                 NONE       X       X                 MINIMAL       필요한 경우 실행       X                 FORCE       필요한 경우 실행       항상 실행           MINIMAL : “서버 업그레이드” 를 건너뛴다 FORCE : MySQL 서버의 시스템 테이블 구조가 잘못 변경됐거나 손상된 경우 사용 AUTO : 기본값. 필요한 경우 두 가지 업그레이드를 모두 자동으로 실행한다.    2.4 서버 설정   MySQL 서버는 단 하나의 설정 파일을 사용한다.    리눅스/유닉스 계열 : my.cnf 파일   윈도우 계열 : my.ini 파일   MySQL 서버는 시작될때만 이 설정 파일을 참조한다. 여러 개의 디렉토리를 순차적으로 탐색하면서 처음 발견된 my.cnf 파일을 사용한다.  다음과 같은 순서로 디렉토리를 탐색한다     /etc/my.cnf 파일   /etc/mysql/my.cnf 파일   /usr/etc/my.cnf 파일   ~/my.cnf 파일   1번과 2번이 주로 탐색에 사용되고, 3번은 컴파일 시 내장된 경로다. 즉, 단 하나의 설정파일만 사용하지만 설정 파일이 위치한 디렉토리는 여러 곳일 수 있다는 것이다.    설정 파일의 구성 하나의 설정 파일에 여러 개의 설정 그룹을 담을 수 있으며, 대체로 실행 프로그램 이름을 그룹명으로 사용한다.  ex) [mysqld_safe] , [mysqld] , [mysql] , [mysqldump]    MySQL 시스템 변수의 특징    MySQL 서버는 기동하면서 설정 파일의 내용을 읽어 메모리나 작동 방식을 초기화하고, 접속된 사용자를 제어하기 위해 이러한 값을 별도로 저장해둔다. 이렇게 저장된 값을 “시스템 변수 (System Variables)” 라고 한다.   각 변수가 시스템 변수인지 세션 변수인지 구분해야한다.  시스템 변수가 가지는 속성    Cmd-Line : MySQL 서버의 명령행 인자로 설정될 수 있는지 여부. “Yes” 이면 명령행 인자로 이 시스템 변수의 값을 변경 가능하다.   Option file : 설정 파일인 my.cnf로 제어할 수 있는지 여부   System Var : 시스템 변수인지 아닌지를 나타낸다. 언더스코어 형식으로 통일.   Var Scope : 시스템 변수의 적용 범위를 나타낸다. 서버 전체 (Global) 를 대상으로 하는지, MySQL 서버와 클라이언트 간의 커넥션 (Session) 만인지 구분. 세션과 글로벌 모두 적용 (Both)   Dynamic : 시스템 변수가 동적인지 정적인지 구분하는 변수     글로벌 변수와 세션 변수    글로벌 변수 : 서버 전체에 영향 세션 변수 : 현재 연결에만 영향 (연결 종료시 사라짐)   글로벌 범위의 시스템 변수는 하나의 MySQL 서버 인스턴스에서 전체적으로 영향을 미치는 시스템 변수다. _서버 자체에 관련된 설정_이다.  ex) MySQL 서버에서 단 하나만 존재하는 InnoDB 버퍼 풀 크기 (innodb_buffer_pool) 혹은 MyISAM의 키 캐시 크기 (key_buffer_size) 등    세션 범위의 시스템 변수는 MySQL 클라이언트가 서버 접속할 때 기본적으로 부여하는 옵션의 기본값을 제어하는 데 사용된다.  ex) 각 클라이언트에서 쿼리 단위로 자동 커밋을 수행할 지 여부를 결정하는 autocommit 변수    세션 범위의 시스템 변수 가운데 MySQL 서버의 설정파일에 명시해 초기화할 수 있는 변수는 대부분 범위가 “Both”다. 서버가 기억만 하고 있다가 실제 클라이언트와의 커넥션이 생성되는 순간에 해당 커넥션의 기본값으로 사용된다. 설정파일에 초깃값을 명시할 수 없다.     글로벌 값은 서버가 기억만 한다.   새로운 연결(세션)시 이 글로벌 값이 복사된다.   글로벌 값을 변경해도 기존 연결에 영향이 없다. (독립적)   변경 후 만든 새 연결에서 새로 바꾼 글로벌 값이 복사되어 사용된다.   ex)  sort_buffer_size (256KB ~ 1MB)  join_buffer_size (256KB)  max_execution_time (0)  SELECT문 최대 실행시간 ms 단위로 제한     정적 변수와 동적 변수    정적 변수 : 서버 실행중에 변경할 수 없다. 변경하려면 재시작 필요하다 동적 변수 : 서버 실행중에 변경 가능하다. SET 명령어로 즉시 적용된다.   MySQL 서버의 시스템 변수는 아래 2가지로 구분한다.     디스크에 저장돼 있는 설정 파일(my.cnf or my.ini)을 변경 하는 경우   이미 기동중인 MySQL 서버의 메모리에 있는 MySQL 서버의 시스템 변수를 변경하는 경우     SET 명령어          SET 명령어는 현재 실행중인 서버에만 적용된다.  설정파일에 반영되는 것은 아니기 때문에 현재 기동중인 MySQL 인스턴스에서만 유효하다. =&gt; my.cnf 파일은 바뀌지 않는다! ( 재시작시 반영 안됨 )            SET PERSIST 로 현재 실행중인 서버에 변경을 적용한다. 또한 설정파일도 변경할 수 있다. =&gt; 이때 파일에 기록되는 것은 mysqld-auto.cnt 라는 별도의 파일에 기록된다. ( 재시작시 반영됨 )            SET PERSIST ONLY 는 현재 실행중인 서버에는 적용되지 않는다. mysqld-auto.cnf 에만 수정해서 저장하고 재시작시 반영된다.      SET PERSIST 또는 SET PERSIST ONLY로 변경된 시스템 변수의 메타데이터는 performance_schema.variables_info 뷰 (모든 시스템 변수 메타데이터) 와 performance_schema.persisted_variables 테이블 (SET PERSIST로 저장한 시스템 변수 값) 을 통해 참조 가능핟.  두 테이블에서 일치하는 값 있는 행만 반환하기 위해 INNER JOIN 사용하면 된다.  RESET PERSIST : mysqld-auto.cnf 파일의 내용을 삭제해야 하는 경우에 사용한다. "
  },
  
  {
    "title": "PGMS_조건에 맞는 아이템들의 가격의 총합 구하기 (SQL)",
    "url": "/posts/PGMS%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%95%84%EC%9D%B4%ED%85%9C%EB%93%A4%EC%9D%98-%EA%B0%80%EA%B2%A9%EC%9D%98-%EC%B4%9D%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-04-26 15:15:10 +0900",
    "content": "[level 2] 조건에 맞는 아이템들의 가격의 총합 구하기 - 273709  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SUM， MAX， MIN  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 04월 26일 15:10:25  문제 설명  다음은 어느 한 게임에서 사용되는 아이템들의 아이템 정보를 담은 ITEM_INFO 테이블입니다. ITEM_INFO 테이블은 다음과 같으며, ITEM_ID, ITEM_NAME, RARITY, PRICE는 각각 아이템 ID, 아이템 명, 아이템의 희귀도, 아이템의 가격을 나타냅니다.           Column name Type Nullable            ITEM_ID INTEGER FALSE   ITEM_NAME VARCHAR(N) FALSE   RARITY INTEGER FALSE   PRICE INTEGER FALSE            문제  ITEM_INFO 테이블에서 희귀도가 'LEGEND'인  아이템들의 가격의 총합을 구하는 SQL문을 작성해 주세요. 이때 컬럼명은 'TOTAL_PRICE'로 지정해 주세요.    예시  예를 들어 ITEM_INFO 테이블이 다음과 같다면           ITEM_ID ITEM_NAME RARITY PRICE            0 ITEM_A COMMON 10000   1 ITEM_B LEGEND 9000   2 ITEM_C LEGEND 11000   3 ITEM_D UNIQUE 10000   4 ITEM_E LEGEND 12000          조건에 해당되는 아이템의 아이템 ID는 1, 2, 4이며 각 아이템들의 가격은 9000, 11000, 12000 이므로 조건에 해당되는 아이템들의 가격의 합은 다음과 같습니다.           TOTAL_PRICE            32000            ※ 참고: 본 문제는 제출 내역 확인 기능을 지원하지 않습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   LIKE로 문자열을 비교해서 일치하는 레코드만 남긴 뒤 SUM으로 합을 구했다.       코드    SELECT SUM(PRICE) AS TOTAL_PRICE     FROM ITEM_INFO         WHERE RARITY LIKE 'LEGEND';   "
  },
  
  {
    "title": "LeetCode_maximum-points-you-can-obtain-from-cards (Java)",
    "url": "/posts/LeetCodemaximum-points-you-can-obtain-from-cards-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-04-26 15:13:02 +0900",
    "content": "1538. Maximum Points You Can Obtain from Cards Medium  There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.  In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.  Your score is the sum of the points of the cards you have taken.  Given the integer array cardPoints and the integer k, return the maximum score you can obtain.  &nbsp; Example 1:   Input: cardPoints = [1,2,3,4,5,6,1], k = 3 Output: 12 Explanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.   Example 2:   Input: cardPoints = [2,2,2], k = 2 Output: 4 Explanation: Regardless of which two cards you take, your score will always be 4.   Example 3:   Input: cardPoints = [9,7,7,9,7,7,9], k = 7 Output: 55 Explanation: You have to take all the cards. Your score is the sum of points of all cards.   &nbsp; Constraints:   \t1 &lt;= cardPoints.length &lt;= 105 \t1 &lt;= cardPoints[i] &lt;= 104 \t1 &lt;= k &lt;= cardPoints.length      문제 풀이   누적합으로 풀이했다. 한 쪽에서 연속으로 뽑을 수 있고 왼쪽과 오른쪽만 선택 가능하므로 양쪽에서 각각 연속으로 몇개를 뽑는가가 중요하다. 순서는 상관없고 개수가 중요하다.      코드   import java.util.*;  class Solution {     public int maxScore(int[] cardPoints, int k) {         int n = cardPoints.length;         int sum=0;         for(int i=0; i&lt;n; i++){             sum += cardPoints[i];         }          if(k &gt;=n) return sum;          int[] LtoR_PrefixSum = new int[n];         int[] RtoL_PrefixSum = new int[n];          LtoR_PrefixSum[0] = cardPoints[0];         for(int i=1; i&lt;n; i++){             LtoR_PrefixSum[i] = LtoR_PrefixSum[i-1] + cardPoints[i];         }          RtoL_PrefixSum[n-1] = cardPoints[n-1];         for(int i=n-2; i&gt;=0; i--){             RtoL_PrefixSum[i] = RtoL_PrefixSum[i+1] + cardPoints[i];         }          System.out.println(Arrays.toString(LtoR_PrefixSum));         System.out.println(Arrays.toString(RtoL_PrefixSum));          int left = k-1;         int right = n;          int res = Math.max(LtoR_PrefixSum[k-1], RtoL_PrefixSum[n-k]);         for(int i = 1; i&lt;= k-1; i++){             res = Math.max(res, LtoR_PrefixSum[left - i] + RtoL_PrefixSum[right - i]);         }         return res;     } }  "
  },
  
  {
    "title": "PGMS_길 찾기 게임 (Java)",
    "url": "/posts/PGMS%EA%B8%B8-%EC%B0%BE%EA%B8%B0-%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-04-23 02:24:24 +0900",
    "content": "[level 3] 길 찾기 게임 - 42892  문제 링크  성능 요약  메모리: 111 MB, 시간: 35.45 ms  구분  코딩테스트 연습 &gt; 2019 KAKAO BLIND RECRUITMENT  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 04월 23일 02:22:35  문제 설명  길 찾기 게임  전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다.  내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다.  라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다.    그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다.    라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다.   트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다. 모든 노드는 서로 다른 x값을 가진다. 같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다. 자식 노드의 y 값은 항상 부모 노드보다 작다. 임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다. 임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.   아래 예시를 확인해보자.  라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.)    이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다.    위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다.   전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3 후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7   다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다. 그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다.   이제 당신이 나설 때가 되었다.   곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때,  노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.  제한사항   nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다.   nodeinfo의 길이는 1 이상 10,000 이하이다. nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다. 모든 노드의 좌표 값은 0 이상 100,000 이하인 정수이다. 트리의 깊이가 1,000 이하인 경우만 입력으로 주어진다. 모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다.      입출력 예           nodeinfo result            [[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]] [[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]          입출력 예 설명  입출력 예 #1  문제에 주어진 예시와 같다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   전위 순회와 후위 순회를 알면 재귀적으로 메서드를 작성해 풀 수 있다. Node 클래스를 만들어서 풀었다.     코드   import java.util.*;  class Solution {     class Node implements Comparable&lt;Node&gt;{         int num;         int x, y;         Node left, right;         Node(int num, int x, int y){             this.num = num;             this.x = x;             this.y = y;         }                  @Override         public int compareTo(Node o){             if(this.y == o.y) return this.x - o.x;             return o.y - this.y;         }              }     List&lt;Integer&gt; preorder, postorder;     public int[][] solution(int[][] nodeinfo) {                 int N = nodeinfo.length;         List&lt;Node&gt; board = new ArrayList&lt;&gt;();         for(int i=0; i&lt;N; i++){             board.add(new Node(i+1, nodeinfo[i][0], nodeinfo[i][1]));         }                  Collections.sort(board);                  Node root = board.get(0);                      for(int i=1; i&lt;board.size(); i++){             insert(root, board.get(i));         }                           preorder = new ArrayList&lt;&gt;();         postorder = new ArrayList&lt;&gt;();                  getPreOrder(root);         getPostOrder(root);                  int[][] res = new int[2][N];                  for(int i=0; i&lt;N; i++){             res[0][i] = preorder.get(i);             res[1][i] = postorder.get(i);         }         return res;     }          private void insert(Node parent, Node child){         // 왼쪽자식         if(child.x &lt; parent.x){             if(parent.left == null) parent.left = child;             else insert(parent.left, child);         }         // 오른쪽자식         else{             if(parent.right == null) parent.right = child;             else insert(parent.right, child);         }     }          private void getPreOrder(Node node){         if(node == null) return;                  preorder.add(node.num);         getPreOrder(node.left);         getPreOrder(node.right);     }          private void getPostOrder(Node node){         if(node == null) return;                  getPostOrder(node.left);         getPostOrder(node.right);         postorder.add(node.num);     } }  "
  },
  
  {
    "title": "PGMS_가사 검색 (Java)",
    "url": "/posts/PGMS%EA%B0%80%EC%82%AC-%EA%B2%80%EC%83%89-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-04-23 00:18:13 +0900",
    "content": "[level 4] 가사 검색 - 60060  문제 링크  성능 요약  메모리: 819 MB, 시간: 1025.94 ms  구분  코딩테스트 연습 &gt; 2020 KAKAO BLIND RECRUITMENT  채점결과  정확성: 25.0효율성: 75.0합계: 100.0 / 100.0  제출 일자  2025년 04월 23일 00:14:06  문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  친구들로부터 천재 프로그래머로 불리는 \"프로도\"는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다. 그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어  \"fro??\"는 \"frodo\", \"front\", \"frost\" 등에 매치되지만 \"frame\", \"frozen\"에는 매치되지 않습니다.  가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요.  가사 단어 제한사항   words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다. 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다. 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다. 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.   검색 키워드 제한사항   queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다. 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다. 검색 키워드는 중복될 수도 있습니다. 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 '?' 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드는 와일드카드 문자인 '?'가 하나 이상 포함돼 있으며, '?'는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다.   예를 들어 \"??odo\", \"fro??\", \"?????\"는 가능한 키워드입니다. 반면에 \"frodo\"('?'가 없음), \"fr?do\"('?'가 중간에 있음), \"?ro??\"('?'가 양쪽에 있음)는 불가능한 키워드입니다.    입출력 예           words queries result            [\"frodo\", \"front\", \"frost\", \"frozen\", \"frame\", \"kakao\"] [\"fro??\", \"????o\", \"fr???\", \"fro???\", \"pro?\"] [3, 2, 4, 1, 0]          입출력 예에 대한 설명   \"fro??\"는 \"frodo\", \"front\", \"frost\"에 매치되므로 3입니다. \"????o\"는 \"frodo\", \"kakao\"에 매치되므로 2입니다. \"fr???\"는 \"frodo\", \"front\", \"frost\", \"frame\"에 매치되므로 4입니다. \"fro???\"는 \"frozen\"에 매치되므로 1입니다. \"pro?\"는 매치되는 가사 단어가 없으므로 0 입니다.      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     트라이 문제라고 생각한다. 여러 길이 (최대 10만)와 여러 쿼리 (최대 10만개) 가 있다.  각 문자를 정방향, 역방향 트라이를 만들어 넣고, 각 문자마다 n글자일 때 몇개의 단어가 있는지 저장한다.     코드   import java.util.*;  class Solution {     class Trie{         Trie[] children;         Map&lt;Integer, Integer&gt; countMap; // 각 길이별 가능한 개수         public Trie(){             children = new Trie[26];             countMap = new HashMap&lt;&gt;();         }                  public void insert(String s, int length){             Trie node = this;             node.countMap.put(length, node.countMap.getOrDefault(length, 0) + 1);                          for(char c : s.toCharArray()){                 if(node.children[c-'a'] == null) node.children[c-'a'] = new Trie();                                  node = node.children[c-'a'];                 node.countMap.put(length, node.countMap.getOrDefault(length, 0) + 1);             }         }                  public int query(String s, int length){             Trie node = this;                          // ? 전까지 일치하는 노드로             for(char c : s.toCharArray()){                 if(c == '?') break;                                  if(node.children[c-'a'] == null) return 0;                 node = node.children[c-'a'];             }                          return node.countMap.getOrDefault(length, 0);         }     }     public int[] solution(String[] words, String[] queries) {         int[] res = new int[queries.length];         Trie normalTrie = new Trie();         Trie reverseTrie = new Trie();         Map&lt;Integer, Integer&gt; lenCount = new HashMap&lt;&gt;();                  for(String w : words){             lenCount.put(w.length(), lenCount.getOrDefault(w.length(), 0) + 1);             normalTrie.insert(w, w.length());             StringBuilder sb = new StringBuilder(w);             sb.reverse();             reverseTrie.insert(sb.toString(), sb.toString().length());         }                  for(int i=0; i&lt;queries.length; i++){             String q = queries[i];                          // \"????????\" 인 경우             if(q.charAt(0) == '?' &amp;&amp; q.charAt(q.length() - 1) == '?'){                 res[i] = lenCount.getOrDefault(q.length(), 0);                 continue;             }                          // xxxx????? 인 경우             if(q.charAt(q.length() - 1) == '?'){                 res[i] = normalTrie.query(q, q.length());             }             // ?????xxxx 인 경우             else{                 StringBuilder sb = new StringBuilder(q);                 sb.reverse();                 res[i] = reverseTrie.query(sb.toString(), sb.toString().length());             }         }         return res;     } }  "
  },
  
  {
    "title": "PGMS_연도별 대장균 크기의 편차 구하기 (SQL)",
    "url": "/posts/PGMS%EC%97%B0%EB%8F%84%EB%B3%84-%EB%8C%80%EC%9E%A5%EA%B7%A0-%ED%81%AC%EA%B8%B0%EC%9D%98-%ED%8E%B8%EC%B0%A8-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-04-22 23:25:32 +0900",
    "content": "[level 2] 연도별 대장균 크기의 편차 구하기 - 299310  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SUM， MAX， MIN  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 04월 22일 23:23:28  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  분화된 연도(YEAR), 분화된 연도별 대장균 크기의 편차(YEAR_DEV), 대장균 개체의 ID(ID) 를 출력하는 SQL 문을 작성해주세요. 분화된 연도별 대장균 크기의 편차는 분화된 연도별 가장 큰 대장균의 크기 - 각 대장균의 크기로 구하며 결과는 연도에 대해 오름차순으로 정렬하고 같은 연도에 대해서는 대장균 크기의 편차에 대해 오름차순으로 정렬해주세요.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 10 2019/01/01 5   2 NULL 2 2019/01/01 3   3 1 100 2020/01/01 4   4 2 10 2020/01/01 4   5 2 17 2020/01/01 6   6 4 101 2021/01/01 22          분화된 연도별 가장 큰 대장균의 크기는 다음과 같습니다.  2019 : 10 2020 : 100 2021 : 101  따라서 각 대장균의 분화된 연도별 대장균 크기의 편차는 다음과 같습니다.  ID 1 : 10 - 10 = 0 ID 2 : 10 -2 = 8 ID 3 : 100 - 100 = 0 ID 4 : 100 - 10 = 90 ID 5 : 100 - 17 = 83 ID 6 : 101 -101 - 0  이를 분화된 연도에 대해 오름차순으로 정렬하고 같은 연도에 대해서는 대장균 크기의 편차에 대해 오름차순으로 정렬하면 결과는 다음과 같아야 합니다.           YEAR YEAR_DEV ID            2019 0 1   2019 8 2   2020 0 3   2020 83 5   2020 90 4   2021 0 6              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   연도별 최대 크기를 subquery로 구한 뒤 그것을 사용해서 각 편차를 구했고, ORDER BY 기준도 먼저 쓰는게 우선적으로 적용되므로 2개를 적어줬다.     코드   SELECT YEAR(DIFFERENTIATION_DATE) AS YEAR,      (SELECT MAX(SIZE_OF_COLONY)      FROM ECOLI_DATA      WHERE YEAR(DIFFERENTIATION_DATE) = YEAR(ed.DIFFERENTIATION_DATE)) - ed.SIZE_OF_COLONY AS YEAR_DEV,      ID         FROM ECOLI_DATA AS ed             ORDER BY YEAR ASC, YEAR_DEV ASC;  "
  },
  
  {
    "title": "BOJ_11438_LCA 2 (Java)",
    "url": "/posts/BOJ11438LCA-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-04-16 23:59:04 +0900",
    "content": "[Platinum V] LCA 2 - 11438  문제 링크  ### 성능 요약  메모리: 108964 KB, 시간: 952 ms  ### 분류  자료 구조, 최소 공통 조상, 희소 배열, 트리  ### 제출 일자  2025년 4월 16일 23:37:54  ### 문제 설명  N(2 ≤ N ≤ 100,000)개의 정점으로 이루어진 트리가 주어진다. 트리의 각 정점은 1번부터 N번까지 번호가 매겨져 있으며, 루트는 1번이다.  두 노드의 쌍 M(1 ≤ M ≤ 100,000)개가 주어졌을 때, 두 노드의 가장 가까운 공통 조상이 몇 번인지 출력한다.  ### 입력  첫째 줄에 노드의 개수 N이 주어지고, 다음 N-1개 줄에는 트리 상에서 연결된 두 정점이 주어진다. 그 다음 줄에는 가장 가까운 공통 조상을 알고싶은 쌍의 개수 M이 주어지고, 다음 M개 줄에는 정점 쌍이 주어진다.  ### 출력  M개의 줄에 차례대로 입력받은 두 정점의 가장 가까운 공통 조상을 출력한다.     문제 풀이        트리에 대한 정보가 주어지고 두 노드의 가장 가까운 공통 조상 노드를 결과로 출력   루트 노드는 항상 1번   트리의 각 정점은 1번~N번까지 존재      입력된 트리의 정보를 저장   입력된 정보로 트리 형성 및 부모 노드(DP)와 깊이를 따로 저장   M개의 노드 쌍에 대한 공통 조상 노드를 찾아서 결과로 출력   DP 구성하기 (희소 배열) 조상 노드에 대한 메모이제이션으로 dp[][]를 구성          dp[m][n] = m번 노드의 2ⁿ만큼 위에 있는 부모 노드를 가리킴           점화식 : dp[m][n] = dp[dp[m][n-1]][n-1]      공통 조상 노드 구하기          두 노드의 깊이가 다르면 깊이가 같아지도록 맞춤           이진 탐색(희소 배열)을 이용해 탐색 횟수를 줄임           깊이가 같아지면 부모 노드로 동시에 이동하며 같은 노드를 가리킬 때까지 반복         코드   /**   * Author: nowalex322, Kim HyeonJae   */    import java.io.*;  import java.util.*;    public class Main {      static BufferedReader br;      static BufferedWriter bw;      static StringTokenizer st;      static int N, M, maxH;      static int[] depth;      static int[][] dp;      static ArrayList&lt;Integer&gt;[] tree;      public static void main(String[] args) throws Exception {          new Main().solution();      }        public void solution() throws Exception {          br = new BufferedReader(new InputStreamReader(System.in));  //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_11438_LCA2/input.txt\")));          bw = new BufferedWriter(new OutputStreamWriter(System.out));            N = Integer.parseInt(br.readLine());            // 트리의 maxH          for(int i=1; i&lt;=N; i*=2){              maxH++;          }            dp = new int[N+1][maxH];          depth = new int[N+1];            tree = new ArrayList[N+1];          for(int i=0; i&lt;=N; i++){              tree[i] = new ArrayList&lt;&gt;();          }            for(int i=1; i&lt;N; i++){              st = new StringTokenizer(br.readLine());              int u = Integer.parseInt(st.nextToken());              int v = Integer.parseInt(st.nextToken());              tree[u].add(v);              tree[v].add(u);          }            initTree(1, 1, 0);          initParent();            M = Integer.parseInt(br.readLine());          for(int i=1; i&lt;=M; i++){              st = new StringTokenizer(br.readLine());              int a = Integer.parseInt(st.nextToken());              int b = Integer.parseInt(st.nextToken());              bw.write(LCA(a, b) + \"\\n\");          }            bw.flush();          bw.close();          br.close();      }        private static int LCA(int a, int b) {          int a_h = depth[a];          int b_h = depth[b];            // a높이 항상 크게 유지          if(a_h &lt; b_h){              int tmp = a;              a = b;              b = tmp;          }            //같은 높이에서 시작하게 높이 맞추기          for(int i=maxH-1; i&gt;=0; i--){              a_h = depth[a];              b_h = depth[b];              int depthGap = a_h - b_h;                if(Math.pow(2, i) &lt;= depthGap) a = dp[a][i]; //희소 배열처럼 점프          }            if(a==b) return a;            // 같은 부모 가리킬때까지 위로 진행 (같은 높이)          for(int i=maxH-1; i&gt;=0; i--){              if(dp[a][i] != dp[b][i]){                  a = dp[a][i];                  b = dp[b][i];              }          }            return dp[a][0];      }        private void initParent() { // dp(부모저장2차원배열) 점화식          for(int h=1; h&lt;maxH; h++){              for(int node=1; node&lt;=N; node++){                  dp[node][h] = dp[dp[node][h-1]][h-1]; // node의 2^h번째 부모 = (node의 부모)의 2^(h-1)번째 부모              }          }      }        private static void initTree(int child, int parent, int d) { // 재귀적으로 아래로 내려가며 트리 형태 만들기          depth[child] = d;          dp[child][0] = parent;          for(int next : tree[child]){              if(next == parent) continue;              initTree(next, child, d+1);          }      }      }  "
  },
  
  {
    "title": "PGMS_풍선 터트리기 (Java)",
    "url": "/posts/PGMS%ED%92%8D%EC%84%A0-%ED%84%B0%ED%8A%B8%EB%A6%AC%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-04-16 00:51:27 +0900",
    "content": "[level 3] 풍선 터트리기 - 68646  문제 링크  성능 요약  메모리: 128 MB, 시간: 33.98 ms  구분  코딩테스트 연습 &gt; 월간 코드 챌린지 시즌1  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 04월 16일 00:47:01  문제 설명  일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.   임의의 인접한 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.   여기서 조건이 있습니다. 인접한 두 풍선 중에서 번호가 더 작은 풍선을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.  당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 불가능할 수도 있습니다.  일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.    제한 사항   a의 길이는 1 이상 1,000,000 이하입니다.   a[i]는 i+1 번째 풍선에 써진 숫자를 의미합니다. a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다. a의 모든 수는 서로 다릅니다.      입출력 예           a result            [9,-1,-5] 3   [-16,27,65,-2,58,-92,-71,-68,-61,-33] 6            입출력 예 설명  입출력 예 #1   첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.   [9, -1, -5] 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다. [9, -5] 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.  두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.   [9, -1, -5] 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다. [-1, -5] 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.  세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.   [9, -1, -5] 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다. [-1, -5] 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.  3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.   입출력 예 #2   최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   일단 문제 제목이 터트리다여서 터뜨리다 아닌가? 하고 찾아보니 예전엔 터트리다가 틀렸는데 복수 표준어라서 둘 다 맞다고 한다.    양쪽 그룹의 최솟값이 지금 보고있는 숫자보다 둘 다 작다면 그 숫자는 불가능.  예시로 [-5, 9, -1]을 해보면 알 것이다.     코드   // 20min  import java.util.*;  class Solution {     public int solution(int[] a) {         if(a.length&lt;=2) return a.length;                  int res = a.length;         int[] left_min = new int[a.length];         int[] right_min = new int[a.length];                  left_min[0] = Integer.MAX_VALUE;         for(int i=1; i&lt;a.length; i++){             left_min[i] = Math.min(left_min[i-1], a[i-1]);         }          right_min[a.length-1] = Integer.MAX_VALUE;         for(int i=a.length-2; i&gt;=0; i--){                         right_min[i] = Math.min(right_min[i+1], a[i+1]);         }                  for(int i=0; i&lt;a.length; i++){             if(left_min[i] &lt; a[i] &amp;&amp; right_min[i] &lt; a[i]) res--;         }         // System.out.println(Arrays.toString(left_min));         // System.out.println(Arrays.toString(right_min));         return res;     } }  "
  },
  
  {
    "title": "LeetCode_Restore IP Addresses (Java)",
    "url": "/posts/LeetCodeRestore-IP-Addresses-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-04-15 23:49:32 +0900",
    "content": "   Leethub 으로 간단하게 Github에 문제와 코드를 업로드하세요!   93. Restore IP Addresses Medium  A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.   \tFor example, &quot;0.1.2.201&quot; and &quot;192.168.1.1&quot; are valid IP addresses, but &quot;0.011.255.245&quot;, &quot;192.168.1.312&quot; and &quot;192.168@1.1&quot; are invalid IP addresses.   Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.  &nbsp; Example 1:   Input: s = &quot;25525511135&quot; Output: [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]   Example 2:   Input: s = &quot;0000&quot; Output: [&quot;0.0.0.0&quot;]   Example 3:   Input: s = &quot;101023&quot; Output: [&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]   &nbsp; Constraints:   \t1 &lt;= s.length &lt;= 20 \ts consists of digits only.      문제 풀이   dfs와 백트래킹으로 간단하게 풀 수 있다. 답을 만들 때는 Stringbuilder을 사용했다. 다시 백트래킹시킬때 setLength로 이전상황으로 만들었다.     코드   import java.util.*;  class Solution {     static String str;     static List&lt;String&gt; res;     static StringBuilder sb;     public List&lt;String&gt; restoreIpAddresses(String s) {         str = s;         res = new ArrayList&lt;&gt;();         sb = new StringBuilder();          int len = s.length();         if(len &lt;= 3 || len &gt;= 13) return res;          dfs(0, 0); // 0개, 0위치 -&gt; 4개, 끝위치 까지 진행         return res;     }      void dfs(int depth, int startIdx){         if(depth == 4 &amp;&amp; startIdx == str.length()){             res.add(sb.toString());             return;         }          if(depth &gt; 4 || startIdx &gt;= str.length()) return;          for(int i=1; i&lt;=3 &amp;&amp; startIdx+i &lt;= str.length(); i++){             String part = str.substring(startIdx, startIdx + i);              int prev_sbLen = sb.length();             if(isValid(part)){                 if(prev_sbLen&gt;0) sb.append(\".\");                 sb.append(part);                 dfs(depth+1, startIdx+i);                 sb.setLength(prev_sbLen);             }         }     }      boolean isValid(String s){         int s_len = s.length();         int num = Integer.parseInt(s);         if(s_len == 1){             return num &gt;= 0 &amp;&amp; num &lt;= 9;         }         else if(s_len == 2){             return num &gt;= 10 &amp;&amp; num &lt;= 99;         }         else if(s_len == 3){             return num &gt;= 100 &amp;&amp; num &lt;= 255;         }         return false;     } }  "
  },
  
  {
    "title": "BOJ_1520_내리막 길 (Java)",
    "url": "/posts/BOJ1520%EB%82%B4%EB%A6%AC%EB%A7%89-%EA%B8%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-04-15 22:45:32 +0900",
    "content": "[Gold III] 내리막 길 - 1520  문제 링크  ### 성능 요약  메모리: 48580 KB, 시간: 488 ms  ### 분류  깊이 우선 탐색, 다이나믹 프로그래밍, 그래프 이론, 그래프 탐색  ### 제출 일자  2025년 4월 15일 22:39:47  ### 문제 설명  여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.    현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.      지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.  ### 입력  첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.  ### 출력  첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.     문제 풀이     Top-Down DP + dfs를 활용하려 하다가 메모이제이션을 해도 시간복잡도가 dfs는 매우 커지니까 (500x500이면 최대 $3^{500}$) 순수 Bottom-up DP로 풀었다.  dp[r][c] 는 (r, c) 에서 맨 오른쪽 아래로 가는 경우의 수다. 그러므로 맨 오른쪽아래 위치 dp값은 1이다.     코드   package BOJ_1520_내리막길;  /**  * 22:10 ~ 22:40  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Node implements Comparable&lt;Node&gt;{         int r, c, h;         public Node(int r, int c, int h) {             this.r = r;             this.c = c;             this.h = h;         }          public int compareTo(Node o) {             return this.h - o.h;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static int[] dr = {-1, 0, 1, 0}, dc = {0, 1, 0, -1};     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1520_내리막길/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          int[][] board = new int[N][M];         int[][] dp = new int[N][M];         dp[N-1][M-1] = 1;          PriorityQueue&lt;Node&gt; nodes = new PriorityQueue&lt;&gt;();          for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; M; j++) {                 int num = Integer.parseInt(st.nextToken());                 board[i][j] = num;                 nodes.add(new Node(i, j, num));             }         }          while(!nodes.isEmpty()) {             Node curr = nodes.poll();              for(int k=0; k&lt;4; k++) {                 int nr = curr.r + dr[k];                 int nc = curr.c + dc[k];                 if(isValid(nr, nc)){                     if(isLow(curr.h, board[nr][nc])){                          dp[nr][nc] += dp[curr.r][curr.c];                     }                 }             }         }          for(int i=0; i&lt;N; i++){             System.out.println(Arrays.toString(dp[i]));         }          System.out.println(dp[0][0]);         br.close();     }      private static boolean isValid(int r, int c) {         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     }      private static boolean isLow(int curr, int next){         return curr &lt; next;     } }  "
  },
  
  {
    "title": "PGMS_부모의 형질을 모두 가지는 대장균 찾기 (SQL)",
    "url": "/posts/PGMS%EB%B6%80%EB%AA%A8%EC%9D%98-%ED%98%95%EC%A7%88%EC%9D%84-%EB%AA%A8%EB%91%90-%EA%B0%80%EC%A7%80%EB%8A%94-%EB%8C%80%EC%9E%A5%EA%B7%A0-%EC%B0%BE%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-04-15 21:53:44 +0900",
    "content": "[level 2] 부모의 형질을 모두 가지는 대장균 찾기 - 301647  문제 링크  ### 성능 요약  메모리: undefined, 시간:  ### 구분  코딩테스트 연습 &gt; SELECT  ### 채점결과  합계: 100.0 / 100.0  ### 제출 일자  2025년 04월 15일 21:49:02  ### 문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다.  다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.             Column name  Type  Nullable                ID  INTEGER  FALSE      PARENT_ID  INTEGER  TRUE      SIZE_OF_COLONY  INTEGER  FALSE      DIFFERENTIATION_DATE  DATE  FALSE      GENOTYPE  INTEGER  FALSE             최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  부모의 형질을 모두 보유한 대장균의 ID(ID), 대장균의 형질(GENOTYPE), 부모 대장균의 형질(PARENT_GENOTYPE)을 출력하는 SQL 문을 작성해주세요. 이때 결과는 ID에 대해 오름차순 정렬해주세요.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면             ID  PARENT_ID  SIZE_OF_COLONY  DIFFERENTIATION_DATE  GENOTYPE                1  NULL  10  2019/01/01  1      2  1  2  2019/01/01  1      3  1  100  2020/01/01  3      4  2  16  2020/01/01  2      5  4  17  2020/01/01  8      6  3  101  2021/01/01  5      7  2  101  2022/01/01  5      8  6  1  2022/01/01  13             각 대장균 별 형질을 2진수로 나타내면 다음과 같습니다.  ID 1 : 1₍₂₎  ID 2 : 1₍₂₎  ID 3 : 11₍₂₎  ID 4 : 10₍₂₎  ID 5 : 1000₍₂₎  ID 6 : 101₍₂₎  ID 7 : 101₍₂₎  ID 8 : 1101₍₂₎  각 대장균 별 보유한 형질을 다음과 같습니다.  ID 1 : 1  ID 2 : 1  ID 3 : 1, 2  ID 4 : 2  ID 5 : 4  ID 6 : 1, 3  ID 7 : 1, 3  ID 8 : 1, 3, 4  각 개체별로 살펴보면 다음과 같습니다.  ID 1 : 최초의 대장균 개체이므로 부모가 없습니다.  ID 2 : 부모는 ID 1 이며 부모의 형질인 1번 형질을 보유하고 있습니다.  ID 3 : 부모는 ID 1 이며 부모의 형질인 1번 형질을 보유하고 있습니다.  ID 4 : 부모는 ID 2 이며 부모의 형질인 1번 형질을 보유하고 있지 않습니다.  ID 5 : 부모는 ID 4 이며 부모의 형질인 2번 형질을 보유하고 있지 않습니다.  ID 6 : 부모는 ID 3 이며 부모의 형질 1, 2번 중 2 번 형질을 보유하고 있지 않습니다.  ID 7 : 부모는 ID 2 이며 부모의 형질인 1번 형질을 보유하고 있습니다.  ID 8 : 부모는 ID 6 이며 부모의 형질 1, 3번을 모두 보유하고 있습니다.  따라서 부모의 형질을 모두 보유한 개체는 ID 2, ID 3, ID 7, ID 8 이며 결과를 ID 에 대해 오름차순 정렬하면 다음과 같아야 합니다.             ID  GENOTYPE  PARENT_GENOTYPE                2  1  1      3  3  1      7  5  1      8  13  5                 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   두 테이블을 JOIN 해서 부모와 자식끼리 연결한 뒤 비트연산자 &amp; 을 통해 부모의 유전자형질이 자식에 포함되면 가능.     코드   SELECT c.ID, c.GENOTYPE, p.GENOTYPE AS PARENT_GENOTYPE      FROM ECOLI_DATA AS c          JOIN ECOLI_DATA AS p              ON c.PARENT_ID = p.ID                  WHERE (c.GENOTYPE &amp; p.GENOTYPE) = p.GENOTYPE                      ORDER BY c.ID ASC;  "
  },
  
  {
    "title": "BOJ_20125_쿠키의 신체 측정 (Java)",
    "url": "/posts/BOJ20125%EC%BF%A0%ED%82%A4%EC%9D%98-%EC%8B%A0%EC%B2%B4-%EC%B8%A1%EC%A0%95-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-04-11 21:05:25 +0900",
    "content": "[Silver IV] 쿠키의 신체 측정 - 20125  문제 링크  ### 성능 요약  메모리: 21568 KB, 시간: 260 ms  ### 분류  구현  ### 제출 일자  2025년 4월 11일 20:59:58  ### 문제 설명  쿠키런은 데브시스터즈에서 제작한 모바일 러닝 액션 게임이다. 마녀의 오븐에서 탈출한 쿠키들과 함께 모험을 떠나는 게임으로, 점프와 슬라이드 2가지 버튼만으로 손쉽게 플레이할 수 있는 것이 특징이다.  연세대학교를 졸업한 김강산 선배님이 데브시스터즈에 취직하면서 주변 사람들에게 쿠키런을 전파시켰다. 하지만 게임을 전파하던 중에 쿠키들에게 신체적으로 이상이 생기는 것을 발견하였다. 팔, 다리 길이가 임의적으로 변한 것이다. 때문에 긴급하게 각 쿠키들의 신체들을 측정하려고 한다.  쿠키들은 신체를 측정하기 위해서 한 변의 길이가 N인 정사각형 판 위에 누워있으며, 어느 신체 부위도 판 밖으로 벗어나지 않는다. 판의 x번째 행, y번째 열에 위치한 곳을 (x, y)로 지칭한다. 판의 맨 왼쪽 위 칸을 (1, 1), 오른쪽 아래 칸을 (N, N)으로 나타낼 수 있다.    그림과 같이 쿠키의 신체는 머리, 심장, 허리, 그리고 좌우 팔, 다리로 구성되어 있다. 그림에서 빨간 곳으로 칠해진 부분이 심장이다. 머리는 심장 바로 윗 칸에 1칸 크기로 있다. 왼쪽 팔은 심장 바로 왼쪽에 붙어있고 왼쪽으로 뻗어 있으며, 오른쪽 팔은 심장 바로 오른쪽에 붙어있고 오른쪽으로 뻗어있다. 허리는 심장의 바로 아래 쪽에 붙어있고 아래 쪽으로 뻗어 있다. 왼쪽 다리는 허리의 왼쪽 아래에, 오른쪽 다리는 허리의 오른쪽 아래에 바로 붙어있고, 각 다리들은 전부 아래쪽으로 뻗어 있다. 각 신체 부위들은 절대로 끊겨있지 않으며 굽혀진 곳도 없다. 또한, 허리, 팔, 다리의 길이는 1 이상이며, 너비는 무조건 1이다.  쿠키의 신체가 주어졌을 때 심장의 위치와 팔, 다리, 허리의 길이를 구하여라.  ### 입력  다음과 같이 입력이 주어진다.  N  a1,1 . . . a1,N  . . . . . .  aN,1 . . . aN,N  ### 출력  첫 번째 줄에는 심장이 위치한 행의 번호 x와 열의 번호 y를 공백으로 구분해서 출력한다.  두 번째 줄에는 각각 왼쪽 팔, 오른쪽 팔, 허리, 왼쪽 다리, 오른쪽 다리의 길이를 공백으로 구분해서 출력하여라.     문제 풀이   간단한 구현문제다. 내 생각에 내 코드는 별로 효율적인 것 같진 않다. 그냥 읽고 문제 풀면 풀 수 있는 문제다.  좀 더 나은 방향으로 풀자면 입력을 받으며 그때그떄 필요한 정보를 기억해놓고, 구할 수 있는 값을 구하는것이다.  머리 : 처음 별 하나 나올때 -&gt; 이 정보로 심장 구할 수 있음 -&gt; 심장 좌우로 팔 길이 구할 수 있음  심장 구했으면 -&gt; 쭉 내려가면서 그 세로선으로 몸통 길이가 나옴 -&gt; 몸통의 끝이 나온다는건 다음에 다리가 나온다는 것.  다리도 col 좌표 이미 머리 저장한 순간 구해지므로 세로로 2번 해도되고, 입력 받으면서 그 column별로 각각 1씩 더해주면서 진행해도됨.  내 생각에 가장 효율적인건 입력을 받으면서 모두 계산하고 (필요한 반복문 만큼만) 바로 정답 출력하는것.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_20125_쿠키의신체측정/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int N = Integer.parseInt(br.readLine());         char[][] board = new char[N][N];          int[] head = new int[2];         boolean firstStar = false;          int[] heart = new int[2];          int armLen = 0;          int[] belly = new int[2];          for (int i = 0; i &lt; N; i++) {             String line = br.readLine();             int cnt = 0;             for (int j = 0; j &lt; N; j++) {                 board[i][j] = line.charAt(j);                 if (board[i][j] == '*' &amp;&amp; !firstStar) {                     firstStar = true;                     head[0] = i;                     head[1] = j;                 }                  if (board[i][j] == '*') {                     cnt++;                     if (cnt &gt;= 3) {                         heart[0] = i;                         heart[1] = head[1];                     }                 }                 if (i == heart[0]) armLen = cnt;             }         }          int legR = 0;         for (int i = head[0]; i &lt; N; i++) {             if (board[i][head[1]] != '*') {                 legR = i;                 break;             }         }         belly[1] = head[1];         belly[0] = legR - 1;          List&lt;Integer&gt; l_list = new ArrayList&lt;&gt;();         for (int j = head[1] - 1; j &lt;= head[1] + 1; j += 2) {             int l_cnt = 0;             for (int i = legR; i &lt; N; i++) {                 if (board[i][j] == '*') {                     l_cnt++;                 } else break;             }             l_list.add(l_cnt);         }          int a_cnt = 0;         for (int j = 0; j &lt; N; j++) {             if (j &gt;= (heart[1] + 1) &amp;&amp; board[heart[0]][j] == '*') {                 a_cnt++;             }         }          StringBuilder sb = new StringBuilder();         sb.append(heart[0] + 1).append(\" \").append(heart[1] + 1).append(\"\\n\");         sb.append(armLen - (1 + a_cnt)).append(\" \").append(a_cnt).append(\" \").append(belly[0] - heart[0]).append(\" \").append(l_list.get(0)).append(\" \").append(l_list.get(1));         System.out.println(sb.toString());          br.close();     } }   "
  },
  
  {
    "title": "PGMS_헤비 유저가 소유한 장소 (SQL)",
    "url": "/posts/PGMS%ED%97%A4%EB%B9%84-%EC%9C%A0%EC%A0%80%EA%B0%80-%EC%86%8C%EC%9C%A0%ED%95%9C-%EC%9E%A5%EC%86%8C-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-04-07 18:21:45 +0900",
    "content": "[level 3] 헤비 유저가 소유한 장소 - 77487  문제 링크  ### 성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  ### 구분  코딩테스트 연습 &gt; 2021 Dev－Matching： 웹 백엔드 개발자（상반기）  ### 채점결과  Empty  ### 제출 일자  2025년 04월 07일 18:17:08  ### 문제 설명  PLACES 테이블은 공간 임대 서비스에 등록된 공간의 정보를 담은 테이블입니다. PLACES 테이블의 구조는 다음과 같으며 ID, NAME, HOST_ID는 각각 공간의 아이디, 이름, 공간을 소유한 유저의 아이디를 나타냅니다. ID는 기본키입니다.             NAME  TYPE                ID  INT      NAME  VARCHAR      HOST_ID  INT             문제  이 서비스에서는 공간을 둘 이상 등록한 사람을 \"헤비 유저\"라고 부릅니다. 헤비 유저가 등록한 공간의 정보를 아이디 순으로 조회하는 SQL문을 작성해주세요.  예시  예를 들어, PLACES 테이블이 다음과 같다면             ID  NAME  HOST_ID                4431977  BOUTIQUE STAYS - Somerset Terrace, Pet Friendly  760849      5194998  BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly  760849      16045624  Urban Jungle in the Heart of Melbourne  30900122      17810814  Stylish Bayside Retreat with a Luscious Garden  760849      22740286  FREE PARKING - The Velvet Lux in Melbourne CBD  30900122      22868779  ★ Fresh Fitzroy Pad with City Views! ★  21058208               760849번 유저는 공간을 3개 등록했으므로 이 유저는 헤비유저입니다.   30900122번 유저는 공간을 2개 등록했으므로 이 유저는 헤비유저입니다.  21058208번 유저는 공간을 1개 등록했으므로 이 유저는 헤비유저가 아닙니다.    따라서 SQL 문을 실행하면 다음과 같이 나와야 합니다.             ID  NAME  HOST_ID                4431977  BOUTIQUE STAYS - Somerset Terrace, Pet Friendly  760849      5194998  BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly  760849      16045624  Urban Jungle in the Heart of Melbourne  30900122      17810814  Stylish Bayside Retreat with a Luscious Garden  760849      22740286  FREE PARKING - The Velvet Lux in Melbourne CBD  30900122                 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        코드   SELECT ID, NAME, HOST_ID     FROM PLACES         WHERE HOST_ID IN(             SELECT HOST_ID             FROM PLACES             GROUP BY HOST_ID             HAVING COUNT(*) &gt;= 2         )             ORDER BY ID ASC;  "
  },
  
  {
    "title": "PGMS_합승 택시 요금 (Java)",
    "url": "/posts/PGMS%ED%95%A9%EC%8A%B9-%ED%83%9D%EC%8B%9C-%EC%9A%94%EA%B8%88-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-04-07 18:18:53 +0900",
    "content": "[level 3] 합승 택시 요금 - 72413  문제 링크  ### 성능 요약  메모리: 85.6 MB, 시간: 125.89 ms  ### 구분  코딩테스트 연습 &gt; 2021 KAKAO BLIND RECRUITMENT  ### 채점결과  정확성: 50.0효율성: 50.0합계: 100.0 / 100.0  ### 제출 일자  2025년 04월 04일 19:48:47  ### 문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  밤늦게 귀가할 때 안전을 위해 항상 택시를 이용하던 무지는 최근 야근이 잦아져 택시를 더 많이 이용하게 되어 택시비를 아낄 수 있는 방법을 고민하고 있습니다. \"무지\"는 자신이 택시를 이용할 때 동료인 어피치 역시 자신과 비슷한 방향으로 가는 택시를 종종 이용하는 것을 알게 되었습니다. \"무지\"는 \"어피치\"와 귀가 방향이 비슷하여 택시 합승을 적절히 이용하면 택시요금을 얼마나 아낄 수 있을 지 계산해 보고 \"어피치\"에게 합승을 제안해 보려고 합니다.    위 예시 그림은 택시가 이동 가능한 반경에 있는 6개 지점 사이의 이동 가능한 택시노선과 예상요금을 보여주고 있습니다.  그림에서 A와 B 두 사람은 출발지점인 4번 지점에서 출발해서 택시를 타고 귀가하려고 합니다. A의 집은 6번 지점에 있으며 B의 집은 2번 지점에 있고 두 사람이 모두 귀가하는 데 소요되는 예상 최저 택시요금이 얼마인 지 계산하려고 합니다.    그림의 원은 지점을 나타내며 원 안의 숫자는 지점 번호를 나타냅니다.      지점이 n개일 때, 지점 번호는 1부터 n까지 사용됩니다.    지점 간에 택시가 이동할 수 있는 경로를 간선이라 하며, 간선에 표시된 숫자는 두 지점 사이의 예상 택시요금을 나타냅니다.      간선은 편의 상 직선으로 표시되어 있습니다.  위 그림 예시에서, 4번 지점에서 1번 지점으로(4→1) 가거나, 1번 지점에서 4번 지점으로(1→4) 갈 때 예상 택시요금은 10원으로 동일하며 이동 방향에 따라 달라지지 않습니다.    예상되는 최저 택시요금은 다음과 같이 계산됩니다.      4→1→5 : A, B가 합승하여 택시를 이용합니다. 예상 택시요금은 10 + 24 = 34원 입니다.  5→6 : A가 혼자 택시를 이용합니다. 예상 택시요금은 2원 입니다.  5→3→2 : B가 혼자 택시를 이용합니다. 예상 택시요금은 24 + 22 = 46원 입니다.  A, B 모두 귀가 완료까지 예상되는 최저 택시요금은 34 + 2 + 46 = 82원 입니다.        [문제]  지점의 개수 n, 출발지점을 나타내는 s, A의 도착지점을 나타내는 a, B의 도착지점을 나타내는 b, 지점 사이의 예상 택시요금을 나타내는 fares가 매개변수로 주어집니다. 이때, A, B 두 사람이 s에서 출발해서 각각의 도착 지점까지 택시를 타고 간다고 가정할 때, 최저 예상 택시요금을 계산해서 return 하도록 solution 함수를 완성해 주세요.  만약, 아예 합승을 하지 않고 각자 이동하는 경우의 예상 택시요금이 더 낮다면, 합승을 하지 않아도 됩니다.  [제한사항]    지점갯수 n은 3 이상 200 이하인 자연수입니다.  지점 s, a, b는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.      즉, 출발지점, A의 도착지점, B의 도착지점은 서로 겹치지 않습니다.    fares는 2차원 정수 배열입니다.  fares 배열의 크기는 2 이상 n x (n-1) / 2 이하입니다.      예를들어, n = 6이라면 fares 배열의 크기는 2 이상 15 이하입니다. (6 x 5 / 2 = 15)  fares 배열의 각 행은 [c, d, f] 형태입니다.  c지점과 d지점 사이의 예상 택시요금이 f원이라는 뜻입니다.  지점 c, d는 1 이상 n 이하인 자연수이며, 각기 서로 다른 값입니다.  요금 f는 1 이상 100,000 이하인 자연수입니다.  fares 배열에 두 지점 간 예상 택시요금은 1개만 주어집니다. 즉, [c, d, f]가 있다면 [d, c, f]는 주어지지 않습니다.    출발지점 s에서 도착지점 a와 b로 가는 경로가 존재하는 경우만 입력으로 주어집니다.      [입출력 예]             n  s  a  b  fares  result                6  4  6  2  [[4, 1, 10], [3, 5, 24], [5, 6, 2], [3, 1, 41], [5, 1, 24], [4, 6, 50], [2, 4, 66], [2, 3, 22], [1, 6, 25]]  82      7  3  4  1  [[5, 7, 9], [4, 6, 4], [3, 6, 1], [3, 2, 3], [2, 1, 6]]  14      6  4  5  6  [[2,6,6], [6,3,7], [4,6,7], [6,5,11], [2,5,12], [5,3,20], [2,4,8], [4,3,9]]  18             입출력 예에 대한 설명    입출력 예 #1  문제 예시와 같습니다.  입출력 예 #2      합승을 하지 않고, B는 3→2→1, A는 3→6→4 경로로 각자 택시를 타고 가는 것이 최저 예상 택시요금입니다.  따라서 최저 예상 택시요금은 (3 + 6) + (1 + 4) = 14원 입니다.    입출력 예 #3      A와 B가 4→6 구간을 합승하고 B가 6번 지점에서 내린 후, A가6→5` 구간을 혼자 타고 가는 것이 최저 예상 택시요금입니다.  따라서 최저 예상 택시요금은 7 + 11 = 18원 입니다.       출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   플로이드-워셜로 풀었다      코드   import java.util.*;  class Solution {     public int solution(int n, int s, int a, int b, int[][] fares) {         int board[][] = new int[n+1][n+1];                  for(int i=1; i&lt;=n; i++){             for(int j=1; j&lt;=n; j++){                 if(i==j) board[i][j] = 0;                 else board[i][j] = Integer.MAX_VALUE;             }         }                  for(int[] f : fares){             board[f[0]][f[1]] = f[2];             board[f[1]][f[0]] = f[2];         }                  for(int k=1; k&lt;=n; k++){             for(int i=1; i&lt;=n; i++){                 for(int j=1; j&lt;=n; j++){                     if(board[i][k] != Integer.MAX_VALUE &amp;&amp; board[k][j] != Integer.MAX_VALUE){                         if(board[i][j] &gt; board[i][k] + board[k][j]) board[i][j] = board[i][k] + board[k][j];                     }                 }             }         }                  int res = Integer.MAX_VALUE;         for(int node=1; node&lt;=n; node++){             res = Math.min(res, board[s][node] + board[node][a] + board[node][b]);         }                  return res;     } }  "
  },
  
  {
    "title": "Hit Me Up ; README.md 방문자 수 카운팅 서비스 ",
    "url": "/posts/README.md-%EB%B0%A9%EB%AC%B8%EC%9E%90-%EC%88%98-%EC%B9%B4%EC%9A%B4%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/",
    "categories": "사이드, 프로젝트",
    "tags": "github, hits, readme",
    "date": "2025-04-05 17:23:32 +0900",
    "content": "   Hit Me Up ; URL 방문자 수 카운팅 서비스 (ver.1)      예전 Readme에 여러가지 뱃지들을 추가할 때 방문자 수를 보여주는 뱃지를 추가했었다. 그런데 최근 어느순간부터 뱃지가 제대로 나오지 않았다.  원래 hits.seeyoufarm.com 에서 뱃지를 만들었었는데 더이상 지원하지 않는지 표시가 안되었다.  구글링을 많이 해 보았지만 대체할만한 서비스가 없어서 직접 만들어보기로 했다.     프로젝트 구성 전   일단 프로젝트를 구성할 때 가장 먼저 생각했던 건 무료로 운영하고자 했다는 점이다. 여러 무료 호스팅 서비스를 살펴본 결과 Firebase 와 Google Cloud Run 을 선정했다.  정적인 단일 페이지 호스팅을 Firebase로, 백엔드 로직을 Cloud Run으로 배포해 두었고 아직 하는중이지만 도메인도 커스텀 매핑 하고자 한다.  익숙한 Java언어 대신 Kotlin공부차 Kotlin + Spring Boot 프로젝트로 백엔드를 구성했다. 정적인 웹 페이지는 html과 css로 간단하게 만들었다.  Database는 Firestore로 간단하게 사용하고자 했다. (NoSQL)     프로젝트 로직   메인 로직에 관해 간단하게 설명하고자 한다.  방문자 카운터의 핵심 기능은 URL마다 방문자 수를 카운팅하는 것이다.     사용자가 웹사이트에서 GitHub 페이지 URL과 배지 옵션(타이틀, 색상 등)을 설정   시스템은 해당 URL에 대한 마크다운 코드와 HTML 코드 생성   사용자는 생성된 마크다운 코드를 자신의 GitHub README에 붙여넣기   누군가 해당 GitHub 페이지를 방문할 때마다 배지 이미지를 요청하게 되고, 이때 카운터가 증가함   SVG 형식으로 방문자 수 배지를 생성하여 반환      고민한 부분   페이지에서 뱃지를 생성하고 새로고침을 할 때 방문자수가 늘어선 안된다. 이를 미리보기라는 상태 (preview) 로 만들어 웹페이지에서는 뱃지 생성 및 DB 저장만 일어나고 카운트가 늘진 않는다. @GetMapping(\"/count/increment\", produces = [\"image/svg+xml\"]) fun getBadge(     @RequestParam(\"url\") encodedUrl: String,     @RequestParam(\"count_bg\", defaultValue = \"#79C83D\") countBg: String,     @RequestParam(\"title_bg\", defaultValue = \"#555555\") titleBg: String,     @RequestParam(\"title\", defaultValue = \"hits\") title: String,     @RequestParam(\"edge_flat\", defaultValue = \"false\") edgeFlat: Boolean,     @RequestParam(\"preview\", defaultValue = \"false\") preview: Boolean, ): ResponseEntity&lt;String&gt; {     val url = URLDecoder.decode(encodedUrl, StandardCharsets.UTF_8)      // preview 모드일때는 카운트 증가 안함. 현재 카운트 조회만 함.     val count = if (preview) {         hitsService.getHits(url)     } else {         hitsService.incrementHits(url)     }          // 배지 생성     val svg = SvgGenerator.generateSvg(title, formattedTitleBg, formattedCountBg, edgeFlat, count)      return ResponseEntity.ok()         .header(\"Cache-Control\", \"no-cache, no-store, must-revalidate\")         .body(svg) }   Firestore 데이터 관리  URL을 안전하게 저장하기 위해 Base64 인코딩을 사용했다  방문자 수 증가 로직은 트랜잭션 내에서 처리하여 동시성 문제를 방지했다  fun incrementHits(url: String): Long {     val docId = getDocumentIdFromUrl(url)!!     val documentRef = firestore.collection(collection).document(docId)      try {         // 트랜잭션 내에서 카운터 증가         return firestore.runTransaction { transaction -&gt;             val document = transaction.get(documentRef).get()             val currentCount = if (document.exists()) {                 (document.getLong(\"count\") ?: 0)             } else {                 0             }             val newCount = currentCount + 1              // 새 데이터로 문서 업데이트             transaction.set(                 documentRef,                 mapOf(                     \"url\" to url,                     \"count\" to newCount,                     \"lastUpdated\" to com.google.cloud.Timestamp.now()                 )             )              newCount         }.get()     } catch (e: Exception) {         logger.error(\"방문자 수 증가 중 오류 발생\", e)         return 1 // 기본값 반환     } }   뱃지는 방문자 수를 사용해 SVG 뱃지를 생성했다. 그리고 이를 마크다운 형식과 html형식으로 붙여넣을 수 있도록 만들었다.     배포 과정   Cloud Run에 배포하기 위해 Dockerfile과 CloudBuild.yaml 설정이 필요했다. 참고로 디폴트로 .yaml 을 인식하기 때문에 .yml 이라고 마음대로 만들면 인식이 안될수도있다. (경험담)  그리고 Firebase Hosting과 Cloud Run을 연결하기 위해 firebase.json 파일을 작성했다. {   \"hosting\": {     \"public\": \"public\",     \"ignore\": [\"firebase.json\", \"**/.*\", \"**/node_modules/**\"],     \"rewrites\": [       {         \"source\": \"/api/**\",         \"run\": {           \"serviceId\": \"hitmeup-backend\",           \"region\": \"asia-northeast1\"         }       },       {         \"source\": \"**\",         \"destination\": \"/index.html\"       }     ]   } }   처음에는 리전을 서울 (asia-northeast1) 로 설정해 배포했다. 하지만 cloud run의 커스텀 도메인 매핑은 서울을 지원하지 않았다.     해당 문서 참조 : 커스텀 도메인 매핑   Hit Me Up은 Github 저장소에서 더 자세히 확인할 수 있다.     어려웠던 점   Firebase와 Cloud Run 연동 문제 Firebase Hosting으로 프론트엔드를, Cloud Run으로 백엔드를 배포했지만, 프론트엔드에서 백엔드 API를 호출할 때 CORS(Cross-Origin Resource Sharing) 오류가 발생했다. Firebase에서 어떻게 Cloud Run API를 적절히 라우팅할지에 대한 설정이 불분명했다.     CORS 설정 추가: 백엔드 Spring Boot 애플리케이션에 CORS 필터를 추가   Firebase Hosting 리다이렉션 설정: firebase.json 파일에 리다이렉션 규칙을 추가하여 /api/** 경로로 오는 모든 요청을 Cloud Run 서비스로 전달하도록 구성   Firestore 문서 ID 문제 처음에는 URL을 그대로 Firestore 문서 ID로 사용하려 했으나, Path should point to a Document Reference: hits 오류가 발생했다. Firestore는 문서 ID에 /, ., [, ] 등의 특수 문자를 허용하지 않기 때문이다.     Base64 인코딩 사용: URL을 안전한 문서 ID로 변환하기 위해 Base64 인코딩을 사용하고, Firestore에서 사용할 수 없는 문자들을 대체   트랜잭션 내 문서 존재 여부 확인: 문서가 존재하지 않을 경우 초기값으로 생성하는 로직을 트랜잭션 내에 구현   도메인 매핑 문제 DuckDNS 에서 무료 도메인을 사용하려 했으나, Cloud Run 도메인 매핑은 여러 개의 A 레코드와 AAAA 레코드를 요구했다. 그러나 DuckDNS는 하나의 도메인에 단일 A 레코드만 설정할 수 있어 직접 도메인 매핑이 불가능했다.     리전 변경 시도: 먼저 서울 리전에서는 도메인 매핑 자체가 지원되지 않아 도쿄 리전으로 변경   Firebase Hosting을 프록시로 사용: DuckDNS 도메인을 Cloud Run에 직접 연결하는 대신, Firebase Hosting을 프록시로 사용하는 방식으로 전환. Firebase Hosting은 단일 A 레코드 설정만으로도 작동함   firebase.json 파일 설정: Firebase Hosting에서 Cloud Run 백엔드로 API 요청을 리다이렉트하도록 설정   마크다운 URL 수정: 기존에는 Cloud Run URL을 직접 사용하던 마크다운 코드를 Firebase Hosting URL을 사용하도록 변경   이 부분은 나중에 다시 따로 도메인을 구매한다면 다른 방법으로도 도전해 볼 계획이다.  배포 구성 파일 문제 Cloud Build를 사용하여 GitHub 저장소에서 자동 배포를 설정했으나, 배포할 때마다 빌드 실패나 서비스 시작 문제가 발생했다.     Firebase 설정 문제 해결: Firebase 인증 정보를 Cloud Run에 전달하는 과정에서 문제가 발생. 여러 참고자료를 바탕으로 열심히 오류를 수정함… 이런 설정 파트는 처음 마주하면서 놓치는 부분이 생길 수 있어 항상 어려운 것 같다.      마치며   개발 초보라 기능도 간단하고 많이 부족한 서비스지만 더 좋은 카운팅 서비스가 나오기 전까진 쓰려고 한다. 빨리 도메인도 바꾸고 서버 스펙도 올리고 싶은데 운영 비용이 아깝다는 생각이 자꾸 들어서 쉽게 손이 안간다… 여러 일정으로 바쁜 시기지만 뿌듯했다. 추가로 오늘 수 / 전체 수 형태도 지원하면 좋을 것 같다.  참고    github 저장소  "
  },
  
  {
    "title": "PGMS_2022 Kakao_사라지는 발판 (Java)",
    "url": "/posts/PGMS2022-Kakao92345-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-04-02 03:36:47 +0900",
    "content": "[level 3] 사라지는 발판 - 92345  문제 링크  성능 요약  메모리: 83.5 MB, 시간: 13.12 ms  구분  코딩테스트 연습 &gt; 2022 KAKAO BLIND RECRUITMENT  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 04월 02일 03:31:41  문제 설명  문제 설명  플레이어 A와 플레이어 B가 서로 게임을 합니다. 당신은 이 게임이 끝날 때까지 양 플레이어가 캐릭터를 몇 번 움직이게 될지 예측하려고 합니다.  각 플레이어는 자신의 캐릭터 하나를 보드 위에 올려놓고 게임을 시작합니다. 게임 보드는 1x1 크기 정사각 격자로 이루어져 있으며, 보드 안에는 발판이 있는 부분과 없는 부분이 있습니다. 발판이 있는 곳에만 캐릭터가 서있을 수 있으며, 처음 캐릭터를 올려놓는 곳은 항상 발판이 있는 곳입니다. 캐릭터는 발판이 있는 곳으로만 이동할 수 있으며, 보드 밖으로 이동할 수 없습니다. 밟고 있던 발판은 그 위에 있던 캐릭터가 다른 곳으로 이동하여 다른 발판을 밞음과 동시에 사라집니다. 양 플레이어는 번갈아가며 자기 차례에 자신의 캐릭터를 상하좌우로 인접한 4개의 칸 중에서 발판이 있는 칸으로 옮겨야 합니다.  다음과 같은 2가지 상황에서 패자와 승자가 정해지며, 게임이 종료됩니다.   움직일 차례인데 캐릭터의 상하좌우 주변 4칸이 모두 발판이 없거나 보드 밖이라서 이동할 수 없는 경우, 해당 차례 플레이어는 패배합니다. 두 캐릭터가 같은 발판 위에 있을 때, 상대 플레이어의 캐릭터가 다른 발판으로 이동하여 자신의 캐릭터가 서있던 발판이 사라지게 되면 패배합니다.   게임은 항상 플레이어 A가 먼저 시작합니다. 양 플레이어는 최적의 플레이를 합니다. 즉, 이길 수 있는 플레이어는 최대한 빨리 승리하도록 플레이하고, 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이합니다. '이길 수 있는 플레이어'는 실수만 하지 않는다면 항상 이기는 플레이어를 의미하며, '질 수밖에 없는 플레이어'는 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 플레이어를 의미합니다. 최대한 오래 버틴다는 것은 양 플레이어가 캐릭터를 움직이는 횟수를 최대화한다는 것을 의미합니다.  아래 그림은 초기 보드의 상태와 각 플레이어의 위치를 나타내는 예시입니다.    위와 같은 경우, 플레이어 A는 실수만 하지 않는다면 항상 이길 수 있습니다. 따라서 플레이어 A는 이길 수 있는 플레이어이며, B는 질 수밖에 없는 플레이어입니다. 다음은 A와 B가 최적의 플레이를 하는 과정을 나타냅니다.   플레이어 A가 초기 위치 (1, 0)에서 (1, 1)로 이동합니다. 플레이어 A가 (0, 0)이나 (2, 0)으로 이동할 경우 승리를 보장할 수 없습니다. 따라서 무조건 이길 방법이 있는 (1, 1)로 이동합니다. 플레이어 B는 (1, 1)로 이동할 경우, 바로 다음 차례에 A가 위 또는 아래 방향으로 이동하면 발판이 없어져 패배하게 됩니다. 질 수밖에 없는 플레이어는 최대한 오래 버티도록 플레이하기 때문에 (1, 1)로 이동하지 않습니다. (1, 2)에서 위쪽 칸인 (0, 2)로 이동합니다. A가 (1, 1)에서 (0, 1)로 이동합니다. B에게는 남은 선택지가 (0, 1)밖에 없습니다. 따라서 (0, 2)에서 (0, 1)로 이동합니다. A가 (0, 1)에서 (0, 0)으로 이동합니다. 이동을 완료함과 동시에 B가 서있던 (0, 1)의 발판이 사라집니다. B가 패배합니다. 만약 과정 2에서 B가 아래쪽 칸인 (2, 2)로 이동하더라도 A는 (2, 1)로 이동하면 됩니다. 이후 B가 (2, 1)로 이동, 다음 차례에 A가 (2, 0)으로 이동하면 B가 패배합니다.   위 예시에서 양 플레이어가 최적의 플레이를 했을 경우, 캐릭터의 이동 횟수 합은 5입니다. 최적의 플레이를 하는 방법은 여러 가지일 수 있으나, 이동한 횟수는 모두 5로 같습니다.  게임 보드의 초기 상태를 나타내는 2차원 정수 배열 board와 플레이어 A의 캐릭터 초기 위치를 나타내는 정수 배열 aloc, 플레이어 B의 캐릭터 초기 위치를 나타내는 정수 배열 bloc이 매개변수로 주어집니다. 양 플레이어가 최적의 플레이를 했을 때, 두 캐릭터가 움직인 횟수의 합을 return 하도록 solution 함수를 완성해주세요.    제한사항   1 ≤ board의 세로 길이 ≤ 5 1 ≤ board의 가로 길이 ≤ 5 board의 원소는 0 또는 1입니다.   0은 발판이 없음을, 1은 발판이 있음을 나타냅니다. 게임 보드의 좌측 상단 좌표는 (0, 0), 우측 하단 좌표는 (board의 세로 길이 - 1, board의 가로 길이 - 1)입니다.  aloc과 bloc은 각각 플레이어 A의 캐릭터와 플레이어 B의 캐릭터 초기 위치를 나타내는 좌표값이며 [r, c] 형태입니다.   r은 몇 번째 행인지를 나타냅니다. 0 ≤ r &lt; board의 세로 길이 c는 몇 번째 열인지를 나타냅니다. 0 ≤ c &lt; board의 가로 길이 초기 보드의 aloc과 bloc 위치는 항상 발판이 있는 곳입니다. aloc과 bloc이 같을 수 있습니다.  상대 플레이어의 캐릭터가 있는 칸으로 이동할 수 있습니다.     입출력 예           board aloc bloc result            [[1, 1, 1], [1, 1, 1], [1, 1, 1]] [1, 0] [1, 2] 5   [[1, 1, 1], [1, 0, 1], [1, 1, 1]] [1, 0] [1, 2] 4   [[1, 1, 1, 1, 1]] [0, 0] [0, 4] 4   [[1]] [0, 0] [0, 0] 0            입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.  입출력 예 #2  주어진 조건을 그림으로 나타내면 아래와 같습니다.    항상 이기는 플레이어는 B, 항상 지는 플레이어는 A입니다.  다음은 B가 이기는 방법 중 하나입니다.   A가 (1, 0)에서 (0, 0)으로 이동 B가 (1, 2)에서 (2, 2)로 이동 A가 (0, 0)에서 (0, 1)로 이동 B가 (2, 2)에서 (2, 1)로 이동 A가 (0, 1)에서 (0, 2)로 이동 B가 (2, 1)에서 (2, 0)으로 이동 A는 더 이상 이동할 수 없어 패배합니다.   위와 같이 플레이할 경우 이동 횟수 6번 만에 게임을 B의 승리로 끝낼 수 있습니다.  B가 다음과 같이 플레이할 경우 게임을 더 빨리 끝낼 수 있습니다. 이길 수 있는 플레이어는 최대한 빨리 게임을 끝내려 하기 때문에 위 방법 대신 아래 방법을 선택합니다.   A가 (1, 0)에서 (0, 0)으로 이동 B가 (1, 2)에서 (0, 2)로 이동 A가 (0, 0)에서 (0, 1)로 이동 B가 (0, 2)에서 (0, 1)로 이동 A는 더 이상 이동할 수 없어 패배합니다.   위와 같이 플레이할 경우 이동 횟수 4번 만에 게임을 B의 승리로 끝낼 수 있습니다. 따라서 4를 return 합니다.  입출력 예 #3  양 플레이어는 매 차례마다 한 가지 선택지밖에 고를 수 없습니다. 그 결과, (0, 2)에서 어디로도 이동할 수 없는 A가 패배합니다. 양 플레이어가 캐릭터를 움직인 횟수의 합은 4입니다.  입출력 예 #4  게임을 시작하는 플레이어 A가 처음부터 어디로도 이동할 수 없는 상태입니다. 따라서 A의 패배이며, 이동 횟수의 합은 0입니다.    제한시간 안내   정확성 테스트 : 10초      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        DFS를 이용하여 모든 가능한 게임 상태를 탐색   각 상태에서 현재 플레이어의 최적 전략을 결정   재귀적으로 게임 결과 계산   승패 판단    현재 플레이어가 이동한 후, 다음 플레이어의 상태를 확인   dfs 반환 이동 횟수가 짝수: 다음 플레이어가 더 이상 움직일 수 없음 → 현재 플레이어 승리            0으로 생각해보면 쉬움 : 0회 움직일 수 있다는건 이제 못움직이므로 그사람(지금 플레이어 기준 다음 사람일 것이다) 패배. 즉 지금 플레이어 승리           dfs 반환 이동 횟수가 홀수: 다음 플레이어 이후에 현재 플레이어가 움직일 수 없음 → 현재 플레이어 패배   \\(O(4^{(N*M)})\\) 이지만, 백트래킹하면 괜찮다.     코드   class Solution {     static int[] dr = {-1, 0, 1, 0}, dc = {0, -1, 0, 1};     static int res = 0;     static int N, M;     public int solution(int[][] board, int[] aloc, int[] bloc) {         N = board.length;         M = board[0].length;         res = dfs(board, aloc, bloc, 0);         return res;     }          private int dfs(int[][] board, int[] aloc, int[] bloc, int order){         // 순서 0이면 a, 1면 b         int currR, currC;         currR = order == 0 ? aloc[0] : bloc[0];         currC = order == 0 ? aloc[1] : bloc[1];                  // 전 사람이 이기면 끝         if(board[currR][currC] == 0 || !canMove(board, currR, currC)) return 0;                  int currWin = Integer.MAX_VALUE;         int currLose = 0;         boolean isCurrWin = false;                  // 지금 발판 없애기         board[currR][currC] = 0;                  for(int k=0; k&lt;4; k++){             int nr = currR + dr[k];             int nc = currC + dc[k];                          if(isValid(nr, nc) &amp;&amp; board[nr][nc] == 1){                 int nextCnt; // 이후 나의 이동횟수                 nextCnt = order == 0 ? dfs(board, new int[] {nr, nc}, bloc, 1-order) : dfs(board, aloc, new int[] {nr, nc}, 1-order);                                  // 다음 플레이어가 짐 -&gt; 지금 플레이어 최대한 빨리이기기                 if(nextCnt%2 == 0){                     currWin = Math.min(currWin, nextCnt + 1);                     isCurrWin = true;                 }                  // 다음 플레이어가 이김 -&gt; 지금 플레이어 최대한 늦게지기                 else currLose = Math.max(currLose, nextCnt + 1);             }         }         board[currR][currC] = 1;                  return isCurrWin ? currWin : currLose;     }          private static boolean canMove(int[][] board, int r, int c){         for (int k = 0; k &lt; 4; k++) {             int nr = r + dr[k];             int nc = c + dc[k];             if (isValid(nr, nc) &amp;&amp; board[nr][nc] == 1) return true;         }         return false;     }          private static boolean isValid(int r, int c){         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     } }  "
  },
  
  {
    "title": "BOJ_3687_성냥개비 (Java)",
    "url": "/posts/BOJ3687%EC%84%B1%EB%83%A5%EA%B0%9C%EB%B9%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-31 22:13:38 +0900",
    "content": "[Gold II] 성냥개비 - 3687  문제 링크  성능 요약  메모리: 14060 KB, 시간: 104 ms  분류  다이나믹 프로그래밍, 그리디 알고리즘  제출 일자  2025년 3월 31일 22:01:50  문제 설명  성냥개비는 숫자를 나타내기에 아주 이상적인 도구이다. 보통 십진수를 성냥개비로 표현하는 방법은 다음과 같다.    성냥개비의 개수가 주어졌을 때, 성냥개비를 모두 사용해서 만들 수 있는 가장 작은 수와 큰 수를 찾는 프로그램을 작성하시오.  입력  첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 최대 100개 이다. 각 테스트 케이스는 한 줄로 이루어져 있고, 성냥개비의 개수 n이 주어진다. (2 ≤ n ≤ 100)  출력  각 테스트 케이스에 대해서 입력으로 주어진 성냥개비를 모두 사용해서 만들 수 있는 가장 작은 수와 가장 큰 수를 출력한다. 두 숫자는 모두 양수이어야 하고, 숫자는 0으로 시작할 수 없다.      문제 풀이    45분 소요     코드   /**  * Author: nowalex322, Kim HyeonJae  * 21:15 ~ 22:05  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static int[] nums = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // 0~9 성냥개수     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_3687_성냥개비/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          long[] dp = new long[101]; // min계산 // 100 = 14*7 + 2 -&gt; 최대15자리 -&gt; long         Arrays.fill(dp, Long.MAX_VALUE);         dp[2] = 1;         dp[3] = 7;         dp[4] = 4;         dp[5] = 2;         dp[6] = 6;         dp[7] = 8;         dp[8] = 10;         dp[9] = 18;         dp[10] = 22;          // DP 계산 - 최소값 구하기         for (int i = 11; i &lt;= 100; i++) {             for (int num = 0; num &lt; 10; num++) {                 if (i - nums[num] &gt;= 2 &amp;&amp; dp[i - nums[num]] != Long.MAX_VALUE) { // 자릿수추가 (앞 or 뒤)                                      // 0                     if(num == 0) dp[i] = Math.min(dp[i], dp[i-nums[num]] * 10L);                      else{                         long tmp1 = dp[i - nums[num]] * 10L + num;                         long tmp2 = num * (long) Math.pow(10, digitCnt(dp[i-nums[num]])) + dp[i-nums[num]];                          dp[i] = Math.min(dp[i], Math.min(tmp1, tmp2));                     }                 }             }         }          int T = Integer.parseInt(br.readLine());         while(T-- &gt; 0) {             int n = Integer.parseInt(br.readLine());              StringBuilder sb = new StringBuilder();              //min             sb.append(dp[n]).append(\" \");              //max             if(n%2 == 1){                 sb.append(7);                 for(int i=0; i&lt;(n-3)/2; i++){                     sb.append(1);                 }             }             else{                 for(int i=0; i&lt;n/2; i++){                     sb.append(1);                 }             }             sb.append(\"\\n\");             bw.write(sb.toString());         }         bw.flush();         bw.close();         br.close();     }      private int digitCnt(long num){         if(num==0) return 1;         return (int) Math.log10(num) + 1;     } }  "
  },
  
  {
    "title": "BOJ_2109_순회강연 (Java)",
    "url": "/posts/BOJ2109%EC%88%9C%ED%9A%8C%EA%B0%95%EC%97%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-31 21:09:03 +0900",
    "content": "[Gold III] 순회강연 - 2109  문제 링크  성능 요약  메모리: 21660 KB, 시간: 288 ms  분류  자료 구조, 그리디 알고리즘, 우선순위 큐, 정렬  제출 일자  2025년 3월 31일 21:06:40  문제 설명  한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.  예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.  입력  첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.  출력  첫째 줄에 최대로 벌 수 있는 돈을 출력한다.     문제 풀이   처음에 d일이하인줄 모르고 d일만 가능한줄 알고 너무 쉽게 풀었다가 다시 풀었다.  d일 이하의 최대 일수에 배치하도록 TreeSet을 이용했고 floor메서드를 통해 특정값 포함 이하중에서 최대값을 반환했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  * 20:25 ~ 21:05  */  import java.io.*; import java.util.*;  public class Main {     class Lecture implements Comparable&lt;Lecture&gt;{         int day, pay;         public Lecture(int day, int pay){             this.day = day;             this.pay = pay;         }          @Override         public int compareTo(Lecture o) {             return o.pay - this.pay;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int n;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2109_순회강연/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          n = Integer.parseInt(br.readLine());         Lecture[] lectures = new Lecture[n];         int maxD = 0;         for(int i=0; i&lt;n; i++){             st = new StringTokenizer(br.readLine());             int p = Integer.parseInt(st.nextToken());             int d = Integer.parseInt(st.nextToken());             maxD = Math.max(maxD, d);             lectures[i] = new Lecture(d, p);         }         Arrays.sort(lectures);          TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();         for(int i=1; i&lt;=maxD; i++){             ts.add(i);         }          int res = 0;         for(Lecture l : lectures){             int ableD = ts.floor(l.day)==null ? 0 : ts.floor(l.day);             ts.remove(ableD);             if(ableD != 0) res += l.pay;         }         System.out.println(res);         br.close();     } }  "
  },
  
  {
    "title": "LeetCode_354. Russian Doll Envelopes (Java)",
    "url": "/posts/LeetCode354.-Russian-Doll-Envelopes-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-03-28 18:23:59 +0900",
    "content": "354. Russian Doll Envelopes Hard  You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.  One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope&#39;s width and height.  Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).  Note: You cannot rotate an envelope.  &nbsp; Example 1:   Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).   Example 2:   Input: envelopes = [[1,1],[1,1],[1,1]] Output: 1   &nbsp; Constraints:   \t1 &lt;= envelopes.length &lt;= 105 \tenvelopes[i].length == 2 \t1 &lt;= wi, hi &lt;= 105      문제 풀이   처음에는 단순히 정렬을 통해서만 비교했다. 하지만 다음과 같은 반례가 생겼다. [[2,100], [3,200], [4,300], [5,500], [5,400], [5,250], [6,370], [6,360], [7,380]]  이렇게 했을 때 단순히 너비 높이 오름차순으로 정렬하고 둘 다 포함될때만 시도하니 최적의 경우를 찾지 못했다.  본 예시에서는 4,300  고르는것보다 5,250 고르는게 너비 4를 뛰어넘더라도 미래를 보았을 때 이득이다.  일단 이를 보았을 때 한가지 정렬기준으로 정렬 한 뒤 LIS 형태를 띈다.  그래서 너비로 정렬 한 뒤 LIS를 구해보았다.  이때 일단 너비로 정렬하면 [[2,100], [3,200], [4,300], [5,500], [5,400], [5,250], [6,370], [6,360], [7,380]] 이 되는데  이때 다음으로 높이를 내림차순으로 정렬해서 LIS를 구한다.  그럼 이 상태인데 처음에 너비 2, 3, 4까지 100, 200, 300 이 된다.  그럼 LIS = [100, 200, 300] 이다. 다음으로 너비 5들이 많은데 순서대로 500, 400, 250이다.  원래대로라면    LIS = [100, 200, 300, 500]   LIS = [100, 200, 300, 400] 까지는 잘 따라왔을 것이다.   다음이 너비 5에 높이 250인데 250이 들어갈 자리는 300자리다.    LIS = [100, 200, 250, 400] 가 된다. 사실 너비 5가 2개 들어갈 수 없어 400은 없다고 봐야한다.   그 다음은 각각 너비 6의 370과 360을 처리해야한다.    LIS = [100, 200, 250, 370]   LIS = [100, 200, 250, 360] 이렇게 된다.   그 다음 마지막으로    LIS = [100, 200, 250, 360, 380] 이렇게 된다.   이러한 방법을 구현하면 되는데 제한 조건이 $10^5$  이므로 O($N^2$)이므로 이분탐색으로 LIS삽입 위치를 구해 NlogN으로 최적화하면 된다.     코드   import java.util.*;  class Solution {     class Size implements Comparable&lt;Size&gt;{         int x, y;         public Size(int x, int y){             this.x = x;             this.y = y;         }          @Override         public int compareTo(Size o){             if(this.x == o.x) return o.y - this.y;             return this.x - o.x;         }     }     public int maxEnvelopes(int[][] envelopes) {         int n = envelopes.length;         Size[] sizes = new Size[n];         for(int i=0; i&lt;n; i++){             sizes[i] = new Size(envelopes[i][0], envelopes[i][1]);         }          Arrays.sort(sizes);          int[] dp = new int[n]; // LIS         int len = 0;          for(Size s : sizes){ // x기준 오름차순, y는 내림차순             int left = 0, right = len-1;              int res = len; // 맨뒤 삽입 디폴트, res 위치가 새 LIS값 삽입할 위치.             while(left&lt;=right){                 int mid = left + (right-left)/2;                 if(dp[mid] &gt;= s.y) {                     res = mid;                     right = mid-1;                 }                 else{                     left = mid+1;                 }             }              dp[res] = s.y;              if(res == len) len++; // 맨끝 삽입한 경우         }         return len;     } }  "
  },
  
  {
    "title": "PGMS_가격이 제일 비싼 식품의 정보 출력하기 (SQL)",
    "url": "/posts/PGMS%EA%B0%80%EA%B2%A9%EC%9D%B4-%EC%A0%9C%EC%9D%BC-%EB%B9%84%EC%8B%BC-%EC%8B%9D%ED%92%88%EC%9D%98-%EC%A0%95%EB%B3%B4-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-03-28 16:51:46 +0900",
    "content": "[level 2] 가격이 제일 비싼 식품의 정보 출력하기 - 131115  문제 링크  ### 성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  ### 구분  코딩테스트 연습 &gt; SUM， MAX， MIN  ### 채점결과  Empty  ### 제출 일자  2025년 03월 28일 16:48:47  ### 문제 설명  다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품 코드, 식품분류, 식품 가격을 의미합니다.             Column name  Type  Nullable                PRODUCT_ID  VARCHAR(10)  FALSE      PRODUCT_NAME  VARCHAR(50)  FALSE      PRODUCT_CD  VARCHAR(10)  TRUE      CATEGORY  VARCHAR(10)  TRUE      PRICE  NUMBER  TRUE               문제  FOOD_PRODUCT 테이블에서 가격이 제일 비싼 식품의 식품 ID, 식품 이름, 식품 코드, 식품분류, 식품 가격을 조회하는 SQL문을 작성해주세요.     예시  FOOD_PRODUCT 테이블이 다음과 같을 때             PRODUCT_ID  PRODUCT_NAME  PRODUCT_CD  CATEGORY  PRICE                P0018  맛있는고추기름  CD_OL00008  식용유  6100      P0019  맛있는카놀라유  CD_OL00009  식용유  5100      P0020  맛있는산초유  CD_OL00010  식용유  6500      P0021  맛있는케첩  CD_OL00001  소스  4500      P0022  맛있는마요네즈  CD_OL00002  소스  4700             SQL을 실행하면 다음과 같이 출력되어야 합니다.             PRODUCT_ID  PRODUCT_NAME  PRODUCT_CD  CATEGORY  PRICE                P0020  맛있는산초유  CD_OL00010  식용유  6500                 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   서브쿼리로 가장 비싼 값과 일치하는 레코드를 출력했다.  다른 방법으로 price로 내림차순한 뒤 LIMIT으로 1개 출력하는 방법도 있다.      코드   SELECT PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE      FROM FOOD_PRODUCT          WHERE PRICE = (SELECT MAX(PRICE) FROM FOOD_PRODUCT);  "
  },
  
  {
    "title": "BOJ_11657_타임머신 (Java)",
    "url": "/posts/BOJ11657%ED%83%80%EC%9E%84%EB%A8%B8%EC%8B%A0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-28 16:18:10 +0900",
    "content": "[Gold IV] 타임머신 - 11657  문제 링크  ### 성능 요약  메모리: 19564 KB, 시간: 256 ms  ### 분류  벨만–포드, 그래프 이론, 최단 경로  ### 제출 일자  2025년 3월 28일 16:08:59  ### 문제 설명  N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 버스가 M개 있다. 각 버스는 A, B, C로 나타낼 수 있는데, A는 시작도시, B는 도착도시, C는 버스를 타고 이동하는데 걸리는 시간이다. 시간 C가 양수가 아닌 경우가 있다. C = 0인 경우는 순간 이동을 하는 경우, C &lt; 0인 경우는 타임머신으로 시간을 되돌아가는 경우이다.  1번 도시에서 출발해서 나머지 도시로 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.  ### 입력  첫째 줄에 도시의 개수 N (1 ≤ N ≤ 500), 버스 노선의 개수 M (1 ≤ M ≤ 6,000)이 주어진다. 둘째 줄부터 M개의 줄에는 버스 노선의 정보 A, B, C (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)가 주어진다.   ### 출력  만약 1번 도시에서 출발해 어떤 도시로 가는 과정에서 시간을 무한히 오래 전으로 되돌릴 수 있다면 첫째 줄에 -1을 출력한다. 그렇지 않다면 N-1개 줄에 걸쳐 각 줄에 1번 도시에서 출발해 2번 도시, 3번 도시, ..., N번 도시로 가는 가장 빠른 시간을 순서대로 출력한다. 만약 해당 도시로 가는 경로가 없다면 대신 -1을 출력한다.     문제 풀이     벨만 포드를 풀기위해 풀었다. 벨만포드는 생각보다 구현이 쉽다. 그리고 어떤 문제에 사용해야하는지도 거의 정해져있는것같다. 간선의 가중치가 음수가 있을때 사용하면 좋은 것 같다.     코드   package BOJ_11657_타임머신;  /**  * Author: nowalex322, Kim HyeonJae  * 15:51 ~ 16:08  */  import java.io.*; import java.util.*;  public class Main {     class Edge {         int from, to, weight;          public Edge(int from, int to, int weight) {             this.from = from;             this.to = to;             this.weight = weight;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_11657_타임머신/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         int N = Integer.parseInt(st.nextToken());         int M = Integer.parseInt(st.nextToken());          List&lt;Edge&gt; edges = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; M; i++) {             st = new StringTokenizer(br.readLine());             int u = Integer.parseInt(st.nextToken());             int v = Integer.parseInt(st.nextToken());             int w = Integer.parseInt(st.nextToken());             edges.add(new Edge(u, v, w));         }          // 벨만 포드         long[] dist = new long[N + 1];         Arrays.fill(dist, Long.MAX_VALUE);         dist[1] = 0; // 시작 1          boolean negativeCycle = false; // 음의 사이클 체크 -&gt; -1          for (int i = 0; i &lt; N - 1; i++) { // N-1개             for (Edge e : edges) {                 if (dist[e.from] != Long.MAX_VALUE) {                     if (dist[e.to] &gt; dist[e.from] + e.weight) {                         dist[e.to] = dist[e.from] + e.weight;                     }                 }             }         }          for (Edge e : edges) {             if (dist[e.to] != Long.MAX_VALUE) {                 if (dist[e.to] &gt; dist[e.from] + e.weight) {                     negativeCycle = true;                     break;                 }             }         }          if (negativeCycle) sb.append(\"-1\");         else {             for (int i = 2; i &lt;= N; i++) {                 if (dist[i] != Long.MAX_VALUE) {                     sb.append(dist[i]).append(\"\\n\");                 } else sb.append(\"-1\").append(\"\\n\");             }         }         System.out.println(sb.toString());         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1719_택배 (Java)",
    "url": "/posts/BOJ1719%ED%83%9D%EB%B0%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-28 16:15:45 +0900",
    "content": "[Gold III] 택배 - 1719  문제 링크  ### 성능 요약  메모리: 21208 KB, 시간: 336 ms  ### 분류  데이크스트라, 플로이드–워셜, 그래프 이론, 최단 경로  ### 제출 일자  2025년 3월 28일 15:40:31  ### 문제 설명  명우기업은 2008년부터 택배 사업을 새로이 시작하기로 하였다. 우선 택배 화물을 모아서 처리하는 집하장을 몇 개 마련했지만, 택배 화물이 각 집하장들 사이를 오갈 때 어떤 경로를 거쳐야 하는지 결정하지 못했다. 어떤 경로를 거칠지 정해서, 이를 경로표로 정리하는 것이 여러분이 할 일이다.    예시된 그래프에서 굵게 표시된 1, 2, 3, 4, 5, 6은 집하장을 나타낸다. 정점간의 간선은 두 집하장간에 화물 이동이 가능함을 나타내며, 가중치는 이동에 걸리는 시간이다. 이로부터 얻어내야 하는 경로표는 다음과 같다.    경로표는 한 집하장에서 다른 집하장으로 최단경로로 화물을 이동시키기 위해 가장 먼저 거쳐야 하는 집하장을 나타낸 것이다. 예를 들어 4행 5열의 6은 4번 집하장에서 5번 집하장으로 최단 경로를 통해 가기 위해서는 제일 먼저 6번 집하장으로 이동해야 한다는 의미이다.  이와 같은 경로표를 구하는 프로그램을 작성하시오.  ### 입력  첫째 줄에 두 수 n과 m이 빈 칸을 사이에 두고 순서대로 주어진다. n은 집하장의 개수로 200이하의 자연수, m은 집하장간 경로의 개수로 10000이하의 자연수이다. 이어서 한 줄에 하나씩 집하장간 경로가 주어지는데, 두 집하장의 번호와 그 사이를 오가는데 필요한 시간이 순서대로 주어진다. 집하장의 번호들과 경로의 소요시간은 모두 1000이하의 자연수이다.  ### 출력  예시된 것과 같은 형식의 경로표를 출력한다.     문제 풀이   플로이드 워셜로 경유지중심으로 O($N^3$)으로 풀었다. 다익스트라 하면 O(N*MlogN)인데 M이 매우 크고 N이 매우 작으므로 이게 더 효율적이다.     코드   /**   * Author: nowalex322, Kim HyeonJae   * 15:14 ~ 15:40 (26min)   */    import java.io.*;  import java.util.*;    public class Main {      static BufferedReader br;      static BufferedWriter bw;      static StringTokenizer st;      static int n, m;      static StringBuilder sb = new StringBuilder();        public static void main(String[] args) throws Exception {          new Main().solution();      }        public void solution() throws Exception {          br = new BufferedReader(new InputStreamReader(System.in));  //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1719_택배/input.txt\")));          bw = new BufferedWriter(new OutputStreamWriter(System.out));            st = new StringTokenizer(br.readLine());          n = Integer.parseInt(st.nextToken());          m = Integer.parseInt(st.nextToken());            int[][] board = new int[n + 1][n + 1]; // 경로길이(최소)          for (int i = 1; i &lt;= n; i++) {              for (int j = 1; j &lt;= n; j++) {                  if (i == j) board[i][j] = 0;                  else board[i][j] = Integer.MAX_VALUE;              }          }          int[][] res = new int[n + 1][n + 1]; // 다음정점 최신화          for (int i = 1; i &lt;= n; i++) {              for (int j = 1; j &lt;= n; j++) {                  if (i == j) res[i][j] = -1;                  else res[i][j] = j;              }          }            for (int i = 0; i &lt; m; i++) {              st = new StringTokenizer(br.readLine());              int u = Integer.parseInt(st.nextToken());              int v = Integer.parseInt(st.nextToken());              int w = Integer.parseInt(st.nextToken());                board[u][v] = w;              board[v][u] = w;          }            for (int k = 1; k &lt;= n; k++) {              for (int i = 1; i &lt;= n; i++) {                  for (int j = 1; j &lt;= n; j++) {                      if (board[i][k] != Integer.MAX_VALUE &amp;&amp; board[k][j] != Integer.MAX_VALUE) {                          if (board[i][j] &gt; board[i][k] + board[k][j]) {                              board[i][j] = board[i][k] + board[k][j];                              res[i][j] = res[i][k];                          }                      }                  }              }          }            for (int i = 1; i &lt;= n; i++) {              for (int j = 1; j &lt;= n; j++) {                  if (i == j) sb.append(\"- \");                  else sb.append(res[i][j]).append(\" \");              }              sb.append(\"\\n\");          }          System.out.println(sb.toString());          br.close();      }  }  "
  },
  
  {
    "title": "PGMS_Kakao 2023_이모티콘 할인행사 (Java)",
    "url": "/posts/PGMSKakao-2023%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98-%ED%95%A0%EC%9D%B8%ED%96%89%EC%82%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-03-27 21:30:13 +0900",
    "content": "[level 2] 이모티콘 할인행사 - 150368  문제 링크  성능 요약  메모리: 85.3 MB, 시간: 59.33 ms  구분  코딩테스트 연습 &gt; 2023 KAKAO BLIND RECRUITMENT  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 03월 27일 21:28:02  문제 설명  카카오톡에서는 이모티콘을 무제한으로 사용할 수 있는 이모티콘 플러스 서비스 가입자 수를 늘리려고 합니다. 이를 위해 카카오톡에서는 이모티콘 할인 행사를 하는데, 목표는 다음과 같습니다.   이모티콘 플러스 서비스 가입자를 최대한 늘리는 것. 이모티콘 판매액을 최대한 늘리는 것.   1번 목표가 우선이며, 2번 목표가 그 다음입니다.  이모티콘 할인 행사는 다음과 같은 방식으로 진행됩니다.   n명의 카카오톡 사용자들에게 이모티콘 m개를 할인하여 판매합니다. 이모티콘마다 할인율은 다를 수 있으며, 할인율은 10%, 20%, 30%, 40% 중 하나로 설정됩니다.   카카오톡 사용자들은 다음과 같은 기준을 따라 이모티콘을 사거나, 이모티콘 플러스 서비스에 가입합니다.   각 사용자들은 자신의 기준에 따라 일정 비율 이상 할인하는 이모티콘을 모두 구매합니다. 각 사용자들은 자신의 기준에 따라 이모티콘 구매 비용의 합이 일정 가격 이상이 된다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.   다음은 2명의 카카오톡 사용자와 2개의 이모티콘이 있을때의 예시입니다.           사용자 비율 가격            1 40 10,000   2 25 10,000                    이모티콘 가격            1 7,000   2 9,000          1번 사용자는 40%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다. 2번 사용자는 25%이상 할인하는 이모티콘을 모두 구매하고, 이모티콘 구매 비용이 10,000원 이상이 되면 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입합니다.  1번 이모티콘의 가격은 7,000원, 2번 이모티콘의 가격은 9,000원입니다.  만약, 2개의 이모티콘을 모두 40%씩 할인한다면, 1번 사용자와 2번 사용자 모두 1,2번 이모티콘을 구매하게 되고, 결과는 다음과 같습니다.           사용자 구매한 이모티콘 이모티콘 구매 비용 이모티콘 플러스 서비스 가입 여부            1 1, 2 9,600 X   2 1, 2 9,600 X          이모티콘 플러스 서비스 가입자는 0명이 늘어나고 이모티콘 판매액은 19,200원이 늘어납니다.  하지만, 1번 이모티콘을 30% 할인하고 2번 이모티콘을 40% 할인한다면 결과는 다음과 같습니다.           사용자 구매한 이모티콘 이모티콘 구매 비용 이모티콘 플러스 서비스 가입 여부            1 2 5,400 X   2 1, 2 10,300 O          2번 사용자는 이모티콘 구매 비용을 10,000원 이상 사용하여 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입하게 됩니다. 따라서, 이모티콘 플러스 서비스 가입자는 1명이 늘어나고 이모티콘 판매액은 5,400원이 늘어나게 됩니다.  카카오톡 사용자 n명의 구매 기준을 담은 2차원 정수 배열 users, 이모티콘 m개의 정가를 담은 1차원 정수 배열 emoticons가 주어집니다. 이때, 행사 목적을 최대한으로 달성했을 때의 이모티콘 플러스 서비스 가입 수와 이모티콘 매출액을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.    제한사항   1 ≤ users의 길이 = n ≤ 100   users의 원소는 [비율, 가격]의 형태입니다. users[i]는 i+1번 고객의 구매 기준을 의미합니다. 비율% 이상의 할인이 있는 이모티콘을 모두 구매한다는 의미입니다.   1 ≤ 비율 ≤ 40  가격이상의 돈을 이모티콘 구매에 사용한다면, 이모티콘 구매를 모두 취소하고 이모티콘 플러스 서비스에 가입한다는 의미입니다.   100 ≤ 가격 ≤ 1,000,000 가격은 100의 배수입니다.   1 ≤ emoticons의 길이 = m ≤ 7   emoticons[i]는 i+1번 이모티콘의 정가를 의미합니다. 100 ≤ emoticons의 원소 ≤ 1,000,000 emoticons의 원소는 100의 배수입니다.      입출력 예           users emoticons result            [[40, 10000], [25, 10000]] [7000, 9000] [1, 5400]   [[40, 2900], [23, 10000], [11, 5200], [5, 5900], [40, 3100], [27, 9200], [32, 6900]] [1300, 1500, 1600, 4900] [4, 13860]            입출력 예 설명  입출력 예 #1  문제의 예시와 같습니다.  입출력 예 #2  다음과 같이 할인하는 것이 이모티콘 플러스 서비스 가입자를 최대한 늘리면서, 이모티콘 판매액 또한 최대로 늘리는 방법입니다.           이모티콘 할인율            1 40   2 40   3 20   4 40          위와 같이 할인하면 4명의 이모티콘 플러스 가입자와 13,860원의 판매액을 달성할 수 있습니다. 다른 할인율을 적용하여 이모티콘을 판매할 수 있지만 이보다 이모티콘 플러스 서비스 가입자를 최대한 늘리면서, 이모티콘 판매액 또한 최대로 늘리는 방법은 없습니다. 따라서, [4, 13860]을 return 하면 됩니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   풀이 시간 : 25분   dfs로 충분히 가능한 제한범위라 진행했다.     코드    class Solution {     static int ePlusCnt, eSalesMoney;     public int[] solution(int[][] users, int[] emoticons) {         int[] answer = new int[2];         ePlusCnt=0; // 플러스사용자 수         eSalesMoney=0; // 이모티콘 판매액                  int[] saleP = new int[emoticons.length]; // 이모티콘 할인율 %         dfs(0, emoticons.length, saleP, users, emoticons);         answer[0] = ePlusCnt;         answer[1] = eSalesMoney;         return answer;     }     private void dfs(int depth, int target, int[] saleP, int[][] users, int[] emoticons){         if(depth == target){             int[] res = solve(saleP, users, emoticons);             if(ePlusCnt &lt; res[0]){                 ePlusCnt=res[0];                 eSalesMoney=res[1];             }             else if(ePlusCnt == res[0]){                 if(eSalesMoney &lt; res[1]) eSalesMoney=res[1];             }             return;         }                     for(int i=10; i&lt;=40; i+=10){             saleP[depth] = i;             dfs(depth+1, target, saleP, users, emoticons);         }     }     private int[] solve(int[] saleP, int[][] users, int[] emoticons){         int totalPeople = 0; // 가입수         int totalMoney = 0; // 매출                  // 각 사람마다 얼마 쓰는지 체크         for(int[] u : users){             int currSaleP = u[0];             int currMoney = u[1];                          int sum=0;             for(int i=0; i&lt;emoticons.length; i++){                 if(saleP[i] &gt;= currSaleP){ // 이 이모티콘은 삼                     int discountPrice = (emoticons[i] * (100 - saleP[i])) / 100;                     sum += discountPrice;                 }             }             if(sum &gt;= currMoney) totalPeople++;             else totalMoney += sum;         }                  return new int[] {totalPeople, totalMoney};     } }   "
  },
  
  {
    "title": "BOJ_10431_줄 세우기 (Java, C++, Python)",
    "url": "/posts/BOJ10431%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0-Java-C-Python/",
    "categories": "알고리즘",
    "tags": "C++, Java, python, 백준, 알고리즘",
    "date": "2025-03-27 20:10:21 +0900",
    "content": "[Silver V] 줄세우기 - 10431  문제 링크  성능 요약  메모리: 32412 KB, 시간: 116 ms  분류  구현, 시뮬레이션, 정렬  제출 일자  2025년 3월 27일 20:06:08  문제 설명  초등학교 선생님 강산이는 아이들을 데리고 단체로 어떤 일을 할 때 불편함이 없도록 새로 반에 배정받은 아이들에게 키 순서대로 번호를 부여한다. 번호를 부여할 땐 키가 가장 작은 아이가 1번, 그 다음이 2번, ... , 가장 큰 아이가 20번이 된다. 강산이네 반 아이들은 항상 20명이며, 다행히도 같은 키를 가진 학생은 한 명도 없어서 시간이 조금 지나면 아이들은 자기들의 번호를 인지하고 한 줄로 세우면 제대로 된 위치에 잘 서게 된다.  하지만 매년 첫 며칠간 강산이와 강산이네 반 아이들은 자기가 키 순으로 몇 번째인지 잘 알지 못해 아주 혼란스럽다. 자기 위치를 찾지 못하는 아이들을 위해 강산이는 특별한 방법을 생각해냈다.  우선 아무나 한 명을 뽑아 줄의 맨 앞에 세운다. 그리고 그 다음부터는 학생이 한 명씩 줄의 맨 뒤에 서면서 다음 과정을 거친다.   \t자기 앞에 자기보다 키가 큰 학생이 없다면 그냥 그 자리에 서고 차례가 끝난다. \t자기 앞에 자기보다 키가 큰 학생이 한 명 이상 있다면 그중 가장 앞에 있는 학생(A)의 바로 앞에 선다. 이때, A부터 그 뒤의 모든 학생들은 공간을 만들기 위해 한 발씩 뒤로 물러서게 된다.   이 과정을 반복하면 결국 오름차순으로 줄을 설 수가 있다.  아이들의 키가 주어지고, 어떤 순서로 아이들이 줄서기를 할 지 주어진다. 위의 방법을 마지막 학생까지 시행하여 줄서기가 끝났을 때 학생들이 총 몇 번 뒤로 물러서게 될까?  입력  첫 줄에 테스트 케이스의 수 P (1 ≤ P ≤ 1000) 가 주어진다.  각 테스트 케이스는 테스트 케이스 번호 T와 20개의 양의 정수가 공백으로 구분되어 주어진다.  20개의 정수는 줄서기를 할 아이들의 키를 줄서기 차례의 순서대로 밀리미터 단위로 나타낸 것이다.  모든 테스트 케이스는 독립적이다.  출력  각각의 테스트 케이스에 대해 테스트 케이스의 번호와 학생들이 뒤로 물러난 걸음 수의 총합을 공백으로 구분하여 출력한다.     문제 풀이   리스트 맨 뒤에서부터 제대로 찾아갈 때 까지 cnt를 늘려가고 이후 다시 정렬.      코드   Java 코드 /**   * Author: nowalex322, Kim HyeonJae   */    import java.io.*;  import java.util.*;    public class Main {      static BufferedReader br;      static BufferedWriter bw;      static StringTokenizer st;      static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {          new Main().solution();      }        public void solution() throws Exception {          br = new BufferedReader(new InputStreamReader(System.in));          //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_10431_줄세우기/input.txt\")));          bw = new BufferedWriter(new OutputStreamWriter(System.out));            int T = Integer.parseInt(br.readLine());          while (T-- &gt; 0) {              List&lt;Integer&gt; height = new ArrayList&lt;&gt;();              st = new StringTokenizer(br.readLine());              int TC = Integer.parseInt(st.nextToken());              sb.append(TC).append(\" \");                int cnt = 0;              for(int i = 1; i &lt;= 20; i++) {                  int h = Integer.parseInt(st.nextToken());                  for(int j=height.size()-1; j&gt;=0; j--) {                      if(height.get(j) &gt; h) cnt++;                      else break;                  }                  height.add(h);                  Collections.sort(height);              }                sb.append(cnt).append(\"\\n\");          }          System.out.println(sb.toString());          br.close();      }  }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     vector&lt;int&gt; height;     int cnt = 0;      int tc;     cin &gt;&gt; tc;     cout &lt;&lt; tc &lt;&lt; \" \";      for (int i = 1; i &lt;= 20; i++) {         int h;         cin &gt;&gt; h;          for (int j = height.size() - 1; j &gt;= 0; j--) {             if (height[j] &gt; h)                 cnt++;             else                 break;         }          height.push_back(h);         sort(ALL(height));     }      cout &lt;&lt; cnt &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt;     cin &gt;&gt; tt;      while (tt--) {         solve();     }     return 0; }   Python 코드 import sys imput = sys.stdin.readline  T = int(input())  for _ in range(T):     data = list(map(int, input().split()))     TC = data[0]     heights = data[1:]      cnt = 0     sorted_heights = []      for h in heights:         for j in range(len(sorted_heights)-1, -1, -1):             if sorted_heights[j] &gt; h: cnt += 1             else: break          sorted_heights.append(h)         sorted_heights.sort()      print(TC, cnt)  "
  },
  
  {
    "title": "BOJ_2661_좋은 수열 (Java)",
    "url": "/posts/BOJ2661%EC%A2%8B%EC%9D%80-%EC%88%98%EC%97%B4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-25 23:54:24 +0900",
    "content": "[Gold IV] 좋은수열 - 2661  문제 링크  ### 성능 요약  메모리: 14460 KB, 시간: 132 ms  ### 분류  백트래킹  ### 제출 일자  2025년 3월 25일 23:22:57  ### 문제 설명  숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다.  다음은 나쁜 수열의 예이다.    \t33  \t32121323  \t123123213    다음은 좋은 수열의 예이다.    \t2  \t32  \t32123  \t1232123    길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.  ### 입력  입력은 숫자 N하나로 이루어진다. N은 1 이상 80 이하이다.  ### 출력  첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 N인 좋은 수열들 중에서 가장 작은 수를 나타내는 수열만 출력한다. 수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.     문제 풀이        코드   /**   * Author: nowalex322, Kim HyeonJae   */    import java.io.*;  import java.util.*;    public class Main {      static BufferedReader br;      static BufferedWriter bw;      static StringTokenizer st;      static int N, arr[];      static boolean flag = false;      static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {          new Main().solution();      }        public void solution() throws Exception {          br = new BufferedReader(new InputStreamReader(System.in));          //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2661_좋은수열/input.txt\")));          bw = new BufferedWriter(new OutputStreamWriter(System.out));            N = Integer.parseInt(br.readLine());          arr = new int[81]; // 1-based            makeNum(1);            bw.flush();          bw.close();          br.close();      }        void makeNum(int idx){          if(flag) return;            if(idx &gt; N) {              for(int i=1; i&lt;=N; i++) {                  System.out.print(arr[i]);              }              flag = true;              return;          }            for(int i=1; i&lt;=3; i++){              if(arr[idx-1] == i) continue;              arr[idx] = i;              if(isValid(idx)) makeNum(idx+1);          }      }        boolean isValid(int idx) {          int cnt = 0;          for(int i=2; i&lt;=idx/2; i++){ // 부분수열 길이 2~ idx/2까지              for(int j=1; j&lt;=idx-i; j++){ // 시작인덱스                  cnt = 0;                  for(int k=j; k&lt;=j+i-1; k++){ // 첫 부분수열                      if(k+i &gt; idx) continue;                      if(arr[k] == arr[k+i]) cnt++; // ex) 1-4 / 2-5 / 3-6                  }                  if(cnt == i) return false;              }          }          return true;      }  }  "
  },
  
  {
    "title": "BOJ_13975_파일 합치기 3 (Java)",
    "url": "/posts/BOJ13975%ED%8C%8C%EC%9D%BC-%ED%95%A9%EC%B9%98%EA%B8%B0-3-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-25 23:50:19 +0900",
    "content": "[Gold IV] 파일 합치기 3 - 13975  문제 링크  ### 성능 요약  메모리: 279312 KB, 시간: 2468 ms  ### 분류  자료 구조, 그리디 알고리즘, 우선순위 큐  ### 제출 일자  2025년 3월 25일 21:40:00  ### 문제 설명  소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.  예를 들어, C1, C2, C3, C4가 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.  소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.  ### 입력  프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 1,000,000)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.  ### 출력  프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.     문제 풀이        코드   /**   * Author: nowalex322, Kim HyeonJae   */    import java.io.*;  import java.util.*;    public class Main {      static BufferedReader br;      static BufferedWriter bw;      static StringTokenizer st;      static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {          new Main().solution();      }        public void solution() throws Exception {          br = new BufferedReader(new InputStreamReader(System.in));          //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_13975_파일합치기3/input.txt\")));          bw = new BufferedWriter(new OutputStreamWriter(System.out));            int T = Integer.parseInt(br.readLine());          while (T--&gt; 0) {              int K = Integer.parseInt(br.readLine());              st = new StringTokenizer(br.readLine());              PriorityQueue&lt;Long&gt; pq = new PriorityQueue&lt;&gt;();              for (int i = 0; i &lt; K; i++) {                  pq.add(Long.parseLong(st.nextToken()));              }              long min = 0;              while(pq.size() &gt;=2) {                  Long tmp1 = pq.poll();                  Long tmp2 = pq.poll();                  tmp1 += tmp2;                  min += tmp1;                  pq.add(tmp1);              }              sb.append(min).append(\"\\n\");          }          System.out.println(sb.toString());          br.close();      }  }  "
  },
  
  {
    "title": "LeetCode_1037_Minimum Number of K Consecutive Bit Flips (Java)",
    "url": "/posts/LeetCode1037Minimum-Number-of-K-Consecutive-Bit-Flips-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-03-25 23:48:30 +0900",
    "content": "1037. Minimum Number of K Consecutive Bit Flips Hard  You are given a binary array nums and an integer k.  A k-bit flip is choosing a subarray of length k from nums and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.  Return the minimum number of k-bit flips required so that there is no 0 in the array. If it is not possible, return -1.  A subarray is a contiguous part of an array.  &nbsp; Example 1:    Input: nums = [0,1,0], k = 1  Output: 2  Explanation: Flip nums[0], then flip nums[2].    Example 2:    Input: nums = [1,1,0], k = 2  Output: -1  Explanation: No matter how we flip subarrays of size 2, we cannot make the array become [1,1,1].    Example 3:    Input: nums = [0,0,0,1,0,1,1,0], k = 3  Output: 3  Explanation:   Flip nums[0],nums[1],nums[2]: nums becomes [1,1,1,1,0,1,1,0]  Flip nums[4],nums[5],nums[6]: nums becomes [1,1,1,1,1,0,0,0]  Flip nums[5],nums[6],nums[7]: nums becomes [1,1,1,1,1,1,1,1]    &nbsp; Constraints:    \t1 &lt;= nums.length &lt;= 105  \t1 &lt;= k &lt;= nums.length       문제 풀이        코드    class Solution {      public int minKBitFlips(int[] nums, int k) {          int left = 0;          int[] prefixSum = new int[nums.length + 1];          int cnt = 0;          int currSum = 0; // 이전 뒤집기 기억해서 지금칸에 몇번 뒤집을지 0~k번 중 반영해야함            for (int i = 0; i &lt; nums.length; i++) {              currSum += prefixSum[i];                int currState = (nums[i] + currSum) % 2;                if (currState != 1) {                  if (i &gt; nums.length - k) {                      return -1;                  }                    cnt++;                    prefixSum[i]++;                  prefixSum[i + k]--;                    currSum++;              }          }            return cnt;      }  }  "
  },
  
  {
    "title": "BOJ_1976_여행 가자 (Java)",
    "url": "/posts/BOJ1976%EC%97%AC%ED%96%89-%EA%B0%80%EC%9E%90-Java-7fv3wkih/",
    "categories": "알고리즘",
    "tags": "",
    "date": "2025-03-25 23:43:52 +0900",
    "content": "[Gold IV] 여행 가자 - 1976  문제 링크  성능 요약  메모리: 19060 KB, 시간: 160 ms  분류  자료 구조, 분리 집합, 그래프 이론, 그래프 탐색  제출 일자  2025년 3월 25일 19:22:21  문제 설명  동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.  도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성하시오. 같은 도시를 여러 번 방문하는 것도 가능하다.  입력  첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N개의 줄에는 N개의 정수가 주어진다. i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1부터 N까지 차례대로 매겨져 있다.  출력  첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.     문제 풀이   Union-find 기법으로 풀었다. 처음에는 인접리스트 배열로 다 저장하려했는데 이것마저 필요없어서 지웠다. 단순히 입력받는 도시들을 다 분리집합으로 구분한 뒤 여행경로 도시들만 체크해주면된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int[] p;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1976_여행가자/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int N = Integer.parseInt(br.readLine());         p = new int[N+1];         for(int i = 0; i &lt; N+1; i++) {             p[i] = i;         }          int M = Integer.parseInt(br.readLine());         for (int i = 1; i &lt;= N; i++) {             st = new StringTokenizer(br.readLine());             int u = i;             for (int v=1; v&lt;=N; v++) {                 int connetion = Integer.parseInt(st.nextToken());                 if(connetion==1) {                     if(find(u) != find(v)) union(u,v);                 }             }         }          st = new StringTokenizer(br.readLine());         int c = Integer.parseInt(st.nextToken());          boolean isAble = true;         for (int i = 1; i &lt; M; i++) {             int nc = Integer.parseInt(st.nextToken());             if(find(c) != find(nc)){                 isAble = false;                 break;             }         }          if(isAble) System.out.println(\"YES\");         else System.out.println(\"NO\");          br.close();     }      private int find(int x){         if(p[x] != x) return p[x] = find(p[x]);         return p[x];     }      private void union(int x, int y){         int px = find(x);         int py = find(y);          if(px != py) {             if (px &lt; py) p[py] = px;             else p[px] = py;         }     } }  "
  },
  
  {
    "title": "PGMS_금과 은 운반하기 (Java)",
    "url": "/posts/PGMS%EA%B8%88%EA%B3%BC-%EC%9D%80-%EC%9A%B4%EB%B0%98%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-03-25 13:34:44 +0900",
    "content": "[level 3] 금과 은 운반하기 - 86053  문제 링크  ### 성능 요약  메모리: 105 MB, 시간: 75.97 ms  ### 구분  코딩테스트 연습 &gt; 월간 코드 챌린지 시즌3  ### 채점결과  정확성: 100.0합계: 100.0 / 100.0  ### 제출 일자  2025년 03월 24일 04:20:44  ### 문제 설명  어느 왕국에 하나 이상의 도시들이 있습니다. 왕국의 왕은 새 도시를 짓기로 결정하였습니다. 해당 도시를 짓기 위해서는 도시를 짓는 장소에 금 a kg과 은 b kg이 전달되어야 합니다.  각 도시에는 번호가 매겨져 있는데, i번 도시에는 금 g[i] kg, 은 s[i] kg, 그리고 트럭 한 대가 있습니다. i번 도시의 트럭은 오직 새 도시를 짓는 건설 장소와 i번 도시만을 왕복할 수 있으며, 편도로 이동하는 데 t[i] 시간이 걸리고, 최대 w[i] kg 광물을 운반할 수 있습니다. (광물은 금과 은입니다. 즉, 금과 은을 동시에 운반할 수 있습니다.) 모든 트럭은 같은 도로를 여러 번 왕복할 수 있으며 연료는 무한대라고 가정합니다.  정수 a, b와 정수 배열 g, s, w, t가 매개변수로 주어집니다. 주어진 정보를 바탕으로 각 도시의 트럭을 최적으로 운행했을 때, 새로운 도시를 건설하기 위해 금 a kg과 은 b kg을 전달할 수 있는 가장 빠른 시간을 구해 return 하도록 solution 함수를 완성해주세요.    제한사항    0 ≤ a, b ≤ 109  1 ≤ g의 길이 = s의 길이 = w의 길이 = t의 길이 = 도시 개수 ≤ 105      0 ≤ g[i], s[i] ≤ 109  1 ≤ w[i] ≤ 102  1 ≤ t[i] ≤ 105  a ≤ g의 모든 수의 합  b ≤ s의 모든 수의 합        입출력 예             a  b  g  s  w  t  result                10  10  [100]  [100]  [7]  [10]  50      90  500  [70,70,0]  [0,0,500]  [100,100,2]  [4,8,1]  499               입출력 예 설명  입출력 예 #1    도시가 오직 하나뿐이므로, 0번 도시의 유일한 트럭이 모든 운반을 해결해야 합니다. 이 트럭은 최대 7kg만큼의 광물을 운반할 수 있으며 편도 완주에는 10시간이 걸립니다.  맨 처음에 10시간을 써서 7kg만큼의 금을 운반하고, 10시간을 써서 다시 도시로 돌아오고, 10시간을 써서 7kg만큼의 은을 운반하고, 10시간을 써서 다시 도시로 돌아오고, 마지막으로 10시간을 써서 3kg만큼의 금과 3kg만큼의 은을 운반하면, 총 50시간 만에 필요한 모든 금과 은을 조달할 수 있습니다.  따라서, 50을 return 해야 합니다.    입출력 예 #2    도시가 3개이고, 0번과 1번 도시는 금만 70kg씩 가지고 있고 2번 도시는 은을 500kg 가지고 있습니다.      0번 도시의 트럭은 용량은 100kg, 편도 완주 시간은 4시간입니다.  1번 도시의 트럭은 용량은 100kg, 편도 완주 시간은 8시간입니다.  2번 도시의 트럭은 용량은 2kg, 편도 완주 시간은 1시간입니다.    금은 0번 도시의 트럭과 1번 도시의 트럭이 각각 45kg씩 나누어서 운반하면 8시간 안에 필요한 모든 금을 조달할 수 있습니다.  은은 2번 도시의 트럭이 한 번에 2kg씩 250번 운반하면(249번 왕복 + 1번 편도) 총 499시간 만에 필요한 모든 은을 조달할 수 있습니다.  따라서, 499를 return 해야 합니다.       출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        코드   class Solution {      public long solution(int a, int b, int[] g, int[] s, int[] w, int[] t) {          long ans=0;                    long left = 0;          long right = (long) 1e15;                    long res = 0;          while(left &lt;= right){              long mid = left + (right-left) / 2L;              if(canBuild(a, b, g, s, w, t, mid)){                  res = mid;                  right = mid-1;              }              else left = mid+1;          }          return res;      }            private static boolean canBuild(int a, int b, int[] g, int[] s, int[] w, int[] t, long mid){          long goldW = 0; // a이상이어야함          long silverW = 0; // b이상이어야함          long totalW = 0; // a+b이상이어야함                        for(int i=0; i&lt;w.length; i++){              long cnt = (long) mid / (2L * (long) t[i]);              if(mid % (2L * (long) t[i]) &gt;= t[i]) cnt++; // 편도 1회                             long maxW = cnt * w[i]; // 최대한 트럭에 싣고 옮길때 양              long maxGold = Math.min(maxW, g[i]);  // 보유 금 넘지 않게              long maxSilver = Math.min(maxW, s[i]); // 보유 은 넘지 않게                            long moveW = Math.min(g[i] + s[i], maxW);                            totalW += moveW;              goldW += maxGold;              silverW += maxSilver;          }                    return totalW &gt;= a+b &amp;&amp; goldW &gt;= a &amp;&amp; silverW &gt;= b;      }  }  "
  },
  
  {
    "title": "BOJ_24492_Cow Frisbee",
    "url": "/posts/BOJ24492Cow-Frisbee/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-22 17:48:16 +0900",
    "content": "[Gold II] Cow Frisbee - 24492  문제 링크  성능 요약  메모리: 54876 KB, 시간: 516 ms  분류  자료 구조, 스택  제출 일자  2025년 3월 22일 17:44:04  문제 설명 Farmer John’s $N$ cows ($N \\leq 3 \\times 10^5)$ have heights $1, 2, \\ldots, N$. One day, the cows are standing in a line in some order playing frisbee; let $h_1 \\ldots h_N$ denote the heights of the cows in this order (so the $h$’s are a permutation of $1 \\ldots N$).  Two cows at positions $i$ and $j$ in the line can successfully throw the frisbee back and forth if and only if every cow between them has height lower than $\\min(h_i, h_j)$.  Please compute the sum of distances between all pairs of locations $i&lt;j$ at which there resides a pair of cows that can successfully throw the frisbee back and forth. The distance between locations $i$ and $j$ is $j-i+1$.  입력 The first line of input contains a single integer $N$. The next line of input contains $h_1 \\ldots h_N$, separated by spaces.  출력 Output the sum of distances of all pairs of locations at which there are cows that can throw the frisbee back and forth. Note that the large size of integers involved in this problem may require the use of 64-bit integer data types (e.g., a “long long” in C/C++).     문제 풀이   양 방향을 보기 위해 왼-&gt;오 와 오-&gt;왼 두 번 진행해줬다.  Stack 자료구조를 사용해 자신보다 큰것이 top에 있으면 자신을 넣고, 그게 아니라 자기보다 작은것이면 빼면서 거리계산해줬다.       코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Cow{         int idx, height;         public Cow(int idx, int height){             this.idx = idx;             this.height = height;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_24492_CowFrisbee/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int N = Integer.parseInt(br.readLine());         int[] arr = new int[N];         st = new StringTokenizer(br.readLine());         for(int i = 0; i &lt; N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }          Stack&lt;Cow&gt; stack_LtoR = new Stack&lt;&gt;();         long res = 0;         for(int i = 0; i &lt; N; i++) {             Cow currCow = new Cow(i, arr[i]);             while(!stack_LtoR.isEmpty()) {                 if(stack_LtoR.peek().height &lt; currCow.height) {                     Cow tmpCow = stack_LtoR.pop();                     res += currCow.idx - tmpCow.idx + 1;                 }                 else break;             }             stack_LtoR.push(currCow);         }          Stack&lt;Cow&gt; stack_RtoL = new Stack&lt;&gt;();         for(int i = N-1; i &gt;=0; i--) {             Cow currCow = new Cow(i, arr[i]);             while(!stack_RtoL.isEmpty()) {                 if(stack_RtoL.peek().height &lt; currCow.height) {                     Cow tmpCow = stack_RtoL.pop();                     res += tmpCow.idx - currCow.idx + 1;                 }                 else break;             }             stack_RtoL.push(currCow);         }         System.out.println(res);         br.close();     } }  "
  },
  
  {
    "title": "Computer Science Note - Database",
    "url": "/posts/Computer-Science-Note-Database/",
    "categories": "CS, Note",
    "tags": "CS, 데이터베이스",
    "date": "2025-03-22 00:30:43 +0900",
    "content": "   본 게시글의 그림들은 참고 레퍼런스들을 토대로 직접 그렸음을 미리 밝힙니다.   Database    1. 데이터베이스의 기본   1-1. 엔티티    사람, 장소, 물건 등 여러개의 속성을 지닌 명사를 의미   ex) 회원이라는 엔티티 -&gt; 속성 : 이름, 아이디, 주소, 전화번호를 속성으로 가짐 서비스의 요구사항에 맞춰 속성이 정해짐   약한 엔티티와 강한 엔티티    A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적일 때            강한 엔티티 : B       약한 엔티티 : A             1-2. 릴레이션    데이터베이스에서 정보를 구분하여 저장하는 기본 단위   엔티티에 관한 데이터를 릴레이션 하나에 담아서 관리함            RDBS에서는 “테이블” 이라고 부름       NoSQL에서는 “컬렉션” 이라고 부름           테이블과 컬렉션    관계형 데이터베이스 (MySQL) : 레코드 - 테이블 - 데이터베이스   NoSQL 데이터베이스 (MongoDB) : 도큐먼트 - 컬렉션 - 데이터베이스     1-3. 속성 (attribute)    릴레이션에서 관리하는 구체적이며 고유한 이름 갖는 정보     1-4. 도메인 (Domain)    릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합   ex) 속성 : 성별 -&gt; 도메인(값) : 남, 여     1-5. 필드와 레코드 회원이라는 테이블로 설명해보자.    회원이란 엔티티는 member라는 테이블   속성이 이름, 아이디 등이 있으면 필드로 name, ID 등   테이블에 쌓이는 행(row)로 Alex, Kguswo가 들어가는데 이걸 레코드(= 튜플) 라고 한다     필드 타입 숫자 타입 | 타입 | 용량(바이트) | 최솟값(부호있음) | 최댓값(부호있음) | 최솟값(부호없음) | 최댓값(부호없음) | |——|————|—————-|—————-|—————-|—————-| | TINYINT | 1 | -128 | 127 | 0 | 255 | | SMALLINT | 2 | -32,768 | 32,767 | 0 | 65,535 | | MEDIUMINT | 3 | -8,388,608 | 8,388,607 | 0 | 16,777,215 | | INT | 4 | -2,147,483,648 | 2,147,483,647 | 0 | 4,294,967,295 | | BIGINT | 8 | -263 | 263-1 | 0 | 264-1 |  날짜 타입    DATE            날짜 부분만 있고 시간 부분은 없음       지원범위 : 1000-01-01 ~ 9999-12-31       3 바이트           DATETIME            날짜 + 시간       지원 범위 : 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59       8 바이트           TIMESTAMP            날짜 + 시간       지원 범위 : 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07       4 바이트           문자 타입    CHAR            고정 길이 문자열, 길이 : 0 ~ 255       레코드를 저장할 때 무조건 선언한 길이 값으로 “고정”해서 저장       수를 입력해서 몇 자까지 입력할지 정함. ex) CHAR(30) : 최대 30글자       ex) CHAR(100) 선언 후 10글자 저장해도 100바이트로 저장           VARCHAR            가변 길이 문자열, 길이 : 0 ~ 255       입력한 데이터에 따라 용량을 가변시켜 저장       ex) 10글자의 이메일을 저장할 경우 VARCHAR(1000)이라고 선언했어도 10글자에 해당하는 바이트 + 길이 기록용 1 바이트로 저장           TEXT            큰 문자열 저장할 때 사용       게시판의 본문 저장할 때           BLOB            이미지, 동영상 등 큰 데이터 저장할 때 사용       하지만 AWS S3 이용하는 등 서버에 파일 올리고 파일에 관한 경로를 VARCHAR 로 저장하는게 일반적임           ENUM            ENUM(‘x-small’, ‘small’, ‘medium’, ‘large’, ‘x-large’) 형태로 쓰임, 이 중에서 하나만 선택하는 단일 선택만 가능.       ENUM 리스트에 없는 잘못된 값을 삽입하면 빈 문자열이 대신 삽입됨       장점 : ENUM 사용시 x-small 등이 0, 1 등으로 매핑되어 메모리 적게 사용       최대 65535개의 요소 넣을 수 있음           SET            ENUM과 비슷하지만 여러개의 데이터 선택할 수 있음.       비트 단위의 연산을 할 수 있음       최대 64개의 요소 넣을 수 있음           ENUM이나 SET 사용시 공간적으로 이점을 볼 수 있지만 애플리케이션 수정에 따라 데이터베이스의 ENUM or SET에 정의한 목록을 수정해야 한다는 단점이 있다.    1-6 관계 DB에는 여러개의 테이블이있고 테이블간의 관계가 있다  1:1 관계 유저 - 유저이메일 테이블에서 유저당 이메일은 한개씩 있다. 이 경우 1:1 관계다. 1:1 관계는 테이블을 2개의 테이블로 나눠 구조를 더 이해하기 쉽게 만들어준다.  1:N 관계 쇼핑몰의 경우 한 유저당 여러 상품을 장바구니에 넣을 수 있다. 이 경우 1:N 관계다. 하나도 넣지 않을수도 있으니 0도 포함된다.  N:M 관계 학생과 강의의 관계에서 한 학생이 여러 강의 들을 수 있고 한 강의도 여러 학생을 포함할 수 있다. 이 경우 N:M 관계다. N:M 관계는 테이블 2개를 직접 연결하지 않고 중간에 1:N, 1:M 관계를 갖는 테이블 2개로 나눠서 중간에 학생_강의 테이블을 둔다(학생 ID, 강의 ID).    1-7 키    슈퍼키 : 유일성이 있다 ( 중복값 없음 )            후보키 : 최소성을 갖춘 키 ( 필드 조합없이 최소 필드만 써서 키 형성가능)                    기본키 : 기본키로 선택된 키           대체키 : 기본키로 선택되지 못한 키                           기본키 (Primary Key)    유일성과 최소성을 만족하는 키   테이블의 데이터 중 고유하게 존재하는 속성이며, 기본키에 해당하는 데이터는 중복되어서는 안된다.   자연키    중복되지 않는 것을 “자연스럽게” 뽑다가 나오는 키   언젠가는 변하는 속성   ex) 유저테이블에서 주민등록번호, 이름, 성별 등이 있을 때 중복된 값으로 이름, 성별은 제외하면 주민등록번호가 자연스레 남는다. 자연키는 주민등록번호가 된다.   인조키    인위적으로 ID를 부여 -&gt; 고유 식별자가 생김   Oracle은 sequence, MySQL은 auto increment등으로 설정   자연키와는 달리 변하지 않으므로 보통 기본키는 인조키   외래키 (Foreign Key)    다른 테이블의 기본키를 그대로 참조하는 값으로 개체와의 관계를 식별하는데 사용   외래키는 중복되어도 괜찮다.   후보키 (candidate key)    기본키가 될 수 있는 후보들   유일성과 최소성을 만족   슈퍼키 (super key)    각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키        2. ERD 정규화 과정   ERD(Entity Relationship Diagram)는 릴레이션 간의 관계를 정의한 것이다.   2-1. ERD의 중요성    시스템 요구사항을 기반으로 작성됨, 이를 기반으로 DB 구축   이후 디버깅 or 비즈니스 프로세스 재설계시 설게도 역할도 함   *비정형 데이터는 충분히 표현할 수 없다.     *비정형 데이터 : 비구조화 데이터, 미리 정의된 데이터 모델이 없거나 미리 정의된 방식으로 정리되지 않은 정보        2-2. 정규화 과정 릴레이션 간의 잘못된 종속관계로 인해 데이터베이스 이상현상 생겨서 이를 해결하거나, 저장공간 효율적으로 사용하기 위해 릴레이션 여러개로 분리하는 과정  정규형 원칙    같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 만들어야 함   자료의 중복성은 감소해야 함   독립적인 관계는 별개의 릴레이션으로 표현해야함   각각의 릴레이션은 독립적인 표현이 가능해야 함   제1정규형    릴레이션의 모든 도메인이 더이상 분해될 수 없는 원자값만으로 구성되어야 한다   릴레이션의 속성 값 중 한개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안된다   제2정규형    릴레이션이 제 1 정규형이며 부분 함수의 종속성을 제거한 형태            기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것           릴레이션을 분해할 때 동등한 릴레이션으로 분해해야하고, 정보 손실이 발생하지 않는 무손실 분해여야한다   제3정규형    제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태     이행적 함수 종속 : A-&gt;B 와 B-&gt;C 가 존재하면 논리적으로 A-&gt;C가 성립하는데 이때 집합 C가 집합 A에 이행적으로 함수 종속이다.      보이스/코드 정규형    제3정규형이고, 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 릴레이션의 함수 종속 관계에서 모든 결정자가 후보키인 상태     결정자 : X-&gt;Y일 때 X는 결정자, Y는 종속자           3. 트랜잭션과 무결성   3-1. 트랜잭션    데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위   여러개의 쿼리를 하나로 묶는 단위   ACID : 원자성, 일관성, 독립성, 지속성   (1) 원자성    트랜잭션과 관련된 이리 모두 수행되었거나 되지 않았거나를 보장하는 특징   “all or nothing”   커밋과 롤백    커밋(commit) : 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장됨            ex) 커밋 시작 (update-insert-delete) 커밋 종료 로 하나의 트랜잭션 단위로 수행되고 이후 데이터베이스에 영구 저장됨           Q. 하지만 에러나 여러 이슈 때문에 트랜잭션 전으로 돌려야 한다면? A : 롤백!    롤백이란 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일.   커밋과 롤백 덕분에 데이터의 무결성이 보장된다.   트랜잭션 전파    트랜잭션 수행시 커넥션 단위로 수행하기 때문에 커넥션 객체를 넘겨서 수행해야함, 하지만 매번 넘기기 어렵고 귀찮음   이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것을 트랜잭션 전파라고 한다.   ex) Spring에서의 @Transactional   (2) 일관성    “허용된 방식”으로만 데이터를 변경해야 하는 것을 의미   데이터베이스에 기록된 모든 데이터는 여러 조건, 규칙에 따라 유효함을 가짐   ex) 자금 100만원인 사람이 200만원을 빌려줄 수 없음.   (3) 격리성    트랜잭션 수행 시 서로 끼어들지 못하는 것   복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야함   데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야함   쉽게 생각하면 트랜잭션 순차적으로 실행하면 되는데 이는 성능 저하를 일으킴!            =&gt; 격리성은 여러개의 격리 수준으로 나뉘어 격리성을 보장               격리 수준은 SERIALIZABLE, REPEATABLE_READ, READ_COMMITTED, READ_UNCOMMITTED가 있으며 위로 갈수록 동시성이 강하지만 격리성은 약해짐   격리 수준에 따라 발생하는 현상 - 팬텀 리드    한 트랜잭션 내에서 동일한 쿼리 보냈을 때 해당 조회 결과가 다른 경우   ex) 10살 이상인 회원 조회 쿼리 보낸 후 결과가 3명일 때, 15살인 회원 추가시 4개가 조회되는 것   - 반복 가능하지 않은 조회    한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우   ex) A의 자금이 100만원이라고 조회했는데 이후 B가 그 값을 0으로 변경해서 커밋하면 이후 A는 0을 조회하게 된다.   팬텀 리드와 다른 점은 반복 가능하지 않은 조회는 행 값이 달라질 수 있는데, 팬텀 리드는 다른 행이 선택될 수도 있다는 점.   - 더티 리드    반복가능하지 않은 조회와 유사함   한 트랜잭션이 실행중일 때 다른 트랜잭션에 의해 수정되었지만 아직 “커밋되지 않은” 행의 데이터를 읽을 수 있을 때 발생   ex) A의 자금이 100만원이라고 조회했는데 이후 B가 그 값을 0으로 변경했고 이를 커밋하기 전에도 조회하면 0을 조회하게 된다.   격리 수준 - SERIALIZABLE    트랜잭션을 순차적으로 진행시키는 것   여러 트랜잭션이 동시에 같은 행에 접근 불가, 기다려야함   교착상태 일어날 확률도 많고, 가장 성능이 떨어지는 격리 수준   - REPEATABLE_READ    하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는다.   - READ_COMMITTED    가장 많이 사용되는 격리 수준   트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 즉 커밋 완료된 데이터에 대해서만 조회를 허용   하지만 어떤 트랜잭션이 접근한   - READ_UNCOMMITTED    가장 낮은 격리 수준   하나의 트랜잭션이 커밋되기 전에 다른 트랜잭션에 노출되는 문제가 있지만 가장 빠름   거대한 양의 데이터를 “어림잡아” 집계할 때 사용하면 좋음   (4) 지속성    성공적으로 수행된 트랜잭션은 영원히 반영되어야함   데이터베이스에 시스템 장애 생겨도 원래 상태로 복구 가능.   checksum, 저널링, 롤백 등의 기능 제공     저널링 : 파일 시스템 또는 데이터베이스 시스템에 변경 사항을 커밋하기 전에 로깅하는것, 트랜잭션 등 변경 사항에 대한 로그 남기는것        3-2. 무결성    데이터의 정확성, 일관성, 유효성을 유지하는 것, 무결성이 유지되어야 데이터베이스 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는 신뢰가 생김   무결성의 종류    개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않음   참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지   고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성값은 모두 고유값을 가짐   NULL 무결성 : 특정 속성값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없다는 제약 조건        4. 데이터베이스 종류   4-1. 관계형 데이터베이스    행과열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스   SQL이라는 언어로 조작   MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등   MySQL    스토리지 엔진은 데이터베이스의 심장이다, 모듈식 아키텍쳐로 쉽게 스토리지 엔진을 바꿀 수 있으며 데이터 워어하우징, 트랜잭션 처리, 고가용성 처리가 장점이다.   스토리지 엔진 위에는 커넥터API 및 서비스계층을 통해 MySQL DB랑 쉽게 상호작용   PostgreSQL    VACUUM : 디스크 조각이 차지하는 영역을 회수할 수 있는 장치   최대 테이블 크기 : 32TB   SQL 뿐만 아니라 JSON을 이용해서 데이터 접근 가능   지정 시간에 복구하는 기능, 로깅, 접근제어, 중첩된 트랜잭션, 백업 등 가능     4-2. NoSQL 데이터베이스    Not Only SQL; SQL을 사용하지 않는 데이터베이스. ex) MongoDB, redis   MongoDB    JSON을 통해 데이터 접근 가능.   Binary JSON(BSON) 형태로 데이터가 저장됨.   와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 DB다.   장점 : 확장성 뛰어남, 빅데이터를 저장할 때 성능 좋음, 고가용성, 샤딩, 레플리카셋 지원, 스키마 정해놓지 않고 데이터 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석 or 로깅 구현할 때 좋음   도큐먼트 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 유티크한 값인 ObjectID가 생성된다   Redis    인메모리 데이터베이스. 키-값 데이터 모델 기반   기본적인 데이터 타입 : 문자열(String), 최대 512MB 저장가능   그 외 set, hash 지원   pub/sub 기능을 통해 채팅 시스템, 다른 DB앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 set (sorted-set) 자료구로 이용한 실시간 순위표 서비스 등에 사용됨        5. 인덱스   5-1. 인덱스의 필요성    데이터 빠르게 찾을 수 있는 하나의 장치. ex) 책 마지막 장에 있는 찾아보기와 같다.     5-2. B-트리    루트 노드, 리프 노드, 브랜치 노드로 나뉨   E를 찾는다고 하면 전체 테이블을 탐색하는 것이 아니라 E가 있을법한 리프노드로 가서 E를 탐색하기 때문에 더 빠르게 탐색 가능하다.   자세한 예시로 57을 찾는 과정을 보자.  맨 위 루트노드부터 탐색한다. 그 후 브랜치 노드를 거쳐 리프노드까지 내려온다. “57보다 같거나 클 때 까지 &lt;=” 를 기반으로 정렬된 값을 기반으로 탐색한다. 마지막 리프노드 도달시 57이 가리키는 데이터 포인터를 통해 결괏값을 반환한다.  인덱스가 효율적인 이유와 대수확장성    효율적인 이유 : 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형잡힌 트리 구조와 깊이의 대수확장성 때문     대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장. 기본적으로 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목수는 4배씩 증가.        5-3. 인덱스 만드는 방법 MySQL    클러스터형 인덱스            테이블당 하나 설정       primary key 옵션으로 기본키로 만듬       기본키로 반들지 않고 unique not null 옵션 붙여도 가능           세컨더리 인덱스            보조 인덱스로 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야함       create index … 명령어로 만들 수 있음           -&gt; 하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스보다 성능 좋다. ex) name이라는 필드만으로 쿼리 보낸다면 클러스터형 인덱스, name, age, email 등 다양한 필드 기반으로 쿼리 보낸다면 세컨더리 인덱스  MongoDB    도큐먼트 생성시 자동으로 ObjectID 형성되고 해당 키가 기본키로 설정됨   세컨더리 키도 부가적으로 설정해서 기본키와 세컨더리 키 같이 쓰는 복합 인덱스 사용 가능     5-4. 인덱스 최적화 기법 (MongoDB 기준) 1. 인덱스는 비용이다    인덱스는 두 번 탐색하도록 강요한다. 인덱스 리스트, 그다음 컬렉션 순으로 탐색하기 때문에 읽기 비용 발생.   또한 컬렉션 수정되었을 때 인덱스도 수정되어야한다. 이때 B-트리의 높이를 균형있게 조절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있게 분산시키는 비용도 든다.   따라서 모든 필드에 인덱스 설정하는 것은 좋지 않고, 컬렉션에서 가져올 양 많을수록 인덱스 사용이 비효율적이다.  2. 항상 테스팅하라    서비스 특징에 따라 인덱스 최적화 기법이 다른데 서비스에서 사용하는 객체의 깊이, 테이블의 양이 다르기 때문이다.   explain() 함수를 통해 인덱스를 만들고, 쿼리 보낸 후 테스팅하며 걸리는 시간을 최소화해야한다.   MySQL 테스팅코드 EXPLAIN \tSELECT * FROM t1 \t\tJOIN t2 ON t1.c1 = t2.c1   3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다    여러 필드 기반 조회시 복합 인덱스 생성하는데, 이 인덱스 생성할때 순서가 있고 생성 순서에 따라 인덱스 성능도 달라진다.        같음 &gt; 정렬 &gt; 다중 값 &gt; 카디널리티 순으로 생성해야한다.             어떠한 값과 같음을 비교하는 == 이나 equal이라는 쿼리가 있으면 제일 먼저 인덱스로 설정       정렬에 쓰는 필드라면 그 다음 인덱스로 설정       다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 &gt; 이거나 &lt; 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스 설정       *카디널리티가 높은 순서 기반으로 인덱스 생성해야한다.  ex) age 와 email이 있을 때 email이 카디널리티가 높으므로 email이라는 필드에 인덱스 먼저 생성         *카디널리티  : 유니크한 값의 정도                       6. 조인의 종류      조인 : 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것            MySQL : JOIN       MongoDB : lookup                    lookup은 되도록 사용하지 말자. MongoDB는 조인연산에 대해 관계형 데이터베이스보다 성능이 덜어진다고 여러 벤치마크 테스트를 통해 알려진 바 있다.                           따라서 조인이 많은 경우 RDBS를 사용하자.  **조인의 종류    내부조인 (Inner Join) : 왼쪽 테이블과 오른쪽 테이블 두 행이 모두 일치하는 행 표기   왼쪽 조인 (Left Outer Join) : 왼쪽 테이블의 모든 행이 표기   오른쪽 조인 (Right Outer Join) : 오른쪽 테이블의 모든 행이 표기   합집합 조인 (Full Outer Join) : 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기     6-1. 내부조인 (Inner Join) SELECT * FROM TableA A \tINNER JOIN TableB B     \tON A.key = B.key     6-2. 왼쪽 조인 (Left Outer Join) SELECT * FROM Table A A \tLEFT JOIN TableB B     \tON A.key = B.key     6-3. 오른쪽 조인 (Right Outer Join) SELECT * FROM TableA A \tRIGHT JOIN TableB B     \tON A.key = B.key     6-4. 합집합 조인 (Full Outer Join) SELECT * FROM TableA A \tFULL OUTER JOIN TableB B     \tON A.key = B.key        7. 조인의 원리   7-1. 중첩 루프 조인 (NLJ, Nested Loop Join)    중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법   랜덤 접근에 대한 비용이 많이 증가하므로 대용량 테이블에서 사용 X   ex) t1, t2테이블 조인한다고 했을때 첫번째 테이블에서 행을 한번에 하나씩 읽고 그 다음 테이블에서도 행을 하나씩 읽어 조건에 맞는 레코드 찾아 결괏값 반환     블록 중첩 루프 조인 (BNL, Block Nested Loop) : 중첩 루프 조인에서 발전한 조인할 테이블을 작은 블록으로 나눠 블록 하나씩 조인하는 방식           7-2. 정렬 병합 조인    각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬 끝난 후 조인 작업 수행   조인에 쓸 적절한 인덱스가 없고 대용량 테이블들을 조인하고 조인 조건으로 &lt; , &gt; 등 범위 비교 연산자 있을 때 사용     7-3. 해시 조인    해시 테이블 기반 조인   테이블 2개 조인시 하나의 테이블이 메모리에 온전히 들어간다면 중첩 루프 조인보다 효율적.(메모리에 올릴 수 없을 정도로 크다면 디스크를 사용하는 비용 발생)   동등(=) 조인에서만 사용 가능   MySQL의 해시 조인 - 빌드단계, 프로브 단계로 나뉨 빌드 단계    입력 테이블 중 하나 기반으로 메모리 내 해시 테이블을 빌드하는 단계   ex) persons와 countries라는 테이블 조인시 둘 중 바이트가 더 작은 테이블 기반으로 테이블을 빌드   또한 조인에 사용되는 필드가 해시 테이블의 키로 사용된다. ex) “countries.country_id”가 키로 사용됨   프로브 단계    레코드 읽기 시작하며, 각 레코드에서 “persons.country_id”에 일치하는 레코드 찾아서 결괏값으로 반환   "
  },
  
  {
    "title": "Computer Science Note - Network",
    "url": "/posts/Computer-Science-Note-Network/",
    "categories": "CS, Note",
    "tags": "CS, 네트워크",
    "date": "2025-03-21 06:01:41 +0900",
    "content": "   본 게시글의 그림들은 참고 레퍼런스들을 토대로 직접 그렸음을 미리 밝힙니다.   NETWORK     1. 네트워크 기초   네트워크 : 노트 (Node) + 링크 (Link) 가 연결되어 리소스를 공유하는 집합    1-1. 처리량과 지연시간  좋은 네트워크    많은 처리량을 처리 가능   지연시간이 짧음   장애 빈도가 적음   좋은 보안   처리량(Throughput) : 링크 내에서 성공적으로 전달된 데이터 양 ( 트래픽 얼마나 처리했는지 의미 ) 많은 트래픽 처리 = 많은 처리량을 가진다     처리량 단위 : BPS (Bits Per Second)   처리량에 영향을 주는 것들            사용자들이 많이 접속할때마다 커지는 트래픽       네트워크 장치 간의 대역폭       네트워크 중간에 발생하는 에러       장치의 하드웨어 스펙               트래픽 (y축) : 특정 시점에 링크 내에 흐르는 데이터의 양 ex) 서버에 저장된 파일들을 클라이언트가 다운받으면 발생하는 데이터의 누적량   대역폭 : 주어진 시간동안 네트워크 연결을 통해 흐를 수 있는 비트의 수   요약    트래픽 증가 = 흐르는 데이터 양이 증가   처리량 증가 = 처리되는 트래픽 증가   지연 시간 (Latency) : 요청이 처리되는 시간, 메시지가 두 장치 왕복하는데 걸리는 시간 매체 타입(유선, 무선), 패킷 크기, 라우터의 패킷 처리 시간 등에 영향받음    1-2. 네트워크 토폴로지와 병목현상 네트워크 토폴로지 : 노드와 링크가 어떻게 배치되어있는지에 대한 방식 (연결 형태)     트리 토폴로지            계층형 토폴로지라고도 하며 트리 형태로 배치       장점 : 노드의 추가, 삭제가 쉬움       단점 : 특정 노드에 트래픽이 집중될 때 하위 노드에 영향 끼칠 수 있음           버스 토폴로지            중앙 통신 회선 하나에 여러 노드가 연결되어 공유       근거리 통신망 (LAN)에서 사용       장점 : 설치 비용이 적고 신뢰성이 우수함, 중앙 통신 회선에 노드 추가 및 삭제가 쉬움       단점 : 스푸핑           스푸핑 : LAN상에서 송신부 패킷을 관련없는 다른 호스트에게 가지 않도록 하는 스위칭 기능 마비시키거나 속여서 특정 노드에 그 해당 패킷이 들어오도록 처리함.스푸핑을 적용하면 올바른 수신부로 가야할 패킷이 악의적인 노드에 전달됨.      스타 토폴로지            중앙에 있는 노드에 모두 연결된 네트워크 구성       장점 : 노드를 추가하거나 에러 탐지가 쉬움, 패킷 충돌 가능성 낮음. 어떠한 노드에 장애가 발생해도 쉽게 에러 발견 가능. 장애 노드가 중앙 노드가 아니면 다른 노드에 거의 영향 X.       단점 : 중앙 노드 장애 발생시 전체 네트워크 사용 불가, 설치 비용 매우 비쌈.           링형 토폴로지            각각의 노드가 양 옆의 두 노드와 연결되서 전체적으로 한붓그리기 고리처럼 하나의 연속된 길을 통해 통신.       데이터는 노드 to 노드로 이동하며, 각각의 노드는 고리 모양의 길을 통해 패킷 처리.       장점 : 노드 수 증가해도 네트워크 손실 거의 없음. 충돌 발생 가능성 낮고 노드 고장 쉽게 찾을 수 있음.       단점 : 네트워크 구성 변경이 어렵고, 회선에 장애가 발생하면 전체 네트워크에 영향을 크게 끼침.           메시 토폴로지            그물망처럼 연결되어있는 구조.       장점 : 한 단말장치에 장애가 발생해도 여러개의 경로가 존재하므로 네트워크를 계속 사용할 수 있고, 트래픽 분산 처리가 가능.       단점 : 노드 추가가 어렵고 비용과 운용 비용이 너무 비쌈.           병목 현상  병목 현상 (Bottleneck) : 전체 시스템의 성능이나 용량이 하나의 구성요소로 인해 제한 받는 현상.  병목현상이라 불리는 이유는 병의 몸통보다 병의 목이 좁아서 물이 상대적으로 느리게 흐르는 것과 같음. 병목현상은 이벤트 트래픽 많이 생기고 그 트래픽 처리 못하면 생김. 그래서 웹 사이트 접속 못하는 현상이 발생.  토폴로지가 중요한 이유는 병목현상을 찾을때 중요한 기준이 되기 때문!    1-3. 네트워크 분류    LAN(Local Area Network) : 개인적으로 소유 가능한 소규모 네트워크            근거리 통신망. 좁은 공간에서 운영되며 전송속도가 빠르고 혼잡하지 않다.           MAN(Metropolitan Area Network) : 시 규모의 네트워크            대도시 지역 네트워크(넓은 지역). 전송 속도 평균이며 LAN보다는 혼잡.           WAN(Wide Area Network) : 세계 규모 네트워크            광역 네트워크(국가, 대륙 크기). 전송속도 느리고 가장 혼잡.             1-4. 네트워크 성능 분석 명령어 네트워크 병목현상 주 원인    네트워크 대역폭   네트워크 토폴로지   서버 CPU, 메모리 사용량   비효율적인 네트워크 구성   테스트를 진행하며 네트워크로 부터 발생한 문제점 임을 확인했으면 네트워크 성능 분석을 해야함. 이때 사용하는 명령어에 대해 알아보자.  ping (Packet INternet Groper)    네트워크 상태 확인하려는 대상 노드를 향해 일정 크기의 패킷을 전송하는 명령어   이를 통해 해당 노드의 패킷 수신 상태와 도달하기까지 시간, 해당 노드까지 네트워크 잘 연결되어있는지 등 알 수 있음   TCP/IP 프로토콜 중에서 ICMP 프로토콜을 통해 동작. 그렇기 때문에 ICMP 지원안하는 기기 대상으로는 실행 불가 or 네트워크 정책상 ICMP나 traceroute 차단하는 대상 경우 ping 테스트 불가   ping [IP 주소 or 도메인 주소] ex) ping www.google.com -n 12 : -n 12 옵션으로 12번의 패킷을 보내고 받는다   netstat    접속되어있는 서비스들의 네트워크 상태를 표시하는데 사용   네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 등 리스트 보여줌   주로 서비스 포트 열려있는지 확인할때 사용   nslookup    DNS에 관련된 내용 확인에 사용   특정 도메인에 매핑된 IP 확인하기 위함   tracert    목적지 노드까지 네트워크 경로 확인할 때 사용   목적지 노드까지 구간들 중 어느 구간에서 응답시간 느려지는지 확인 가능     1-5. 네트워크 프로토콜 표준화 다른 장치들까지 데이터 주고받기 위해 설정된 공통 인터페이스. IEEE 또는 IETF에서 정함.     IEEE802.3 : 유선 LAN 프로토콜. 이를 통해 만든 기업이 다른 장치들도 서로 데이터 송수신.   ex) 웹 접속 시 사용하는 HTTP. 서로 약속된 HTTP라는 인터페이스를 통해 노드들은 웹 서비스를 기반으로 데이터 주고받을 수 있다.     2. TCP/IP 4계층 모델   TCP/IP 4계층과 OSI 7계층 비교 및 대표 스택 (빨간색)   TCP/IP 계층은 4개를 가지고 있음. OSI 7계층은 애플리케이션 계층을 3개로 쪼개고 링크 계층을 데이터 링크 계층 + 물리 계층으로 나눠서 표현. 인터넷 계층을 네트워크 계층으로 부름.  이 계층들은 특정 계층이 변경되었을 때 다른 계층이 영향을 받지 않도록 유연하게 설계되었다. ex) 전송계층에서 TCP가 UDP로 변경되었다고 해서 인터넷 웹 브라우저를 다시 설치해야하는 것은 아니다.    애플리케이션 계층 (Application Layer)    웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공하는 계층   응용 프로그램이 사용되는 프로토콜 계층 (FTP, HTTP, SSH, SMTP, DNS)            FTP : 장치와 장치간 파일 전송시 사용하는 표준 통신 프로토콜       SSH : 보안되지 않은 네트워크에서 네트워크 서비스 안전하게 운영하기 위한 암호화 프로토콜       HTTP : World Wide Web (www) 위한 데이터 통신의 기초. 웹사이트 이용시 쓰는 프로토콜       SMTP : 전자 메일 전송을 위한 인터넷 표준 통신 프로토콜       DNS : 도메인 이름과 IP주소 매핑해주는 서버. ex) www.naver.com에 DNS쿼리가 오면 , [Root DNS] =&gt; [.com DNS] =&gt; [.naver DNS] =&gt; [.www DNS] 과정을 거쳐 완벽한 주소를 찾아 IP 주소 매핑함. 예를 들어 www.naver.com IP주소가 222.111.222.111에서 222.111.222.122로 바뀌어도 똑같은 www.naver.com로 서비스 가능.             전송 계층 (Transport Layer)    송신자와 수신자를 연결하는 통신 서비스 제공   연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어 제공할 수 있음   애플리케이션 - 인터넷 계층 사이의 데이터 전달될 때 중계 역할   ex) TCP / UDP   TCP    패킷 순서 보장   연결지향 프로토콜 사용해서 연결   신뢰성 구축해서 수신 여부 확인   가상 회선 패킷 교환 방식 사용   UDP    순서 보장 X   수신 여부 확인 X   단순히 데이터만 주는 데이터그램 패킷 교환 방식 사용   가상 회선 패킷 교환 방식 각 패킷에는 가상회선 식별자가 포함되며 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착.  데이터그램 패킷 교환 방식 패킷이 독립적으로 이동하며 최적의 경로 선택하여 진행. 하나의 메시지에서 분할된 여러 패킷은 서로 다른 경로로 전송될 수 있고 도착한 순서가 다를 수 있다.  TCP 연결 성립 과정 TCP는 신뢰성 확보하기 위해 3-Way-HandShake 라는 작업을 진행한다. 이 글 참고   1. SYN 단계    클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보낸다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀀스 번호를 말하며 장치마다 다를 수 있다.   2. SYN + AKC 단계    서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN+1을 보낸다.   3. AKC 단계    클라이언트는 서버의 ISN+1 한 값인 승인번호를 담아 ACK를 서버에 보낸다.   이렇게 3-Way-HandShake 과정 이후 신뢰성이 구축되고 데이터 전송을 시작한다. 이 과정 덕분에 TCP는 신뢰성 있는 계층이라고 하고 UDP는 이 과정이 없어서 신뢰성이 없다.  *키워드 SYN : SYNchronization의 약자. 연결 요청 플래그 ACK : ACKnowledgement의 약자. 응답 플래그 ISN : Initial Sequence Numbers의 약어. 초기 네트워크 연결할 때 할당된 32비트 고유 시퀀스 번호  TCP 연결 해제 과정                먼저 클라이언트가 연결을 닫으려고 할 때 FIN 으로 설정된 세그먼트 보낸다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다린다.                       서버는 클라이언트로 ACK 라는 승인 세그먼트를 보낸다. 그리고 CLOSE_WAIT  상태에 들어간다. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어간다.                       서버는 ACK 를 보내고 일정 시간 이후 클라이언트에게 FIN 이라는 세그먼트 보낸다.                       클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED상태가 된다. 이후 클라이언트는 어느정도 시간 대기한 후 연결 닫히고 클라이언트와 서버의 모든 자원 연결 해제된다. (CLOSED)           Q. 왜 TIME_WAIT만큼 기다리다가 닫을까?    지연 패킷이 발생할 경우. 패킷이 뒤늦게 도달하고 이를 처리하지 못한다면 데이터 무결성 문제가 발생한다.   두 장치가 연결이 닫혔는지 확인하기 위함. 만약 LAST_AKC 상태에서 닫히게 되면 다시 새로운 연결을 하려고 할 때 장치는 계속 LAST_ACK로 되어있기 때문에 접속 오류 발생.   보통 우분투에서 60초, 윈도우에서 4분정도로 설정되어있다.    인터넷 계층 (Intenet Layer)    장치로부터 받은 네트워크 패킷을 IP 주소로 지정된 목적지로 전송하기 위해 사용되는 계층   IP, ARP, ICMP 등이 있고 패킷을 수신해야 할 상대의 주소를 지정해 데이터 전달   상대방이 제대로 받았는지에 대해 보장하지 않는 비연결형적 특징     링크 계층    전선, 광섬유, 무선 등 실질적으로 데이터 전달하며 장치 간 신호 주고받는 규칙을 정하는 계층   데이터 링크 계층 + 물리 계층 으로 나누기도함            물리계층 : 무선LAN과 유선LAN을 통해 0과 1로 이루어진 데이터 보내는 계층       데이터 링크 계층 : “이더넷 프레임”을 통해 에러 확인, 흐름 제어, 접근 제어 담당           유선LAN(IEEE802.3) 유선LAN을 이루는 이더넷은 IEEE802.3 이라는 프로토콜 사용, 전이중화 통신을 사용.          전이중화 통신 (Full Duplex) : 양쪽 장치가 동시에 송수신 가능 송신로와 수신로로 나눠서 데이터 주고받음.           CSMA/CD : 데이터를 “보낸 이후” 충돌이 발생하면 일정 시간 이후 재전송하는 방식      유선LAN을 이루는 케이블    트위스트 페어 케이블 : 8개의 구리선을 두개씩 꼬아서 묶은 케이블   광섬유 케이블 : 레이저를 이용해 통신하기 때문에 매우 빠르고 장거리 통신 가능.   무선LAN(IEEE802.11) 수신과 송신에 같은 채널 사용. 반이중화 통신 사용. 반이중화 통신 (Half Duplex) : 양쪽 장치는 서로 통신할 수 있지만, 동시에는 통신할 수 없다. 하나의 데이터를 받기 전까지 전송이 제한된다.     CSMA/CS : 반이중화 통신 중 하나로 장치에서 데이터를 보내기 전까지 일련의 괒어을 기반으로 사전에 가능한 한 충돌을 방지하는 방식.            사용중인 채널이 있다면 다른 채널 감지하다가 유후상태인 채널 발견       프레임 간 공간 시간인 IFS 시간만큼 기다림.       프레임 보내기 전 0 ~ $2^k - 1$ 사이에서 결정된 랜덤 상수 기반의 결정된시간만큼 기다린 뒤 프레임 보냄. 프레임 보낸 뒤 제대로 송신되었고 ACK 세그먼트 받았다면 끝낸다. 그러나 받지 못했으면 k = k+1을 해서 이 과정 반복한다. 이 과정 반복하다가 $k_{max}$보다 커지면 해당 프레임 전송 버린다. (abort)           *전이중화 통신은 양방향 통신 가능해서 충돌 가능성이 없기 때문에 이런 메커니즘 필요없음.  무선 LAN 이루는 주파수 2.4GHz대역 or 5GHz 대역 중 하나로 구축.    2.4GHz            장점 : 장애물에 강함       단점 : 전자레인지, 무선 등 전파 간섭 일어나는 경우 많음           5GHz (일반적으로 선택함)            장점 : 사용할 수 있는 채널 수 많음, 동시에 사용 가능 -&gt; 깨끗한 전파 환경           와이파이 (wifi)    전자기기들이 무선LAN 신호에 연결할 수 있게 하는 기술.   AP(공유기)로 유선 LAN에 흐르는 신호를 무선 LAN으로 바꿔서 신호가 닿는 범위내에서 무선 인터넷 사용 가능.   ex) 무선LAN기술 예시 : wifi, 지그비, 블루투스   BSS (Basic Service Set)    기본 서비스 집합, 단순 공유기를 통해 네트워크 접속이 아니라 동일 BSS내에 있는 AP 장치들과 장치들이 서로 통신 가능한 구조   근거리 무선 통신 제공, 하나의 AP만을 기반으로 구축되어 있음   사용자가 한 곳에서 다른곳으로 자유롭게 이동 가능, 네트워크에 접속은 불가능   ESS (Extended Service Set)    하나 이상의 연결된 BSS 그룹   장거리 무선 통신을 제공하며 BSS보다 더 많은 가용성과 이동성을 지원   사용자가 한 곳에서 다른 곳으로 이동하며 중단 없이 네트워크에 계속 연결가능    이더넷 프레임 데이터 링크 계층은 이더넷 프레임을 통해 전달받은 데이터의 에러를 검출하고 캡슐화한다. 구조는 아래와 같다.      Preamble : 이더넷 프레임 시작 알림   SFD(Start Frame Delimeter) : 다음 바이트부터 MAC 주소 필드 시작됨을 표시   DMAC, SMAC : 수신, 송신 MAC 주소   EtherType : 데이터 계층 위의 계층인 IP 프로토콜 정의. ex) IPv4 or IPv6   Payload : 전달받은 데이터   CRC : 에러 확인 비트   *MAC : 컴퓨터나 노트북 각 장치에 네트워크 연결하기 위한 LAN카드가 있는데 이를 구별하기 위한 식별번호. 6Byte로 구성됨.  계층 간 데이터 송수신 과정    애플리케이션 계층에서 전송 계층으로 Request 값들이 캡슐화 과정을 거쳐 전달된다.   다시 링크 계층을 통해 해당 서버와 통신을 하고, 해당 서버의 링크 계층으로부터 애플리케이션까지 비캡슐화를 통해 데이터가 전송된다.   캡슐화 과정 상위 계층의 헤더와 데이터를 하위 계층의 데이터 부분에 넣고, 해당 계층의 헤더를 덧붙임  비캡슐화 과정 하위 계층에서 상위계층으로 갈때 각 계층 헤더부분 제거 링그 계층부터 올라오면서 프레임 -&gt; 패킷 -&gt; 세그먼트 -&gt; 메시지 로 비캡슐화된다. 최종적으로 사용자에게는 애플리케이션의 PDU인 메시지로 전달된다.    2-2. PDU (Protocol Data Unit)    네트워크의 계층 to 계층으로 데이터가 전달될 때의 한 덩어리   구성요소            Header : 제어 관련 정보들이 포함됨       Payload : 데이터를 의미                    애플리케이션 계층 : 메시지           **전송 계층 **: 세그먼트(TCP), 데이터그램(UDP)           인터넷 계층 : 패킷           **링크 계층 **: 프레임(데이터 링크 계층), 비트(물리계층)                           이 사이트 에서 curl 명령어로 www.naver.com으로 HTTP 요청해서 PDU 테스트를 해보자. 출력 결과 Content-Type: text/html; charset=UTF-8 Cache-Control: no-cache, no-store, must-revalidate Pragma: no-cache x-frame-options: DENY x-xss-protection: 1; mode=block strict-transport-security: max-age=63072000; includeSubdomains referrer-policy: unsafe-url Content-Encoding: gzip Server: nfront Content-Length: 41653 Date: Thu, 20 Mar 2025 17:22:05 GMT Connection: keep-alive Vary: Accept-Encoding       3. 네트워크 기기   3-1. 네트워크 기기 처리 범위 상위 계층을 처리하는 기기는 하위 계층을 처리할 수 있지만, 반대로는 불가능    애플리케이션 계층 : L7 스위치   인터넷 계층 : 라우터, L3 스위치   데이터 링크 계층 : L2 스위치, 브리지   물리 계층 : NIC, 리피터, AP     3-2. 애플리케이션 계층 처리하는 기기 L7 스위치    스위치는 여러 장비 연결하고 데이터 통신을 중재하며 목적지가 연결된 포트로만 전기 신호 보내서 데이터 전송   로드 밸런서 라고도 하며, 서버의 부하를 분산하는 기기   클라이언트로부터 오는 Request들을 뒤쪽의 여러 서버로 나누는 역할, 시스템이 처리할 수 있는 트래픽 증가를 목표로 함   URL, 서버, 캐시, 쿠키 기반으로 트래픽 분산   바이러스, 불필요한 외부 데이터 걸러내는 필터링 기능   응용프로그램 수준의 트래픽 모니터링 가능   만약 장애가 발생한 서버가 있다면 이는 트래픽 분산 대상에서 제외해야 하는데, 정기적인 health check를 이용해서 감시   L4 스위치 vs L7 스위치         L4 스위치는 전송 계층을 처리하는 기기로 스트리밍 관련 서비스에서는 사용 불가. 메시지를 기반으로 인식하지 못하고 IP와 포트 기반 (주로 포트 기반) 트래픽 분산한다.           L7 스위치는 IP, 포트 이외에도 URL, HTTP헤더, 쿠키 등을 기반으로 트래픽 분산           AWS에서는 L7스위치 기반 로드밸런싱은 ALB컴포넌트로, L4스위치 기반 로드밸런싱은 NLB 컴포넌트로 한다.      헬스 체크 (Health Check)    서버가 정상인지 비정상인지 판별하기 위해 헬스체크함. 전송 주기와 재전송 횟수를 설정한 뒤 반복적으로 서버에 요청을 보냄 (서버가 부하되지 않을 만큼).   TCP, HTTP 등 다양한 방법을 요청을 보내며, 이 요청이 정상적으로 이루어졌다면 정상이라고 판별.  ex) TCP 요청시 3-way-handshake 일어나지 않으면 정상이 아니라는 뜻   로드 밸런서를 이용한 서버 이중화 로드 밸런서는 2대 이상의 서버를 기반으로 가상 IP를 제공하고 이를 기반으로 안정적인 서비스를 제공한다.    3-3. 인터넷 계층을 처리하는 기기 라우터    여러개의 네트워크를 연결, 분할, 구분시켜줌   다른 네트워크에 존재하는 장치끼리 서로 데이터 주고받을 때 패킷 소모를 최소화하고 경로를 최적화하여 최소 경로로 패킷을 포워딩   L3 스위칭    L2스위치의 기능과 라우팅 기능을 갖춘 장비. 라우터라고 해도 무방함   하드웨어 기반의 라우팅을 담당     3-4. 데이터 링크 계층을 처리하는 기기 L2 스위치    장치들의 MAC 주소를 MAC 주소 테이블을 통해 관리하며, 연결된 장치로부터 패킷이 왔을 때 패킹 전송을 담당   IP 주소를 이해하지 못해 IP 주소 기반 라우팅은 불가능, 단순히 MAC 주소를 읽어 스위칭 하는 역할   목적지가 MAC 주소테이블에 없다면 전체 포트에 전달하고 MAC 주소테이블 주소는 일정시간 이후 삭제하는 기능도 있다.   브리지 (Bridge)    두개의 근거리 통신망(LAN)을 상호 접속할 수 있도록 하는 통신망 연결 장치   포트와 포트 사이의 다리 역할을 하며 장치에서 받아온 MAC주소를 MAC 주소 테이블로 관리   통신망 범위 확장하고 서로 다른 LAN 등으로 이루어진 “하나의” 통신망을 구축할 때 사용     3-5. 물리 계층을 처리하는 기기 NIC (Network Interface Card)    LAN 카드라고 하는 네트워크 인터페이스 카드는 2대 이상의 컴퓨터 네트워크를 구성하는데 사용됨   네트워크와 빠른 속도로 데이터를 송수신할 수 있도록 컴퓨터 내에 설치하는 확장 카드   각 LAN 카드에는 고유 식별번호인 MAC 주소가 있다   리피터 (Repeater)    리피터로 들어오는 약해진 신호 정도를 증폭해서 다른쪽으로 전달   AP (Access Point)    패킷을 복사하는 기기   AP에 유선LAN 연결한 후 다른 장치에서 무선 LAN 사용해서 무선 네트워크 사용 가능        4. IP 주소   4-1. ARP        컴퓨터간 통신은 IP주소에서 ARP를 통해 MAC 주소를 찾아 MAC 주소를 기반으로 통신함     ARP (Address Resolution Protocol) 는 IP 주소로부터 MAC 주소를 구하는 IP와 MAC 주소의 다리 역할을 하는 프로토콜     ARP를 통해 가상 주소인 IP 주소를 실제 주소인 MAC으로 변환. 반대로 RARP를 통해 실제 주소인 MAC주소를 가상 주소인 IP주소로 변환하기도 함      장치 A가 ARP Request 브로드캐스트를 보내 IP 주소인 100.10.10.1 (예시)에 해당하는 MAC 주소를 찾는다. 그 후 해당 MAC 주소에 맞는 장치 B가 ARP Reply 유니캐스트를 통해 MAC주소를 반환하는 과정을 거쳐 IP주소에 맞는 MAC 주소를 찾게 된다.  * 브로드 캐스트 : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송 * 유니캐스트 : 고유 주소로 식별된 하나의 네트워크 목적지에 1:1로 데이터 전송    4-2 홉바이홉 통신 (hop by hop)    IP 주소를 통해 통신하는 과정, 통신망에서 각 패킷이 여러개의 라우터를 건너가는 모습을 표현함   수많은 서브네트워크 안에 있는 라우터의 라우팅테이블 IP를 기반으로 패킷을 전달해나가며 라우팅을 수행해서 최종 목적지까지 패킷 전달   통신 장치에 있는 “라우팅 테이블“의 IP를 통해 시작주소에서 시작해서 다음 IP로 이동하는 “라우팅” 과정 거쳐서 패킷이 최종 목적지에 도달   라우팅 테이블    라우터에 들어가있는 목적지 정보들과 그 목적지로 가기 위한 방법이 들어있는 리스트   송신지에서 수신지까지 도달하기 위해 사용됨   게이트웨이와 모든 목적지에 대해 해당 목적지 도달하기위해 거쳐야 할 다음 라우터 정보를 가짐   게이트웨이    서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 관문 역할하는 컴퓨터/소프트웨어   사용자는 인터넷 접속하기 위해 수많은 게이트웨이를 거쳐야하고, 게이트웨이는 서로 다른 네트워크 상의 통신 프로토콜 변환해주기도 함   라우팅테이블 예시) netstat -r     4-3 IP 주소체계    IPv4 : 32비트를 8비트 단위로 .을 찍어 표기, 123.45.67.89 같은 방식   IPv6 : 64비트를 16비트 단위로 .을 찍어 표기, 2001:db8:ff00:8329 같은 방식   클래스 기반 할당 방식 (Classful Network Addressing)    처음에는 A, B, C, D, E 다섯개의 클래스로 구분하는 클래스 기반 할당 방식을 사용했음   앞부분을 네트워크주소, 뒷부분을 컴퓨터에 부여하는 주소인 호스트 주소로 놓고 사용    클래스 A, B, C 는 일대일 통신으로 사용됨. 클래스 D는 멀티캐스트 통신, 클래스 E는 앞으로 사용할 예비용.     클래스 A 범위 : 0.0.0.0 ~ 127.255.255.255 00000000.00000000.00000000.00000000 ~ 01111111.1011111.1111111.11111111   클래스 B 범위 : 128.0.0.0 ~ 191.255.255.255 10000000.00000000.00000000.00000000 ~ 1011111.1011111.1111111.11111111   클래스 C 범위 : 192.0.0.0 ~ 223.255.255.255 11000000.00000000.00000000.00000000 ~ 11011111.1011111.1111111.11111111   맨 왼쪽 비트 : 구분 비트    클래스 A는 0, 클래스 B는 10, 클래스 C는 110   네트워크 첫 번째 주소는 네트워크 주소로 사용되고 가장 마지막 주소는 브로드캐스트용 주소로 네트워크에 속해있는 모든 컴퓨터에 데이터 보낼 때 사용됨  이 방식은 사용하는 주소보다 버리는 주소가 많은 단점이 있음. 이를 해소하기 위해 DHCP와 IPv6, NAT가 생김.  DHCP (Dynamic Host Configuration Protocol)    IP 주소 및 기타 통신 매개변수를 자동으로 할당하기 위한 네트워크 관리 프로토콜   네트워크 장치의 IP 주소를 수동으로 설정할 필요 없이 인터넷 접속할 때 마다 자동으로 IP 주소 할당   많은 라우터와 게이트웨이 장비에 DHCP기능 있기 때문에 대부분의 가정용 네트워크에서 IP주소 할당   NAT (Network Address Translation)    패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법   IPv4 주소체계만으로는 많은 주소 감당하지 못하는 단점 있지만, NAT로 공인 IP와 사설 IP로 나눠서 많은 주소 처리    사설IP를 NAT장치를 통해 공인 IP로 외부 인터넷에 요청할 수 있다. 이를 통해 A, B, C, D 는 1개의 공인 IP를 기반으로 각각 다른 IP를 가지는것처럼 사용 가능.  공유기와 NAT    NAT 쓰는 이유 : 여러대의 호스트가 하나의 공인 IP 주소를 사용해서 인터넷 접속하기 위해서 ex) 인터넷 회선 하나 개통하고 인터넷 공유기 달아서 여러 PC 사용할 수 있는 이유는 인터넷 공유기에 NAT기능이 있기 때문   NAT를 이용한 보안    NAT로 내부 네트워크에서 사용하는 IP주소와 외부에 드러나는 IP주소를 다르게 유지할 수 있기 때문에 어느정도 보안 가능   NAT 단점    여러명이 동시에 인터넷 접속하게 되므로 실제 접속하는 호스트 숫자에 따라 접속 속도가 느려질 수 있다.     4-4. IP주소를 이용한 위치 정보 IP주소는 인터넷에서 사용하는 네트워크 주소이기 때문에 위치추적 가능하다. 이 사이트에서 위치를 찾아볼 수 있다.  서울대입구역 근처에 거주중인데 나름 IP만으로 비슷하게 찾은것을 볼 수 있다. 한 정거장 정도 차이가 난다.       5. HTTP   HTTP : 전송 계층 위의 애플리케이션 계층으로서 웹 서비스 통신에 사용됨   5-1. HTTP/1.0    한 연결당 하나의 요청을 처리하도록 설계됨   RTT 증가를 불러오게 됨   RTT 증가     서버로부터 파일을 가져올 때마다 TCP의 3-way-handshake를 계속 열어야해서 RTT가 증가하는 단점이 있음   RTT의 증가를 해결하기 위한 방법 매번 연결할때마다 RTT 증가하니 서버 부담이 많이가고, 사용자 응답시간이 길어졌다. 그래서 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩을 사용하곤 했다.          이미지 스플리팅     많은 이미지 다운받으면 과부하 걸리기 때문에 많은 이미지가 합쳐져있는 하나의 이미지를 다운받고 이를 기반으로 background-image의 position을 이용해서 이미지 표기           코드 압축     코드를 압축해서 개행 문자, 빈칸 없애서 코드의 크기 최소화           이미지 Base64 인코딩     이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법.  장점 : 서버와의 연결을 열고 이미지에 대해 서버에 HTTP요청을 할 필요가 없다 단점 : Base64 문자열로 변환시 37% 정도 크기가 더 커진다        5-2. HTTP/1.1    매번 TCP 연결 하는게 아니라 한번 TCP 초기화한 이후 keep-alive 옵션으로 여러개의 파일을 송수신할 수 있다.      단점은 문서안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비례해서 대기시간이 길어진다는 점이다   HOL Blocking (Head Of Line Blocking)    네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될 때 성능저하 발생 ex) 맨 처음 패킷 매우 큰 이미지 있어서 느리게 다운받아지면 그 뒤에 있는것들 대기해서 다운로드 지연됨   무거운 헤더구조    HTTP/1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어있고 압축이 되지 않아 무겁다     5-3. HTTP/2    SPDY 프로토콜에서 파생된 HTTP/1.x보다 지연시간 줄이고 응답시간 더 빠르게 하고, 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리 지원하는 프로토콜   멀티플렉싱    여러개의 스트림 사용하여 송수신   특정 스트림 손상돼도 해당 스트림만 영향받지 다른 스트림들은 멀쩡함   헤더 압축    허프만 코딩 압축 알고리즘으로 HPACK 압축형식을 가짐   허프만 코딩 : 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도 높은 정보는 적은 비트수 사용해서 표현, 빈도 낮은 정보는 비트 수 많이 사용해서 표현 -&gt; 전체 데이터 표현에 필요한 비트양 줄이기  서버 푸시    HTTP/1.1에서는 클라이언트가 서버에 요청해야만 파일 받을 수 있었다면, HTTP/2는 클라이언트의 요청 없이 서버가 바로 리소스 푸시 가능      5-4. HTTPS    HTTPS는 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청   이 방법으로 통신을 암호화함   SSL (Secure Socket Layer) /TLS (Transport Layer Security Protocol)    전송 계층에서 보안을 제공하는 프로토콜   클라이언트와 서버가 통신할 때 SSL/TLS를 통해 제 3자 메시지 도청 및 변조 방지   공격자가 서버인 척 하며 사용자 정보 가로채는 “인터셉터” 방지 가능   인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 사용   보안 세션    보안이 시작되고 끝나는동안 유지되는 세션. SSL/TLS 는 핸드셰이크를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보등을 공유함   HTTPS 구축방법    직접 CA에서 구매한 인증키를 기반으로 HTTPS 서비스 구축   서버 앞단에 HTTPS를 제공하는 로드밸런서 두기   서버 앞단에 HTTPS 제공하는 CDN 둬서 구축     5-5. HTTP/3    World Wide Web에서 정보를 교환하는데 사용되는 HTTP의 세번째 버전   TCP 위에서 돌아가는 HTTP/2와 달리 QUIC라는 계층 위에서 돌아감   UDP기반으로 돌아감    장점 : HTTP/2의 장점인 멀티플렉싱도 가지고있으면서 초기 연결 설정시 지연 시간 감소   초기 연결 설정 시 지연 시간 감소 QUIC는 TCP를 사용하지 않기 때문에 통신 시작할 때 번거로운 3-Way-HandShake 과정 거치지 않음  QUIC는 첫 연결 설정에 1-RTT만 소요된다. 클라이언트가 서버에 어떤 신호를 한 번 주고, 서버도 거기에 응답만 하면 바로 본 통신 시작 가능하다.  QUIC는 순방향 오류 수정 메커니즘이 적용되었다. 이는 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식이며 열악한 네트워크 환경에서도 패킷 손실률이 낮다.     References      Service set (802.11 network)  "
  },
  
  {
    "title": "BOJ_2877_4와 7 (Java)",
    "url": "/posts/BOJ28774%EC%99%80-7-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-19 20:08:30 +0900",
    "content": "[Gold V] 4와 7 - 2877  문제 링크  성능 요약  메모리: 14284 KB, 시간: 100 ms  분류  구현, 수학  제출 일자  2025년 3월 19일 20:04:13  문제 설명  창영이는 4와 7로 이루어진 수를 좋아한다. 창영이가 좋아하는 수 중에 K번째 작은 수를 구해 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 K(1 ≤ K ≤ 109)가 주어진다.  출력  첫째 줄에 창영이가 좋아하는 숫자 중 K번째 작은 수를 출력한다.     문제 풀이      자릿수별 개수 파악            1자리 숫자: 2개 (4, 7) = 2¹       2자리 숫자: 4개 (44, 47, 74, 77) = 2²       3자리 숫자: 8개 (444, 447, …) = 2³       n자리 숫자: 2ⁿ개                K번째 숫자의 자릿수 찾기           해당 자릿수 내에서의 위치 계산      이진수 변환            자릿수 내 위치(pos)를 이진수로 표현       0은 4로, 1은 7로 변환           K번째 숫자가 몇 자리 숫자인지 찾고, 해당 자릿수 내에서의 위치를 이진수로 표현한 뒤 4와 7로 변환     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2877_4와7/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  long K = Long.parseLong(br.readLine());          int digits = 1;         long sum = 0;          while(true){             long cnt = 1L &lt;&lt; (digits);              if(sum + cnt &gt;= K) break;              sum += cnt;             digits++;         }          long pos = K - sum - 1; // K-sum 번째이므로 인덱스로는 -1          for(int i=0; i&lt;digits; i++){ // 맨 오른쪽 자릿수부터 숫자찾기, 0이면 작은수 1이면 큰수             if((pos &amp; (1L &lt;&lt; (digits - 1 - i))) == 0) sb.append(\"4\");             else sb.append(\"7\");         }         System.out.println(sb.toString());         br.close();     } }  "
  },
  
  {
    "title": "BOJ_2169_로봇 조종하기 (Java)",
    "url": "/posts/BOJ2169%EB%A1%9C%EB%B4%87-%EC%A1%B0%EC%A2%85%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-19 19:22:11 +0900",
    "content": "[Gold II] 로봇 조종하기 - 2169  문제 링크  성능 요약  메모리: 89348 KB, 시간: 532 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 3월 19일 19:19:15  문제 설명  NASA에서는 화성 탐사를 위해 화성에 무선 조종 로봇을 보냈다. 실제 화성의 모습은 굉장히 복잡하지만, 로봇의 메모리가 얼마 안 되기 때문에 지형을 N×M 배열로 단순화 하여 생각하기로 한다.  지형의 고저차의 특성상, 로봇은 움직일 때 배열에서 왼쪽, 오른쪽, 아래쪽으로 이동할 수 있지만, 위쪽으로는 이동할 수 없다. 또한 한 번 탐사한 지역(배열에서 하나의 칸)은 탐사하지 않기로 한다.  각각의 지역은 탐사 가치가 있는데, 로봇을 배열의 왼쪽 위 (1, 1)에서 출발시켜 오른쪽 아래 (N, M)으로 보내려고 한다. 이때, 위의 조건을 만족하면서, 탐사한 지역들의 가치의 합이 최대가 되도록 하는 프로그램을 작성하시오.  입력  첫째 줄에 N, M(1≤N, M≤1,000)이 주어진다. 다음 N개의 줄에는 M개의 수로 배열이 주어진다. 배열의 각 수는 절댓값이 100을 넘지 않는 정수이다. 이 값은 그 지역의 가치를 나타낸다.  출력  첫째 줄에 최대 가치의 합을 출력한다.     문제 풀이   dfs로 접근하면 시간초과가 발생한다. 이에 dp를 사용했다. 각 층마다 진행하면 위에서 내려오는것, 왼쪽으로 이동하는것, 오른쪽으로 이동하는것으로 생각할 수 있다.  왼쪽과 오른쪽을 나누어 계산해주면 중복이 없다.      코드   package BOJ_2169_로봇조종하기;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, dr[] = {0, 0, 1}, dc[] = {-1, 1, 0};     static int[][] board, dp;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2169_로봇조종하기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         board = new int[N][M];         for(int i = 0; i &lt; N; i++){             st = new StringTokenizer(br.readLine());             for(int j = 0; j &lt; M; j++){                 board[i][j] = Integer.parseInt(st.nextToken());             }         }          int[][] dp = new int[N][M];         dp[0][0] = board[0][0];         for(int j=1; j &lt; M; j++){             dp[0][j] = dp[0][j-1] + board[0][j];         }          for(int i=1; i&lt;N; i++){             int[] LtoR = new int[M];             int[] RtoL = new int[M];              LtoR[0] = dp[i-1][0] + board[i][0];             for(int j=1; j&lt;M; j++){                 LtoR[j] = Math.max(dp[i-1][j], LtoR[j-1]) + board[i][j];             }              RtoL[M-1] = dp[i-1][M-1] + board[i][M-1];             for(int j=M-2; j&gt;=0; j--){                 RtoL[j] = Math.max(dp[i-1][j], RtoL[j+1]) + board[i][j];             }              for(int j=0; j&lt;M; j++){                 dp[i][j] = Math.max(LtoR[j], RtoL[j]);             }         }          System.out.println(dp[N-1][M-1]);         br.close();     } }  "
  },
  
  {
    "title": "BOJ_10800_컬러볼 (Java)",
    "url": "/posts/BOJ10800%EC%BB%AC%EB%9F%AC%EB%B3%BC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-19 06:16:56 +0900",
    "content": "[Gold II] 컬러볼 - 10800  문제 링크  성능 요약  메모리: 102656 KB, 시간: 1816 ms  분류  구현, 누적 합, 정렬  제출 일자  2025년 3월 19일 06:11:23  문제 설명  지훈이가 최근에 즐기는 컴퓨터 게임이 있다. 이 게임은 여러 플레이어가 참여하며, 각 플레이어는 특정한 색과 크기를 가진 자기 공 하나를 조종하여 게임에 참여한다. 각 플레이어의 목표는 자기 공보다 크기가 작고 색이 다른 공을 사로잡아 그 공의 크기만큼의 점수를 얻는 것이다. 그리고 다른 공을 사로잡은 이후에도 본인의 공의 색과 크기는 변하지 않는다. 다음 예제는 네 개의 공이 있다. 편의상 색은 숫자로 표현한다.   \t \t\t \t\t\t공 번호 \t\t\t색 \t\t\t크기 \t\t \t \t \t\t \t\t\t1 \t\t\t1 \t\t\t10 \t\t \t\t \t\t\t2 \t\t\t3 \t\t\t15 \t\t \t\t \t\t\t3 \t\t\t1 \t\t\t3 \t\t \t\t \t\t\t4 \t\t\t4 \t\t\t8 \t\t \t   이 경우, 2번 공은 다른 모든 공을 사로잡을 수 있다. 반면, 1번 공은 크기가 더 큰 2번 공과 색이 같은 3번 공은 잡을 수 없으며, 단지 4번 공만 잡을 수 있다.   공들의 색과 크기가 주어졌을 때, 각 플레이어가 사로잡을 수 있는 모든 공들의 크기의 합을 출력하는 프로그램을 작성하시오.   입력  첫 줄에는 공의 개수를 나타내는 자연수 N이 주어진다(1 ≤ N ≤ 200,000). 다음 N개의 줄 중 i번째 줄에는 i번째 공의 색을 나타내는 자연수 Ci와 그 크기를 나타내는 자연수 Si가 주어진다(1 ≤ Ci ≤ N, 1 ≤ Si ≤ 2,000). 서로 같은 크기 혹은 같은 색의 공들이 있을 수 있다.  출력  N개의 줄을 출력한다. N개의 줄 중 i번째 줄에는 i번째 공을 가진 플레이어가 잡을 수 있는 모든 공들의 크기 합을 출력한다.     문제 풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Ball implements Comparable&lt;Ball&gt;{         int idx, C, S;         public Ball(int idx, int color, int size){             this.idx = idx;             this.C = color;             this.S = size;         }          @Override         public int compareTo(Ball o) {             if(this.S == o.S) return this.C - o.C;             return this.S - o.S;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, colorSum[][], res[];     static Ball[] balls;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {             br = new BufferedReader(new InputStreamReader(System.in)); //            br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_10800_컬러볼/input.txt\")));             bw = new BufferedWriter(new OutputStreamWriter(System.out));              N = Integer.parseInt(br.readLine());             balls = new Ball[N];             res = new int[N];              for(int i = 0; i &lt; N; i++){                 st = new StringTokenizer(br.readLine());                 Ball ball = new Ball(i, Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));                 balls[i] = ball;             }              Arrays.sort(balls);              // color 1-based             int sum = 0;             colorSum = new int[N+1][2]; // j=0 : 이전사이즈까지 합, j=1 : 같은 사이즈 크기              int finalSize=0; // 바로전 공 사이즈(지금이랑 같거나 작음)             int sameSizeSum = 0; // 같은 크기 공들 사이즈 합              for(int i=0; i&lt;N; i++){                 Ball curr = balls[i];                  if(curr.S != finalSize){                     sum += sameSizeSum; // 지금이랑 같은 크기 공들 다 전체에 더해줌(이제 다음 크기로 고려)                      for(int c=1; c&lt;=N; c++){                         colorSum[c][0] += colorSum[c][1];                         colorSum[c][1] = 0;                     }                      finalSize = curr.S;                      // 다음 크기로 넘어감                     sameSizeSum = 0;                 }                  // 지금까지 합 - 같은색                 res[curr.idx] = sum - colorSum[curr.C][0];                  colorSum[curr.C][1] += curr.S;                 sameSizeSum += curr.S;             }              for (int i = 0; i &lt; N; i++) {                 sb.append(res[i] + \"\\n\");             }             System.out.println(sb.toString());             br.close();     } }  "
  },
  
  {
    "title": "PGMS_2023 Kakao_표 병합 (Java)",
    "url": "/posts/PGMS2023-Kakao%ED%91%9C-%EB%B3%91%ED%95%A9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-03-19 04:55:35 +0900",
    "content": "[level 3] 표 병합 - 150366  문제 링크  성능 요약  메모리: 78.3 MB, 시간: 21.13 ms  구분  코딩테스트 연습 &gt; 2023 KAKAO BLIND RECRUITMENT  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 03월 19일 04:54:15  문제 설명  당신은 표 편집 프로그램을 작성하고 있습니다.  표의 크기는 50 × 50으로 고정되어있고 초기에 모든 셀은 비어 있습니다.  각 셀은 문자열 값을 가질 수 있고, 다른 셀과 병합될 수 있습니다. 위에서 r번째, 왼쪽에서 c번째 위치를 (r, c)라고 표현할 때, 당신은 다음 명령어들에 대한 기능을 구현하려고 합니다.      \"UPDATE r c value\"   (r, c) 위치의 셀을 선택합니다. 선택한 셀의 값을 value로 바꿉니다.   \"UPDATE value1 value2\"   value1을 값으로 가지고 있는 모든 셀을 선택합니다. 선택한 셀의 값을 value2로 바꿉니다.   \"MERGE r1 c1 r2 c2\"   (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀을 선택하여 병합합니다. 선택한 두 위치의 셀이 같은 셀일 경우 무시합니다. 선택한 두 셀은 서로 인접하지 않을 수도 있습니다. 이 경우 (r1, c1) 위치의 셀과 (r2, c2) 위치의 셀만 영향을 받으며, 그 사이에 위치한 셀들은 영향을 받지 않습니다. 두 셀 중 한 셀이 값을 가지고 있을 경우 병합된 셀은 그 값을 가지게 됩니다. 두 셀 모두 값을 가지고 있을 경우 병합된 셀은 (r1, c1) 위치의 셀 값을 가지게 됩니다. 이후 (r1, c1) 와 (r2, c2) 중 어느 위치를 선택하여도 병합된 셀로 접근합니다.   \"UNMERGE r c\"   (r, c) 위치의 셀을 선택하여 해당 셀의 모든 병합을 해제합니다. 선택한 셀이 포함하고 있던 모든 셀은 프로그램 실행 초기의 상태로 돌아갑니다. 병합을 해제하기 전 셀이 값을 가지고 있었을 경우 (r, c) 위치의 셀이 그 값을 가지게 됩니다.   \"PRINT r c\"   (r, c) 위치의 셀을 선택하여 셀의 값을 출력합니다. 선택한 셀이 비어있을 경우 \"EMPTY\"를 출력합니다.    아래는 UPDATE 명령어를 실행하여 빈 셀에 값을 입력하는 예시입니다.            commands 효과            UPDATE 1 1 menu (1,1)에 \"menu\" 입력   UPDATE 1 2 category (1,2)에 \"category\" 입력   UPDATE 2 1 bibimbap (2,1)에 \"bibimbap\" 입력   UPDATE 2 2 korean (2,2)에 \"korean\" 입력   UPDATE 2 3 rice (2,3)에 \"rice\" 입력   UPDATE 3 1 ramyeon (3,1)에 \"ramyeon\" 입력   UPDATE 3 2 korean (3,2)에 \"korean\" 입력   UPDATE 3 3 noodle (3,3)에 \"noodle\" 입력   UPDATE 3 4 instant (3,4)에 \"instant\" 입력   UPDATE 4 1 pasta (4,1)에 \"pasta\" 입력   UPDATE 4 2 italian (4,2)에 \"italian\" 입력   UPDATE 4 3 noodle (4,3)에 \"noodle\" 입력          위 명령어를 실행하면 아래 그림과 같은 상태가 됩니다.    아래는 MERGE 명령어를 실행하여 셀을 병합하는 예시입니다.            commands 효과            MERGE 1 2 1 3 (1,2)와 (1,3) 병합   MERGE 1 3 1 4 (1,3)과 (1,4) 병합          위 명령어를 실행하면 아래와 같은 상태가 됩니다.    병합한 셀은 \"category\" 값을 가지게 되며 (1,2), (1,3), (1,4) 중 어느 위치를 선택하더라도 접근할 수 있습니다.    아래는 UPDATE 명령어를 실행하여 셀의 값을 변경하는 예시입니다.            commands 효과            UPDATE korean hansik \"korean\"을 \"hansik\"으로 변경   UPDATE 1 3 group (1,3) 위치의 셀 값을 \"group\"으로 변경          위 명령어를 실행하면 아래와 같은 상태가 됩니다.    아래는 UNMERGE 명령어를 실행하여 셀의 병합을 해제하는 예시입니다.           commands 효과            UNMERGE 1 4 셀 병합 해제 후 원래 값은 (1,4)가 가짐          위 명령어를 실행하면 아래와 같은 상태가 됩니다.    실행할 명령어들이 담긴 1차원 문자열 배열 commands가 매개변수로 주어집니다. commands의 명령어들을 순서대로 실행하였을 때, \"PRINT r c\" 명령어에 대한 실행결과를 순서대로 1차원 문자열 배열에 담아 return 하도록 solution 함수를 완성해주세요.    제한사항   1 ≤ commands의 길이 ≤ 1,000 commands의 각 원소는 아래 5가지 형태 중 하나입니다.   \"UPDATE r c value\"   r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다. value는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다.  \"UPDATE value1 value2\"   value1은 선택할 셀의 값, value2는 셀에 입력할 내용을 나타내며, 알파벳 소문자와 숫자로 구성된 길이 1~10 사이인 문자열입니다.  \"MERGE r1 c1 r2 c2\"   r1, c1, r2, c2는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.  \"UNMERGE r c\"   r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.  \"PRINT r c\"   r, c는 선택할 셀의 위치를 나타내며, 1~50 사이의 정수입니다.   commands는 1개 이상의 \"PRINT r c\" 명령어를 포함하고 있습니다.     입출력 예           commands result            [\"UPDATE 1 1 menu\", \"UPDATE 1 2 category\", \"UPDATE 2 1 bibimbap\", \"UPDATE 2 2 korean\", \"UPDATE 2 3 rice\", \"UPDATE 3 1 ramyeon\", \"UPDATE 3 2 korean\", \"UPDATE 3 3 noodle\", \"UPDATE 3 4 instant\", \"UPDATE 4 1 pasta\", \"UPDATE 4 2 italian\", \"UPDATE 4 3 noodle\", \"MERGE 1 2 1 3\", \"MERGE 1 3 1 4\", \"UPDATE korean hansik\", \"UPDATE 1 3 group\", \"UNMERGE 1 4\", \"PRINT 1 3\", \"PRINT 1 4\"] [\"EMPTY\", \"group\"]   [\"UPDATE 1 1 a\", \"UPDATE 1 2 b\", \"UPDATE 2 1 c\", \"UPDATE 2 2 d\", \"MERGE 1 1 1 2\", \"MERGE 2 2 2 1\", \"MERGE 2 1 1 1\", \"PRINT 1 1\", \"UNMERGE 2 2\", \"PRINT 1 1\"] [\"d\", \"EMPTY\"]            입출력 예 설명  입출력 예 #1   문제 예시와 같습니다. (1,3) 위치의 셀은 비어있고 (1,4) 위치의 셀 값은 \"group\"입니다. 따라서 [\"EMPTY\", \"group\"]을 return 해야 합니다.   입출력 예 #2   모든 UPDATE 명령어를 실행하면 아래와 같은 상태가 됩니다.      \"MERGE 1 1 1 2\" 명령어를 실행하면 아래와 같은 상태가 됩니다.      \"MERGE 2 2 2 1\" 명령어를 실행하면 아래와 같은 상태가 됩니다.      \"MERGE 2 1 1 1\" 명령어를 실행하면 아래와 같은 상태가 됩니다.      \"UNMERGE 2 2\" 명령어를 실행하면 아래와 같은 상태가 됩니다.        출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        코드   import java.util.*;  class Solution {     static int[] p;     static String[] values;     static Map&lt;Integer, List&lt;Integer&gt;&gt; cellList = new HashMap&lt;&gt;();     public String[] solution(String[] commands) {         p = new int[2500];         values = new String[2500];         List&lt;String&gt; res = new ArrayList&lt;&gt;();         for(int i=0; i&lt;2500; i++){             p[i] = i;         }                  for(int i=0; i&lt;2500; i++){             List&lt;Integer&gt; initialList = new ArrayList&lt;&gt;();             initialList.add(i);             cellList.put(i, initialList);         }                  for(String command : commands){             String[] line = command.split(\" \");             String type = line[0];             if(type.equals(\"UPDATE\")){                 // \"UPDATE r c value\"                 if(line.length == 4){                     int r = Integer.parseInt(line[1]) - 1;                     int c = Integer.parseInt(line[2]) - 1;                     String value = line[3];                                          int idx = r*50 + c;                     values[find(idx)] = value;                 }                                  // \"UPDATE value1 value2\"                 else{                     String value1 = line[1];                     String value2 = line[2];                                          for(int i=0; i&lt;2500; i++){                         if(i==find(i) &amp;&amp; value1.equals(values[i])){                             values[i] = value2;                         }                     }                 }             }             else if(type.equals(\"MERGE\")){                 int r1 = Integer.parseInt(line[1]) - 1;                 int c1 = Integer.parseInt(line[2]) - 1;                 int r2 = Integer.parseInt(line[3]) - 1;                 int c2 = Integer.parseInt(line[4]) - 1;                                  int idx1 = r1 * 50 + c1;                 int idx2 = r2 * 50 + c2;                 int p1 = find(idx1);                 int p2 = find(idx2);                                  // 이미 같음                 if(p1 == p2) continue;                                  // 각 셀 빈거 체크                 boolean is_p1_empty = false;                 if(values[p1] == null) is_p1_empty=true;                 boolean is_p2_empty = false;                 if(values[p2] == null) is_p2_empty=true;                                  // 둘 다 비었으면 바로합치기                 if(is_p1_empty &amp;&amp; is_p2_empty) union(idx1, idx2);                                  // p2로 병합 (p1 비었고 p2값있음)                 else if(is_p1_empty &amp;&amp; !is_p2_empty) union(idx2, idx1);                                      // 둘다 값있으면 r1 c1쪽                 else union(idx1, idx2);             }             else if(type.equals(\"UNMERGE\")){                 int r = Integer.parseInt(line[1]) - 1;                 int c = Integer.parseInt(line[2]) - 1;                 int idx = r * 50 + c;                 String value = values[find(idx)];                                  // null로 초기화하고 r, c만 값할당                 List&lt;Integer&gt; cells = new ArrayList&lt;&gt;(cellList.get(find(idx)));                 for(int cellIdx : cells){                     p[cellIdx] = cellIdx;                     values[cellIdx] = null;                                          List&lt;Integer&gt; initialCell = new ArrayList&lt;&gt;();                     initialCell.add(cellIdx);                     cellList.put(cellIdx, initialCell);                 }                                  values[idx] = value;                             }             else if(type.equals(\"PRINT\")){                 int r = Integer.parseInt(line[1]) - 1;                 int c = Integer.parseInt(line[2]) - 1;                 int idx = r * 50 + c;                 String value = values[find(idx)];                                  res.add(value == null ? \"EMPTY\" : value);             }         }         String[] ans = new String[res.size()];         for(int a=0; a&lt;ans.length; a++){             ans[a] = res.get(a);         }         return ans;     }          static int find(int x){         if(p[x] != x) return p[x] = find(p[x]);         return p[x];     }          static void union(int x, int y){ // x를 부모로 합치기         int px = find(x);         int py = find(y);                  if(px == py) return;                  p[py] = px;         values[py] = null;                  // 셀합치기         List&lt;Integer&gt; mergedCells = new ArrayList&lt;&gt;(cellList.get(px));         for(int i : cellList.get(py)){             mergedCells.add(i);         }         cellList.put(px, mergedCells);         cellList.put(py, mergedCells);     } }  "
  },
  
  {
    "title": "LeetCode_Ones and Zeroes",
    "url": "/posts/LeetCodeOnes-and-Zeroes/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-03-19 00:20:53 +0900",
    "content": "474. Ones and Zeroes Medium  You are given an array of binary strings strs and two integers m and n.  Return the size of the largest subset of strs such that there are at most m 0&#39;s and n 1&#39;s in the subset.  A set x is a subset of a set y if all elements of x are also elements of y.  &nbsp; Example 1:   Input: strs = [&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;], m = 5, n = 3 Output: 4 Explanation: The largest subset with at most 5 0&#39;s and 3 1&#39;s is {&quot;10&quot;, &quot;0001&quot;, &quot;1&quot;, &quot;0&quot;}, so the answer is 4. Other valid but smaller subsets include {&quot;0001&quot;, &quot;1&quot;} and {&quot;10&quot;, &quot;1&quot;, &quot;0&quot;}. {&quot;111001&quot;} is an invalid subset because it contains 4 1&#39;s, greater than the maximum of 3.   Example 2:   Input: strs = [&quot;10&quot;,&quot;0&quot;,&quot;1&quot;], m = 1, n = 1 Output: 2 Explanation: The largest subset is {&quot;0&quot;, &quot;1&quot;}, so the answer is 2.   &nbsp; Constraints:   \t1 &lt;= strs.length &lt;= 600 \t1 &lt;= strs[i].length &lt;= 100 \tstrs[i] consists only of digits &#39;0&#39; and &#39;1&#39;. \t1 &lt;= m, n &lt;= 100      문제 풀이        코드   class Solution {     public int findMaxForm(String[] strs, int m, int n) {         int len = strs.length;         int[][][] dp = new int[len+1][m+1][n+1];          for(int i=1; i&lt;=len; i++){             String s = strs[i-1];             int[] cnt = count(s);             int zeroCnt = cnt[0];             int oneCnt = cnt[1];              // 0-1 냅색             for(int j=0; j&lt;=m; j++){                 for(int k=0; k&lt;=n; k++){                     dp[i][j][k] = dp[i-1][j][k]; // 0-case - default                      if(j &gt;= zeroCnt &amp;&amp; k &gt;= oneCnt) dp[i][j][k] = Math.max(dp[i][j][k], dp[i-1][j-zeroCnt][k-oneCnt] + 1); // 1-case                 }             }         }          return dp[len][m][n];     }      private int[] count(String s){         int[] cnt = new int[2];         for(int i=0; i&lt;s.length(); i++){             if(s.charAt(i) == '0') cnt[0]++;             else cnt[1]++;         }         return cnt;     } }  "
  },
  
  {
    "title": "BOJ_1027_고층 건물 (Java)",
    "url": "/posts/BOJ1027%EA%B3%A0%EC%B8%B5-%EA%B1%B4%EB%AC%BC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-18 18:42:44 +0900",
    "content": "[Gold IV] 고층 건물 - 1027  문제 링크  성능 요약  메모리: 14220 KB, 시간: 104 ms  분류  브루트포스 알고리즘, 기하학, 수학  제출 일자  2025년 3월 18일 18:33:54  문제 설명  세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는데, 빌딩은 선분으로 나타낸다. i번째 빌딩 (1부터 시작)은 (i,0)부터 (i,높이)의 선분으로 나타낼 수 있다. 고층 빌딩 A에서 다른 고층 빌딩 B가 볼 수 있는 빌딩이 되려면, 두 지붕을 잇는 선분이 A와 B를 제외한 다른 고층 빌딩을 지나거나 접하지 않아야 한다. 가장 많은 고층 빌딩이 보이는 빌딩을 구하고, 거기서 보이는 빌딩의 수를 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 빌딩의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에 1번 빌딩부터 그 높이가 주어진다. 높이는 1,000,000,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 문제의 정답을 출력한다.     문제 풀이     좌우 건물들의 높이를 이용했다. 기울기의 증감이 일정하게 증가하느냐 감소하느냐를 보면된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, h[];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1027_고층건물/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         h = new int[N];         st = new StringTokenizer(br.readLine());         for(int i=0; i&lt;N; i++) {             h[i] = Integer.parseInt(st.nextToken());         }          int res = 0;         for(int i=0; i&lt;N; i++) {             int left = 0, right = 0;              if(i==0) right = countRight(0);             else if(i==N-1) left = countLeft(N-1);             else {                 left = countLeft(i);                 right = countRight(i);             }              if(res &lt; left + right) res = left + right;         }          System.out.println(res);         br.close();     }      private int countLeft(int idx) {         int cnt = 0;          double a = 1000000001; // 기울기         for(int i=idx-1; i&gt;=0; i--){             double new_a = (h[idx] - h[i]) / (double) (Math.abs(idx-i));             if(new_a &lt; a) {                 cnt++;                 a = new_a;             }          }         return cnt;     }      private int countRight(int idx) {         int cnt = 0;          double a = -1000000001;         for(int i=idx+1; i&lt;N; i++){             double new_a = (h[i] - h[idx]) / (double) (Math.abs(idx-i));             if(a &lt; new_a) {                 cnt++;                 a = new_a;             }         }         return cnt;     } }  "
  },
  
  {
    "title": "BOJ_20437_문자열 게임 2 (Java)",
    "url": "/posts/BOJ20437%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%8C%EC%9E%84-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-18 05:05:59 +0900",
    "content": "[Gold V] 문자열 게임 2 - 20437  문제 링크  성능 요약  메모리: 28544 KB, 시간: 296 ms  분류  슬라이딩 윈도우, 문자열  제출 일자  2025년 3월 18일 05:00:29  문제 설명  작년에 이어 새로운 문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.   \t알파벳 소문자로 이루어진 문자열 W가 주어진다. \t양의 정수 K가 주어진다. \t어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다. \t어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.   위와 같은 방식으로 게임을 T회 진행한다.  입력  문자열 게임의 수 T가 주어진다. (1 ≤ T ≤ 100)  다음 줄부터 2개의 줄 동안 문자열 W와 정수 K가 주어진다. (1 ≤ K ≤ |W| ≤ 10,000)   출력  T개의 줄 동안 문자열 게임의 3번과 4번에서 구한 연속 문자열의 길이를 공백을 사이에 두고 출력한다.  만약 만족하는 연속 문자열이 없을 시 -1을 출력한다.     문제 풀이     1번 답 구하기와 2번 답 구하기를 각각 나누어서 설명하겠다.  1. 가장 짧은 문자열: 투 포인터 (슬라이딩 윈도우) 방식     왼쪽(left)과 오른쪽(right) 포인터를 사용하여 윈도우를 조절   윈도우 내에서 각 문자의 발생 횟수를 계산   어떤 문자가 정확히 K번 등장하면 최소 길이를 갱신하고 윈도우를 축소   2. 가장 긴 문자열: Deque 활용     각 알파벳별로 Deque를 사용하여 최대 K개의 인덱스를 추적   모든 문자에 대해, 정확히 K개의 해당 문자를 포함하는 가장 긴 부분 문자열을 찾음   첫 번째와 마지막 글자가 같은 문자이므로, 자연스럽게 조건 충족됨      코드   package BOJ_20437_문자열게임;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int T, K;     static String W;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_20437_문자열게임/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  T = Integer.parseInt(br.readLine());         while (T-- &gt; 0) {             W = br.readLine();             K = Integer.parseInt(br.readLine());              // 문자열별 개수             int[] count = new int[26];             for(int i=0; i&lt;W.length(); i++) {                 count[W.charAt(i) - 'a']++;             }              // K개짜리 정답 존재             boolean flag = false;             for(int i=0; i&lt;26; i++) {                 if(count[i] &gt;= K) {                     flag = true;                     break;                 }             }              if(!flag){                 sb.append(\"-1\").append(\"\\n\");                 continue;             }              // 1번 답구하기             int minLen = Integer.MAX_VALUE;             int left=0, right = 0;             int[] charCount = new int[26];              while(right &lt; W.length()) {                 char curr = W.charAt(right);                 charCount[curr - 'a']++;                  while(charCount[curr - 'a'] &gt;= K) {                     if(charCount[curr - 'a'] == K) {                         minLen = Math.min(minLen, right-left+1);                     }                      charCount[W.charAt(left) - 'a']--;                     left++;                 }                  right++;             }              // 2번답 구하기             int maxLen = -1;             Deque&lt;Integer&gt;[] K_len = new ArrayDeque[26];             for(int i=0; i&lt;26; i++) {                 K_len[i] = new ArrayDeque&lt;&gt;();             }              for(int i=0; i&lt;W.length(); i++) {                 int curr = W.charAt(i)-'a';                 K_len[curr].add(i);                  if(K_len[curr].size() &gt; K){                     K_len[curr].pollFirst();                 }                  if(K_len[curr].size() == K){                     int first = K_len[curr].peekFirst();                     int last = K_len[curr].peekLast();                     maxLen = Math.max(maxLen, last - first + 1);                 }             }              if(minLen == Integer.MAX_VALUE) sb.append(\"-1\").append(\"\\n\");             else sb.append(minLen).append(\" \").append(maxLen).append(\"\\n\");         }           System.out.println(sb.toString());         br.close();     } }  "
  },
  
  {
    "title": "PGMS_이름에 el이 들어가는 동물 찾기 (SQL)",
    "url": "/posts/PGMS%EC%9D%B4%EB%A6%84%EC%97%90-el%EC%9D%B4-%EB%93%A4%EC%96%B4%EA%B0%80%EB%8A%94-%EB%8F%99%EB%AC%BC-%EC%B0%BE%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-03-17 21:55:11 +0900",
    "content": "[level 2] 이름에 el이 들어가는 동물 찾기 - 59047  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; String， Date  채점결과  Empty  제출 일자  2025년 03월 17일 21:54:36  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          보호소에 돌아가신 할머니가 기르던 개를 찾는 사람이 찾아왔습니다. 이 사람이 말하길 할머니가 기르던 개는 이름에 'el'이 들어간다고 합니다. 동물 보호소에 들어온 동물 이름 중, 이름에 \"EL\"이 들어가는 개의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 이름 순으로 조회해주세요. 단, 이름의 대소문자는 구분하지 않습니다.  예시  예를 들어 ANIMAL_INS 테이블이 다음과 같다면           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A355753 Dog 2015-09-10 13:14:00 Normal Elijah Neutered Male   A352872 Dog 2015-07-09 17:51:00 Aged Peanutbutter Neutered Male   A353259 Dog 2016-05-08 12:57:00 Injured Bj Neutered Male   A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female   A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male           이름에 'el'이 들어가는 동물은 Elijah, Ella, Maxwell 2입니다. 이 중, 개는 Elijah, Maxwell 2입니다.   따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.            ANIMAL_ID NAME            A355753 Elijah   A382192 Maxwell 2            본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        코드   SELECT ANIMAL_ID, NAME     FROM ANIMAL_INS         WHERE NAME LIKE '%el%'         AND ANIMAL_TYPE = 'Dog'             ORDER BY NAME;  "
  },
  
  {
    "title": "BOJ_15573_채굴 (Java)",
    "url": "/posts/BOJ15573%EC%B1%84%EA%B5%B4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-16 17:06:56 +0900",
    "content": "[Gold III] 채굴 - 15573  문제 링크  성능 요약  메모리: 314360 KB, 시간: 1664 ms  분류  너비 우선 탐색, 이분 탐색, 그래프 이론, 그래프 탐색, 매개 변수 탐색  제출 일자  2025년 3월 16일 16:59:34  문제 설명  땅 위에 놓여있는 세로 N, 가로 M 길이의 광산에 1 × 1 광물 N × M개가 있으며, 각 광물은 고유의 강도Si, j를 가진다.     채굴기를 이용하여 이 광물들을 채굴하려고 한다. 채굴기는 공기와 맞닿아 있는 광물 하나를 골라 채굴할 수 있다. 바닥과 광물과만 맞닿아 있으면 채굴할 수 없다. 채굴기의 성능 D에 대해, 채굴기는 강도가 D 이하인 광물들만 채굴할 수 있다. 원하는 광물의 수 K 이상을 채굴할 수 있는 최소의 D를 구하여라.  입력  첫째 줄에 N, M, K가 주어진다. (1 ≤ N, M ≤ 1000, 1 ≤ K ≤ N × M) 둘째 줄부터 맨 위의 광물들부터 순서대로 N줄 동안 M개의 광물의 강도 Si, j가 주어진다.(i = 1, 2, ..., N, j = 1, 2, ..., M) (1 ≤ Si, j ≤ 106)  출력  K개 이상의 광물을 채굴할 수 있는 최소의 D를 구하여라.     문제 풀이   간단한 bfs 문제다. 효율적으로 최소 D값을 찾기 위해 파라매트릭 서치를 사용했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, K;     static int [] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static int[][] board;     static boolean[][] visited;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15573_채굴/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());         board = new int[N][M];         visited = new boolean[N][M];          int maxD = 0;         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; M; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());                 if(board[i][j] &gt; maxD) maxD = board[i][j];             }         }          int left = 1, right = maxD;         int res = 0;         while(left &lt;= right) {             int mid = left + (right - left) / 2;              int count = countMines(mid);              if(count &gt;= K){                 res = mid;                 right = mid - 1;             }             else left = mid + 1;         }          System.out.println(res);         br.close();     }      private int countMines(int mid) {         visited = new boolean[N][M];         int cnt = 0;          for (int j = 0; j &lt; M; j++) {             if (!visited[0][j] &amp;&amp; board[0][j] &lt;= mid) {                 cnt += bfs(0, j, mid);             }         }          for (int i=1; i&lt;N; i++) {             if(!visited[i][0] &amp;&amp; board[i][0] &lt;= mid) cnt += bfs(i, 0, mid);         }          for (int i=1; i&lt;N; i++) {             if(!visited[i][M-1] &amp;&amp; board[i][M-1] &lt;= mid) cnt += bfs(i, M-1, mid);         }          return cnt;     }      private static int bfs(int r, int c, int D){         Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();         queue.offer(new int[]{r, c});         visited[r][c] = true;         int cnt = 1;          while(!queue.isEmpty()){             int[] curr = queue.poll();              for (int k=0; k &lt; 4; k++){                 int nextR = curr[0] + dr[k];                 int nextC = curr[1] + dc[k];                  if(isValid(nextR, nextC) &amp;&amp; !visited[nextR][nextC]){                     if(board[nextR][nextC] &lt;= D){                         queue.offer(new int[]{nextR, nextC});                         visited[nextR][nextC] = true;                         cnt++;                     }                 }             }         }          return cnt;     }      private static boolean isValid(int nr, int nc) {         return nr &gt;= 0 &amp;&amp; nr &lt; N &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; M;     } }  "
  },
  
  {
    "title": "BOJ_12886_돌 그룹 (Java)",
    "url": "/posts/BOJ12886%EB%8F%8C-%EA%B7%B8%EB%A3%B9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-14 15:36:17 +0900",
    "content": "[Gold IV] 돌 그룹 - 12886  문제 링크  성능 요약  메모리: 69936 KB, 시간: 260 ms  분류  너비 우선 탐색, 그래프 이론, 그래프 탐색  제출 일자  2025년 3월 14일 15:33:01  문제 설명  오늘 강호는 돌을 이용해 재미있는 게임을 하려고 한다. 먼저, 돌은 세 개의 그룹으로 나누어져 있으며 각각의 그룹에는 돌이 A, B, C개가 있다. 강호는 모든 그룹에 있는 돌의 개수를 같게 만들려고 한다.  강호는 돌을 단계별로 움직이며, 각 단계는 다음과 같이 이루어져 있다.  크기가 같지 않은 두 그룹을 고른다. 그 다음, 돌의 개수가 작은 쪽을 X, 큰 쪽을 Y라고 정한다. 그 다음, X에 있는 돌의 개수를 X+X개로, Y에 있는 돌의 개수를 Y-X개로 만든다.  A, B, C가 주어졌을 때, 강호가 돌을 같은 개수로 만들 수 있으면 1을, 아니면 0을 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 A, B, C가 주어진다. (1 ≤ A, B, C ≤ 500)  출력  돌을 같은 개수로 만들 수 있으면 1을, 아니면 0을 출력한다.     문제 풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_12886_돌그룹/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         int A = Integer.parseInt(st.nextToken());         int B = Integer.parseInt(st.nextToken());         int C = Integer.parseInt(st.nextToken());          boolean isAble = bfs(A, B, C);         System.out.println(isAble ? \"1\" : \"0\");         bw.flush();         bw.close();         br.close();     }      private boolean bfs(int A, int B, int C) {         int totalW = A + B + C;         if (totalW % 3 != 0) return false;         if (A == B &amp;&amp; B == C) return true;          int[] arr = new int[]{A, B, C};         Arrays.sort(arr);          boolean[][] visited = new boolean[totalW + 1][totalW + 1];         Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();         visited[arr[0]][arr[1]] = true;         queue.offer(new int[]{arr[0], arr[1], arr[2]});          while (!queue.isEmpty()) {             int[] curr = queue.poll();             int a = curr[0];             int b = curr[1];             int c = curr[2];              List&lt;int[]&gt; list = new ArrayList&lt;&gt;();             list.add(new int[]{a, b, totalW - a - b});             list.add(new int[]{b, c, totalW - b - c});             list.add(new int[]{c, a, totalW - c - a});              for (int[] l : list) {                 int x = l[0];                 int y = l[1];                 if (x == y) continue;                  int nx, ny;                 if (x &lt; y) {                     nx = x + x;                     ny = y - x;                 } else {                     nx = x - y;                     ny = y + y;                 }                  int next[] = {nx, ny, totalW - nx - ny};                 Arrays.sort(next);                 if (!visited[next[0]][next[1]]) {                     if (next[0] == next[1] &amp;&amp; next[1] == next[2]) return true;                      visited[next[0]][next[1]] = true;                     queue.offer(new int[]{next[0], next[1], next[2]});                 }             }         }         return false;     } }  "
  },
  
  {
    "title": "BOJ_14232_보석 도둑 (Java)",
    "url": "/posts/BOJ14232%EB%B3%B4%EC%84%9D-%EB%8F%84%EB%91%91-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-14 15:06:13 +0900",
    "content": "[Silver I] 보석 도둑 - 14232  문제 링크  성능 요약  메모리: 14368 KB, 시간: 116 ms  분류  수학, 정수론, 소수 판정, 에라토스테네스의 체  제출 일자  2025년 3월 14일 15:03:12  문제 설명  희대의 도둑 효빈이는 세계 최고의 보석가게 영선상에 잠입할 계획이다. 이 영선상은 최고의 보석가게답게 최고의 보안장치를 두고 있는데, 이 보안장치를 해제하지 않는다면 보석을 여러 개 훔쳐갈 시, 보석끼리 달라붙으며 무게가 모든 보석들의 곱으로 늘어난다.  효빈이는 이 보안장치를 해제할 수 없기 때문에, 차라리 곱해진 대로 최대한 많은 보석들을 가져오기로 계획했다. 효빈이는 한번에 k라는 무게를 들 수 있으므로, 딱 k만큼의 무게만큼의 보석을 가져오고 싶은데, 그 때 보석들의 최대 개수를 알고싶다.  영선상에는 세계 최고의 보석가게답게 모든 무게의 보석들이 매우 많이때문에, 훔쳐가는 보석이 부족할 일은 없다. 다만 모든 보석들은 무게가 1보다 크다.  효빈이는 이제 영선상에 잡입할 계획을 다 세웠다. 하지만 무슨 보석들을 훔쳐올지 결정하지 못하였는데, 효빈이를 대신하여 훔쳐올 보석들을 결정해주자.  입력  첫째 줄에는 효빈이가 들 수 있는 무게 k가 주어진다.(2≤k≤1012)  출력  첫째 줄에는 효빈이가 훔쳐올 보석의 개수를 출력하고, 다음 줄에는 훔쳐올 보석들의 무게를 오름차순으로 출력하시오.     문제 풀이     무조건 K만큼 들어야하므로 나눗셈을 적용했다. 나눌 수 없는수는 소수이므로 소수로 계속 나누어주었다.     코드   package BOJ_14232_보석도둑;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static long K;     static List&lt;Long&gt; elements = new ArrayList&lt;&gt;();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14232_보석도둑/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          K = Long.parseLong(br.readLine());          long cnt = 0;         long num = K;          for (long i = 2; i * i &lt;= num; i++) {             while (num % i == 0) {                 elements.add(i);                 num /= i;                 cnt++;             }         }          if (num &gt; 1) {             elements.add(num);             cnt++;         }          Collections.sort(elements);          sb.append(cnt).append(\"\\n\");         for (int i = 0; i &lt; elements.size(); i++) {             sb.append(elements.get(i)).append(\" \");         }         System.out.println(sb.toString());         br.close();     } }  "
  },
  
  {
    "title": "BOJ_14225_부분수열의 합 (Java)",
    "url": "/posts/BOJ14225%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-13 15:25:23 +0900",
    "content": "[Silver I] 부분수열의 합 - 14225  문제 링크  ### 성능 요약  메모리: 16396 KB, 시간: 124 ms  ### 분류  브루트포스 알고리즘  ### 제출 일자  2025년 3월 13일 15:23:25  ### 문제 설명  수열 S가 주어졌을 때, 수열 S의 부분 수열의 합으로 나올 수 없는 가장 작은 자연수를 구하는 프로그램을 작성하시오.  예를 들어, S = [5, 1, 2]인 경우에 1, 2, 3(=1+2), 5, 6(=1+5), 7(=2+5), 8(=1+2+5)을 만들 수 있다. 하지만, 4는 만들 수 없기 때문에 정답은 4이다.  입력  첫째 줄에 수열 S의 크기 N이 주어진다. (1 ≤ N ≤ 20)  둘째 줄에는 수열 S가 주어진다. S를 이루고있는 수는 100,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 수열 S의 부분 수열의 합으로 나올 수 없는 가장 작은 자연수를 출력한다.     문제 풀이        코드    /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, S[];     static boolean[] visited, isNum;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14225_부분수열의합/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         S = new int[N];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             S[i] = Integer.parseInt(st.nextToken());         }          visited = new boolean[N];         isNum = new boolean[100000*20 + 1];          dfs(0, 0);         for(int i = 0; i &lt; isNum.length; i++) {             if(!isNum[i]) {                 System.out.println(i);                 break;             }         }         br.close();     }      private void dfs(int depth, int sum) {         if(depth == N){             isNum[sum] = true;             return;         }          dfs(depth + 1, sum + S[depth]);         dfs(depth + 1, sum);     }   }  "
  },
  
  {
    "title": "BOJ_2835_인기도 조사 (Java)",
    "url": "/posts/BOJ2835%EC%9D%B8%EA%B8%B0%EB%8F%84-%EC%A1%B0%EC%82%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-11 03:38:37 +0900",
    "content": "[Gold III] 인기도 조사 - 2835  문제 링크  성능 요약  메모리: 204196 KB, 시간: 1884 ms  분류  자료 구조, 느리게 갱신되는 세그먼트 트리, 누적 합, 세그먼트 트리  제출 일자  2025년 3월 10일 23:26:53  문제 설명  최근에 상근이가 살고 있는 나라에서는 인구 조사가 있었다. 사실 이번 인구 조사의 진짜 이유는 바로 텔레비전 인기도 조사이다.  각 사람이 텔레비전을 시청한 시간은 아래와 같은 형식이다.  HH:MM:SS - HH:NN:SS  앞 시간은 그 사람이 텔레비전을 시청하기 시작한 시간이며, 다음 시간은 시청을 마친 시간이다. 사람들은 그 구간의 가장 처음과 마지막 초에도 텔레비전을 시청한다. 만약, 어떤 사람이 자정이 넘기 전(23:45:30) 에 텔레비전을 시작했다면, 다음날 텔레비전 시청을 종료한다. (01:15:00)  모든 데이터를 수집했고, 이제 이 데이터를 분석하려고 한다.  어떤 초의 인기도는 그 초에 티비를 보고 있던 사람의 수로 나타낼 수 있다. 또, 구간의 인기도는 구간에 포함되는 초의 인기도의 합을 그 구간의 길이로 나눈 값이다.  Q개의 구간이 주어졌을 때, 그 구간의 인기도를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 상근이가 살고 있는 나라의 국민의 수 N이 주어진다. (N ≤ 100,000)  다음 N개 줄에는 각 사람이 티비를 시청한 구간이 문제에서 설명한 대로 주어진다. (0 ≤ HH ≤ 23, 0 ≤ MM ≤ 59, 0 ≤ SS ≤ 59)  다음 줄에는 인기도를 조사하려고 하는 구간의 수 Q가 주어진다. (Q ≤ 100,000)  다음 Q개 줄에는 인기도를 구하려고 하는 구간이 같은 형식으로 주어진다.  출력  총 Q개의 구간에 대해서 각 구간의 인기도를 출력한다. 정답과의 오차는 최대 10-6까지 허용한다.     문제 풀이        코드   누적합 풀이  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, Q;     static final int END = 60*60*24;     static int[] prefixSum;     static long[] time;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2835_인기도조사/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         prefixSum = new int[24 * 60 * 60 + 1];         for (int i = 0; i &lt; N; i++) {             String line = br.readLine();             st = new StringTokenizer(line, \" :-\");             int start = calTime(st);             int end = calTime(st);              if(start &lt;= end){                 prefixSum[start]++;                 prefixSum[end+1]--;             }             else{                 prefixSum[start]++;                 prefixSum[END]--;                 prefixSum[0]++;                 prefixSum[end+1]--;             }         }         for (int i = 1; i &lt;= END; i++) {             prefixSum[i] += prefixSum[i-1];         }          time = new long[END];         for (int i = 0; i &lt; END; i++) {             if(i==0) time[0] = prefixSum[0];             else time[i] = time[i-1] + prefixSum[i];         }          Q = Integer.parseInt(br.readLine());         while(Q--&gt;0){             String line = br.readLine();             st = new StringTokenizer(line, \" :-\");             int start = calTime(st);             int end = calTime(st);              double avg = 0;              if(start &lt;= end){                 if(start != 0) avg = (double) (time[end] - time[start - 1]) / (end+1-start);                 else avg = (double) time[end] / (end+1-start);             }             else{                 avg = (double) ((time[END - 1] - time[start - 1]) + time[end]) / ((END-start) + (end+1));             }             sb.append(String.format(\"%.10f\", avg)).append(\"\\n\");         }          System.out.println(sb.toString());         bw.flush();         bw.close();         br.close();     }      private int calTime(StringTokenizer st){         return 3600 * Integer.parseInt(st.nextToken()) + 60 * Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken());     } }     세그먼트트리 + Lazy Propagation 풀이  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static final int SIZE = 24 * 60 * 60;     static int N, Q;     static long[] tree;     static long[] lazy;     static long total = 0; // 모든 인기도의 합     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2835_인기도조사/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  int h = (int) Math.ceil(Math.log(SIZE) / Math.log(2));         int treeSize = 1 &lt;&lt; (h+1);         tree = new long[treeSize];         lazy = new long[treeSize];          N = Integer.parseInt(br.readLine());         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine(), \" :-\");             int start = calTime(st);             int end = calTime(st);              if(start &lt;= end){                 update(1, start, end, 0, SIZE-1);                 total += end+1 - start;             }             else{                 update(1, start, SIZE-1, 0, SIZE-1);                 update(1, 0, end, 0, SIZE-1);                 total += SIZE-start + end+1;             }         }          Q = Integer.parseInt(br.readLine());         while(Q--&gt;0){             st = new StringTokenizer(br.readLine(), \" :-\");             int start = calTime(st);             int end = calTime(st);              if(start &lt;= end){                 long sum = query(1, start, end, 0, SIZE-1);                 double res = (double)sum / (end+1 - start);                 sb.append(String.format(\"%.10f\", res)).append(\"\\n\");             }             else{ // end+1 부터 start-1을 제외시키기                 long sum = total - query(1, end+1, start-1, 0, SIZE-1);                 double res = (double)sum / (SIZE - (start-(end+1)));                 sb.append(String.format(\"%.10f\", res)).append(\"\\n\");             }         }         System.out.println(sb.toString());         bw.flush();         bw.close();         br.close();     }      /**      *      * @param node : 현재노드      * @param start : 업데이트할 구간 시작점      * @param end : 업데이트할 구간 끝점      * @param from : 노드가 담당하는 구간 시작점      * @param to : 노드가 담당하는 구간 끝점      */     private void update(int node, int start, int end, int from, int to) {         updateLazy(node, from, to);          if(to &lt; start || end &lt; from) return;          // 업데이트할 구간이 지금노드범위 완전 포함하면         if(start &lt;= from &amp;&amp; to &lt;= end){             tree[node] += (to+1 - from); // 구간만큼 인기도 1씩 증가              // 구간이 있으면 더 아래로 자식한테 lazy전파             if(from != to){                 lazy[node*2] += 1;                 lazy[node*2+1] += 1;             }             return;         }          int mid = from + (to - from) / 2;         update(node*2, start, end, from, mid);         update(node*2+1, start, end, mid+1, to);         tree[node] = tree[node*2] + tree[node*2+1];     }      /**      *      * @param node : 현재노드      * @param start : 업데이트할 구간 시작점      * @param end : 업데이트할 구간 끝점      * @param from : 노드가 담당하는 구간 시작점      * @param to : 노드가 담당하는 구간 끝점      * @return : 구간 값      */     private long query(int node, int start, int end, int from, int to){         updateLazy(node, from, to);          if(end &lt; from || to &lt; start) return 0;          if(start &lt;= from &amp;&amp; to &lt;= end) return tree[node];          int mid = from + (to - from) / 2;         return query(node*2, start, end, from, mid) + query(node*2+1, start, end, mid+1, to);     }      // 현재 노드의 lazy 값 반영     private static void updateLazy(int node, int from, int to) {         if(lazy[node] != 0) {             tree[node] += (to+1 - from) * lazy[node];             if(from != to){                 lazy[node*2] += lazy[node];                 lazy[node*2+1] += lazy[node];             }             lazy[node] = 0;         }     }      private int calTime(StringTokenizer st){         return 3600 * Integer.parseInt(st.nextToken()) + 60 * Integer.parseInt(st.nextToken()) + Integer.parseInt(st.nextToken());     } }  "
  },
  
  {
    "title": "BOJ_1826_연료 채우기 (Java)",
    "url": "/posts/BOJ1826%EC%97%B0%EB%A3%8C-%EC%B1%84%EC%9A%B0%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-10 21:06:43 +0900",
    "content": "[Gold II] 연료 채우기 - 1826  문제 링크  성능 요약  메모리: 20244 KB, 시간: 232 ms  분류  자료 구조, 그리디 알고리즘, 우선순위 큐, 정렬  제출 일자  2025년 3월 10일 20:56:48  문제 설명  성경이는 트럭을 정글 속에서 운전하다가 트럭의 연료탱크에 갑자기 구멍이 나서 1km를 가는데 1L의 연료가 새 나가게 되었다. 이것을 고치기 위해서는 가장 가까운 마을에 가야 한다. 그런데 그냥 가다가는 중간에 연료가 다 빠질 수가 있다. 다행스럽게도 정글 곳곳에 연료를 채울 수 있는 주유소가 N개 있다. 그런데 정글 속에서 중간에 차를 멈추는 행위는 매우 위험한 행위이므로 주유소에서 멈추는 횟수를 최소화 하려 한다.  그리고 다행이도 성경이의 트럭은 매우 좋아서 연료 탱크에는 연료의 제한이 없이 많이 충분히 많이 넣을 수 있다고 한다. 각각의 주유소의 위치와, 각 주유소에서 얻을 수 있는 연료의 양이 주어져 있을 때, 주유소에서 멈추는 횟수를 구하는 프로그램을 작성하시오.  정글은 일직선이고, 성경이의 트럭과 주유소도 모두 일직선 위에 있다. 주유소는 모두 성경이의 트럭을 기준으로 오른쪽에 있다.  입력  첫째 줄에 주유소의 개수 N(1 ≤ N ≤ 10,000)가 주어지고 두 번째 줄부터 N+1번째 줄 까지 주유소의 정보가 주어진다. 주유소의 정보는 두개의 정수 a,b로 이루어 져 있는데 a(1 ≤ a ≤ 1,000,000)는 성경이의 시작 위치에서 주유소 까지의 거리, 그리고 b(1 ≤ b ≤ 100)는 그 주유소에서 채울 수 있는 연료의 양을 의미한다. 그리고 N+2번째 줄에는 두 정수 L과 P가 주어지는데 L(1 ≤ L ≤ 1,000,000)은 성경이의 위치에서 마을까지의 거리, P(1 ≤ P ≤ 1,000,000)는 트럭에 원래 있던 연료의 양을 의미한다.  모든 주유소와 마을은 서로 다른 좌표에 있고, 마을은 모든 주유소보다 오른쪽에 있다.  출력  첫째 줄에 주유소에서 멈추는 횟수를 출력한다. 만약 마을에 도착하지 못할경우 -1을 출력한다.     문제 풀이        현재 위치에서 갈 수 있는 모든 주유소 중에서 가장 많은 연료를 제공하는 곳을 선택   우선순위 큐를 사용하여 방문 가능한 주유소 중 가장 연료가 많은곳 찾기   currPos 사용안해도됨      문제 풀이   package BOJ_1826_연료채우기;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Station implements Comparable&lt;Station&gt;{         int pos, gas;         public Station(int pos, int gas){             this.pos = pos;             this.gas = gas;         }          @Override         public int compareTo(Station o){             return this.pos - o.pos;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, L, P, res;     static Station[] stations;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1826_연료채우기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         stations = new Station[N];         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             stations[i] = new Station(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken()));         }          Arrays.sort(stations);         st = new StringTokenizer(br.readLine());         L = Integer.parseInt(st.nextToken());         P = Integer.parseInt(st.nextToken());          if (P &gt;= L) {             System.out.println(0);             return;         }          PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder());         int currPos = 0;         int currGas = P;         boolean isFinished = false;         int idx = 0;          while(!isFinished) {             while(idx &lt; N &amp;&amp; stations[idx].pos &lt;= currPos + currGas) {                 pq.offer(stations[idx].gas);                 idx++;             }              if (pq.isEmpty()) {                 res = -1;                 break;             }              currGas += pq.poll();             res++;              if(currPos + currGas &gt;= L) isFinished = true;         }          System.out.println(res);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (10)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-10/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-03-10 05:13:10 +0900",
    "content": "   Network Layer - (1)      복습   UDP : User Datagram Protocol  DNS 서버에게 IP 주소를 요청할 때 UDP를 사용하는 이유? DNS는 신뢰성보다 속도가 더 중요하고, 많은 클라이언트를 수용하는 것을 필요로 한다. 따라서 속도가 빠르고, 연결 상태를 유지하지 않고 정보 기록을 최소화하여 많은 클라이언트 수용이 가능한 UDP를 사용한다.   Principle of Reliable Data Transfer   RDT에서 2가지 안좋은 현상 가능                패킷 에러                       패킷 loss           1. 패킷 에러 처리하려면    에러 발생했는지 탐지 detection   탐지되었으면 다시 보내는사람한테 feedback으로 알리기   재전송 retransmission   재전송하기때문에 그걸 구분하기위한 Seq#   2. 패킷 Loss 처리하려면    타임아웃 Timeout 될때까지 피드백 오지않으면 유실이라 판단하고 재전송    Pipelined Protocols  현실적으로 인터넷에서 사용하려면 feedback을 받지 않은 상황에서도 한꺼번에 패킷을 배치처리해서 쏟아부어야한다. -&gt; Pipeline 방식  Pipeline 방식으로 Reliable Data Transfer 구현하는 방법    go-Back-N   selective repeat   Go-Back-N     장점 : 동작이 단순하다. Receiver 저장공간 필요없고 Seq# 트래킹해서 저장할필요 X. Sender도 타이머가 1개밖에없다.   단점 : 오버헤드가 크다. 하나라도 유실되면 Window 안에있는 모든 패킷 다 재전송   Selective Repeat    장점 : 유실된 패킷만 재전송   단점 : 구현 복잡. Receiver 더 지능적이고 저장공간 많아야한다. Sender 더 복잡. 모든 윈도우 안에있는 패킷마다 타이머를 가져야한다.    TCP      포인트 to 포인트, 즉 딱 2개의 소켓   reliable하고 in-order 순서있는 스트림   파이프라인 방식   양쪽에 각각 버퍼가 2개씩있다. send버퍼/receive버퍼 양쪽에 각각있다.   TCP Segment Structure  TCP Seq# 와 ACKs     ACK : cumulative ACK. 사용자A가 보내는 ACK 80 은 79까지 잘 받았고 80번 기다리고 있다는 뜻.   A는 요청하는거 번호 쏘고 B는 요청한거 주면서 Seq는 요청했던거 주면서 그대로 번호 주고 ACK는 다음꺼 보낸다.  TCP Cumulative ACK  TCP는 패킷 유실에 대처하기위해 Timer 사용. 실제로 timeout 터지면 패킷유실이라고 판단. timeout길이 생각보다 길다.  RTT보존값 구한다음 이 값에 마진의 4배해서 매우 넉넉하게 잡아놓는다. 이 계산식은 이전 게시물 참고.  =&gt; 너무 오래 걸린다. 빨리 판단해보자 -&gt; Fast Retransmit  Fast Retransmit    같은 Seq#에 해당하는 ACK를 여러개 받으면 패킷유실이라고 판단!            TCP ACK는 누적이기때문에 중간에 하나 유실된 이후 가는 모든 ACK는 다 유실된 패킷의 Seq#를 가리키기 때문이다.           1개 받고 그 뒤에 3개 추가로 와서 총 4개의 같은 번호 ACK 받으면 유실이라 판단   TCP Retransmission   TCP Congestion Control    3개의 메인 Phase 반복됨 1. Slow Start 2. Additive increase :  3. Multiplicative decrease :       Chapter 4. Network Layer  우리는 애플리케이션레이어에서 HTTP, 전송레이어에서 UDP, TCP를 통해 데이터를 주고받을때 어떤내용을 써야하고 어떤 정보를 적어주어야하는지 공부했다. 그럼 이것을 어떻게 TCP 세그먼트를 어떤 경로로 목적지까지 잘 배송시킬지를 생각해봐야한다.  이를 담당하는것은 IP 인터넷 프로토콜 하나뿐이다. TCP세그먼트가 IP패킷에 담겨지면 라우터는 그 패킷을 받아서 알맞은 경로로 목적지까지 배송해준다.     Router  네트워크 레이어 = “배송담당” 이기때문에 중간에 라우터들은 구현을 네트워크 레이어까지만 하면 된다. 어디로 전달할지만 정해주면 되기 때문이다.  라우터의 역할 2가지    Forwarding : 포워딩 테이블을 보고 어떤 라우터가 다음인지 보고 그 엔트리에 해당하는 라우터로 넘김   Routing: 목적지를 적어놓는 포워딩 테이블을 만들어주는 일    라우터가 너무 많은데 포워딩 테이블 길어지는 것 아닐까?  주소의 범위로 적어놓는다. ex) A부터 B까지 범위는 K로 나가라. 서울, 대전, 부산 이렇게 범위로.  예시  Longest Prefix Matching  DA 1번은 0번과 매칭됨. DA 2번은 2번, 3번 인터페이스와 매칭됨 이런경우 더 구체적으로 일치하는 긴 케이스인 2번과 매칭됨.  우체국이라 생각하면됨.  "
  },
  
  {
    "title": "SQL vs NoSQL",
    "url": "/posts/SQL-vs-NoSQL/",
    "categories": "공부",
    "tags": "백엔드",
    "date": "2025-03-10 03:21:34 +0900",
    "content": "관계형 데이터베이스 관계형 데이터베이스는 고정된 row와 column으로 구성된 테이블에 데이터를 저장한다. 그리고 SQL을 사용하여 여러 테이블에 존재하는 데이터와 관계에 따라서 조인하여 합칠 수 있다. 관계형 데이터베이스는 데이터를 중복 없이 한번만 저장하고, 데이터 무결성을 보장한다. 관계형 데이터베이스의 경우 일반적으로 스케일 업을 사용하여 확장한다. 관계형 데이터베이스는 스키마를 유연하게 바꾸기 어렵다는 한계가 존재한다. 또한, 관계가 존재하기 때문에 비즈니스 요구사항이 더욱 발전하면 복잡한 쿼리가 생기게 된다.  비 관계형 데이터베이스 NoSQL이라고도 불리는 비 관계형 데이터베이스는 정해진 스키마가 존재하지 않으며 자유롭게 데이터를 저장하고 조회할 수 있다. 문서, 키-밸류, 와이드 컬럼, 그래프 유형이 존재한다. 대량의 데이터와 높은 사용자 부하에서도 손쉽게 확장할 수 있다. 반면 중복을 허용하는 NoSQL의 경우 데이터의 일관성이 저하되며 용량이 증가한다는 단점이 있다.  사용시 고려사항 데이터가 구조화되어있고, 자주 변경되지 않으며, 트랜잭션과 복잡한 쿼리, 그리고 데이터 무결성과 일관성이 중요한 경우 관계형 데이터베이스를 선택할 수 있다. 트랜잭션이 필요한 서버 애플리케이션을 개발하는 경우가 대표적인 예시다.  반면, 아주 낮은 응답 지연시간이 요구되거나 다루는 데이터의 스키마가 빈번히 변경되거나, 아주 많은 양의 데이터를 저장해야 하는 상황에서는 비 관계형 데이터베이스를 고려할 수 있다. "
  },
  
  {
    "title": "HTTP/1.1 vs HTTP/2.0",
    "url": "/posts/HTTP1.1-vs-HTTP2.0/",
    "categories": "공부",
    "tags": "백엔드",
    "date": "2025-03-10 03:13:59 +0900",
    "content": "HTTP/1.1 HTTP는 웹상에서 클라이언트와 서버간의 통신을 위한 프로토콜이다. HTTP/1.0의 경우 한개의 요청과 응답마다 TCP 커넥션을 생성하여 사용되었다. 하지만 이러한 요청은 매 요청마다 연결을 생성하는 오버헤드가 발생한다. HTTP/1.1은 이러한 문제를 지속 커넥션 (Persistent Connection) 이라는 지정한 타임아웃만큼 커넥션을 종료하지 않는 방식으로 해결한다.  또한 Pipelining(파이프라이닝)을 지원하여 요청의 응답 지연을 감소한다. 파이프라이닝에서 HTTP요청은 연속적이며, 순차적으로 전달된다. 기존에는 요청한 이후에 응답을 기다리고 그 다음 요청을 보냈지만, 파이프라이닝에선 필요한 모든 자원에 대한 요청을 순차적으로 서버로 전송한 다음 모든 요청에 대한 응답을 한 번에 기다린다.  HTTP/1.1은 1.0버전에 비해 상당히 개선되었지만 여전히 문제가 존재했다. 대표적으로 Head-of-Line Blocking(HOL Blocking) 문제가 있다.  만약 3개의 요청을 파이프라인을 통해 전송을 한다고 했을때, 서버는 모든 요청을 순서에 맞춰서 응답해야한다. 이때 첫번째 요청이 오래 걸린다면, 나머지 요청은 첫번째 요청의 처리를 기다려야한다. 또한 1.1버전은 매 요청마다 동일한 헤더를 반복하여 전송한다는 문제점도 존재한다.  HTTP/2.0 HTTP/1.1은 메시지를 일반 텍스트 형식으로 전송했다. 2.0부터는 기존 HTTP메시지를 프레임이라는 단위로 분할하고 이를 바이너리 형태로 만들어서 전송한다. 따라서, 기존 1.1버전에 비해 파싱 및 전송 속도가 향상되었다.  또한, HTTP/2.0부터는 Multiplexing(멀티플렉싱)을 지원한다. 이는 하나의 커넥션을 사용하여 요청과 응답을 병렬로 처리할 수 있는 방식이다. 클라이언트가 서버로 여러 요청을 동시에 보내도 각 요청이 독립적으로 처리되기 때문에 애플리케이션 레이어의 HOL Blocking 문제를 해결한다. 또한 HPACK 헤더 압축 방식을 사용해 반복되는 헤더를 효율적으로 관리하여 대역폭 사용이 최적화되었다.    References    HTTP/2 For Web Developers  "
  },
  
  {
    "title": "프로세스보다 쓰레드의 컨텍스트 스위칭이 빠른 이유",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%B3%B4%EB%8B%A4-%EC%93%B0%EB%A0%88%EB%93%9C%EC%9D%98-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%AD%EC%9D%B4-%EB%B9%A0%EB%A5%B8-%EC%9D%B4%EC%9C%A0/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-03-09 05:47:54 +0900",
    "content": "Context Switching 컨텍스트 스위칭은 CPU나 코어에서 실행중이던 프로세스나 쓰레드가 다른 프로세스나 쓰레드로 교체되는 과정이다. 이는 멀티태스킹 시스템에서 여러 작업을 효율적으로 관리하기 위해 필수적인 메커니즘이다.  Context 컨텍스트는 프로세스나 쓰레드의 현재 상태를 의미한다. 여기에는 CPU의 레지스터 상태(프로그램 카운터, 스택 포인터 등)와 메모리 상태가 포함된다. 컨텍스트는 프로세스나 쓰레드가 실행을 중단하고 나중에 다시 시작할 때 필요한 모든 정보를 담고있다.  Context Switching이 필요한 이유 멀티태스킹 시스템에서는 여러 프로세스나 쓰레드가 동시에 실행되는 것처럼 보이도록 CPU가 짧은 시간 단위로 작업을 전환하며 여러 작업을 처리한다. 이를 통해 사용자에게는 여러 작업이 동시에 진행되는 것처럼 인식되며, 시스템 자원을 효율적으로 활용할 수 있다.  Context Switching이 발생하는 시점                Time Slice(Quantum)를 다 사용했을 때       각 프로세스나 쓰레드에 할당된 CPU시간이 다 소진되면 스위칭 발생                       I/O 작업이 필요할 때       프로세스나 쓰레드가 I/O 작업을 수행해야 할 경우, CPU는 다른 작업을 처리하기 위해 현재 작업을 중단하고 스위칭을 수행                       우선순위 변경       더 높은 우선순위의 작업이 발생하면 현재 작업을 중단하고 우선순위가 높은 작업으로 전환할 수 있다.           Context Switching을 수행하는 주체 컨텍스트 스위칭은 운영체제의 커널(kernel)에 의해 수행된다. 커널은 시스템 자원을 관리하고 프로세스 및 쓰레드의 상태를 조정하여 효율적인 작업 처리를 담당한다.  Context Switching의 구체적인 과정 Process Context Switching (다른 프로세스에 속한 쓰레드 간의 컨텍스    현재 프로세스의 상태 저장 : 실행중인 프로세스의 레지스터 상태와 메모리 정보 저장   다음 프로세스의 상태 로드 : 스케줄러가 선택한 다음 실행할 프로세스의 저장된 상태를 로드   프로세스 전환 : CPU는 새로운 프로세스의 실행 시작   추가 메모리 처리 : 새로운 프로세스의 가상 메모리 주소체계를 설정하고, MMU(Memory Management Unit)와 TLB(Translation Lookaside Buffer)를 업데이트   Thread Context Switching (같은 프로세스에 속한 스레드 간의 컨텍스트 스위칭)    현재 프로세스의 상태 저장 : 실행중인 쓰레드의 레지스터 상태를 저장   다음 프로세스의 상태 로드 : 동일한 프로세스 내에서 실행할 다음 쓰레스 상태 로드   프로세스 전환 : CPU는 새로운 쓰레드의 실행 시작   추가 메모리 처리 : 동일한 프로세스 내 쓰레드간 전환이므로 메모리 관련 추가 처리가 필요없음   Process와 Thread Context Switching의 공통점    커널모드에서 실행 : 컨텍스트 스위칭은 항상 운영체제의 커널 모드에서 수행된다   CPU 레지스터 상태 교체 : 현재 실행중인 작업의 레지스터 상태를 저장하고, 다음 작업의 레지스터 상태를 복원   Process와 Thread Context Switching의 차이점 같은 프로세스에 속한 쓰레드들 간의 컨텍스트 스위칭은 같은 프로세스에 속하기 때문에 메모리 영역을 공유한다. 그래서 스위칭이 발생해도 메모리와 관련한 추가 작업이 발생하지 않는다.  하지만 다른 프로세스에 속한 쓰레드 간 컨텍스트 스위칭은 메모리 프로세스간 메모리 주소체계가 다르기 때문에 메모리 주소 관련 처리를 추가적으로 수행해야 한다.  그래서 MMU(Memory Manage Unit) 또한 새로운 프로세스의 주소체계를 바로보도록 수정해줘야하고, TLB(Translation Lookaside Buffer)라는 가상 메모리 주소와 실제 메모리 주소의 매핑 정보를 들고있는 캐시도 비워줘야한다. 만약 TLB 캐시를 비워주지 않는 경우 이전에 작업했던 프로세스의 주소에 접근할 가능성이 있기 때문에 반드시 수행해야한다.  Thread Context Switching이 Process보다 빠른 이유 Thread Context Switching(쓰레드 컨텍스트 스위칭)의 경우 Process Context Switching(프로세스 컨텍스트 스위칭)과 달리 MMU가 새로운 주소 체계 바로보도록 수정하고, TLB 가상 메모리 &lt;-&gt; 실제 메모리 매핑정보 저장된 캐시를 비우는 등의 메모리 주소 관련 작업을 하지 않고, CPU의 상태 정보만 바꿔주면 되기 떄문이다.  References    컨텍스트 스위칭 뽀개기!  "
  },
  
  {
    "title": "Scale-Up vs Scale-Out",
    "url": "/posts/Scale-Up-vs-Scale-Out/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-03-09 05:21:11 +0900",
    "content": "기존 개발하던 서비스의 서버가 한계에 다다랐을 때 Scale-Up (스케일 업) 혹은 Scale-Out (스케일 아웃) 을 고려한다.  Scale-Up 스케일 업은 기존의 서버를 더 높은 사양으로 업그레이드하는것이다. 예를들면 AWS EC2 t2.micro에서 t2.small로 업그레이드 하는 방식이다.  스케일 업은 상대적으로 간단히 서버의 성능을 향상시킬 수 있다는 장점이 있다. 하지만, 특정 서버를 무한정 업그레이드 할 수 없으며, 장애에 대한 자동복구 (failover) 나 다중화(re-dudancy)방안을 제시하지 않는다. 또한 스케일 업 전략을 선택하는 경우에는 향후 사용량을 미리 추정하여 미리 고사양의 서버를 확보하는 경우가 있다. 이러한 경우 실제 필요한 서버의 사양보다 과한 사양의 장비를 확보할 수 있기 때문에 비용적인 손실이 존재할 수 있다.  Scale-Out 스케일 아웃은 비슷한 사양의 장비를 추가하여 수평으로 확장하는 방식이다. 서버로 들어오는 많은 요청을 비슷한 사양의 서버 n대로 분산시켜 성능을 향상시킨다. 스케일 아웃은 그때그때 필요한 만큼 서버를 추가할 수 있으므로 상대적으로 스케일 업 방식보다 비용 효율적일 수 있다. 또한, 특정 서버의 장애 발생 상황에서도 스케일업 방식보다 가용성이 높다. 하지만 스케일 아웃 방식은 n대의 서버를 관리해야 하므로 관리 포인트가 늘어나며, 각 서버에 부하를 분산하기 위한 로드 밸런싱에 대한 고민이 추가로 필요하다는 단점이 있다.    References    scale-up vs scale-out  "
  },
  
  {
    "title": "ACID란?",
    "url": "/posts/ACID%EB%9E%80/",
    "categories": "공부",
    "tags": "백엔드",
    "date": "2025-03-09 03:25:54 +0900",
    "content": "ACID는 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)의 약자이며, 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 의미한다.  원자성(Atomicity) 원자성은 트랜잭션 내부 연산들이 부분적으로 실행되고 중단되지 않는 것을 보장한다는 것이다. 쉽게 말하자면, 트랜잭션은 전체 성공과 전체 실패 중 한 가지만 수행한다. 예를 들면 계좌 이체 트랜잭션은 다음과 같은 연산으로 이루어져 있다. 1. A의 계좌에서 20만원 출금 2. B의 계좌에 20만원 입금  이때 2번 과정에서 에러가 발생하면 1번 과정을 취소해야한다.  일관성(Consistency) 일관성은 트랜잭션이 성공적으로 완료되면 일관성 있는 데이터베이스 상태로 유지되는 것을 보장한다. 제약조건과 같이 데이터베이스에 정의된 규칙을 트랜잭션이 위반하는 경우에는 해당 트랜잭션은 취소되어야 한다.  격리성(Isolation) 격리성은 동시에 실행되는 여러 트랜잭션이 서로 독립적임을 보장한다. 가장 엄격할 경우에는 트랜잭션을 순차적으로 실행하기도 한다. 트랜잭션을 수행할 때 다른 트랜잭션이 해당 작업 사이에 끼어들지 못하도록 보장한다. 쉽게 이야기하면 트랜잭션 밖에서 어떠한 연산도 어떠한 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.  예를들어 계좌 이체 작업에서 A 계좌의 잔고와 B 계좌의 잔고 총합이 100만원으로 시작했을때, 특정 순간에는 총합이 100만원이 아닌 경우도 있을것이다. 하지만, 다른 트랜잭션은 항상 잔고의 총합인 100만원을 볼 수 있도록 보장해야한다.  지속성(Durability) 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템에 장애가 발생해도 성공적으로 수행된 트랜잭션의 결과는 항상 데이터베이스에 반영되어야한다. 전형적으로 트랜잭션은 로그로 남고, 로그가 저장되어야 트랜잭션이 성공했다고 간주한다. 추후 장애가 발생하면 이 로그를 활용해 데이터베이스를 회복한다.  References    ACID 데이터베이스와 BASE 데이터베이스의 차이점은 무엇인가요?   데이터베이스 트랜잭션(transaction)을 아십니까? 그리고 트랜잭션의 매우 중요한 속성들인 ACID를 아십니까? 모르신다면 들렀다 가시지요  "
  },
  
  {
    "title": "REST 란?",
    "url": "/posts/REST-%EB%9E%80/",
    "categories": "공부",
    "tags": "백엔드",
    "date": "2025-03-09 02:25:56 +0900",
    "content": "REST(Representational State Transfer) 는 자원의 표현을 이용하여 상태를 주고받는 것을 의미한다. 여기서 자원이란 소프트웨어가 관리하는 모든 것을 의미하고 자원의 표현은 자원을 나타내기 위한 이름을 의미한다. 예를들어, 서버가 관리하는 주문 데이터는 order 라고 표현할 수 있고, 이 주문이라는 표현을 보고 주문이라는 상태를 주고받는다. 최근에는 일반적으로 자원의 상태를 나타내기 위해 JSON format을 사용한다.  REST는 네트워크 상에서 클라이언트와 서버의 통신 방식 중 하나이며, HTTP 프로토콜을 사용한다. 구체적으로는 HTTP URI를 활용하여 자원을 명시하고 HTTP 메서드를 통해 CRUD 연산을 적용하는 것을 의미한다.  API API(Application Programming Interface) 란 컴퓨터 프로그램 간 정보를 주고받을 수 있도록 하는 일종의 출입구와 같은 역할을 수행한다. API가 REST 기반으로 구현되어 있다면, 이를 REST API라고 부릅니다.  REST의 장단점 REST의 장점으로는 서버와 클라이언트의 역할을 명확하게 분리하며, HTTP 프로토콜을 따르는 모든 플랫폼에서 사용할 수 있다. 또한 CURL, Postman 을 사용해 간단하게 테스트할 수 있다는 장점도 존재한다. REST의 단점으로는 요청 및 응답 스타일의 통신만 지원한다는 것이다. 그리고 HTTP메서드로 행위를 표현하기 어려운 경우도 존재하며 요청 한 번으로 여러 자원을 가져오기 어렵다는 단점이 존재한다.  그리고 REST 방식의 경우 자원의 상태를 전송하기 위해 JSON 포맷을 사용한다. JSON과 같은 텍스트 포맷은 자기 서술적이며, 메시지 소비자가 자신의 자신이 관심이 있는 값만 골라서 사용하고 나머지는 무시하면 되므로 메시지 구조가 자주 바뀌어도 하위 호환성을 보장하는 것이 유리하다. 하지만 메시지가 다소 길다는 것이 단점이다. 메시지가 길면 네트워크 트래픽을 더욱 사용하며 전송속도가 느릴 수 있으며, 메시지를 해석하는 데 오버헤드가 발생할 수 있다. "
  },
  
  {
    "title": "동시성과 병렬성",
    "url": "/posts/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-03-09 01:27:15 +0900",
    "content": "  Concurrency (동시성) 논리적으로 동시에 실행되는 것처럼 보이게 만드는 개념. 이름과 달리 여러 작업을 동시에 수행하지는 않는다. 그렇게 보일 뿐. 단일 코어를 기준으로 시간 분할을 통해 여러 스레드를 번갈아가며 작업을 수행함으로써, 마치 동시에 여러 작업이 처리되는 것처럼 보인다.  사용자의 입력을 기다리거나, 네트워크 요청, 파일 입출력 등의 I/O 작업시에는 CPU가 유휴 상태로 대기하게 된다. 이때 CPU가 아무것도 하지않고 대기하는 대신, 컨텍스트 스위칭을 통해 다른 쓰레드의 작업을 처리할 수 있다. 이러한 특성 덕분에 서버는 여러 클라이언트의 요청을 동시에 처리할 수 있어서 효율적이다.  하지만 동시성 환경을 신중하게 고려하지 않으면 여러 쓰레드를 사용하면서 데드락, Race Condition, Starvation 등의 문제가 발생할 수 있다.  Parallelism (병렬성) 물리적으로 동일한 시간에 여러 작업을 독립적으로 수행하는 것을 의미. 여러개의 코어가 각각 독립된 쓰레드의 작업을 동시에 처리함으로써, 실제로 여러 작업이 동시에 실행된다. 동시성과는 달리, 하나의 코어가 여러 쓰레드를 번갈아 가면서 처리할 필요 없이, 각 코어에서 독립적으로 작업을 실행한다.  독립적인 하위 작업으로 나눌 수 있는 계산과 같은 작업을 여러 코어에 분산함으로써, 작업 완료 시간을 최소화 할 수 있어 고성능 컴퓨팅에 이상적이다. 하지만 병렬처리는 데이터나 리소스를 공유할 때 작업 간 동기화가 필요한 경우가 많아, 이러한 동기화로 인해 상당한 오버헤드가 발생할 수 있다.  References    Concurrency vs Parallelism: A Simplified Explanation   Concurrency vs Parallelism  "
  },
  
  {
    "title": "PGMS_중복 제거하기 (SQL)",
    "url": "/posts/PGMS%EC%A4%91%EB%B3%B5-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-03-08 20:00:32 +0900",
    "content": "[level 2] 중복 제거하기 - 59408  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; SUM， MAX， MIN  채점결과  Empty  제출 일자  2025년 03월 08일 19:59:10  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          동물 보호소에 들어온 동물의 이름은 몇 개인지 조회하는 SQL 문을 작성해주세요. 이때 이름이 NULL인 경우는 집계하지 않으며 중복되는 이름은 하나로 칩니다.   예시  예를 들어 ANIMAL_INS 테이블이 다음과 같다면           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A562649 Dog 2014-03-20 18:06:00 Sick NULL Spayed Female   A412626 Dog 2016-03-13 11:17:00 Normal *Sam Neutered Male   A563492 Dog 2014-10-24 14:45:00 Normal *Sam Neutered Male   A513956 Dog 2017-06-14 11:54:00 Normal *Sweetie Spayed Female          보호소에 들어온 동물의 이름은 NULL(없음), *Sam, *Sam, *Sweetie입니다. 이 중 NULL과 중복되는 이름을 고려하면, 보호소에 들어온 동물 이름의 수는 2입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.           count            2          ※ 컬럼 이름(위 예제에서는 count)은 일치하지 않아도 됩니다.    본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제풀이        코드   SELECT COUNT(DISTINCT NAME)     FROM ANIMAL_INS         WHERE NAME IS NOT NULL;  "
  },
  
  {
    "title": "BOJ_2225_합분해 (Java, Python)",
    "url": "/posts/BOJ2225%ED%95%A9%EB%B6%84%ED%95%B4-Java-Python/",
    "categories": "알고리즘",
    "tags": "Java, python, 백준, 알고리즘",
    "date": "2025-03-08 18:51:42 +0900",
    "content": "[Gold V] 합분해 - 2225  문제 링크  성능 요약  메모리: 34456 KB, 시간: 44 ms  분류  다이나믹 프로그래밍, 수학  제출 일자  2025년 3월 8일 18:48:44  문제 설명  0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.  덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.  입력  첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.  출력  첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.     문제 풀이        코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K;     static final int MOD = 1_000_000_000;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2225_합분해/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());          int[][] dp = new int[K + 1][N + 1];          for (int j = 1; j &lt;= N; j++) {             dp[1][j] = 1;         }          for (int i = 2; i &lt;= K; i++) { // 개수             dp[i][0] = 1;             for (int j = 1; j &lt;= N; j++) { // 합                 dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD;             }         }          System.out.println(dp[K][N]);     } }     Python 코드 N, K = map(int, input().split()) MOD = 1_000_000_000  dp = [[0] * (N+1) for _ in range(K+1)]  for j in range(1, N+1):     dp[1][j] = 1  for i in range(2, K+1):     dp[i][0] = 1     for j in range(1, N+1):         dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD  print(dp[K][N])  "
  },
  
  {
    "title": "PGMS_가장 큰 삼각형 덩어리 (Java)",
    "url": "/posts/PGMS%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%82%BC%EA%B0%81%ED%98%95-%EB%8D%A9%EC%96%B4%EB%A6%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-03-08 13:21:25 +0900",
    "content": "[level 4] 가장 큰 삼각형 덩어리 - 389629  문제 링크  성능 요약  메모리: 121 MB, 시간: 89.95 ms  구분  코딩테스트 연습 &gt; 2025 프로그래머스 코드챌린지 본선  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 03월 07일 20:11:02  문제 설명  N행 M열의 2차원 격자 grid가 주어집니다. 격자의 각 칸은 한 변의 길이가 √2인 정사각형이며, 각 칸 안에는 대각선이 하나 그어져 있습니다. 이 대각선은 / 방향(1) 또는 \\ 방향(-1) 중 하나입니다.  각 정사각형 칸은 대각선에 의해 동일한 크기의 직각삼각형 두 개로 나뉘며, 당신은 각 칸에서 두 삼각형 중 정확히 하나만 색칠할 수 있습니다. 색칠된 삼각형들은 한 '변'을 공유해야 서로 연결되며, 이렇게 연결된 삼각형들의 집합을 하나의 삼각형 덩어리라고 합니다.  당신의 목표는 격자 전체를 적절히 색칠하여, 연결된 하나의 삼각형 덩어리 중 가능한 가장 큰 덩어리의 넓이를 구하는 것입니다. 각 삼각형의 넓이는 칸을 이루는 정사각형의 면적(2)의 절반인 1입니다. 따라서 덩어리에 포함된 삼각형의 개수가 곧 그 덩어리의 넓이가 됩니다.  격자의 상태를 나타내는 2차원 정수 배열 grid가 매개변수로 주어집니다. 이 격자를 적절히 색칠했을 때, 만들 수 있는 삼각형 덩어리들 중에서 가장 넓이가 큰 덩어리의 넓이를 return 하도록 solution 함수를 완성해 주세요.    제한사항   1 ≤ grid의 세로 길이 = N ≤ 200,000 1 ≤ grid의 가로 길이 = M ≤ 200,000 1 ≤ N × M ≤ 200,000 grid[i][j]는 -1, 1 중 하나의 값을 가집니다. grid[i][j]가 -1이면 \\ 방향을 나타내며, 1이면 / 방향을 나타냅니다.     테스트 케이스 구성 안내  아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.           그룹 총점 추가 제한 사항            #1 50% N × M ≤ 20   #2 50% 추가 제한 사항 없음            입출력 예           grid result            [[-1, -1, -1], [1, 1, -1], [1, 1, 1]] 5   [[1, -1, 1], [-1, 1, -1]] 4   [[1]] 1            입출력 예 설명  입출력 예 #1  격자의 상태는 아래 그림과 같습니다.    각 칸에서 한 개의 삼각형을 적절히 색칠했을 때, '하나로 연결된 삼각형 덩어리' 중 넓이가 가장 큰 경우는 아래 그림에서 색칠된 부분과 같습니다. 이 경우 덩어리의 넓이는 5이므로, 5를 return 해야 합니다.    입출력 예 #2  격자의 상태는 아래 그림과 같습니다.    각 칸에서 한 개의 삼각형을 적절히 색칠했을 때, '하나로 연결된 삼각형 덩어리' 중 넓이가 가장 큰 경우는 아래 그림에서 색칠된 부분과 같습니다. 이 경우 덩어리의 넓이는 4이므로, 4를 return 해야 합니다.    입출력 예 #3  최대 1개의 삼각형을 색칠할 수 있습니다. 삼각형 하나의 넓이인 1을 return 합니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     대각선에 상태가 1과 -1이 있고, 각 칸마다 2개의 삼각형으로 나뉜다. 이때 대각선 1에 의해 나뉜 삼각형을 왼쪽부터 1과 2, 대각선 -1에 의해 나뉜 삼각형을 왼쪽부터 -1, -2로 설정했다. 이후 각 삼각형마다 어떤 방향으로 갈 수 있는지 살펴보면    부분삼각형 1 : 왼쪽, 위   부분삼각형 2 : 오른쪽, 아래   부분삼각형 -1 : 왼쪽, 아래   부분삼각형 -2 : 오른쪽, 위   1과 2를 보고 각 격자에 어떤 대각선이 있는지도 알 수 있으며 각 삼각형을 만난 순간 어떤 방향으로 진행해야하는지도 알 수 있다. 이렇게 다음 진행해야할 방향을 nextDir로 만든 뒤 사용했다.  그리고 한 격자에서 한개의 삼각형만 사용할 수 있으므로 2차원 visited로 격자 방문처리도 해주었고, 이전에 방문했더라도 bfs돌면서 다시 방문할 순 있기 때문에 그 bfs메서드 도는 순간에만 일회용으로 방문처리를 해주어야했다. 처음에는 HashSet에서 매번 생성해 visited를 해주었는데 오버헤드가 커 3개의 테스트케이스에서 시간초과가 발생했다. 이를 bfs마다 id를 부여해 int[][] visited로 처리해줬다. bfsId 가 k일때 k인것만 다시 밟지 않으면된다.     코드   import java.util.*;  class Solution {     static int N, M, max=Integer.MIN_VALUE, bfsCnt=1;     static int[] dr = {0, -1, 0, 1}, dc = {-1, 0, 1, 0}; // 좌 상 우 하     static int[][][] board;     static int[][] visited;     static int[][] nextDirs;     public int solution(int[][] grid) {         int res = 0;         N = grid.length;         M = grid[0].length;                  board = new int[N][M][2];         visited = new int[N][M];         nextDirs = new int[2][3]; // [r, c, nextState]                  // 각 칸마다 2개의 삼각형이 존재         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;M; j++){                 // \"/\" 모양 : 1                 if(grid[i][j] == 1){                     board[i][j][0] = 1;                     board[i][j][1] = 2;                  }                 // \"\\\"모양 : -1                 else{                     board[i][j][0] = -1;                     board[i][j][1] = -2;                 }             }         }                          for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;M; j++){                 for(int k=0; k&lt;2; k++){                     if(visited[i][j] == 0){                         // System.out.println(\"시작점 : \" + i + \" , \" + j + \" , \" + \"방향 : \" + k);                         int cnt = bfs(i, j, k, grid, bfsCnt++);                         if(cnt &gt; max) max = cnt;                     }                 }             }         }         return max;     }          // bfs 메서드     private static int bfs(int r, int c, int pos, int[][] grid, int bfsId){         int cnt = 1;         Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();         queue.offer(new int[] {r, c, pos});          visited[r][c] = bfsId;                  while(!queue.isEmpty()){             int[] curr = queue.poll();             int currState = board[curr[0]][curr[1]][curr[2]];                          int idx = getNext(curr[0], curr[1], currState, grid);                          for(int i=0; i&lt;idx; i++){                 int nextR = nextDirs[i][0];                 int nextC = nextDirs[i][1];                 int nextState = nextDirs[i][2]; // -2, -1, 1, 2                 int nextP = (int) Math.abs(nextState) %2 == 1 ? 0 : 1; // 0 or 1                                  if(!isValid(nextR, nextC)) continue;                                  if(visited[nextR][nextC] == bfsId) continue;                                  visited[nextR][nextC] = bfsId;                 queue.offer(new int[] {nextR, nextC, nextP});                 cnt++;             }                      }         // System.out.println(\"cnt : \" + cnt);         return cnt;     }          private static int getNext(int r, int c, int state, int[][] grid){         int dirCnt = 0;                  // 4가지 종류의 삼각형에 대해 다음 방향을 결정             if(state == 1){ // 좌, 상                 int nextR = r + dr[0];                 int nextC = c + dc[0];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==1 ? 2 : -2;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }                                  nextR = r + dr[1];                 nextC = c + dc[1];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==1 ? 2 : -1;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }                              }             else if(state == 2){ // 우, 하                 int nextR = r + dr[2];                 int nextC = c + dc[2];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==1 ? 1 : -1;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }                                  nextR = r + dr[3];                 nextC = c + dc[3];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==1 ? 1 : -2;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }             }             else if(state == -1){ // 좌, 하                 int nextR = r + dr[0];                 int nextC = c + dc[0];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==-1 ? -2 : 2;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }                                  nextR = r + dr[3];                 nextC = c + dc[3];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==-1 ? -2 : 1;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }             }             else{ // -2, 상, 우                 int nextR = r + dr[1];                 int nextC = c + dc[1];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==-1 ? -1 : 2;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }                                  nextR = r + dr[2];                 nextC = c + dc[2];                 if(isValid(nextR, nextC)){                     nextDirs[dirCnt][0] = nextR;                     nextDirs[dirCnt][1] = nextC;                     int nextState = grid[nextR][nextC]==-1 ? -1 : 1;                     nextDirs[dirCnt][2] = nextState;                     dirCnt++;                 }             }         return dirCnt;     }                             private static boolean isValid(int r, int c){         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     } }  "
  },
  
  {
    "title": "BOJ_8980_택배 (Java)",
    "url": "/posts/BOJ8980%ED%83%9D%EB%B0%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-07 13:58:38 +0900",
    "content": "[Gold II] 택배 - 8980  문제 링크  성능 요약  메모리: 20996 KB, 시간: 324 ms  분류  그리디 알고리즘, 정렬  제출 일자  2025년 3월 7일 13:55:58  문제 설명  아래 그림과 같이 직선 도로상에 왼쪽부터 오른쪽으로 1번부터 차례대로 번호가 붙여진 마을들이 있다. 마을에 있는 물건을 배송하기 위한 트럭 한 대가 있고, 트럭이 있는 본부는 1번 마을 왼쪽에 있다. 이 트럭은 본부에서 출발하여 1번 마을부터 마지막 마을까지 오른쪽으로 가면서 마을에 있는 물건을 배송한다.     각 마을은 배송할 물건들을 박스에 넣어 보내며, 본부에서는 박스를 보내는 마을번호, 박스를 받는 마을번호와 보낼 박스의 개수를 알고 있다. 박스들은 모두 크기가 같다. 트럭에 최대로 실을 수 있는 박스의 개수, 즉 트럭의 용량이 있다. 이 트럭 한대를 이용하여 다음의 조건을 모두 만족하면서 최대한 많은 박스들을 배송하려고 한다.   \t조건 1: 박스를 트럭에 실으면, 이 박스는 받는 마을에서만 내린다. \t조건 2: 트럭은 지나온 마을로 되돌아가지 않는다. \t조건 3: 박스들 중 일부만 배송할 수도 있다.   마을의 개수, 트럭의 용량, 박스 정보(보내는 마을번호, 받는 마을번호, 박스 개수)가 주어질 때, 트럭 한 대로 배송할 수 있는 최대 박스 수를 구하는 프로그램을 작성하시오. 단, 받는 마을번호는 보내는 마을번호보다 항상 크다.  예를 들어, 트럭 용량이 40이고 보내는 박스들이 다음 표와 같다고 하자.   \t \t\t \t\t\t보내는 마을 \t\t\t받는 마을 \t\t\t박스 개수 \t\t \t \t \t\t \t\t\t1 \t\t\t2 \t\t\t10 \t\t \t\t \t\t\t1 \t\t\t3 \t\t\t20 \t\t \t\t \t\t\t1 \t\t\t4 \t\t\t30 \t\t \t\t \t\t\t2 \t\t\t3 \t\t\t10 \t\t \t\t \t\t\t2 \t\t\t4 \t\t\t20 \t\t \t\t \t\t\t3 \t\t\t4 \t\t\t20 \t\t \t   이들 박스에 대하여 다음과 같이 배송하는 방법을 고려해 보자.  (1) 1번 마을에 도착하면   \t다음과 같이 박스들을 트럭에 싣는다. (1번 마을에서 4번 마을로 보내는 박스는 30개 중 10개를 싣는다.)    \t \t\t \t\t\t보내는 마을 \t\t\t받는 마을 \t\t\t박스 개수 \t\t \t \t \t\t \t\t\t1 \t\t\t2 \t\t\t10 \t\t \t\t \t\t\t1 \t\t\t3 \t\t\t20 \t\t \t\t \t\t\t1 \t\t\t4 \t\t\t10 \t\t \t   (2) 2번 마을에 도착하면   \t트럭에 실려진 박스들 중 받는 마을번호가 2인 박스 10개를 내려 배송한다. (이때 트럭에 남아있는 박스는 30개가 된다.) \t그리고 다음과 같이 박스들을 싣는다. (이때 트럭에 실려 있는 박스는 40개가 된다.)    \t \t\t \t\t\t보내는 마을 \t\t\t받는 마을 \t\t\t박스 개수 \t\t \t \t \t\t \t\t\t2 \t\t\t3 \t\t\t10 \t\t \t   (3) 3번 마을에 도착하면    \t트럭에 실려진 박스들 중 받는 마을번호가 3인 박스 30개를 내려 배송한다. (이때 트럭에 남아있는 박스는 10개가 된다.) \t그리고 다음과 같이 박스들을 싣는다. (이때 트럭에 실려 있는 박스는 30개가 된다.)    \t \t\t \t\t\t보내는 마을 \t\t\t받는 마을 \t\t\t박스 개수 \t\t \t \t \t\t \t\t\t3 \t\t\t4 \t\t\t20 \t\t \t   (4) 4번 마을에 도착하면    \t받는 마을번호가 4인 박스 30개를 내려 배송한다   위와 같이 배송하면 배송한 전체 박스는 70개이다. 이는 배송할 수 있는 최대 박스 개수이다.  입력  입력의 첫 줄은 마을 수 N과 트럭의 용량 C가 빈칸을 사이에 두고 주어진다. N은 2이상 2,000이하 정수이고, C는 1이상 10,000이하 정수이다. 다음 줄에, 보내는 박스 정보의 개수 M이 주어진다. M은 1이상 10,000이하 정수이다. 다음 M개의 각 줄에 박스를 보내는 마을번호, 박스를 받는 마을번호, 보내는 박스 개수(1이상 10,000이하 정수)를 나타내는 양의 정수가 빈칸을 사이에 두고 주어진다. 박스를 받는 마을번호는 보내는 마을번호보다 크다.   출력  트럭 한 대로 배송할 수 있는 최대 박스 수를 한 줄에 출력한다.     문제풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Package implements Comparable&lt;Package&gt; {         int from, to, weight;          public Package(int from, int to, int weight) {             this.from = from;             this.to = to;             this.weight = weight;         }          @Override         public int compareTo(Package o) {             if (this.to == o.to) return this.from - o.from;             return this.to - o.to;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, C, M, from, to, weight, res;     static Package[] packages;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_8980_택배/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         C = Integer.parseInt(st.nextToken());          M = Integer.parseInt(br.readLine());         packages = new Package[M + 1];         for (int i = 1; i &lt;= M; i++) {             st = new StringTokenizer(br.readLine());             from = Integer.parseInt(st.nextToken());             to = Integer.parseInt(st.nextToken());             weight = Integer.parseInt(st.nextToken());             packages[i] = new Package(from, to, weight);         }          Arrays.sort(packages, 1, M + 1);          int[] availableC = new int[N+1];         Arrays.fill(availableC, C);          for (int i = 1; i &lt;= M; i++) {             Package currP = packages[i];              int minC = C;             // 그 구간에서 옮길 수 있는 양             for(int j= currP.from; j&lt; currP.to; j++) {                 minC = Math.min(minC, availableC[j]);             }              // 배송할 양 결정 (그 구간에서 옮길 수 있는 최소값 or 현재 패키지 박스양 중 최솟값)             int selectedC = Math.min(currP.weight, minC);              if(selectedC &gt; 0){                 for(int k= currP.from; k&lt;currP.to; k++) {                     availableC[k] -= selectedC;                 }                 res += selectedC;             }         }          System.out.println(res);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "PGMS_봉인된 주문 (Java)",
    "url": "/posts/PGMS%EB%B4%89%EC%9D%B8%EB%90%9C-%EC%A3%BC%EB%AC%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-03-07 02:59:37 +0900",
    "content": "[level 3] 봉인된 주문 - 389481  문제 링크  성능 요약  메모리: 154 MB, 시간: 129.59 ms  구분  코딩테스트 연습 &gt; 2025 프로그래머스 코드챌린지 2차 예선  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 03월 07일 02:52:31  문제 설명  어느 날, 전설 속에 전해 내려오는 비밀 주문서가 세상에 다시 모습을 드러냈습니다. 이 주문서에는 마법 세계에서 사용되는 모든 주문이 적혀 있는데, 각 주문은 알파벳 소문자 11글자 이하로 구성되어 있습니다. 주문서에는 실제로 마법적 효과를 지니지 않는 의미 없는 주문들 즉, 알파벳 소문자 11글자 이하로 쓸 수 있는 모든 문자열이 고대의 규칙에 따라 아래와 같이 정렬되어 있습니다.   글자 수가 적은 주문부터 먼저 기록된다. 글자 수가 같다면, 사전 순서대로 기록된다.   예를 들어, 주문서의 시작 부분은 다음과 같이 구성됩니다.   \"a\"→\"b\"→\"c\"→\"d\"→\"e\"→\"f\"→...→\"z\" →\"aa\"→\"ab\"→...→\"az\"→\"ba\"→...→\"by\"→\"bz\"→\"ca\"→...→\"zz\" →\"aaa\"→\"aab\"→...→\"aaz\"→\"aba\"→...→\"azz\"→\"baa\"→...→\"zzz\" →\"aaaa\"→...→\"aazz\"→\"abaa\"→...→\"czzz\"→\"daaa\"→...→\"zzzz\" →\"aaaaa\"→...   하지만 이 주문서에는 오래전 봉인된 저주받은 주문들이 숨겨져 있었고, 이를 악용하려는 자들을 막기 위해 마법사들이 몇몇 주문을 주문서에서 삭제했습니다. 당신은 삭제가 완료된 주문서에서 n번째 주문을 찾아내야 합니다.  예를 들어, 주문서에서 \"d\", \"e\", \"bb\", \"aa\", \"ae\" 5개의 주문을 지웠을 때, 주문서에서 30번째 주문을 찾으려고 합니다.   1~3번째 주문은 \"a\", \"b\", \"c\" 입니다. \"d\"와 \"e\"는 삭제됐으므로 4~24번째 주문은 \"f\" ~ \"z\"입니다. \"aa\"는 삭제됐으므로 25~27번째 주문은 \"ab\", \"ac\", \"ad\"입니다. \"ae\"는 삭제됐으므로 28~30번째 주문은 \"af\", \"ag\", \"ah\"입니다.   따라서 30번째 주문은 \"ah\"가 됩니다. 삭제된 주문 중 “bb”와 같이 n번째 주문보다 뒤에 위치해 있어서 n번째 주문을 찾는 데 영향을 주지 않는 주문도 존재할 수 있습니다.  정수 n과 삭제된 주문들을 담은 1차원 문자열 배열 bans가 매개변수로 주어질 때, 삭제가 완료된 주문서의 n번째 주문을 return 하도록 solution 함수를 완성해 주세요.    제한사항   1 ≤ n ≤ 1015 1 ≤ bans의 길이 ≤ 300,000   bans의 원소는 알파벳 소문자로만 이루어진 길이가 1 이상 11 이하인 문자열입니다. bans의 원소는 중복되지 않습니다.      입출력 예           n bans result            30 [\"d\", \"e\", \"bb\", \"aa\", \"ae\"] \"ah\"   7388 [\"gqk\", \"kdn\", \"jxj\", \"jxi\", \"fug\", \"jxg\", \"ewq\", \"len\", \"bhc\"] \"jxk\"            테스트 케이스 구성 안내  아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.           그룹 총점 추가 제한 사항            #1 15% n ≤ 1,000, bans의 길이 ≤ 100   #2 15% n ≤ 1,000,000   #3 70% 추가 제한 사항 없음            입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.  입출력 예 #2  주어진 주문을 지운 후 주문서의 7,388 번째 주문은 \"jxk\"입니다. 따라서 \"jxk\"를 return 합니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제풀이              해결 접근법:             26진법 체계를 활용하여 문자열을 위치 값으로 변환하고 역변환       누적합을 이용해 각 길이별 문자열 총 개수 미리 계산                주요 데이터 구조:             pow26[]: 26의 거듭제곱 값 저장 (26^0, 26^1, …)       totalCnt[]: 각 길이까지의 문자열 누적 개수 저장                핵심 알고리즘:             위치→문자열, 문자열→위치 변환 함수 구현       밴 목록을 위치 값으로 변환 후 정렬       n보다 작거나 같은 위치의 밴 개수만큼 n을 증가시켜 최종 위치 계산       최종 위치를 다시 문자열로 변환                최적화 포인트:             26의 거듭제곱 미리 계산하여 재사용       불필요한 반복 계산 제거       효율적인 이진 변환 로직 사용              코드   import java.util.*;  class Solution {     static StringBuilder sb;     static long[] totalCnt, pow26;     public String solution(long n, String[] bans) {         String answer = \"\";                  // 누적합으로 길이별 개수 계산         pow26 = new long[12];         pow26[0] = 1;         for(int i=1; i&lt;=11; i++){             pow26[i] = pow26[i-1] * 26;         }         totalCnt = new long[12];         totalCnt[0] = 0;         for(int i=1; i&lt;=11; i++){             totalCnt[i] = totalCnt[i-1] + pow26[i];         }                           // 밴 목록 위치 값으로 변환         long[] banPos = new long[bans.length];         for (int i = 0; i &lt; bans.length; i++) {             banPos[i] = wordToPos(bans[i]);         }         Arrays.sort(banPos);                  long targetPos = n;         for(long b : banPos){             if(b &lt;= targetPos){                 targetPos++;             }             else break;         }                  return posToWord(targetPos);     }     private static long wordToPos(String word){         int len = word.length();         long pos = totalCnt[len-1] + 1;                  for(int i=0; i&lt;len; i++){             int charVal = word.charAt(i) - 'a';             pos += charVal * pow26[len - 1 -i];         }         return pos;     }          private static String posToWord(long pos){         int len = 1;         while(len &lt;= 11 &amp;&amp; totalCnt[len] &lt; pos){             len++;         }                  long offset = pos - 1 - totalCnt[len-1];                  sb = new StringBuilder();         for(int i=len-1; i&gt;=0; i--){             int digit = (int) (offset/pow26[i]);             sb.append((char)('a' + digit));             offset -= digit * pow26[i];         }         return sb.toString();     } }  "
  },
  
  {
    "title": "BOJ_19949_영재의 시험 (Java)",
    "url": "/posts/BOJ19949%EC%98%81%EC%9E%AC%EC%9D%98-%EC%8B%9C%ED%97%98-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-05 16:00:14 +0900",
    "content": "[Silver II] 영재의 시험 - 19949  문제 링크  성능 요약  메모리: 15620 KB, 시간: 196 ms  분류  백트래킹, 브루트포스 알고리즘  제출 일자  2025년 3월 5일 15:56:25  문제 설명  컴퓨터공학과 학생인 영재는 이번 학기에 알고리즘 수업을 수강한다.  평소에 자신의 실력을 맹신한 영재는 시험 전날까지 공부를 하지 않았다.  당연하게도 문제를 하나도 풀지 못하였지만 다행히도 문제가 5지 선다의 객관식 10문제였다.  찍기에도 자신 있던 영재는 3개의 연속된 문제의 답은 같지 않게 한다는 자신의 비법을 이용하여 모든 문제를 찍었다.  이때 영재의 점수가 5점 이상일 경우의 수를 구하여라.  문제의 점수는 1문제당 1점씩이다.  입력  시험의 정답이 첫 줄에 주어진다.  출력  영재의 점수가 5점 이상일 경우의 수를 출력하여라.     문제 풀이   dfs로 모든 경우의수를, 백트래킹 적용해서 풀었다.      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int arr[], select[], res;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_19949_영재의시험/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          arr = new int[10];         select = new int[10];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; 10; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }          dfs(0, 0);          System.out.println(res);         bw.flush();         bw.close();         br.close();     }      private void dfs(int idx, int cnt) {         if(idx == 10){             if(cnt &gt;= 5) {                 res++;             }             return;         }          for(int i=1; i&lt;=5; i++){             if(idx &gt;= 2 &amp;&amp; select[idx-2] == i &amp;&amp; select[idx-1] == i) continue;              select[idx] = i;              if(arr[idx] == i) dfs(idx+1, cnt+1);             else dfs(idx+1, cnt);         }     } }  "
  },
  
  {
    "title": "BOJ_388354_홀짝트리 (Java)",
    "url": "/posts/BOJ388354%ED%99%80%EC%A7%9D%ED%8A%B8%EB%A6%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-03-04 16:52:03 +0900",
    "content": "[level 3] 홀짝트리 - 388354  문제 링크  성능 요약  메모리: 290 MB, 시간: 718.45 ms  구분  코딩테스트 연습 &gt; 2025 프로그래머스 코드챌린지 1차 예선  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 03월 04일 16:35:14  문제 설명  루트 노드가 설정되지 않은 1개 이상의 트리가 있습니다. 즉, 포레스트가 있습니다.  모든 노드들은 서로 다른 번호를 가지고 있습니다.   각 노드는 홀수 노드, 짝수 노드, 역홀수 노드, 역짝수 노드 중 하나입니다. 각 노드의 정의는 다음과 같으며, 0은 짝수입니다.   홀수 노드   노드의 번호가 홀수이며 자식 노드의 개수가 홀수인 노드입니다.  짝수 노드   노드의 번호가 짝수이며 자식 노드의 개수가 짝수인 노드입니다.  역홀수 노드   노드의 번호가 홀수이며 자식 노드의 개수가 짝수인 노드입니다.  역짝수 노드   노드의 번호가 짝수이며 자식 노드의 개수가 홀수인 노드입니다.    당신은 각 트리에 대해 루트 노드를 설정했을 때, 홀짝 트리가 될 수 있는 트리의 개수와 역홀짝 트리가 될 수 있는 트리의 개수를 구하려고 합니다. 각 트리의 정의는 다음과 같습니다.   홀짝 트리   홀수 노드와 짝수 노드로만 이루어진 트리입니다.  역홀짝 트리   역홀수 노드와 역짝수 노드로만 이루어진 트리입니다.    다음은 트리의 루트 노드를 설정하는 예시입니다.  다음과 같은 트리가 있습니다.    위 트리의 루트 노드를 3번 노드로 설정하게 되면 다음과 같은 형태가 됩니다.    노란색 노드는 홀수 노드 혹은 짝수 노드를 나타내고, 빨간색 노드는 역홀수 노드 혹은 역짝수 노드를 나타냅니다. 이 경우, 모든 노드가 노란색이므로 홀짝 트리가 됩니다.  이 트리의 루트 노드를 6번 노드로 설정하게 되면 다음과 같은 형태가 되어 홀짝 트리 혹은 역홀짝 트리가 될 수 없습니다.     이와 마찬가지로 다른 노드를 루트 노드로 설정하는 경우에는 홀짝 트리 혹은 역홀짝 트리가 될 수 없습니다. 3번 노드를 루트 노드로 설정하는 경우에만 홀짝 트리가 될 수 있습니다. 따라서 위 트리는 홀짝 트리가 될 수 있는 트리입니다.  다음은 어떤 노드를 루트 노드로 설정하더라도 홀짝 트리 혹은 역홀짝 트리가 될 수 없는 트리입니다.    즉, 트리는 어떤 노드를 루트 노드로 설정하냐에 따라 홀짝 트리 혹은 역홀짝 트리가 될 수 있습니다. 경우에 따라 하나의 트리가 홀짝 트리와 역홀짝 트리 두 가지 모두 될 수 있거나 두 가지 모두 될 수 없을 수도 있습니다.  포레스트에 존재하는 노드들의 번호를 담은 1차원 정수 배열 nodes, 포레스트에 존재하는 간선들의 정보를 담은 2차원 정수 배열 edges가 매개변수로 주어집니다. 이때, 홀짝 트리가 될 수 있는 트리의 개수와 역홀짝 트리가 될 수 있는 트리의 개수를 1차원 정수 배열에 순서대로 담아 return 하도록 solution 함수를 완성해 주세요.    제한사항   1 ≤ nodes의 길이 ≤ 400,000   1 ≤ nodes의 원소 ≤ 1,000,000 nodes의 원소는 중복되지 않습니다.  1 ≤ edges의 길이 ≤ 1,000,000   edges의 원소는 [a, b] 형태의 1차원 정수 배열이며, a번 노드와 b번 노드 사이에 무방향 간선이 존재한다는 것을 의미합니다. a, b는 nodes에 존재하는 원소이며 서로 다릅니다.  포레스트인 경우만 입력으로 주어집니다.     테스트 케이스 구성 안내  아래는 테스트 케이스 구성을 나타냅니다. 각 그룹 내의 테스트 케이스를 모두 통과하면 해당 그룹에 할당된 점수를 획득할 수 있습니다.           그룹 총점 추가 제한 사항            #1 10% 하나의 트리만 주어집니다. nodes의 길이 ≤ 1,000, edges의 길이 ≤ 1,000   #2 10% nodes의 길이 ≤ 1,000, edges의 길이 ≤ 1,000   #3 30% 하나의 트리만 주어집니다.   #4 50% 추가 제한 사항 없음            입출력 예           nodes edges result            [11, 9, 3, 2, 4, 6] [[9, 11], [2, 3], [6, 3], [3, 4]] [1, 0]   [9, 15, 14, 7, 6, 1, 2, 4, 5, 11, 8, 10] [[5, 14], [1, 4], [9, 11], [2, 15], [2, 5], [9, 7], [8, 1], [6, 4]] [2, 1]            입출력 예 설명  입출력 예 #1  문제의 예시와 같습니다.  홀짝 트리가 될 수 있는 트리가 하나 존재하고, 역홀짝 트리가 될 수 있는 트리는 존재하지 않습니다. 따라서 [1, 0]을 return 해야 합니다.  입출력 예 #2  주어진 포레스트를 그림으로 나타내면 다음과 같습니다.    1, 3번째 트리는 각각 10번 노드, 4번 노드를 루트 노드로 설정하면 홀짝 트리가 될 수 있고, 2번째 트리는 9번 노드를 루트 노드로 설정하면 역홀짝 트리가 될 수 있습니다. 4번째 트리는 어떤 노드를 루트 노드로 설정해도 홀짝 트리 혹은 역홀짝 트리가 될 수 없습니다. 따라서 [2, 1]을 return 해야 합니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제풀이        코드   import java.util.*;  class Solution {     static int[] p;     static ArrayList&lt;Integer&gt;[] board;     static Map&lt;Integer, Integer&gt; p_visited = new HashMap&lt;&gt;();     public int[] solution(int[] nodes, int[][] edges) {         /*             트리 그룹으로 나누고 각 그룹마다 홀짝트리 or 역홀짝트리 여부 보기             -&gt; 홀짝이 1개면 g2++ , 역홀짝이 1개면 g1++         */                  int g1=0, g2=0; // g1 : 홀짝트리 수, g2 : 역홀짝트리 수         int s = 0;         for(int n : nodes){             if(s &lt; n) s = n;         }                  p = new int[s + 1];         for(int i=0; i&lt;nodes.length; i++){             p[nodes[i]] = nodes[i];         }                  board = new ArrayList[s+1];         for(int i=1; i&lt; s + 1; i++){             board[i] = new ArrayList&lt;&gt;();         }                  for(int[] e : edges){             board[e[0]].add(e[1]);             board[e[1]].add(e[0]);         }                  for(int[] e : edges){             union(find(e[0]), find(e[1]));         }                  for(int i=0; i&lt;nodes.length; i++){             int node = find(nodes[i]);             if(!p_visited.containsKey(node)){                 p_visited.put(node, 0);                                  int[] tmp = bfs(node);                 if(tmp[0] == 1) g1++;                 if (tmp[1] == 1) g2++;             }         }                  int[] res = new int[]{g1, g2};         return res;     }          private void union(int x, int y){         int px = find(x);         int py = find(y);         if(px &lt;= py) p[py] = px;         else p[px] = py;         return;     }          private int find(int x){         if(p[x] != x) return p[x] = find(p[x]);         return x;     }          private int[] bfs(int node){         int tmp_g1=0, tmp_g2=0; // 홀짝 and 역홀짝 개수세기                  Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();                  queue.offer(node);         visited.add(node);                  while(!queue.isEmpty()){             int curr = queue.poll();             int currSize = board[curr].size();                          if((curr + currSize) % 2 == 0) tmp_g1++;             else tmp_g2++;                          for(int next : board[curr]){                 if(visited.add(next)){                     queue.offer(next);                 }             }         }          return new int[]{tmp_g1, tmp_g2};     } }  "
  },
  
  {
    "title": "LeetCode_2553_Total Cost to Hire K Workers (Java)",
    "url": "/posts/LeetCode2553Total-Cost-to-Hire-K-Workers-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-03-04 14:23:24 +0900",
    "content": "2553. Total Cost to Hire K Workers Medium  You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.  You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:   \tYou will run k sessions and hire exactly one worker in each session. \tIn each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. \t \t\tFor example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2]. \t\tIn the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process. \t \t \tIf there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. \tA worker can only be chosen once.   Return the total cost to hire exactly k workers.  &nbsp; Example 1:   Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. - In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. - In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. - In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11.   Example 2:   Input: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. - In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. - In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. - In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4.   &nbsp; Constraints:   \t1 &lt;= costs.length &lt;= 105  \t1 &lt;= costs[i] &lt;= 105 \t1 &lt;= k, candidates &lt;= costs.length      문제 풀이   왼쪽K개중 최솟값, 오른쪽 K개중 최솟값을 O(1)에 찾으며 삽입시 log(N)으로 정렬하는 최소힙 2개를 사용했다. 그리고 서로의 구간을 침범하지 않게 left&lt;=right를 유지했다.      코드   class Solution {     public long totalCost(int[] costs, int k, int candidates) {         int left, right;         left = 0;         right = costs.length - 1;         PriorityQueue&lt;Integer&gt; left_pq = new PriorityQueue&lt;&gt;();         PriorityQueue&lt;Integer&gt; right_pq = new PriorityQueue&lt;&gt;();                   for(int i=0; i&lt;candidates; i++){             if(left &lt;= right) left_pq.offer(costs[left++]);         }         for(int i=0; i&lt;candidates; i++){             if(left &lt;= right) right_pq.offer(costs[right--]);         }         long res=0;          while(k--&gt;0){             int a, b;             if(left_pq.isEmpty()) {                 res += right_pq.poll();                 continue;             }             else if(right_pq.isEmpty()){                 res += left_pq.poll();                 continue;             }              a = left_pq.peek();             b = right_pq.peek();             if(a &lt;= b) {                 left_pq.poll();                 if(left &lt;= right) left_pq.offer(costs[left++]);                 res+= a;             }                 else if (b &lt; a){                 right_pq.poll();                 if(left &lt;= right) right_pq.offer(costs[right--]);                 res += b;             }         }          return res;     } }  "
  },
  
  {
    "title": "PGMS_59406_동물 수 구하기 (SQL)",
    "url": "/posts/PGMS59406%EB%8F%99%EB%AC%BC-%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-03-04 13:46:15 +0900",
    "content": "[level 2] 동물 수 구하기 - 59406  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; SUM， MAX， MIN  채점결과  Empty  제출 일자  2025년 03월 04일 13:33:54  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          동물 보호소에 동물이 몇 마리 들어왔는지 조회하는 SQL 문을 작성해주세요.   예시  예를 들어 ANIMAL_INS 테이블이 다음과 같다면           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A399552 Dog 2013-10-14 15:38:00 Normal Jack Neutered Male   A379998 Dog 2013-10-23 11:42:00 Normal Disciple Intact Male   A370852 Dog 2013-11-03 15:04:00 Normal Katie Spayed Female   A403564 Dog 2013-11-18 17:03:00 Normal Anna Spayed Female          동물 보호소에 들어온 동물은 4마리입니다. 따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.           count            4          ※ 컬럼 이름(위 예제에서는 count)은 일치하지 않아도 됩니다.    본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   INTAKE_CONDITION가 있으면 세는걸로 생각하고 구했다.     코드   SELECT COUNT(*)     FROM ANIMAL_INS AS ai         WHERE ai.INTAKE_CONDITION IS NOT NULL;  "
  },
  
  {
    "title": "BOJ_1394_암호 (Java)",
    "url": "/posts/BOJ1394%EC%95%94%ED%98%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-04 13:41:20 +0900",
    "content": "[Gold V] 암호 - 1394  문제 링크  성능 요약  메모리: 28008 KB, 시간: 272 ms  분류  조합론, 자료 구조, 해시를 사용한 집합과 맵, 수학, 문자열  제출 일자  2025년 3월 4일 02:42:06  문제 설명  유진이는 현수의 암호를 알아내려고 한다. 유진이는 사전 조사를 통해 임현수의 컴퓨터에 어떤 문자들이 쓰이는지 알아내었고, 하나씩 대입해보려고 한다. 대입하는 순서는 유진이가 메모한 문자 집합의 순서대로이고, 한 글자부터 암호가 풀릴 때까지 모두 대입해본다. 예를 들어, 메모한 문자 집합이 bca라고 한다면, 유진이는 b, c, a, bb, bc, ba, cb, cc, ca, ab, ac, aa, bbb, bbc, ........ 순서로 암호가 풀릴 때까지 계속 대입해본다.  입력  첫 번째 줄에는 암호로 사용할 수 있는 문자가 공백 없이 주어지고, 두 번째 줄에는 컴퓨터의 암호가 주어진다. 암호에 사용할 수 있는 문자의 종류는 최대 100가지이고, 공백은 사용할 수 없다. 영문자는 대소문자를 구분한다. 암호의 길이는 최대 1,000,000자이다.  출력  첫 번째 줄에 주어진 암호를 몇 번의 시도로 풀 수 있는지 출력한다. 만약 수가 클 경우, 시도 횟수를 900528으로 나눈 나머지를 출력한다.     문제 풀이   암호의 길이가 M일때 1~(M-1)까지의 경우의수는 모두 더해줘야한다. 그걸 다 더해주고,  길이 M일땐 각 위치마다 특정 문자가 잇을건데 그 문자 전 개수 x (전체 문자 개수) ^ (남은 길이) 만큼씩 곱해줘야한다.      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static String N, M;     static int N_len, M_len;     static final int MOD = 900528;     static long res = 0;     static Map&lt;Character, Integer&gt; charPos = new HashMap&lt;&gt;();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1394_암호/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = br.readLine();         M = br.readLine();         N_len = N.length();         M_len = M.length();          /*         M_len-1까지 모든 경우의수는 다 더해야함. 길이 0이면 0         나머지 M_len의 경우의수 추가          */          long power = N_len;         for (int i = 1; i &lt; M_len; i++) {             res = (res + power) % MOD;             power = (power * N_len) % MOD;         }          for (int i = 0; i &lt; N_len; i++) {             charPos.put(N.charAt(i), i);         }          long[] weights = new long[M_len];         weights[M_len - 1] = 1;          for(int i = M_len - 2; i &gt;= 0; i--) {             weights[i] = (weights[i + 1] * N_len) % MOD;         }          for (int i = 0; i &lt; M_len; i++) {             char curr = M.charAt(i);             int currPos = charPos.get(curr);              res = (res + (currPos * weights[i]) % MOD) % MOD;          }          // 마지막에 암호 자체도 카운트         res = (res + 1) % MOD;          System.out.println(res);          bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "LeetCode_127_Word Ladder (Java)",
    "url": "/posts/LeetCode127Word-Ladder-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-03-04 13:37:11 +0900",
    "content": "127. Word Ladder Hard  A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk such that:   \tEvery adjacent pair of words differs by a single letter. \tEvery si for 1 &lt;= i &lt;= k is in wordList. Note that beginWord does not need to be in wordList. \tsk == endWord   Given two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.  &nbsp; Example 1:   Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] Output: 5 Explanation: One shortest transformation sequence is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; cog&quot;, which is 5 words long.   Example 2:   Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] Output: 0 Explanation: The endWord &quot;cog&quot; is not in wordList, therefore there is no valid transformation sequence.   &nbsp; Constraints:   \t1 &lt;= beginWord.length &lt;= 10 \tendWord.length == beginWord.length \t1 &lt;= wordList.length &lt;= 5000 \twordList[i].length == beginWord.length \tbeginWord, endWord, and wordList[i] consist of lowercase English letters. \tbeginWord != endWord \tAll the words in wordList are unique.      문제 풀이   Wordlist에 있는 문자들로 탐색을 이어나가야하는데 하나씩 문자가 다른 것들을 찾는 bfs를 생각했다.       코드   class Solution {     public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {         int cnt = 1;          if(!wordList.contains(endWord)) return 0;          Map&lt;String, Integer&gt; visited = new HashMap&lt;&gt;();          Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();         queue.offer(beginWord);         visited.put(beginWord, 0);          while(!queue.isEmpty()){             int size = queue.size();             for(int i=0; i&lt;size; i++){                 String curr = queue.poll();                  if(curr.equals(endWord)) return cnt;                  for(String next : wordList){                     if(!visited.containsKey(next) &amp;&amp; oneDifferent(curr, next)){                         queue.offer(next);                         visited.put(next, 0);                     }                 }             }             cnt ++;         }         return 0;     }      boolean oneDifferent(String curr, String next) {         if(curr.length() != next.length()) return false;          int diffCnt = 0;         for(int i=0; i&lt;curr.length(); i++){             if(curr.charAt(i) != next.charAt(i)) {                 diffCnt ++;                 if(diffCnt &gt; 1) return false;             }         }         return diffCnt == 1;     } }  "
  },
  
  {
    "title": "BOJ_2866_문자열 잘라내기 (Java)",
    "url": "/posts/BOJ2866%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9E%98%EB%9D%BC%EB%82%B4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-04 01:30:52 +0900",
    "content": "[Gold V] 문자열 잘라내기 - 2866  문제 링크  성능 요약  메모리: 304568 KB, 시간: 1100 ms  분류  이분 탐색, 자료 구조, 해시를 사용한 집합과 맵, 문자열  제출 일자  2025년 3월 2일 21:48:02  문제 설명  R개의 행과 C개의 열로 이루어진 테이블이 입력으로 주어진다. 이 테이블의 원소는 알파벳 소문자이다.  각 테이블의 열을 위에서 아래로 읽어서 하나의 문자열을 만들 수 있다. 예제 입력에서  dobarz adatak  이 주어지는 경우 \"da\", \"od\", \"ba\", \"at\", \"ra\", \"zk\"와 같이 6개의 문자열들이 만들어지게 된다.  만약 가장 위의 행을 지워도 테이블의 열을 읽어서 문자열이 중복되지 않는다면, 가장 위의 행을 지워주고, count의 개수를 1 증가시키는, 이 과정을 반복한다. 만약 동일한 문자열이 발견되는 경우, 반복을 멈추고 count의 개수를 출력 후 프로그램을 종료한다.  테이블이 주어질 경우 count의 값을 구해보자.  입력  첫 번째 줄에는 테이블의 행의 개수와 열의 개수인 R과 C가 주어진다. (2 ≤ R, C ≤ 1000)  이후 R줄에 걸쳐서 C개의 알파벳 소문자가 주어진다. 가장 처음에 주어지는 테이블에는 열을 읽어서 문자열을 만들 때, 동일한 문자열이 존재하지 않는 입력만 주어진다.  출력  문제의 설명과 같이 count의 값을 출력한다.     문제 풀이   모든 문자열을 생각해보고 각 문자열을 행마다 Hashset으로 비교했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb;     static int R, C;     static String[] lines;     static ArrayList&lt;String&gt; words;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2866_문자열잘라내기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         R = Integer.parseInt(st.nextToken());         C = Integer.parseInt(st.nextToken());         lines = new String[R];         words = new ArrayList&lt;&gt;();          for (int i = 0; i &lt; R; i++) {             lines[i] = br.readLine();         }          for(int j = 0; j &lt; C; j++) {             sb = new StringBuilder();             for (int i = 0; i &lt; R; i++) {                 sb.append(lines[i].charAt(j));             }             words.add(sb.toString());         }          Set&lt;String&gt; set;         for (int i = 0; i &lt; R; i++) {             set = new HashSet&lt;&gt;();             for (String s: words) {                 String substring = s.substring(i);                 if(!set.add(substring)) {                     System.out.println(i-1);                     return;                 }             }         }         System.out.println(R - 1);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_17420_깊콘이 넘쳐흘러 (Java)",
    "url": "/posts/BOJ17420%EA%B9%8A%EC%BD%98%EC%9D%B4-%EB%84%98%EC%B3%90%ED%9D%98%EB%9F%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-03-01 05:24:18 +0900",
    "content": "[Platinum V] 깊콘이 넘쳐흘러 - 17420  문제 링크  성능 요약  메모리: 41760 KB, 시간: 584 ms  분류  그리디 알고리즘, 정렬  제출 일자  2025년 3월 1일 05:21:19  문제 설명  정우는 생일을 맞아 친구들에게 기프티콘을 N개 선물받았다. 어떤 기프티콘을 언제 쓸지 다 계획을 정해놨는데, 멍청한 정우는 기프티콘에 기한이 있다는 사실을 까맣게 잊고 있었다. 다행히 기프티콘에는 기한 연장 기능이 있다. 한 기프티콘을 한 번 연장할 때마다 기한이 30일씩 늘어난다.  정우는 기프티콘의 기한 연장을 너무 귀찮아하기 때문에, 기한 연장을 최소한으로 하고 싶어한다. 그리고 정우는 강박증이 있어서, 남은 기프티콘 중 기한이 가장 적게 남은 기프티콘만 사용할 수 있다. 단, 기한이 가장 적게 남은 기프티콘이 여러 개라면 그 중 아무거나 선택할 수 있다. 하루에 여러 기프티콘을 사용하거나 연장하는 것 모두 가능하다.  최소 횟수로 기한 연장을 하면서 기프티콘을 다 쓸 수 있도록 정우를 도와주자.  입력  첫째 줄에 기프티콘의 수 N이 주어진다.  둘째 줄에 A1, A2, ..., AN가 주어진다. 이는 i번째 기프티콘의 남은 기한이 Ai일이라는 뜻이다.  셋째 줄에 B1, B2, ..., BN가 주어진다. 이는 i번째 기프티콘을 Bi일 뒤에 사용할 계획이라는 뜻이다.  출력  첫째 줄에 정우가 기한 연장을 해야 하는 최소 횟수를 출력한다.  정답이 32비트 정수를 넘을 수 있으므로 유의하라.     문제 풀이        코드   package BOJ_17420_깊콘이넘쳐흘러;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Gifticon implements Comparable&lt;Gifticon&gt;{         int idx, leftDate, usedDate;         public Gifticon(int idx, int leftDate, int usedDate){             this.idx = idx;             this.leftDate = leftDate;             this.usedDate = usedDate;         }          @Override         public int compareTo(Gifticon o) {             if(this.usedDate == o.usedDate) return this.leftDate - o.leftDate;             return this.usedDate - o.usedDate;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;     static Gifticon[] gifticons;     static long res;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17420_깊콘이넘쳐흘러/input.txt\")));          N = Integer.parseInt(br.readLine());         gifticons = new Gifticon[N];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             gifticons[i] = new Gifticon(i, Integer.parseInt(st.nextToken()), 0);         }         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             gifticons[i].usedDate = Integer.parseInt(st.nextToken());         }          Arrays.sort(gifticons);          int previousMaxLeftDate = gifticons[0].usedDate; // 이전에 쓴 기프티콘들 중 최대 사용일자         int maxLeftDate = 0; // 이전까지 처리된 기프티콘 중 최대 남은 기한         for(int i = 0; i &lt; N; i++){             Gifticon currGifticon = gifticons[i];              /*                 (i번째 기프티콘 남은기한)이 (i-1까지 처리한 남은기한들)보다 커야함. 그래야 이번에 처리순서가 되니까.                 (i번째 기프티콘 남은기한)이 (i-1까지 기프티콘들의 사용일자들)보다 커야함. 그래야 이전에 안써지고 지금써지니까.                 이때 연장해주는것임. 몇번 연장할지는 아래 addCnt로 계산, 지금기프티콘 남은기한은 (연장횟수 * 30)만큼 연장              */              // 남은 기한 &lt; 사용일자 일땐 일단 먼저 연장해야함             if (currGifticon.leftDate &lt; currGifticon.usedDate) {                 /*                 addCnt = 기프티콘 추가횟수                 30일 -&gt; 1번                 31일 ~ 60일 -&gt; 2번                 61일 ~ 90일 -&gt; 3번                  */                 int addCnt = (currGifticon.usedDate - currGifticon.leftDate + 29) / 30;                 currGifticon.leftDate += addCnt * 30;                 res += addCnt;             }              //  현재 기한이 이전 최대값(previousMaxLeftDate)보다 작으면 추가 연장 (이전에 연장해서 써서 지금도 연장해야함을 의미한다)             if(currGifticon.leftDate &lt; previousMaxLeftDate ){                 int addCnt = (previousMaxLeftDate - currGifticon.leftDate + 29) / 30;                 currGifticon.leftDate += addCnt * 30; // 30일연장                 res += addCnt; // 연장횟수 추가             }              // 남은일자             maxLeftDate = Math.max(maxLeftDate, currGifticon.leftDate);              // 다음 기프티콘도 이번 기프티콘과 써야할 일자가 같다면 previousMaxUsedDate 업데이트할필요없음 쭉 같은날 사용             // 그 외 다른 날짜면 업데이트             if(i+1 &lt; N &amp;&amp; gifticons[i].usedDate != gifticons[i+1].usedDate){                 previousMaxLeftDate = maxLeftDate;             }          }          System.out.println(res);     } }  "
  },
  
  {
    "title": "BOJ_14719",
    "url": "/posts/BOJ14719/",
    "categories": "알고리즘",
    "tags": "",
    "date": "2025-02-28 18:56:15 +0900",
    "content": "[Gold V] 빗물 - 14719  문제 링크  성능 요약  메모리: 14316 KB, 시간: 104 ms  분류  구현, 시뮬레이션  제출 일자  2025년 2월 28일 18:39:00  문제 설명  2차원 세계에 블록이 쌓여있다. 비가 오면 블록 사이에 빗물이 고인다.    비는 충분히 많이 온다. 고이는 빗물의 총량은 얼마일까?  입력  첫 번째 줄에는 2차원 세계의 세로 길이 H과 2차원 세계의 가로 길이 W가 주어진다. (1 ≤ H, W ≤ 500)  두 번째 줄에는 블록이 쌓인 높이를 의미하는 0이상 H이하의 정수가 2차원 세계의 맨 왼쪽 위치부터 차례대로 W개 주어진다.  따라서 블록 내부의 빈 공간이 생길 수 없다. 또 2차원 세계의 바닥은 항상 막혀있다고 가정하여도 좋다.  출력  2차원 세계에서는 한 칸의 용량은 1이다. 고이는 빗물의 총량을 출력하여라.  빗물이 전혀 고이지 않을 경우 0을 출력하여라.     문제 풀이     각 위치에서 좌우 최대높이를 저장한 뒤, 그 중 작은 값을 기준으로 물이 고이게 된다. 그리고 고이는 양은 그 위치에서의 높이를 빼주면 된다. 이때 그 위치에서의 높이가 더 크면 고이는 물의 양이 음수로 계산되므로 이를 음수가 아닌 0으로 처리하면 고이지 않는다고 계산이 된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int H, W, height[], maxL, maxR, maxBoard[][], res;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14719_빗물/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         H = Integer.parseInt(st.nextToken());         W = Integer.parseInt(st.nextToken());         height = new int[W];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; W; i++) {             height[i] = Integer.parseInt(st.nextToken());         }          maxBoard = new int[W][2];         maxL = height[0];         maxR = height[W - 1];          for (int i = 0; i &lt; W; i++) {             maxL = (int) Math.max(maxL, height[i]);             maxBoard[i][0] = maxL;         }          for (int i = W-1; i &gt;= 0; i--) {             maxR = (int) Math.max(maxR, height[i]);             maxBoard[i][1] = maxR;         }          int minH; // 각 인덱스에서 좌우 최대높이 중 작은값 (물이 찰 높이)         for (int i = 0; i &lt; W; i++) {             minH = Math.min(maxBoard[i][0], maxBoard[i][1]);             int water = minH - height[i];             res += (water &gt; 0 ? water : 0);         }         System.out.println(res);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_14391_종이 조각 (Java)",
    "url": "/posts/BOJ14391%EC%A2%85%EC%9D%B4-%EC%A1%B0%EA%B0%81-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-28 04:01:14 +0900",
    "content": "[Gold III] 종이 조각 - 14391  문제 링크  성능 요약  메모리: 18520 KB, 시간: 188 ms  분류  비트마스킹, 브루트포스 알고리즘  제출 일자  2025년 2월 27일 22:06:49  문제 설명  영선이는 숫자가 쓰여 있는 직사각형 종이를 가지고 있다. 종이는 1×1 크기의 정사각형 칸으로 나누어져 있고, 숫자는 각 칸에 하나씩 쓰여 있다. 행은 위에서부터 아래까지 번호가 매겨져 있고, 열은 왼쪽부터 오른쪽까지 번호가 매겨져 있다.  영선이는 직사각형을 겹치지 않는 조각으로 자르려고 한다. 각 조각은 크기가 세로나 가로 크기가 1인 직사각형 모양이다. 길이가 N인 조각은 N자리 수로 나타낼 수 있다. 가로 조각은 왼쪽부터 오른쪽까지 수를 이어 붙인 것이고, 세로 조각은 위에서부터 아래까지 수를 이어붙인 것이다.  아래 그림은 4×4 크기의 종이를 자른 한 가지 방법이다.    각 조각의 합은 493 + 7160 + 23 + 58 + 9 + 45 + 91 = 7879 이다.  종이를 적절히 잘라서 조각의 합을 최대로 하는 프로그램을 작성하시오.  입력  첫째 줄에 종이 조각의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 4)  둘째 줄부터 종이 조각이 주어진다. 각 칸에 쓰여 있는 숫자는 0부터 9까지 중 하나이다.  출력  영선이가 얻을 수 있는 점수의 최댓값을 출력한다.     문제 풀이   최대 4*4 개의 비트라고 생각하고 가로를 0, 세로를 1로 두고 숫자를 계산했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, board[][], max;     static int[] dr = {0, 1}, dc = {1, 0};     static int[] visited;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14391_종이조각/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         board = new int[N][M];          for(int i=0; i&lt;N; i++) {             String line = br.readLine();             for(int j=0; j&lt;M; j++) {                 board[i][j] = line.charAt(j) - '0';             }         }          // 가로 0, 세로 1         for(int bitmask = 0; bitmask &lt; (1&lt;&lt; (N*M)); bitmask++){             int sum = 0;             for(int i=0; i&lt;N; i++) {                 int curr = 0;                 for(int j=0; j&lt;M; j++) {                     int bitPos = i * M + j;                     if((bitmask &amp; (1 &lt;&lt; bitPos)) == 0) { // 가로                         curr *= 10;                         curr += board[i][j];                     }                     else{ // 세로                         sum += curr;                         curr = 0;                     }                 }                 sum += curr;             }              for(int j=0; j&lt;M; j++) {                 int curr = 0;                 for(int i=0; i&lt;N; i++) {                     int bitPos = i * M + j;                     if((bitmask &amp; (1 &lt;&lt; bitPos)) != 0) {                         curr *= 10;                         curr += board[i][j];                     }                     else{                         sum += curr;                         curr = 0;                     }                 }                 sum += curr;             }             max = Math.max(max, sum);         }          System.out.println(max);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "디스코드 뮤직 봇 개발 (4)",
    "url": "/posts/%EB%94%94%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%AE%A4%EC%A7%81-%EB%B4%87-%EA%B0%9C%EB%B0%9C-4/",
    "categories": "사이드, 프로젝트",
    "tags": "GCP, PostgreSQL, discord, docker, docker compose",
    "date": "2025-02-26 05:41:42 +0900",
    "content": "   오늘은 문제가 많았던 출석관련 기능을 수정했다. 기존에 사용하던 SQLite 데이터베이스의 한계와 불편함을 느꼈다. 그럼 이번 수정사항과 여러 시행착오를 아래에서 자세히 설명해보겠다.   SQLite에서 PostgreSQL로 마이그레이션 및 Docker Compose 배포기  기존에 사용하던 SQLite 데이터베이스를 PostgreSQL로 전환하고, Docker Compose를 통해 배포 환경을 구축한 과정을 기록하려고 한다.  기존 SQLite로 출석을 관리할때의 문제점은 다음과 같았다.          확장성 부족: SQLite는 단일 파일 기반의 데이터베이스로, 동시 접속이 많아지면 성능이 급격히 저하된다. 특히, 출석체크 기능을 사용하는 사용자가 많아지면, 데이터베이스 연결이 병목 현상이 발생할 수 있다.           비효율적인 출석체크 로직: 매번 데이터베이스 연결을 열고 닫는 방식으로 인해 성능이 저하되었다. 또한, 연속 출석 체크 로직이 복잡하고 비효율적이었다.           한국 시간대 미적용: datetime.now()가 UTC 기준으로 동작하여, 한국 시간대(KST)를 반영하지 못했다. 이로 인해 출석체크 시간이 매우 불편했다.      또한 극한의 함수형 프로그래밍에 의해 파일 구조 문제도 있었다.          단일 파일(main.py)에 모든 로직 집중되었던 점이 문제였다. 모든 코드가 main.py 파일에 작성되어 있어, 유지보수가 어려웠으며, 특히 데이터베이스 연결 로직과 비즈니스 로직이 혼재되어 있어 코드의 재사용성이 떨어졌다.           모듈화 부재로 출석체크, 음성 채널, 음악 재생 등의 기능이 모두 한 파일에 작성되어 있어, 코드도 매우 길고 기능 추가나 수정이 어려웠다.      이에 문제점을 개선하고자 목표를 잡았다.  수정사항 1. 데이터베이스 전환: SQLite → PostgreSQL          PostgreSQL은 확장성이 뛰어나고, 동시 접속 처리에 적합하다.           비동기 처리를 위한 asyncpg 라이브러리 사용했다.      2. 출석체크 로직 개선          한국 시간대(KST) 적용: pytz 라이브러리를 사용하여 한국 시간대를 반영했다           연속 출석 체크 로직 최적화: 매번 전체 데이터를 조회하지 않고, 사용자별 통계를 별도의 테이블(user_stats)로 관리하여 성능을 개선했다.      3. 파일 구조 모듈화          main.py: 봇의 메인 로직을 담당. 봇 초기화 및 명령어 등록 처리.           database.py: 데이터베이스 연결 및 쿼리 실행을 담당.           cogs/attendance.py: 출석체크, 출석 정보 조회, 월간 출석 현황 등의 명령어를 구현           cogs/voice.py: 음성 채널 관련 명령어 모듈 파일      4. Docker Compose를 통한 배포          PostgreSQL과 봇을 Docker 컨테이너로 구성했다.           docker-compose.yml 파일을 작성하여 PostgreSQL과 봇을 컨테이너로 구성했다.        **위 4가지 변경사항을 하나씩 자세히 알아보자! ** 1. 데이터베이스 전환: SQLite → PostgreSQL  먼저 asyncpg 라이브러리를 사용하여 비동기 데이터베이스 연결을 구현했다.  requirements.txt에 추가해주고 라이브러리를 설치해주었다. asyncpg==0.28.0 pytz==2023.3  db 연결 설정은 database.py 파일에서 PostgreSQL 연결을 설정했다. import asyncpg import os from dotenv import load_dotenv  load_dotenv()  class Database:     def __init__(self):         self.pool = None      async def init_db(self):         self.pool = await asyncpg.create_pool(             host=os.getenv('DB_HOST'),             database=os.getenv('DB_NAME'),             user=os.getenv('DB_USER'),             password=os.getenv('DB_PASSWORD')         )   테이블 구조는 다음과 같다.     attendance: 출석 기록 저장.   user_stats: 사용자별 출석 통계 저장.   2. 출석체크 로직 개선  기존의 문제점이었던 한국 시간대 미 반영을 드디어 적용했다. ptyz를 통해 다음과 같이 한국의 시간으로 설정할 수 있다. import pytz kst = pytz.timezone('Asia/Seoul') today = datetime.now(kst).strftime('%Y-%m-%d')   또한 연속 출첵 로직도 어제 출석했는지 확인해 연속 출석일을 계산한다. 그 후 최대 연속 출석일수를 갱신한다. 스트릭이 이어지면 1을 더하고 아니면 1로 초기화한다. async def mark_attendance(self, user_id, date_str):     # 어제 출석했는지 확인     yesterday = (date_obj - timedelta(days=1))     if last_date == yesterday:         current_streak += 1     else:         current_streak = 1   3. 파일 구조 모듈화  기존 main.py에 모든 함수를 담아두었던 함수형 프로그래밍에서 기능별 모듈화를 진행했다.  main.py: 봇 초기화 및 명령어 등록.  database.py: 데이터베이스 연결 및 쿼리 실행.  cogs/attendance.py: 출석체크, 출석 정보 조회, 월간 출석 현황 등의 명령어 구현.  cogs/voice.py: 음성채널 입출력 등의 명령어 구현.  4. Docker Compose 설정  docker-compose.yml을 다음과 같이 구성해주었다. version: \"3\"  services:   db:     image: postgres:14     volumes:       - postgres_data:/var/lib/postgresql/data     environment:       - POSTGRES_PASSWORD=${DB_PASSWORD}       - POSTGRES_USER=${DB_USER}       - POSTGRES_DB=${DB_NAME}     ports:       - \"5432:5432\"     restart: always     healthcheck:       test: [\"CMD-SHELL\", \"pg_isready -U $${DB_USER} -d $${DB_NAME}\"]       interval: 10s       timeout: 5s       retries: 5    bot:     build: .     depends_on:       - db     restart: always     env_file:       - .env  volumes:   postgres_data:    여기서 $$는 찾아보니 다음과 같은 설명을 찾았다.  Docker Compose에서 환경 변수 탈출 처리    Docker Compose 2.x 버전에서는 이중 달러 기호($$)를 사용해 변수가 Docker Compose에 의해 평가되지 않도록 할 수 있습니다:   그리고 환경변수도 .env 에 업데이트해주었다 DISCORD_TOKEN = 디스코드 토큰값 DB_HOST=db DB_NAME=meloD_db DB_USER=nowalex322 DB_PASSWORD=db 비밀번호   트러블 슈팅 1. PostgreSQL 연결 오류          문제: FATAL: role “nowalex322” does not exist           원인: Docker Compose에서 환경 변수가 제대로 확장되지 않음           해결: healthcheck에서 $${DB_USER}와 같이 이중 달러 기호를 사용하여 변수 확장      2. DataGrip 연결 실패          문제: DataGrip에서 PostgreSQL에 접속할 수 없음           원인: Docker 컨테이너 내부에서 Unix 도메인 소켓을 사용하려고 시도           해결: TCP/IP를 통해 연결 (-h localhost 옵션 추가).            docker-compose exec db psql -U nowalex322 -d meloD_db -h localhost       접속이 성공하면 다음과 같은 프롬프트가 나타납니다:           psql (14.0 (Debian 14.0-1.pgdg110+1))   Type “help” for help.      meloD_db=#      3. Docker 권한 문제          문제: PermissionError: [Errno 13] Permission denied           원인: 현재 사용자가 docker 그룹에 속해 있지 않음           해결: 사용자를 docker 그룹에 추가하고 재로그인                     사용자를 docker 그룹에 추가   다음 명령어로 현재 사용자를 docker 그룹에 추가 sudo usermod -aG docker $USER 이 명령어는 현재 사용자($USER)를 docker 그룹에 추가                       변경 사항 적용 그룹 변경 사항을 적용하려면 로그아웃 후 다시 로그인하거나, 다음 명령어로 세션을 재시작 newgrp docker                       변경 사항 확인 다음 명령어로 사용자가 docker 그룹에 추가되었는지 확인합니다: groups 출력 결과에 docker가 포함되어 있어야 합니다. 예를 들어                  nowalex322 adm dialout cdrom floppy audio dip video plugdev netdev lxd ubuntu google-sudoers docker    이후 postgreSQL 잘 됐으면 Datagrip도 연결해볼 수 있다.  그 전에 방화벽 규칙을 만들어야한다.   여기서 방화벽 규칙 만들기를 누르고    다음과 같이 설정해준다.    트래픽 방향: “인그레스” (외부에서 들어오는 트래픽)   작업: “허용”   소스 IP 범위: 내 IP 값 검색해서 넣기(특정 IP에서만 접속 허용하려면)   프로토콜 및 포트: TCP 포트 (PostgreSQL은 기본적으로 TCP 5432 포트 사용)   PostgreSQL의 기본 포트 : 5432   이제 Datagrip에서 새로운 Data Source에서 PostgreSQL 선택하고  연결하기위한 정보 입력해주면 (외부 IP 주소는 VM 인스턴스에서 확인가능)    잘 연결된 것을 볼 수 있다!  빨리 음악 재생까지 완성하고싶다. 그리고 봇을 디벨롭 하면 할수록 욕심이 더 커져 생각보다 스케일이 커지는 것 같다. "
  },
  
  {
    "title": "BOJ_21758_꿀 따기 (Java)",
    "url": "/posts/BOJ21758%EA%BF%80-%EB%94%B0%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-26 00:16:23 +0900",
    "content": "[Gold V] 꿀 따기 - 21758  문제 링크  성능 요약  메모리: 25356 KB, 시간: 272 ms  분류  그리디 알고리즘, 누적 합  제출 일자  2025년 2월 26일 00:04:35  문제 설명  아래와 같이 좌우로 $N$개의 장소가 있다.    장소들 중 서로 다른 두 곳을 골라서 벌을 한 마리씩 둔다. 또, 다른 한 장소를 골라서 벌통을 둔다. 아래 그림에서 연한 회색의 장소는 벌이 있는 장소이고 진한 회색의 장소는 벌통이 있는 장소이다.    두 마리 벌은 벌통으로 똑바로 날아가면서 지나가는 모든 칸에서 꿀을 딴다. 각 장소에 적힌 숫자는 벌이 지나가면서 꿀을 딸 수 있는 양이다.   \t두 마리가 모두 지나간 장소에서는 두 마리 모두 표시된 양 만큼의 꿀을 딴다. (벌통이 있는 장소에서도 같다.) \t벌이 시작한 장소에서는 어떤 벌도 꿀을 딸 수 없다.   위의 그림과 같이 배치된 경우 두 마리의 벌 모두 $4 + 1 + 4 + 9 + 9 = 27$의 꿀을 따서, 전체 꿀의 양은 54가 된다.   위의 그림과 같이 배치된 경우 왼쪽 장소에서 출발한 벌은 $9 + 4 + 4 + 9 + 9 = 35$의 꿀을 따고 오른쪽 장소에서 출발한 벌은 $4 + 9 + 9 = 22$의 꿀을 따므로, 전체 꿀의 양은 $57$이 된다.   위의 그림과 같은 경우는 전체 꿀의 양이 31이 된다.  장소들의 꿀 양을 입력으로 받아 벌들이 딸 수 있는 가능한 최대의 꿀의 양을 계산하는 프로그램을 작성하라.  입력  첫 번째 줄에 장소의 수 $N$이 주어진다.  다음 줄에 왼쪽부터 각 장소에서 꿀을 딸 수 있는 양이 공백 하나씩을 사이에 두고 주어진다.  출력  첫 번째 줄에 가능한 최대의 꿀의 양을 출력한다.     문제 풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, honey[], maxH, totalH, prefixSum[], max;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_21758_꿀따기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         honey = new int[N];         prefixSum = new int[N];         st = new StringTokenizer(br.readLine());         for(int i=0; i&lt;N; i++) {             honey[i] = Integer.parseInt(st.nextToken());             if(maxH &lt; honey[i]) maxH = honey[i];             totalH += honey[i];         }          // 벌통 맨 왼쪽         // basket = 0, fixedBee = N-1;         prefixSum[0] = honey[0];         for(int i=1; i&lt;=N-2; i++){             prefixSum[i] = prefixSum[i-1] + honey[i];         }         for(int i=1; i&lt;=N-2; i++){             if(prefixSum[N-2] + (prefixSum[i-1] - honey[i]) &gt; max) max = prefixSum[N-2] + prefixSum[i-1] - honey[i];         }          // 벌통 맨 오른쪽         Arrays.fill(prefixSum, 0);         prefixSum[N-1] = honey[N-1];         for(int i=N-2; i&gt;=1; i--){             prefixSum[i] = prefixSum[i+1] + honey[i];         }         for(int i=1; i&lt;=N-2; i++){             if(prefixSum[1] + (prefixSum[i+1] - honey[i]) &gt; max) max = prefixSum[1] + prefixSum[i+1] - honey[i];         }          // 벌 좌우 맨 끝         max = Math.max(max, totalH - honey[0] - honey[N-1] + maxH);          System.out.println(max);         bw.flush();         bw.close();         br.close();     } }   "
  },
  
  {
    "title": "PGMS_164671_조회수가 가장 많은 중고거래 게시판의 첨부파일 조회하기 (SQL)",
    "url": "/posts/PGMS164671%EC%A1%B0%ED%9A%8C%EC%88%98%EA%B0%80-%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%80-%EC%A4%91%EA%B3%A0%EA%B1%B0%EB%9E%98-%EA%B2%8C%EC%8B%9C%ED%8C%90%EC%9D%98-%EC%B2%A8%EB%B6%80%ED%8C%8C%EC%9D%BC-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-02-25 21:31:45 +0900",
    "content": "[level 3] 조회수가 가장 많은 중고거래 게시판의 첨부파일 조회하기 - 164671  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; String， Date  채점결과  Empty  제출 일자  2025년 02월 25일 21:28:25  문제 설명  다음은 중고거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고거래 게시판 첨부파일 정보를 담은 USED_GOODS_FILE 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS은 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다.           Column name Type Nullable            BOARD_ID VARCHAR(5) FALSE   WRITER_ID VARCHAR(50) FALSE   TITLE VARCHAR(100) FALSE   CONTENTS VARCHAR(1000) FALSE   PRICE NUMBER FALSE   CREATED_DATE DATE FALSE   STATUS VARCHAR(10) FALSE   VIEWS NUMBER FALSE          USED_GOODS_FILE 테이블은 다음과 같으며 FILE_ID, FILE_EXT, FILE_NAME, BOARD_ID는 각각 파일 ID, 파일 확장자, 파일 이름, 게시글 ID를 의미합니다.           Column name Type Nullable            FILE_ID VARCHAR(10) FALSE   FILE_EXT VARCHAR(5) FALSE   FILE_NAME VARCHAR(256) FALSE   BOARD_ID VARCHAR(10) FALSE            문제  USED_GOODS_BOARD와 USED_GOODS_FILE 테이블에서 조회수가 가장 높은 중고거래 게시물에 대한 첨부파일 경로를 조회하는  SQL문을 작성해주세요. 첨부파일 경로는 FILE ID를 기준으로 내림차순 정렬해주세요. 기본적인 파일경로는 /home/grep/src/ 이며, 게시글 ID를 기준으로 디렉토리가 구분되고, 파일이름은 파일 ID, 파일 이름, 파일 확장자로 구성되도록 출력해주세요. 조회수가 가장 높은 게시물은 하나만 존재합니다.    예시  USED_GOODS_BOARD 테이블이 다음과 같고           BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS            B0001 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250   B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121   B0003 goung12 배드민턴 라켓 사놓고 방치만 해서 팝니다. 9000 2022-10-02 SALE 212   B0004 keel1990 디올 귀걸이 신세계강남점에서 구입. 정품 아닐시 백퍼센트 환불 130000 2022-10-02 SALE 199   B0005 haphli01 스팸클래식 팔아요 유통기한 2025년까지에요 10000 2022-10-02 SALE 121          USED_GOODS_FILE 테이블이 다음과 같을 때           FILE_ID FILE_EXT FILE_NAME BOARD_ID            IMG_000001 .jpg photo1 B0001   IMG_000002 .jpg photo2 B0001   IMG_000003 .png 사진 B0002   IMG_000004 .jpg 사진 B0003   IMG_000005 .jpg photo B0004          SQL을 실행하면 다음과 같이 출력되어야 합니다.           FILE_PATH            /home/grep/src/B0001/IMG_000001photo1.jpg   /home/grep/src/B0001/IMG_000002photo2.jpg              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   서브쿼리로 최대 VIEWS를 구했다. 원래 MAX(VIEWS)가 되는줄 알았는데 안됐다. 그래서 서브쿼리로 진행했다.       코드   SELECT CONCAT('/home/grep/src/', f.BOARD_ID, '/', f.FILE_ID, f.FILE_NAME, f.FILE_EXT) AS FILE_PATH     FROM USED_GOODS_FILE AS f         WHERE BOARD_ID = (SELECT BOARD_ID                             FROM USED_GOODS_BOARD                                 ORDER BY VIEWS DESC                                     LIMIT 1)             ORDER BY f.FILE_ID DESC;  "
  },
  
  {
    "title": "디스코드 뮤직 봇 개발 (3)",
    "url": "/posts/%EB%94%94%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%AE%A4%EC%A7%81-%EB%B4%87-%EA%B0%9C%EB%B0%9C-3/",
    "categories": "사이드, 프로젝트",
    "tags": "CI/CD, discord, systemd",
    "date": "2025-02-25 05:36:00 +0900",
    "content": "출석체크 기능을 사용하다 보니 자정인데도 출석했다고 인식하는 것을 보고 직감적으로 한국 표준 시간대가 설정되지 않았다고 생각했다. 이를 적용하고자 코드를 변경하려고 했고, 그 전에 CI/CD  및 임시배포방법인 tmux 대신 systemd 로 바꾸고자 생각했다.  이에 먼저 다시 기존 설정을 확인해봤는데 이상한 점을 하나 찾았다.  가상환경 디렉토리 구조 확인 ls -la meloD_venv/bin/  현재 실행 중인 프로세스에서 python 경로 확인 ps aux | grep python  를 한 결과 2가지 특징을 발견했다.      가상환경 구조 : meloD_venv/bin/ 디렉토리가 존재하지만, python3가 시스템의 /usr/bin/python3로 심볼릭 링크되어 있는 특이한 구조였다.   현재 실행 프로세스: 프로세스 목록을 보면 python3 main.py로 실행 중이며, 가상환경 경로를 명시적으로 사용하지 않았다.   그래서 다시 제대로 틀을 잡고자 했다.     현재 필요한 패키지 목록 저장            pip freeze &gt; requirements.txt           기존 가상환경 제거            rm -rf meloD_venv           새 가상환경 생성            python3 -m venv meloD_venv --system-site-packages           가상환경 활성화            source meloD_venv/bin/activate           필요한 패키지 설치            pip install -r requirements.txt           잘 설정해주었다.  다시 본론으로 돌아와서, systemd 서비스 설정을 해보자.  Systemd 서비스 설정    GCP 인스턴스에 SSH로 접속        봇 코드 디렉토리로 이동 cd /path/to/your/discord/MeloD           systemd 서비스 파일 생성 sudo nano /etc/systemd/system/meloD.service      내용을 입력 (실제 경로와 사용자명으로 수정)   [Unit] Description=Discord Bot Service After=network.target  [Service] User=YOUR_USERNAME WorkingDirectory=/path/to/your/bot ExecStart=/usr/bin/python3 /path/to/your/bot/main.py Restart=always RestartSec=10 Environment=\"PATH=/path/to/your/venv/bin:$PATH\"  [Install] WantedBy=multi-user.target        서비스 활성화 및 시작   sudo systemctl daemon-reload       # systemd 설정 파일을 새로 읽어들인다. 서비스 파일을 새로 만들거나 수정한 후에 필요한 명령어 sudo systemctl enable meloD  # meloD 서비스를 시스템 부팅 시 자동으로 시작되도록 설정 sudo systemctl start meloD   # meloD 서비스를 즉시 시작      상태 확인 sudo systemctl status discord-bot 잘 작동된다!    서비스가 자동으로 시작되는지 확인까지 해주었다.  GitHub Actions CI/CD 설정    GCP 인스턴스에 SSH 키 설정   # 로컬 컴퓨터에서 실행 ssh-keygen -t rsa -b 4096 -C \"github-actions\" # (키 저장 위치와 비밀번호 입력)      공개 키를 GCP 인스턴스의 authorized_keys에 추가   # 로컬에서 공개 키 확인 cat ~/.ssh/id_rsa.pub  # GCP 인스턴스에서 실행 echo \"복사한_공개키\" &gt;&gt; ~/.ssh/authorized_keys      GitHub 저장소에 비밀 키 추가:      GitHub 저장소 → Settings → Secrets and variables→ New repository secret   이름: SSH_PRIVATE_KEY, 값: 비밀 키 내용(~/.ssh/id_rsa 파일의 내용) ; 주석과 줄바꿈까지 그대로 복사   이름: HOST, 값: GCP 인스턴스 IP            curl -s ifconfig.me 로 확인           이름: USERNAME, 값: GCP 사용자 이름   이름: TARGET_DIR, 값: 봇 코드 디렉토리 경로            ex) /home/nowalex322/MeloD                .github/workflows/deploy.yml 파일 생성: GitHub Actions Workflow (deploy.yml)   name: Deploy to GCP  on:   push:     branches: [ develop ]  # 푸시될 브랜치를 지정, 필자는 develop 브랜치에 푸시될 때 실행  jobs:   deploy:     runs-on: ubuntu-latest     steps:     - name: Checkout code       uses: actions/checkout@v2            - name: Setup SSH       uses: webfactory/ssh-agent@v0.5.4       with:         ssh-private-key: $              - name: Add to known hosts       run: |         mkdir -p ~/.ssh         ssh-keyscan -H $ &gt;&gt; ~/.ssh/known_hosts              - name: Deploy to GCP       run: |         rsync -avz --delete ./ $@$:$              - name: Restart meloD Service       run: |         ssh $@$ 'sudo systemctl restart meloD'     워크플로우가 잘 작동중이다!    한국 시간대 수정 적용     로컬에서 코드 수정            pip install pytz 먼저 실행       Discord 봇 코드에 시간대 관련 수정 적용           # 필요한 import 추가 import pytz  # AttendanceCommands 클래스의 check_attendance 메소드 수정 @app_commands.command(name='출첵', description=\"출석체크\") async def check_attendance(self, interaction: discord.Interaction):     user_id = str(interaction.user.id)          # 한국 시간대 적용     korea_tz = pytz.timezone('Asia/Seoul')     today = datetime.now(korea_tz).strftime('%Y-%m-%d')      conn = sqlite3.connect('attendance.db')     c = conn.cursor()      # 오늘 출석했는지 확인     c.execute('SELECT * FROM attendance WHERE user_id = ? AND attendance_date = ?', (user_id, today))     if c.fetchone():         await interaction.response.send_message(f'{interaction.user.mention} 이미 오늘은 출석체크를 하셨어요!')         conn.close()         return      # 연속 출석 확인 - 여기도 수정     yesterday = (datetime.now(korea_tz) - timedelta(days=1)).strftime('%Y-%m-%d')     c.execute('SELECT streak, total_days FROM attendance WHERE user_id = ? ORDER BY attendance_date DESC LIMIT 1', (user_id,))     result = c.fetchone()          # 나머지 코드는 동일...           수정한 코드를 GitHub에 push           GitHub Actions가 자동으로 코드를 GCP에 배포하고 서비스를 재시작     "
  },
  
  {
    "title": "VSCode에서 Git Bash Terminal 사용 시 시작 경로 오류 해결하기",
    "url": "/posts/VSCode%EC%97%90%EC%84%9C-Git-Bash-Terminal-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%8B%9C%EC%9E%91-%EA%B2%BD%EB%A1%9C-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/",
    "categories": "오류, 해결",
    "tags": "vscode",
    "date": "2025-02-25 03:43:23 +0900",
    "content": "문제 상황 VS Code에서 Git Bash 터미널을 사용할 때 예상치 못한 문제가 발생했다. 터미널이 프로젝트 작업 공간(workspace folder)에서 시작되지 않고 엉뚱한 위치인 C:/Users/[User]/AppData/Local/Programs/Microsoft VS Code에서 시작되는 현상이 발생했다. 이 문제는 Git Bash에만 해당되며, PowerShell이나 cmd 같은 다른 터미널에서는 발생하지 않았다. 또한 HOME 환경변수가 제대로 설정되지 않는 관련 문제도 함께 발생했다.  문제의 증상     Git Bash 터미널이 항상 VS Code 설치 경로에서 시작됨   git 명령어 사용 시 fatal: unable to access 'C:\\Users owal/.config/git/config': Invalid argument 오류 발생   내가 원하는 결과는 상대경로 및 브랜치까지 구분되는 이런 모양을 원했다. 이를 위해 구글링을 했고 Stack OverFlow에서 답을 찾을 수 있었다.  원인 분석 이 문제는 VS Code가 Git Bash를 시작할 때 작업 디렉토리를 올바르게 전달하지 못하는 데서 발생한다. Git Bash는 기본적으로 –cd= 인수가 없으면 Git Bash 실행 파일이 있는 디렉토리나 VS Code 설치 경로에서 시작한다. 문제의 핵심은 Git Bash가 다른 터미널과 달리 작업 디렉토리를 설정하는 특별한 인수(–cd=)를 필요로 한다는 점이다. terminal.integrated.cwd 설정만으로는 이 문제를 해결할 수 없다.  해결방법    Git Bash 프로파일에 시작 인수 추가하기   settings.json 파일에 Git Bash 프로파일을 수정하여 시작 디렉토리를 지정하는 인수를 추가했다.  드래그 한 부분이 새로 추가한 부분이다.  코드로는 \"terminal.integrated.profiles.windows\": {         \"Git Bash\": {             \"source\": \"Git Bash\",             \"args\": [\"--cd=.\"]         }     },  을 바로 붙여넣으면 된다.  결론  Git Bash가 VS Code에서 항상 잘못된 경로에서 시작하는 문제는 프로파일 설정에 시작 디렉토리를 명시적으로 지정하는 인수를 추가함으로써 해결할 수 있다. 이 해결책은 Git Bash를 VS Code의 다른 터미널처럼 현재 작업 공간에서 시작하도록 하여 개발 워크플로우를 원활하게 유지하는 데 도움이 된다.  References     Git Bash in VS Code starts in the wrong folder  "
  },
  
  {
    "title": "LeetCode_584. Find Customer Referee (SQL)",
    "url": "/posts/LeetCode584.-Find-Customer-Referee-SQL/",
    "categories": "SQL",
    "tags": "leetcode, sql",
    "date": "2025-02-25 02:43:00 +0900",
    "content": "584. Find Customer Referee Easy  Table: Customer   +-------------+---------+ | Column Name | Type    | +-------------+---------+ | id          | int     | | name        | varchar | | referee_id  | int     | +-------------+---------+ In SQL, id is the primary key column for this table. Each row of this table indicates the id of a customer, their name, and the id of the customer who referred them.   &nbsp;  Find the names of the customer that are not referred by the customer with id = 2.  Return the result table in any order.  The result format is in the following example.  &nbsp; Example 1:   Input:  Customer table: +----+------+------------+ | id | name | referee_id | +----+------+------------+ | 1  | Will | null       | | 2  | Jane | null       | | 3  | Alex | 2          | | 4  | Bill | null       | | 5  | Zack | 1          | | 6  | Mark | 2          | +----+------+------------+ Output:  +------+ | name | +------+ | Will | | Jane | | Bill | | Zack | +------+      문제 풀이        코드   SELECT name     FROM Customer         WHERE referee_id != 2 || referee_id IS NULL;  "
  },
  
  {
    "title": "LeetCode_1908. Recyclable and Low Fat Products (SQL)",
    "url": "/posts/LeetCode1908.-Recyclable-and-Low-Fat-Products-SQL/",
    "categories": "SQL",
    "tags": "leetcode, sql",
    "date": "2025-02-25 02:41:35 +0900",
    "content": "1908. Recyclable and Low Fat Products Easy  Table: Products   +-------------+---------+ | Column Name | Type    | +-------------+---------+ | product_id  | int     | | low_fats    | enum    | | recyclable  | enum    | +-------------+---------+ product_id is the primary key (column with unique values) for this table. low_fats is an ENUM (category) of type (&#39;Y&#39;, &#39;N&#39;) where &#39;Y&#39; means this product is low fat and &#39;N&#39; means it is not. recyclable is an ENUM (category) of types (&#39;Y&#39;, &#39;N&#39;) where &#39;Y&#39; means this product is recyclable and &#39;N&#39; means it is not.  &nbsp;  Write a solution to find the ids of products that are both low fat and recyclable.  Return the result table in any order.  The result format is in the following example.  &nbsp; Example 1:   Input:  Products table: +-------------+----------+------------+ | product_id  | low_fats | recyclable | +-------------+----------+------------+ | 0           | Y        | N          | | 1           | Y        | Y          | | 2           | N        | Y          | | 3           | Y        | Y          | | 4           | N        | N          | +-------------+----------+------------+ Output:  +-------------+ | product_id  | +-------------+ | 1           | | 3           | +-------------+ Explanation: Only products 1 and 3 are both low fat and recyclable.      문제 풀이        코드   SELECT product_id     FROM Products         WHERE low_fats = 1 AND recyclable = 1;  "
  },
  
  {
    "title": "LeetCode_88_Merge Sorted Array (Java)",
    "url": "/posts/LeetCode88Merge-Sorted-Array-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-02-25 02:40:07 +0900",
    "content": "88. Merge Sorted Array Easy  You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.  Merge nums1 and nums2 into a single array sorted in non-decreasing order.  The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.  &nbsp; Example 1:   Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.   Example 2:   Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1].   Example 3:   Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.   &nbsp; Constraints:   \tnums1.length == m + n \tnums2.length == n \t0 &lt;= m, n &lt;= 200 \t1 &lt;= m + n &lt;= 200 \t-109 &lt;= nums1[i], nums2[j] &lt;= 109   &nbsp; Follow up: Can you come up with an algorithm that runs in O(m + n) time?     문제 풀이        코드   class Solution {     public void merge(int[] nums1, int m, int[] nums2, int n) {         for(int i=0; i&lt;n; i++){             nums1[m+i] = nums2[i];         }         Arrays.sort(nums1);         // System.out.print(Arrays.toString(nums1));     } }  "
  },
  
  {
    "title": "BOJ_3020_개똥벌레 (Java)",
    "url": "/posts/BOJ3020%EA%B0%9C%EB%98%A5%EB%B2%8C%EB%A0%88-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-24 18:38:29 +0900",
    "content": "[Gold V] 개똥벌레 - 3020  문제 링크  성능 요약  메모리: 56196 KB, 시간: 276 ms  분류  이분 탐색, 누적 합  제출 일자  2025년 2월 24일 18:33:26  문제 설명  개똥벌레 한 마리가 장애물(석순과 종유석)로 가득찬 동굴에 들어갔다. 동굴의 길이는 N미터이고, 높이는 H미터이다. (N은 짝수) 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다.  아래 그림은 길이가 14미터이고 높이가 5미터인 동굴이다. (예제 그림)    이 개똥벌레는 장애물을 피하지 않는다. 자신이 지나갈 구간을 정한 다음 일직선으로 지나가면서 만나는 모든 장애물을 파괴한다.  위의 그림에서 4번째 구간으로 개똥벌레가 날아간다면 파괴해야하는 장애물의 수는 총 여덟개이다. (4번째 구간은 길이가 3인 석순과 길이가 4인 석순의 중간지점을 말한다)    하지만, 첫 번째 구간이나 다섯 번째 구간으로 날아간다면 개똥벌레는 장애물 일곱개만 파괴하면 된다.  동굴의 크기와 높이, 모든 장애물의 크기가 주어진다. 이때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하는 프로그램을 작성하시오.  입력  첫째 줄에 N과 H가 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 200,000, 2 ≤ H ≤ 500,000)  다음 N개 줄에는 장애물의 크기가 순서대로 주어진다. 장애물의 크기는 H보다 작은 양수이다.  출력  첫째 줄에 개똥벌레가 파괴해야 하는 장애물의 최솟값과 그러한 구간의 수를 공백으로 구분하여 출력한다.     문제풀이     누적합으로 풀었다. 종유석과 석순 각각 누적합으로 겹치는 공간의 숫자를 세주었다. 그 개수별 map을 만들었고 value에는 그 구간들을 넣어주었다. 그래서 최소 부수는 횟수를 기억하고있다가 마지막에 그 key로 찾아가 들어있는 구간들을 포함하는 list의 크기를 구해주었다.     코드   package BOJ_3020_개똥벌레;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, H, nums[], odd[], even[], count[], min = Integer.MAX_VALUE;     static Map&lt;Integer, List&lt;Integer&gt;&gt; breakMap = new HashMap&lt;&gt;(); // key : 부수는횟수, value : 해당 구간들     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_3020_개똥벌레/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         H = Integer.parseInt(st.nextToken());         nums = new int[N+1];         odd = new int[H+1]; // 홀수번째(석순) 누적합         even = new int[H+1]; // 짝수번째(종유석) 누적합         count = new int[H+1]; // 구간별 부술 개수 누적합배열          for(int i = 1; i &lt;= N; i++) {             nums[i] = Integer.parseInt(br.readLine());         }          for(int i=1; i&lt;=N; i++){             if(i%2 == 1) odd[nums[i]]++;             else even[(H+1) - nums[i]]++;         } //        System.out.println(\"odd : \" + Arrays.toString(odd)); //        System.out.println(\"even : \" + Arrays.toString(even)); //        System.out.println(\"처음까지임\");         // 홀수는 끝부터 누적합         for(int i=H-1; i&gt;=1; i--){             odd[i] += odd[i+1];         }         // 짝수는 처음부터 누적합         for(int i=2; i&lt;=H; i++){             even[i] += even[i-1];         }          for(int i=1; i&lt;=H; i++){             count[i] = odd[i] + even[i];         }          for(int i=1; i&lt;=H; i++){             if(!breakMap.containsKey(count[i])) breakMap.put(count[i], new ArrayList&lt;&gt;());             breakMap.get(count[i]).add(i);             if(min &gt; count[i]) min = count[i];         } //        System.out.println(\"odd : \" + Arrays.toString(odd)); //        System.out.println(\"even : \" + Arrays.toString(even)); //        System.out.println(\"count : \" + Arrays.toString(count));         sb.append(min).append(\" \").append(breakMap.get(min).size());         System.out.println(sb);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "디스코드 뮤직 봇 개발 (2)",
    "url": "/posts/%EB%94%94%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%AE%A4%EC%A7%81-%EB%B4%87-%EA%B0%9C%EB%B0%9C-2/",
    "categories": "사이드, 프로젝트",
    "tags": "GCP, discord, sqlite",
    "date": "2025-02-24 04:00:31 +0900",
    "content": "   이번엔 디스코드 봇을 24/7 가동하기위한 무료 호스팅 서버를 구축하고자 한다. 여러가지 후보군 중 GCP를 선택했다. 일단 평생 무료 + 300$ 크레딧이 가장 압도적인 이유고 쓰기 편하기도 하기 때문에 선정했다.   참고로 300$ 크레딧은 3달 지속된다. 그 뒤엔 무료플랜 사용으로 적용된다.  좀 더 자세한 사용 요건을 보고싶다면 Google Cloud Free cloud features and trial offer  에서 무료플랜 조건을 보자.    먼저 구글 클라우드 플랫폼 에 접속해 사용할 구글 계정으로 로그인하고 결제수단까지 등록한다. 이것도 안하고 300$로만 낼름하려고 한 심보에 반성했다.  무료 인스턴스 생성   사용을 눌러준다.   인스턴스 만들기로 들어가자.  인스턴스 구성하기  이제 인스턴스 정보를 입력해줄건데 프리티어 조건 을 여기서 봤기때문에 똑같이 넣어줄것이다.     리전 : us-west1 (오리건)   영역 : a, b, c 중 아무거나   E2   머신유형 : e2-micro   을 선택해주자.  다음으로 부팅디스크다.   필수조건은    표준 영구 디스크   30GB   로 설정해주고 OS는 사용하고자 하는 것으로 선택하자. 우분투 최신버전 중 범용적인 22.04 LTS 선택했다.  모든 설정이 끝났고 만들어주면 된다.  *PS ARM64랑 x86/64는 무슨차이? 이건 CPU 아키텍쳐 종류다.    x86/64 (=x64, AMD64)            전통적인 데스크톱/랩톱 CPU 아키텍처       Intel, AMD의 일반적인 프로세서       소프트웨어 호환성이 매우 높음       대부분의 서버용 소프트웨어가 기본적으로 지원           ARM64            모바일 기기에서 시작된 아키텍처       전력 효율이 좋음       Apple M1/M2, 서버용 AWS Graviton 등       일부 소프트웨어는 호환성 확인 필요           디스코드 봇을 python으로 개발한 상황에서 x86/64가 더 안전하다고 판단했다. 이유로는    Python 패키지들이 x86/64에서 더 광범위하게 테스트되고 지원된다.   일부 Python 패키지들은 ARM64용 미리 컴파일된 바이너리를 제공하지 않을 수 있다.   특히 C 확장을 사용하는 패키지들(numpy, pandas 등)의 경우 x86/64에서 설치가 더 수월하다.   사실 별 차이는 없다. discord.py같은 기본적인 것만 사용하면 별로 상관없지만 향후 확장성 고려하면 x86/64가 안전한 선택이다.  생성 후 대시보드   결제요금부터 눈에 띄도록 위치 커스텀해줬다.  이제 VM 인스턴스를 다시 들어가서 SSH를 눌러보면 브라우저 콘솔로 터미널을 접속해 편하게 SSH 접속을 할 수 있다.    배포  일단 작성할 명령어를 설명하면서 진행해보겠다     sudo apt update   sudo apt install python3-pip python3-venv git tmux -y   는 우분투 패키지 관리자다. 우리가 쓸 파이썬 패키지관리자 pip, 파이썬 가상환경 생성도구 venv, 레포 관리할 git, 터미널 세션관리하는 tmux (24/7 돌리기) 를 사용하기에 install로 설치해줬으며 -y는 모두 y로 자동응답하는 키워드다.  그 다음에 혹시 이런 화면이 뜰수도 있는데,  우분투 패키지 구성 화면이라 일부 서비스 재시작할 수 있다는것이라 기본값대로 ok선택하고 Enter 눌러주면된다.  파일을 불러오기 위해 git을 사용해 클론해준다.    git clone https://github.com/Kguswo/MeloD.git   필자처럼 디폴트 브랜치가 아닌 특정 개발 브랜치에 있다면 checkout을 해주자.  cd로 이동해준다.    cd MeloD   이제 가상환경을 설정해줄것이다. 활성화해준다.    python3 -m venv meloD_venv   source meloD_venv/bin/activate   그리고 우리가 로컬에서 개발했던 환경과 같에 만들어주고 실행해야하니까 이후 필요한 라이브러리도 받아준다. 이는 requirements.txt에 정리되어있으므로    pip install -r requirements.txt  로 다운받아준다.   디스코드 토큰을 넣기 위해 환경변수 파일 .env가 필요하다. 다음을 통해 생성 후 작성하자.    nano .env : 파일생성   DISCORD_TOKEN= 디스코드 봇 토큰으로 넣기   이후 cat .env로 체크해보자!  어느정도 준비는 끝났다. 이제 tmux로 파일을 실행할건데 새로운 세션을 만들어준다. tmux new -s meloD 그리고 여기서 파일을 실행한다. python3 main.py  이제 이 세션에서 계속 파일이 실행되고있기에 터미널을 닫아도 괜찮다!  다음에 터미널에 접속해 다시 이 세션에 접속하고 싶을땐 attach로 접속가능하다. 명령어는 tmux attach -t meloD 다음과 같다.  계속 이 세션이 살아있는지 보고자  tmux list-sessions 로 확인해보니  계속 동작중임을 확인했다!  SSH키를 생성하고 컴퓨터에 저장한 뒤 터미널로도 접속하고자 한다면 1. 명령어로 로컬에서 새로운 SSH키를 생성한다.          ssh-keygen -t rsa -b 4096 -C \"이메일 주소\" -f ~/.ssh/키 이름 ex) ssh-keygen -t rsa -b 4096 -C “nowalex322@gmail.com” -f ~/.ssh/meloD_gcp_key      명령어 키워드 간단하게 보면            t rsa: RSA 알고리즘 사용       b 4096: 4096비트 키 길이       C \"이메일 주소\": 키에 대한 설명 (일반적으로 이메일)       f ~/.ssh/키 이름: 키 파일 경로 및 이름 (예: gcp_key)           이 명령어를 실행하면 다음과 같은 파일이 생성된다             ~/.ssh/gcp_key: 개인키 (Private Key)       ~/.ssh/gcp_key.pub: 공개키 (Public Key)         2. 공개키를 GCP에 등록                  2.1. GCP 콘솔을 통해 등록     GCP 콘솔에 로그인.   Compute Engine &gt; 메타데이터 &gt; SSH 키 로 이동.   ~/.ssh/gcp_key.pub 파일의 내용을 복사하여 붙여넣기.                     파일 내용 확인 방법: cat ~/.ssh/키이름.pub                       출력 예시: ssh-rsa AAAAB3NzaC1yc2E... 이메일주소                  저장 클릭.   이후 접속 테스트해보면     ssh -i ~/.ssh/meloD_gcp_key nowalex322@melod-instance-20250223-152133  잘 접속된다!     트러블 슈팅    트러블슈팅은 기능 개발과 관련된 문제 해결 과정이기에 위 내용과 무관한 기능개발 내용입니다.   일단 출석체크 기능때문에 생긴 문제 해결 과정이다. 소규모 서버고 메인 기능이 아니기에 간단하게 SQLite로 가볍게 DB를 관리하고자 했기에 출석 관련 내용이 바이너리 코드로 attendance.db에 담겨있었다.  배포 후 새로 db가 생성되면서 당연하게도 출석이 1일차부터 시작하게되었다. FileZilla를 예전에 사용해본적이 있어 옮기고자 했지만 내 눈에 다른것이 눈에 띄었다.    GCP 브라우저 터미널 내부에서 자체적으로 지원하는 파일 업로드 및 다운로드였다. 너무 간편하다고 생각되어 바로 실행해줬지만 문제가 발생했다.  무조건 프로젝트 루트 디렉토리에 파일이 들어간다는 점이다. 여기서 파일을 이동시켜 덮여씌워주면서 해결했지만 다른 여러 방법들도 시도했다.  먼저 scp명령어다. scp attendance.db nowalex322@melod-instance-20250223-152133:~/MeloD/attendance.db  이런식으로 내로컬에 있는 attendance.db 파일을 서버의 attendance.db 파일로 교체하고자 scp (Secure Copy) 명령어를 사용하려고했다. 그런데 계속 can’t be established., Permission denied등 SSH보안관련 오류가 생겼다.  그래서 SSH키를 재설정해 GCP에 등록도 하고 여러번 시도를 했지만 복사가 되지 않았다.  그래서 그냥 파일 업로드 버튼을 눌러 내 로컬에 있는 attendance.db파일을 업로드했다. 루트 디렉토리에 복사되었고 이를 mv 명령어로 기존 파일이 있던 위치로 옮겨주었다. 이때 이름이 같은 파일이기 때문에 내용을 덮어쓴다.  그리고 이제 내가 원하는 데이터 파일이 있는지 확인해야한다.  SQLite 데이터베이스 파일(.db)을 조회하기 위해 Python으로 간단한 스크립트를 작성했다. 데이터베이스의 테이블 목록, 테이블 구조(컬럼명과 데이터 타입), 그리고 데이터 샘플을 조회할 수 있다. 코드는 크게 두 파일로 구성되어 있다.     헬퍼 함수 (sqlite_helper.py)                     connect : SQLite 데이터베이스에 연결                       execute_query : SQL 쿼리를 실행하고 결과를 딕셔너리 형태로 반환                       get_table_info : 특정 테이블의 구조(컬럼명, 데이터 타입 등)를 조회                  메인 스크립트 (check_db.py)                     테이블 목록 조회: sqlite_master 테이블에서 모든 테이블 이름을 가져오기                       테이블 구조 조회: PRAGMA table_info를 사용하여 테이블의 컬럼명과 데이터 타입을 확인                       데이터 샘플 조회: 각 테이블의 상위 5개 행을 조회하여 출력                  결과   파일이 제대로 들어갔고 정상적으로 반영되었다. 아직 출첵 관련 기능 수정할 사항도 많고 개발해야할 기능들도 많아 갈 길이 멀다. "
  },
  
  {
    "title": "BOJ_1727_커플 만들기 (Java)",
    "url": "/posts/BOJ1727%EC%BB%A4%ED%94%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-23 23:41:02 +0900",
    "content": "[Gold II] 커플 만들기 - 1727  문제 링크  성능 요약  메모리: 20392 KB, 시간: 140 ms  분류  다이나믹 프로그래밍, 그리디 알고리즘, 정렬  제출 일자  2025년 2월 23일 23:34:57  문제 설명  여자친구가 없는 남자 n명과 남자친구가 없는 여자 m명을 불러 모아서 이성 친구를 만들어 주기로 하였다. 하지만 아무렇게나 해줄 수는 없고, 최대한 비슷한 성격의 사람들을 짝 지어 주기로 하였다.  당신은 뭔가 알 수 없는 방법으로 각 사람의 성격을 수치화 하는데 성공하였다. 따라서 각 사람의 성격은 어떤 정수로 표현된다. 이와 같은 성격의 수치가 주어졌을 때, 우선 최대한 많은 커플을 만들고, 각 커플을 이루는 두 사람의 성격의 차이의 합이 최소가 되도록 하려 한다. 남자-여자 커플만 허용된다.  입력  첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 줄에는 n명의 남자들의 성격이 주어진다. 그 다음 줄에는 m명의 여자들의 성격이 주어진다. 성격은 1,000,000이하의 자연수이다.  출력  첫째 줄에 성격의 차이의 합의 최솟값을 출력한다.     문제 풀이     풀이가 꽤 난해했다. 인원 짝이 맞으면 정렬해서 다 연결하면 되겠지만 그게 안된다. N과 M이 달라 그때그때 최적의 선택을 해줘야하면서 모든 경우의 수를 고려해야한다. 일단 같은 개수일 땐 이전 1명씩 덜 골랐을때 최적값에서 이번 차이를 더한다. 그러나 인원수 차이날땐 예를들어 i &gt; j일때 이번에 i를 안 고른 최적값인 dp[i-1][j]값이 최적일수도 있고, 혹은 둘 다 안고른 상태에서 이번의 차이를 더해주는 dp[i-1][j-1] + 차이값이 최적일수도 있다. 이를 모두 고려해야한다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, A[], B[], dp[][];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1727_커플만들기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          A = new int[N+1];         B = new int[M+1];         dp = new int[N+1][M+1];         for(int i=1; i&lt;=N; i++) {             for(int j=1; j&lt;=M; j++) {                 dp[i][j] = Integer.MAX_VALUE;             }         }         for(int i = 0; i &lt;= N; i++) {             dp[i][0] = 0;         }         for(int j=0; j &lt;= M; j++) {             dp[0][j] = 0;         }          st = new StringTokenizer(br.readLine());         for(int i=1; i&lt;=N; i++) {             A[i] = Integer.parseInt(st.nextToken());         }         st = new StringTokenizer(br.readLine());         for(int i=1; i&lt;=M; i++) {             B[i] = Integer.parseInt(st.nextToken());         }          Arrays.sort(A, 1, N+1);         Arrays.sort(B, 1, M+1);          dp[0][0] = 0;         for(int i=1; i&lt;=N; i++) {             for(int j=1; j&lt;=M; j++) {                 // 이번에 양쪽 수 맞을때 최대한 많이 매칭 (정렬해서 최적 가정)                 if(i == j) dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1] + Math.abs(A[i] - B[j]));                  // 남자 &gt; 여자                 else if(i &gt; j) dp[i][j] = Math.min(dp[i][j],                         Math.min(dp[i-1][j], // 이번에 선택안함                                 dp[i-1][j-1] + Math.abs(A[i] - B[j]))); // 이번커플매칭                 // 여자 &gt; 남자                 else dp[i][j] = Math.min(dp[i][j],                             Math.min(dp[i][j-1], // 이번에 선택안함                                     dp[i-1][j-1] + Math.abs(A[i] - B[j]))); // 이번커플매칭             }         }          System.out.println(dp[N][M]);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "PGMS_2022 Kakao_코딩 테스트 공부 (Java)",
    "url": "/posts/PGMS2022-Kakao%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EA%B3%B5%EB%B6%80-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-02-23 13:49:02 +0900",
    "content": "[level 3] 코딩 테스트 공부 - 118668  문제 링크  성능 요약  메모리: 54.4 MB, 시간: 13.68 ms  구분  코딩테스트 연습 &gt; 2022 KAKAO TECH INTERNSHIP  채점결과  정확성: 50.0효율성: 50.0합계: 100.0 / 100.0  제출 일자  2025년 02월 23일 13:45:07  문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  당신은 코딩 테스트를 준비하기 위해 공부하려고 합니다. 코딩 테스트 문제를 풀기 위해서는 알고리즘에 대한 지식과 코드를 구현하는 능력이 필요합니다.  알고리즘에 대한 지식은 알고력, 코드를 구현하는 능력은 코딩력이라고 표현합니다. 알고력과 코딩력은 0 이상의 정수로 표현됩니다.  문제를 풀기 위해서는 문제가 요구하는 일정 이상의 알고력과 코딩력이 필요합니다.  예를 들어, 당신의 현재 알고력이 15, 코딩력이 10이라고 가정해보겠습니다.   A라는 문제가 알고력 10, 코딩력 10을 요구한다면 A 문제를 풀 수 있습니다. B라는 문제가 알고력 10, 코딩력 20을 요구한다면 코딩력이 부족하기 때문에 B 문제를 풀 수 없습니다.   풀 수 없는 문제를 해결하기 위해서는 알고력과 코딩력을 높여야 합니다. 알고력과 코딩력을 높이기 위한 다음과 같은 방법들이 있습니다.   알고력을 높이기 위해 알고리즘 공부를 합니다. 알고력 1을 높이기 위해서 1의 시간이 필요합니다. 코딩력을 높이기 위해 코딩 공부를 합니다. 코딩력 1을 높이기 위해서 1의 시간이 필요합니다. 현재 풀 수 있는 문제 중 하나를 풀어 알고력과 코딩력을 높입니다. 각 문제마다 문제를 풀면 올라가는 알고력과 코딩력이 정해져 있습니다. 문제를 하나 푸는 데는 문제가 요구하는 시간이 필요하며 같은 문제를 여러 번 푸는 것이 가능합니다.   당신은 주어진 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 구하려 합니다.  초기의 알고력과 코딩력을 담은 정수 alp와 cop, 문제의 정보를 담은 2차원 정수 배열 problems가 매개변수로 주어졌을 때, 모든 문제들을 풀 수 있는 알고력과 코딩력을 얻는 최단시간을 return 하도록 solution 함수를 작성해주세요.  모든 문제들을 1번 이상씩 풀 필요는 없습니다.  입출력 예 설명을 참고해주세요.    제한사항   초기의 알고력을 나타내는 alp와 초기의 코딩력을 나타내는 cop가 입력으로 주어집니다.   0 ≤ alp,cop ≤ 150  1 ≤ problems의 길이 ≤ 100 problems의 원소는 [alp_req, cop_req, alp_rwd, cop_rwd, cost]의 형태로 이루어져 있습니다. alp_req는 문제를 푸는데 필요한 알고력입니다.   0 ≤ alp_req ≤ 150  cop_req는 문제를 푸는데 필요한 코딩력입니다.   0 ≤ cop_req ≤ 150  alp_rwd는 문제를 풀었을 때 증가하는 알고력입니다.   0 ≤ alp_rwd ≤ 30  cop_rwd는 문제를 풀었을 때 증가하는 코딩력입니다.   0 ≤ cop_rwd ≤ 30  cost는 문제를 푸는데 드는 시간입니다.   1 ≤ cost ≤ 100    정확성 테스트 케이스 제한사항   0 ≤ alp,cop ≤ 20 1 ≤ problems의 길이 ≤ 6   0 ≤ alp_req,cop_req ≤ 20 0 ≤ alp_rwd,cop_rwd ≤ 5 1 ≤ cost ≤ 10    효율성 테스트 케이스 제한사항   주어진 조건 외 추가 제한사항 없습니다.     입출력 예           alp cop problems result            10 10 [[10,15,2,1,2],[20,20,3,3,4]] 15   0 0 [[0,0,2,1,2],[4,5,3,1,2],[4,11,4,0,2],[10,4,0,4,2]] 13            입출력 예 설명  입출력 예 #1   코딩력 5를 늘립니다. 알고력 10, 코딩력 15가 되며 시간이 5만큼 소요됩니다. 1번 문제를 5번 풉니다. 알고력 20, 코딩력 20이 되며 시간이 10만큼 소요됩니다. 15의 시간을 소요하여 모든 문제를 풀 수 있는 알고력과 코딩력을 가질 수 있습니다.   입출력 예 #2   1번 문제를 2번 풉니다. 알고력&nbsp;4, 코딩력&nbsp;2가 되며 시간이 4만큼 소요됩니다. 코딩력&nbsp;3을 늘립니다. 알고력&nbsp;4, 코딩력&nbsp;5가 되며 시간이 3만큼 소요됩니다. 2번 문제를 2번 풉니다. 알고력 10, 코딩력&nbsp;7이 되며 시간이 4만큼 소요됩니다. 4번 문제를 1번 풉니다. 알고력 10, 코딩력 11이 되며 시간이 2만큼 소요됩니다. 13의 시간을 소요하여 모든 문제를 풀 수 있는 알고력과 코딩력을 가질 수 있습니다.     제한시간 안내   정확성 테스트 : 10초 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     처음에는 정렬 문제인줄 알았지만 정렬 기준이 너무 복잡하여 모든 경우의수를 고려해야할 것 같았다. 심지어 +1씩 진행되는 과정이 있어 메모이제이션 dp문제라고 생각했다.     코드   class Solution {     public int solution(int alp, int cop, int[][] problems) {         int maxAl = -1;         int maxCo = -1;         for(int i=0; i&lt;problems.length; i++){             if(problems[i][0] &gt; maxAl) maxAl = problems[i][0];             if(problems[i][1] &gt; maxCo) maxCo = problems[i][1];         }                  // 바로 다 풀수있음         if(alp &gt;= maxAl &amp;&amp; cop &gt;= maxCo) return 0;                  // 최댓값만 능력으로 가지고있어도 됨         if(alp &gt;= maxAl) alp = maxAl;         if(cop &gt;= maxCo) cop = maxCo;                  int[][] time = new int[maxAl + 2][maxCo + 2];         for(int i=alp; i&lt;=maxAl; i++){             for(int j=cop; j&lt;=maxCo; j++){                 time[i][j] = Integer.MAX_VALUE;             }         }         time[alp][cop] = 0;         for(int i=alp; i&lt;=maxAl; i++){             for(int j=cop; j&lt;=maxCo; j++){                 // 1시간에 1 증가                 int currT = time[i][j];                 if(currT == Integer.MAX_VALUE) continue;                                  time[i+1][j] = Math.min(currT + 1, time[i+1][j]);                 time[i][j+1] = Math.min(currT + 1, time[i][j+1]);                                  for(int k=0; k&lt;problems.length; k++){                     int[] currP = problems[k];                                           // 문제 풀 수 있을때                     if(i&gt;=currP[0] &amp;&amp; j&gt;=currP[1]) {                         int nextAl = i + currP[2];                         int nextCo = j + currP[3];                         int nextT = currT + currP[4];                          nextAl = Math.min(nextAl, maxAl);                         nextCo = Math.min(nextCo, maxCo);                          time[nextAl][nextCo] = Math.min(nextT, time[nextAl][nextCo]);                     }                                      }             }         }         return time[maxAl][maxCo];     } }  "
  },
  
  {
    "title": "BOJ_20033_Square, Not Rectangle (Java)",
    "url": "/posts/BOJ20033Square-Not-Rectangle-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-23 01:11:23 +0900",
    "content": "[Gold IV] Square, Not Rectangle - 20033  문제 링크  성능 요약  메모리: 46272 KB, 시간: 396 ms  분류  이분 탐색, 자료 구조, 스택  제출 일자  2025년 2월 23일 01:02:13  문제 설명  A histogram is a polygon made by aligning $N$ adjacent rectangles that share a common base line. Each rectangle is called a bar. The $i$-th bar from the left has width 1 and height $H_i$.  Your goal is to find the area of the largest rectangle contained in the given histogram, such that one of the sides is parallel to the base line.    Figure 1. The histogram given in the example, with the largest rectangle shown on the right.  Actually, no, you have to find the largest square. Since the area of a square is determined by its side length, you are required to output the side length instead of the area.   Figure 2. The histogram given in the example, with the largest square shown on the right.  입력 On the first line, a single integer $N$ is given, where $1 \\le N \\leq 300\\,000$.  On the next line, $N$ space-separated integers $H_1, H_2, \\cdots, H_N$, are given. $H_i$ $(1 \\le H_i \\le 10^9)$ is the height of the $i$-th bar.  출력 Output the side length of the largest square in the histogram, such that one of the sides is parallel to the base line.     문제 풀이     최대 K x K 되는 정사각형 변 길이 K 결정문제다. 파라메트릭 서치 느낌으로 풀었다.     코드   package BOJ_20033_SquareNotRectangle;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, H[];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_20033_SquareNotRectangle/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         H = new int[N];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             H[i] = Integer.parseInt(st.nextToken());         }          int left = 1, right = N;         int res = 0;         while(left &lt;= right) {             int mid = left + (right - left) / 2;             if(isAble(mid)){                 res = mid;                 left = mid + 1;             }             else{                 right = mid - 1;             }         }         System.out.println(res);         bw.flush();         bw.close();         br.close();     }      private boolean isAble(int mid) {         int cnt = 0;         for (int i = 0; i &lt; N; i++) {             if(mid &lt;= H[i]) {                 cnt++;                 if(cnt &gt;= mid) return true;             }             else cnt = 0;         }         return false;     } }  "
  },
  
  {
    "title": "디스코드 뮤직 봇 개발 (1)",
    "url": "/posts/%EB%94%94%EC%8A%A4%EC%BD%94%EB%93%9C-%EB%AE%A4%EC%A7%81-%EB%B4%87-%EA%B0%9C%EB%B0%9C-1/",
    "categories": "사이드, 프로젝트",
    "tags": "discord",
    "date": "2025-02-22 11:10:50 +0900",
    "content": "   디스코드를 애용하는 1인으로서 다양한 봇들은  너무 유용하고 편한 기능이다. 그중에서도 뮤직봇은 대부분의 사용자들이 애용하는 봇이라고 생각한다. 음성채널에서 간단하게 원하는 음악을 스트리밍할 수 있기 때문이다. 그런데 요즘 youtube링크를 붙여넣어도 뮤직봇이 먹통인 경우가 많아 이상함을 느꼈고, 대부분의 봇들이 망가지는 현상을 겪어 직접 봇을 만들어보기로 했다. 잘 작동할지는 아직 모르겠지만 경험삼아 끄적여보았다.   봇 생성  먼저 디스코드 개발자 포털로 들어가 봇을 생성해야한다.  로그인 후 New Application을 클릭하고 원하는 이름을 작성한 뒤 Create를 눌러준다. 이후 좌측 Bot 을 눌러 Add Bot을 해주면 봇이 추가된다.   다음과 같이 사진도 넣어주었다. AI 이미지 생성을 위해 Canva를 사용했다.  여기서 Reset Token을 하면 토큰값이 생성되는데 이 토큰은 봇에 접속하기 위한 고유키이므로 유출되어선 안된다. 잘 저장해주자.  서버에 추가  이제 봇을 디스코드 서버에 추가해보자.  OAuth2 탭을 클릭 후 봇의 권한을 체크하고 URL을 생성해주면 된다.    다음과 같이 골랐는데 이유는 먼저 bot체크는 필수고, applications.commands는 /텍스트 형식으로 작동하던 명령어 방식대신 슬래시 명령어로 /를 치고 명령어를 골라 작동시키기 위해 추가했다.  그러면 맨 아래 Generated URL 이 생길것이고 이 주소를 복사붙여넣기해 들어가면 원하는 서버에 봇을 추가할 수 있다.    일단 오프라인이지만 서버에 잘 추가된 모습이다.  이후 레포지토리에는 여러 이슈와 커밋으로 나누어두었지만 지금까지 개발된 상황을 요약하고자 한다.  일단 source meloD_env/Scripts/activate 로 가상환경을 활성화해주고 python main.py 로 실행해주면?   제대로 봇이 동작하며 디스코드에서도 보면  온라인으로 바뀌어 명령어를 실행할 수 있게 된다.    봇 실행  기본 명령어  먼저 슬래시 명령어를 일반 채팅채널에서 사용해보자. / 를 입력하면 자동으로 사용가능 명령어가 나오는데  각각 사용해보면   다음과 같이 잘 작동하는 것을 볼 수 있다! 슬래시 명령어는 UX적으로 접근성이 편하고 물리적 부담감을 줄여주기 때문에 이렇게 변경하였고, 출력도 임베드로 깔끔한 UI가 반영되도록 했다.  텍스트 템플릿은 생성형 AI를 사용했는데 나름 레퍼런스를 여러개 넣어주니 다음과 같이 이모지도 사용해 잘 작성해주었다. 명령어들은 추후 추가하며 어떻게 바뀔지 모르겠지만 수정 가능성이 높다.  출석 기능 출석 기능도 살펴보자. 소규모기 때문에 간단하게 python으로 SQLite를 사용해 구현했다. 이미 출첵을 해버려서 이전에 슬래시 명령어로 변경하기전 출첵했던 기록을 가져왔다. 사진에 보이듯 기존 명령어는 /출첵 이런식으로 전부 작성해야해서 물리적 피로도가 높다.    음성 채팅방 기능  다음 기능으로 음성채팅 채널에 참가한 후 사용가능한 명령어를 테스트해보자.    이렇게 입퇴장을 개발하면서 먼저 되는지 구현을 해 본 것이고 이것조차 입장, 퇴장으로 구분한건 매우 UX적으로 귀찮기 때문에 다음과 같이 변경할 예정이다.     노래 재생 시 자동 입장 ex) /재생 [URL] -&gt; 입장해서 노래 재생   음악을 특정시간동안 재생하지 않거나, 음성채팅방이 특정시간 비었을 때 자동 퇴장      여기까지 디스코드 봇을 구현해 봤는데 생각보다 레퍼런스도 많고 재밌게 개발했다. 지금은 파이썬 코드를 실행시켜야 작동가능하므로 향후 배포하여 24/7의 봇이 되어 여러 사람들이 사용할 수 있는 봇이 될때까지 해보아야겠다.  "
  },
  
  {
    "title": "BOJ_12991_홍준이의 행렬 (Java)",
    "url": "/posts/BOJ12991%ED%99%8D%EC%A4%80%EC%9D%B4%EC%9D%98-%ED%96%89%EB%A0%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-20 16:30:22 +0900",
    "content": "[Gold I] 홍준이의 행렬 - 12991  문제 링크  성능 요약  메모리: 31356 KB, 시간: 552 ms  분류  이분 탐색, 매개 변수 탐색  제출 일자  2025년 2월 20일 16:26:32  문제 설명  홍준이에게는 길이가 N인 수열 2개 A와 B가 있습니다. 이때 N2 크기의 행렬을 만드는데, 행렬의 i행 j열의 원소는 수열 A의 i번째 원소와 수열 B의 j번째 원소의 곱으로 정의합니다. 홍준이는 이 원소들을 모두 정렬하였습니다.  홍준이는 정렬된 결과에서 K번째(1번부터 계산)에 위치하는 값이 궁금해졌습니다. 하지만 계산이 느린 홍준이는 정렬하는데 너무 시간이 오래 걸리기 때문에 여러분에게 도움을 요청하였습니다. 홍준이를 도와 K번째 원소의 값을 구하는 프로그램을 작성하세요.  입력  첫째 줄에 N과 K가 주어집니다. (1 ≤ N ≤ 30000, 1 ≤ K ≤ N2)  둘째 줄에 수열 A의 원소를 나타내는 N개의 정수가 공백을 사이에 두고 주어집니다.  셋째 줄에 수열 B의 원소를 나타내는 N개의 정수가 공백을 사이에 두고 주어집니다.  각 수열의 원소들은 1 이상 10억 이하의 자연수입니다.  출력  N2 크기의 행렬에서 K번째로 작은 수의 값을 출력합니다.     문제 풀이     이분탐색을 2번 활용해주었다.     코드   package BOJ_12991_홍준이의행렬;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K;     static long res;     static long[] A, B;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_12991_홍준이의행렬/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());         A = new long[N];         B = new long[N];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             A[i] = Long.parseLong(st.nextToken());         }         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             B[i] = Long.parseLong(st.nextToken());         }          Arrays.sort(A);         Arrays.sort(B);          long left, right;         left = A[0] * B[0];         right = A[N - 1] * B[N - 1];          while (left &lt;= right) {             long mid = left + (right - left) / 2;             if (count(mid)) {                 res = mid;                 right = mid - 1;             } else {                 left = mid + 1;             }         }          System.out.println(res);         bw.flush();         bw.close();         br.close();     }      private boolean count(long target) {         int cnt = 0;         for (int i = 0; i &lt; N; i++) {             int tmp = 0;             int left = 0, right = N - 1;             while (left &lt;= right) {                 int mid = left + (right - left) / 2;                 if (A[i] * B[mid] &lt;= target) {                     tmp = mid + 1;                     left = mid + 1;                 } else {                     right = mid - 1;                 }             }             cnt += tmp;         }         return cnt &gt;= K;     } }  "
  },
  
  {
    "title": "PGMS_요격 시스템 (Java)",
    "url": "/posts/PGMS%EC%9A%94%EA%B2%A9-%EC%8B%9C%EC%8A%A4%ED%85%9C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-02-20 15:28:18 +0900",
    "content": "[level 2] 요격 시스템 - 181188  문제 링크  성능 요약  메모리: 182 MB, 시간: 516.01 ms  구분  코딩테스트 연습 &gt; 연습문제  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 02월 20일 15:24:28  문제 설명  A 나라가 B 나라를 침공하였습니다. B 나라의 대부분의 전략 자원은 아이기스 군사 기지에 집중되어 있기 때문에 A 나라는 B 나라의 아이기스 군사 기지에 융단폭격을 가했습니다. A 나라의 공격에 대항하여 아이기스 군사 기지에서는 무수히 쏟아지는 폭격 미사일들을 요격하려고 합니다. 이곳에는 백발백중을 자랑하는 요격 시스템이 있지만 운용 비용이 상당하기 때문에 미사일을 최소로 사용해서 모든 폭격 미사일을 요격하려 합니다. A 나라와 B 나라가 싸우고 있는 이 세계는 2 차원 공간으로 이루어져 있습니다. A 나라가 발사한 폭격 미사일은 x 축에 평행한 직선 형태의 모양이며 개구간을 나타내는 정수 쌍 (s, e) 형태로 표현됩니다. B 나라는 특정 x 좌표에서 y 축에 수평이 되도록 미사일을 발사하며, 발사된 미사일은 해당 x 좌표에 걸쳐있는 모든 폭격 미사일을 관통하여 한 번에 요격할 수 있습니다. 단, 개구간 (s, e)로 표현되는 폭격 미사일은 s와 e에서 발사하는 요격 미사일로는 요격할 수 없습니다. 요격 미사일은 실수인 x 좌표에서도 발사할 수 있습니다. 각 폭격 미사일의 x 좌표 범위 목록 targets이 매개변수로 주어질 때, 모든 폭격 미사일을 요격하기 위해 필요한 요격 미사일 수의 최솟값을 return 하도록 solution 함수를 완성해 주세요.    제한 사항   1 ≤ targets의 길이 ≤ 500,000 targets의 각 행은 [s,e] 형태입니다.   이는 한 폭격 미사일의 x 좌표 범위를 나타내며, 개구간 (s, e)에서 요격해야 합니다. 0 ≤ s &lt; e ≤ 100,000,000      입출력 예           targets result            [[4,5],[4,8],[10,14],[11,13],[5,12],[3,7],[1,4]] 3            입출력 예 설명   위 그림과 같이 최소 세 번의 요격 미사일 발사로 전부 방어할 수 있습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   처음에는 시작점을 기준으로 정렬했는데 특정 케이스들이 틀렸다고 나왔다. 여러 케이스들을 생각해보니 1~10 후 2~3, 4~5, 6~7 이런 케이스들에 대해 참 애매한것이다. 예를들어 이때 끝은 10으로 기준인데 차례로 끝이 3, 끝이 5, 끝이 7이므로 내부에 포함된다고 볼 수 있을텐데 그게 아니라 각각 다른 미사일을 써야한다. 이에 끝점을 기준으로 정렬했다.  끝점을 기준으로 정렬해 시작점이 이전 끝점과 교차되어 포함되면 한 미사일로 처리가능하다. 그게 아니면 새로 끝점기준을 갱신한다.     코드   import java.util.*;  class Solution {     class Gap implements Comparable&lt;Gap&gt;{         int start, end;         public Gap(int start, int end){             this.start = start;             this.end = end;         }                  @Override         public int compareTo(Gap o){             return this.end - o.end;         }     }     static Gap[] gaps;     public int solution(int[][] targets) {         int res = 1;         gaps = new Gap[targets.length];         for(int i=0; i&lt;targets.length; i++){             gaps[i] = new Gap(targets[i][0], targets[i][1]);         }                  Arrays.sort(gaps);                  // int s = gaps[0].start;         int e = gaps[0].end;                   for(int i=1; i&lt;gaps.length; i++){             int currS = gaps[i].start;             int currE = gaps[i].end;                          if(e &gt; currS) continue;             else{                 res++;                 e = currE;             }         }                  return res;     } }  "
  },
  
  {
    "title": "BOJ_14258_XOR 그룹 (Java)",
    "url": "/posts/BOJ14258XOR-%EA%B7%B8%EB%A3%B9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-19 16:43:55 +0900",
    "content": "[Platinum V] XOR 그룹 - 14258  문제 링크  성능 요약  메모리: 56844 KB, 시간: 1544 ms  분류  자료 구조, 분리 집합, 오프라인 쿼리  제출 일자  2025년 2월 19일 16:39:34  문제 설명  N*M 격자에 서로 다른 수가 하나씩 들어가 있다. XOR 그룹이라는 것을 정의를 하여 합을 최대로 하려한다. XOR 그룹이란 위, 아래, 오른쪽, 왼쪽으로 인접한 칸에 수가 있다면, 그 칸과 연결되어 그 수를 모두 XOR한 값을 가지는 그룹이 된다. 만약, 중간에 수가 빠져있으면, 연결이 되지 않으므로, 한 격자판에 여러 XOR 그룹이 있을 수 있다.  이제 격자판에서 작은 수부터 제거해 나갈 것이다. 하나를 지울 때 마다 XOR 그룹이 변하는데, XOR그룹의 값의 합의 최대가 될 때, 그 값을 구하여라.  입력  첫째 줄에 n, m이 주어진다.(1 ≤ n, m ≤ 1,000)  다음 n줄에는 격자의 i번째 줄의 수 m개가 주어진다. 수는 1,000,000보다 크지 않은 음이 아닌 정수이다.  출력  XOR 그룹의 값의 합이 최대가 되는 값을 구하여라     문제 풀이     제일 작은수를 제거해나가는 대신 빈 칸에서 제일 큰수를 넣어가며 진행했다. 이때 그룹을 이루는 것끼리 union-find로 진행할 수 있다.     코드   코드 1 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Cell implements Comparable&lt;Cell&gt; {         int r, c, val;         public Cell(int r, int c, int val) {             this.r = r;             this.c = c;             this.val = val;         }          @Override         public int compareTo(Cell o) {             return o.val - this.val;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static long res;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, 1, -1};     static int[] parent; // parent[i] = i값의 대표     static long[] XOR; // XOR[px] = 대표px그룹의 XOR값     static int[][] board;     static boolean[][] visited;     static Cell[] cells;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14258_XOR그룹/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         board = new int[N][M];         visited = new boolean[N][M];          parent = new int[1000001];         XOR = new long[1000001];         for(int i=0; i&lt; parent.length; i++){             parent[i] = i;         }          cells = new Cell[N*M];         for(int i=0; i&lt;N; i++) {             st = new StringTokenizer(br.readLine());             for(int j=0; j&lt;M; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());                 cells[i*M + j] = new Cell(i, j, board[i][j]);             }         }         Arrays.sort(cells);          long sum = 0;         for(Cell c : cells) {             int currR = c.r, currC = c.c;             int currVal = c.val;              visited[currR][currC] = true;             XOR[currVal] = currVal;             sum += currVal;              for(int k=0; k&lt;4; k++) {                 int nextR = currR + dr[k];                 int nextC = currC + dc[k];                 if(nextR &gt;= 0 &amp;&amp; nextR &lt; N &amp;&amp; nextC &gt;= 0 &amp;&amp; nextC &lt; M &amp;&amp; visited[nextR][nextC]) {                     int nextVal = board[nextR][nextC];                      int px = find(currVal);                     int py = find(nextVal);                      // 부모가 다르면 병합해야함                     if(px != py){                         sum -= XOR[px];                         sum -= XOR[py];                          union(currVal, nextVal);                          sum += XOR[find(currVal)];                     }                 }             }             res = Math.max(sum, res);         }         System.out.println(res);         bw.flush();         bw.close();         br.close();     }      public int find(int x){         if(parent[x] != x) return parent[x] = find(parent[x]);         return parent[x];     }      public void union(int x, int y){         int px = find(x);         int py = find(y);         if(px == py) return;          if(px &lt; py){             parent[py] = px;             XOR[px] ^= XOR[py];         }         else{             parent[px] = py;             XOR[py] ^= XOR[px];         }     } }     코드 2 (빠른 입출력) /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Cell implements Comparable&lt;Cell&gt; {         int r, c, val;         public Cell(int r, int c, int val) {             this.r = r;             this.c = c;             this.val = val;         }          @Override         public int compareTo(Cell o) {             return o.val - this.val;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static long res;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, 1, -1};     static int[] parent; // parent[i] = i값의 대표     static long[] XOR; // XOR[px] = 대표px그룹의 XOR값     static int[][] board;     static boolean[][] visited;     static Cell[] cells;     static FastReader fr;     public class FastReader {         private final DataInputStream din;         private final byte[] buffer;         private int bufferPointer, bytesRead;          public FastReader() {             din = new DataInputStream(System.in);             buffer = new byte[16384];             bufferPointer = bytesRead = 0;         }          private byte read() throws IOException {             if (bufferPointer == bytesRead)                 fillBuffer();             return buffer[bufferPointer++];         }          private void fillBuffer() throws IOException {             bytesRead = din.read(buffer, bufferPointer = 0, buffer.length);             if (bytesRead == -1)                 buffer[0] = -1;         }          public int nextInt() throws IOException {             int ret = 0;             byte c = read();             while (c &lt;= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do {                 ret = ret * 10 + c - '0';             } while ((c = read()) &gt;= '0' &amp;&amp; c &lt;= '9');             return neg ? -ret : ret;         }     }      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         fr = new FastReader();         N = fr.nextInt();         M = fr.nextInt();         board = new int[N][M];         visited = new boolean[N][M];          parent = new int[1000001];         XOR = new long[1000001];         for(int i=0; i&lt; parent.length; i++){             parent[i] = i;         }          cells = new Cell[N*M];         for(int i=0; i&lt;N; i++) {             for(int j=0; j&lt;M; j++) {                 board[i][j] = fr.nextInt();                 cells[i*M + j] = new Cell(i, j, board[i][j]);             }         }         Arrays.sort(cells);          long sum = 0;         for(Cell c : cells) {             int currR = c.r, currC = c.c;             int currVal = c.val;              visited[currR][currC] = true;             XOR[currVal] = currVal;             sum += currVal;              for(int k=0; k&lt;4; k++) {                 int nextR = currR + dr[k];                 int nextC = currC + dc[k];                 if(nextR &gt;= 0 &amp;&amp; nextR &lt; N &amp;&amp; nextC &gt;= 0 &amp;&amp; nextC &lt; M &amp;&amp; visited[nextR][nextC]) {                     int nextVal = board[nextR][nextC];                      int px = find(currVal);                     int py = find(nextVal);                      // 부모가 다르면 병합해야함                     if(px != py){                         sum -= XOR[px];                         sum -= XOR[py];                          union(currVal, nextVal);                          sum += XOR[find(currVal)];                     }                 }             }             res = Math.max(sum, res);         }         System.out.println(res);     }      public int find(int x){         if(parent[x] != x) return parent[x] = find(parent[x]);         return parent[x];     }      public void union(int x, int y){         int px = find(x);         int py = find(y);         if(px == py) return;          if(px &lt; py){             parent[py] = px;             XOR[px] ^= XOR[py];         }         else{             parent[px] = py;             XOR[py] ^= XOR[px];         }     } }  "
  },
  
  {
    "title": "BOJ_2457_공주님의 정원 (Java)",
    "url": "/posts/BOJ2457%EA%B3%B5%EC%A3%BC%EB%8B%98%EC%9D%98-%EC%A0%95%EC%9B%90-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-19 04:27:31 +0900",
    "content": "[Gold III] 공주님의 정원 - 2457  문제 링크  성능 요약  메모리: 22040 KB, 시간: 268 ms  분류  그리디 알고리즘, 정렬  제출 일자  2025년 2월 19일 04:11:26  문제 설명  오늘은 공주님이 태어난 경사스러운 날이다. 왕은 이 날을 기념하기 위해 늘 꽃이 피어있는 작은 정원을 만들기로 결정했다.  총 N개의 꽃이 있는 데, 꽃은 모두 같은 해에 피어서 같은 해에 진다. 하나의 꽃은 피는 날과 지는 날이 정해져 있다. 예를 들어, 5월 8일 피어서 6월 13일 지는 꽃은 5월 8일부터 6월 12일까지는 꽃이 피어 있고, 6월 13일을 포함하여 이후로는 꽃을 볼 수 없다는 의미이다. (올해는 4, 6, 9, 11월은 30일까지 있고, 1, 3, 5, 7, 8, 10, 12월은 31일까지 있으며, 2월은 28일까지만 있다.)  이러한 N개의 꽃들 중에서 다음의 두 조건을 만족하는 꽃들을 선택하고 싶다.   \t공주가 가장 좋아하는 계절인 3월 1일부터 11월 30일까지 매일 꽃이 한 가지 이상 피어 있도록 한다. \t정원이 넓지 않으므로 정원에 심는 꽃들의 수를 가능한 적게 한다.    N개의 꽃들 중에서 위의 두 조건을 만족하는, 즉 3월 1일부터 11월 30일까지 매일 꽃이 한 가지 이상 피어 있도록 꽃들을 선택할 때, 선택한 꽃들의 최소 개수를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에는 꽃들의 총 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 각 꽃이 피는 날짜와 지는 날짜가 주어진다. 하나의 날짜는 월과 일을 나타내는 두 숫자로 표현된다. 예를 들어서, 3 8 7 31은 꽃이 3월 8일에 피어서 7월 31일에 진다는 것을 나타낸다.   출력  첫째 줄에 선택한 꽃들의 최소 개수를 출력한다. 만약 두 조건을 만족하는 꽃들을 선택할 수 없다면 0을 출력한다.     문제 풀이     날짜를 정렬한다. 정렬 기준은 시작일을 오름차순, 끝일을 내림차순으로.  모든 날짜가 연속되도록 만들었다.  이후 선택을할건데 최대한 지금까지 한 구간이랑 한 날짜라도 겹쳐야하고 이후 뒤로 기간이 늘어야하므로 이걸 flag로 체크하면서 진행.     코드   코드 1 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Flower implements Comparable&lt;Flower&gt;{         int start, end;         public Flower(int start, int end){             this.start = start;             this.end = end;         }          @Override         public int compareTo(Flower o) {             if(this.start == o.start) return o.end - this.end;             return this.start - o.start;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, START, END, res;     static int[] monthPrefix = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30}; // 1~11월     static Flower[] flowers;     static boolean flag=true; // 가능하면 true     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2457_공주님의정원/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          // m월 0일         for(int i=1; i&lt;monthPrefix.length; i++) {             monthPrefix[i] += monthPrefix[i-1];         } //        System.out.println(Arrays.toString(monthPrefix));         START = monthPrefix[2] + 1;         END = monthPrefix[10] + 30;          N = Integer.parseInt(br.readLine());         flowers = new Flower[N];         int m1, d1, m2, d2;         for(int i=0; i&lt;N; i++) {             st = new StringTokenizer(br.readLine());             m1 = Integer.parseInt(st.nextToken());             d1 = Integer.parseInt(st.nextToken());             m2 = Integer.parseInt(st.nextToken());             d2 = Integer.parseInt(st.nextToken());             flowers[i] = new Flower(monthPrefix[m1-1] + d1, monthPrefix[m2-1] + d2);         }          Arrays.sort(flowers);          int currEnd = START;         int idx = 0;         while(currEnd &lt;= END &amp;&amp; flag) {             int nextEnd = currEnd;             while(idx &lt; N &amp;&amp; flowers[idx].start &lt;= currEnd){                 if(nextEnd &lt; flowers[idx].end){                     nextEnd = flowers[idx].end;                 }                 idx++;             }              // 발전이 없음             if(nextEnd == currEnd) flag = false;             else {                 res++;                 currEnd = nextEnd;             }         }         System.out.println(flag? res : 0);         bw.flush();         bw.close();         br.close();     } }     코드 2(빠른입출력)  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static class FastReader {         private final DataInputStream din;         private final byte[] buffer;         private int bufferPointer, bytesRead;          public FastReader() {             din = new DataInputStream(System.in);             buffer = new byte[16384];             bufferPointer = bytesRead = 0;         }          private byte read() throws IOException {             if (bufferPointer == bytesRead)                 fillBuffer();             return buffer[bufferPointer++];         }          private void fillBuffer() throws IOException {             bytesRead = din.read(buffer, bufferPointer = 0, buffer.length);             if (bytesRead == -1)                 buffer[0] = -1;         }          public int nextInt() throws IOException {             int ret = 0;             byte c = read();             while (c &lt;= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do {                 ret = ret * 10 + c - '0';             } while ((c = read()) &gt;= '0' &amp;&amp; c &lt;= '9');             return neg ? -ret : ret;         }     }     class Flower implements Comparable&lt;Flower&gt;{         int start, end;         public Flower(int start, int end){             this.start = start;             this.end = end;         }          @Override         public int compareTo(Flower o) {             if(this.start == o.start) return o.end - this.end;             return this.start - o.start;         }     }     static FastReader fr;     static int N, START, END, res;     static int[] monthPrefix = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30}; // 1~11월     static Flower[] flowers;     static boolean flag=true; // 가능하면 true     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         fr = new FastReader();          // m월 0일         for(int i=1; i&lt;monthPrefix.length; i++) {             monthPrefix[i] += monthPrefix[i-1];         } //        System.out.println(Arrays.toString(monthPrefix));         START = monthPrefix[2] + 1;         END = monthPrefix[10] + 30;          N = fr.nextInt();         flowers = new Flower[N];         int m1, d1, m2, d2;         for(int i=0; i&lt;N; i++) {             m1 = fr.nextInt();             d1 = fr.nextInt();             m2 = fr.nextInt();             d2 = fr.nextInt();             flowers[i] = new Flower(monthPrefix[m1-1] + d1, monthPrefix[m2-1] + d2);         }          Arrays.sort(flowers);          int currEnd = START;         int idx = 0;         while(currEnd &lt;= END &amp;&amp; flag) {             int nextEnd = currEnd;             while(idx &lt; N &amp;&amp; flowers[idx].start &lt;= currEnd){                 if(nextEnd &lt; flowers[idx].end){                     nextEnd = flowers[idx].end;                 }                 idx++;             }              // 발전이 없음             if(nextEnd == currEnd) flag = false;             else {                 res++;                 currEnd = nextEnd;             }         }         System.out.print(flag? res : 0);     } }  "
  },
  
  {
    "title": "BOJ_17485_진우의 달 여행 (Large) (Java)",
    "url": "/posts/BOJ17485%EC%A7%84%EC%9A%B0%EC%9D%98-%EB%8B%AC-%EC%97%AC%ED%96%89-Large-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-19 02:33:41 +0900",
    "content": "[Gold V] 진우의 달 여행 (Large) - 17485  문제 링크  성능 요약  메모리: 18468 KB, 시간: 196 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 2월 19일 02:30:21  문제 설명  우주비행이 꿈이였던 진우는 음식점 '매일매일싱싱'에서 열심히 일한 결과 달 여행에 필요한 자금을 모두 마련하였다! 지구와 우주사이는 N X M 행렬로 나타낼 수 있으며 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료의 양이다.  [예시]    진우는 여행경비를 아끼기 위해 조금 특이한 우주선을 선택하였다. 진우가 선택한 우주선의 특징은 아래와 같다.  1. 지구 -&gt; 달로 가는 경우 우주선이 움직일 수 있는 방향은 아래와 같다.    2. 우주선은 전에 움직인 방향으로 움직일 수 없다. 즉, 같은 방향으로 두번 연속으로 움직일 수 없다.  진우의 목표는 연료를 최대한 아끼며 지구의 어느위치에서든 출발하여 달의 어느위치든 착륙하는 것이다.  최대한 돈을 아끼고 살아서 달에 도착하고 싶은 진우를 위해 달에 도달하기 위해 필요한 연료의 최소값을 계산해 주자.  입력  첫줄에 지구와 달 사이 공간을 나타내는 행렬의 크기를 나타내는 N, M (2 ≤ N, M ≤ 1000)이 주어진다.  다음 N줄 동안 각 행렬의 원소 값이 주어진다. 각 행렬의 원소값은 100 이하의 자연수이다.  출력  달 여행에 필요한 최소 연료의 값을 출력한다.     문제 풀이     간단한 3차원 dp문제다. 이전 방향을 포함해서 고려해야하기때문이다     코드   코드 1 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, dp[][][], res = Integer.MAX_VALUE;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17485_진우의달여행Large/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         dp = new int[N+1][M+1][3];          for(int i = 1; i &lt;= N; i++) {             for(int j = 1; j &lt;= M; j++) {                 for(int k=0; k &lt; 3; k++) {                     dp[i][j][k] = Integer.MAX_VALUE;                 }             }         }           for(int i=1; i&lt;=N; i++) {             if(i==1){                 st = new StringTokenizer(br.readLine());                 for(int j=1; j&lt;=M; j++){                     int num = Integer.parseInt(st.nextToken());                     for(int k=0; k&lt;3; k++) {                         dp[i][j][k] = num;                     }                 }             }             else{                 st = new StringTokenizer(br.readLine());                 for(int j=1; j&lt;=M; j++) {                     int num = Integer.parseInt(st.nextToken());                     // 밑으로 |                     dp[i][j][0] = Math.min(dp[i-1][j][1], dp[i-1][j][2]) + num;                     // 왼오\\방향                     if(j&gt;=2) dp[i][j][1] = Math.min(dp[i-1][j-1][0], dp[i-1][j-1][2]) + num;                     // 오왼/ 방향                     if(j&lt;M) dp[i][j][2] = Math.min(dp[i-1][j+1][0], dp[i-1][j+1][1]) + num;                 }             }         }          for(int j=1; j&lt;=M; j++) {             for(int k=0; k&lt;3; k++) {                 res = Math.min(res, dp[N][j][k]);             }         }         System.out.println(res);         bw.flush();         bw.close();         br.close();     } }     코드 2 (빠른 입출력) /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, dp[][][], res = Integer.MAX_VALUE;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17485_진우의달여행Large/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         dp = new int[N+1][M+1][3];          for(int i = 1; i &lt;= N; i++) {             for(int j = 1; j &lt;= M; j++) {                 for(int k=0; k &lt; 3; k++) {                     dp[i][j][k] = Integer.MAX_VALUE;                 }             }         }           for(int i=1; i&lt;=N; i++) {             if(i==1){                 st = new StringTokenizer(br.readLine());                 for(int j=1; j&lt;=M; j++){                     int num = Integer.parseInt(st.nextToken());                     for(int k=0; k&lt;3; k++) {                         dp[i][j][k] = num;                     }                 }             }             else{                 st = new StringTokenizer(br.readLine());                 for(int j=1; j&lt;=M; j++) {                     int num = Integer.parseInt(st.nextToken());                     // 밑으로 |                     dp[i][j][0] = Math.min(dp[i-1][j][1], dp[i-1][j][2]) + num;                     // 왼오\\방향                     if(j&gt;=2) dp[i][j][1] = Math.min(dp[i-1][j-1][0], dp[i-1][j-1][2]) + num;                     // 오왼/ 방향                     if(j&lt;M) dp[i][j][2] = Math.min(dp[i-1][j+1][0], dp[i-1][j+1][1]) + num;                 }             }         }          for(int j=1; j&lt;=M; j++) {             for(int k=0; k&lt;3; k++) {                 res = Math.min(res, dp[N][j][k]);             }         }         System.out.println(res);         bw.flush();         bw.close();         br.close();     } }     "
  },
  
  {
    "title": "BOJ_1256_사전 (Java)",
    "url": "/posts/BOJ1256%EC%82%AC%EC%A0%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-19 01:00:03 +0900",
    "content": "[Gold II] 사전 - 1256  문제 링크  성능 요약  메모리: 14240 KB, 시간: 104 ms  분류  조합론, 다이나믹 프로그래밍, 수학  제출 일자  2025년 2월 19일 00:49:23  문제 설명  동호와 규완이는 212호에서 문자열에 대해 공부하고 있다. 김진영 조교는 동호와 규완이에게 특별 과제를 주었다. 특별 과제는 특별한 문자열로 이루어 진 사전을 만드는 것이다. 사전에 수록되어 있는 모든 문자열은 N개의 \"a\"와 M개의 \"z\"로 이루어져 있다. 그리고 다른 문자는 없다. 사전에는 알파벳 순서대로 수록되어 있다.  규완이는 사전을 완성했지만, 동호는 사전을 완성하지 못했다. 동호는 자신의 과제를 끝내기 위해서 규완이의 사전을 몰래 참조하기로 했다. 동호는 규완이가 자리를 비운 사이에 몰래 사전을 보려고 하기 때문에, 문자열 하나만 찾을 여유밖에 없다.  N과 M이 주어졌을 때, 규완이의 사전에서 K번째 문자열이 무엇인지 구하는 프로그램을 작성하시오.  입력  첫째 줄에 세 정수 N, M, K가 순서대로 주어진다.  출력  첫째 줄에 규완이의 사전에서 K번째 문자열을 출력한다. 만약 규완이의 사전에 수록되어 있는 문자열의 개수가 K보다 작으면 -1을 출력한다.     문제 풀이     combination 수를 구했다.     코드   package BOJ_1256_사전;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M, K, res;     static long combCnt;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1256_사전/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());          N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());          combCnt = combCnt(N+M, N, M);         if(K &gt; combCnt) {             System.out.println(-1);             return;         }          int aCnt=N, zCnt=M;          long cnt = 0;         for(int i=0; i&lt;N+M; i++){              if(aCnt == 0) {                 sb.append('z');                 continue;             }             else if(zCnt == 0){                 sb.append('a');                 continue;             }              if(aCnt &gt; 0) cnt = combCnt(aCnt + zCnt - 1, aCnt -1, zCnt);              if(K &lt;= cnt){                 System.out.println(\"cnt = \" + cnt);                 sb.append('a');                 System.out.println(sb);                 aCnt--;             }             else{                 System.out.println(\"cnt = \" + cnt);                 sb.append('z');                 System.out.println(sb);                 zCnt--;                 K -= cnt;                 System.out.println(\"K = \" + K);             }         }         System.out.println(sb);         bw.flush();         bw.close();         br.close();     }      private long combCnt(int total, int a, int z) { // 조합 개수세기         int m = Math.min(a, z);         long cnt=1;         for(int i=1; i&lt;=m; i++) { //            if(cnt &gt;= Long.MAX_VALUE/(total-m+i)) return 1000000001;             cnt = cnt * (total-m+i)/i;             if(cnt &gt; 1000000000) return 1000000001;         }         return cnt;     } }  "
  },
  
  {
    "title": "BOJ_24230_트리 색칠하기 (Java)",
    "url": "/posts/BOJ24230%ED%8A%B8%EB%A6%AC-%EC%83%89%EC%B9%A0%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-16 20:57:03 +0900",
    "content": "[Gold V] 트리 색칠하기 - 24230  문제 링크  성능 요약  메모리: 105944 KB, 시간: 1624 ms  분류  깊이 우선 탐색, 그래프 이론, 그래프 탐색, 트리  제출 일자  2025년 2월 16일 20:52:11  문제 설명  정점이  $N$개인 트리가 있다. 정점에는 1부터  $N$까지 번호가 붙어있다. 트리의 루트는 항상 1번 정점이며 맨 처음에는 모든 정점이 하얀색으로 칠해져 있는 상태이다.&lt;/p&gt;  하나의 정점에 색칠하면 해당 정점 아래 있는 모든 정점이 같은 색으로 칠해진다. 색은 섞이지 않고 색칠할 때마다 그 색으로 덮어진다. 단, 하얀색으로 색칠할 수는 없다.  아래 그림처럼 정점 10개로 구성된 트리가 있다고 가정을 해보자.    [그림 1] 하얀색으로 칠해져 있는 트리  3번 정점을 노란색으로 칠하면 그 아래 있는 정점 5, 6, 8, 9, 10 모두 노란색으로 칠해진다.    [그림 2] 정점 3에 노란색을 칠한 후 트리의 상태  그리고 정점 5에 파란색을 칠한다면 그 아래 있는 정점 8, 9, 10 모두 파란색으로 칠해진다.    [그림 3] 정점 5에 파란색을 칠한 후 트리의 상태  입력으로 트리의 정보와 정점의 색 정보가 주어진다. 색 정보는 음이 아닌 정수로 주어지며 값이 0인 경우는 항상 하얀색을 의미한다.  하얀색을 제외한 색만 사용해서 모든 정점을 주어진 색으로 칠하고 싶을 때 최소 몇 번 색을 칠해야 모든 정점을 원하는 색으로 칠할 수 있는지 구해보자.  입력  첫째 줄에 트리를 구성하는 정점의 개수  $N(1 ≤ N ≤ 200,000)$이 주어진다.  둘째 줄에 1번 정점부터  $N$번 정점까지 각 색 정보  $C_i (0 ≤ C_i ≤ N)$가 공백으로 구분되어 주어진다.  셋째 줄부터  $N - 1$개의 줄에 걸쳐 연결된 두 정점  $a, b(1 ≤ a, b ≤ N$,  $a ≠ b)$가 공백으로 구분되어 주어진다.  모든 정점을 칠할 수 있는 입력만 주어진다.  출력  하얀색을 제외한 색만 사용해서 모든 정점을 원하는 색으로 칠하기 위해 최소 몇 번 칠하면 되는지 출력한다.     문제풀이   위에서부터 dfs로 색칠하면된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, node, a, b, res;     static int[] colors;     static List&lt;Integer&gt;[] tree;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_24230_트리색칠하기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         colors = new int[N+1];         st = new StringTokenizer(br.readLine());         for(int i=1; i&lt;=N; i++) {             colors[i] = Integer.parseInt(st.nextToken());         }          tree = new ArrayList[N+1];         for(int i=1; i&lt;=N; i++) {             tree[i] = new ArrayList&lt;&gt;();         }          for(int i=0; i&lt;N-1; i++) {             st = new StringTokenizer(br.readLine());             a = Integer.parseInt(st.nextToken());             b = Integer.parseInt(st.nextToken());             tree[a].add(b);             tree[b].add(a);         }          dfs(1, 0, 0);          System.out.println(res);         bw.flush();         bw.close();         br.close();     }      private void dfs(int curr, int parent, int color) {         if(colors[curr] != colors[parent]) res++;          for(int node : tree[curr]) {             if(node != parent) dfs(node, curr, colors[curr]);         }     } }  "
  },
  
  {
    "title": "PGMS_루시와 엘라 찾기 (SQL)",
    "url": "/posts/PGMS%EB%A3%A8%EC%8B%9C%EC%99%80-%EC%97%98%EB%9D%BC-%EC%B0%BE%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-02-16 01:41:05 +0900",
    "content": "[level 2] 루시와 엘라 찾기 - 59046  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; String， Date  채점결과  Empty  제출 일자  2025년 02월 16일 01:35:27  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          동물 보호소에 들어온 동물 중 이름이 Lucy, Ella, Pickle, Rogan, Sabrina, Mitty인 동물의 아이디와 이름, 성별 및 중성화 여부를 조회하는 SQL 문을 작성해주세요.   예시  이때 결과는 아이디 순으로 조회해주세요. 예를 들어 ANIMAL_INS 테이블이 다음과 같다면           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A373219 Cat 2014-07-29 11:43:00 Normal Ella Spayed Female   A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female   A353259 Dog 2016-05-08 12:57:00 Injured Bj Neutered Male   A354540 Cat 2014-12-11 11:48:00 Normal Tux Neutered Male   A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female          SQL문을 실행하면 다음과 같이 나와야 합니다.            ANIMAL_ID NAME SEX_UPON_INTAKE            A373219 Ella Spayed Female   A377750 Lucy Spayed Female            본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     IN 을 사용해서 풀었다.     코드   SELECT ai.ANIMAL_ID, ai.NAME, ai.SEX_UPON_INTAKE     FROM ANIMAL_INS AS ai         WHERE ai.NAME IN ('Lucy', 'Ella', 'Pickle', 'Rogan', 'Sabrina', 'Mitty')             ORDER BY ai.ANIMAL_ID ASC;  "
  },
  
  {
    "title": "BOJ_10159_저울 (Java)",
    "url": "/posts/BOJ10159%EC%A0%80%EC%9A%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-15 18:45:19 +0900",
    "content": "[Gold IV] 저울 - 10159  문제 링크  성능 요약  메모리: 15012 KB, 시간: 144 ms  분류  깊이 우선 탐색, 플로이드–워셜, 그래프 이론, 그래프 탐색, 최단 경로  제출 일자  2025년 2월 15일 18:40:57  문제 설명  무게가 서로 다른 N 개의 물건이 있다. 각 물건은 1부터 N 까지 번호가 매겨져 있다. 우리는 일부 물건 쌍에 대해서 양팔 저울로 어떤 것이 무거운 것인지를 측정한 결과표를 가지고 있다. 이 결과표로부터 직접 측정하지 않은 물건 쌍의 비교 결과를 알아낼 수도 있고 알아내지 못할 수도 있다. 예를 들어, 총 6개의 물건이 있고, 다음 5개의 비교 결과가 주어졌다고 가정하자. ([1]은 1번 물건의 무게를 의미한다.)  [1]&gt;[2], [2]&gt;[3], [3]&gt;[4], [5]&gt;[4], [6]&gt;[5]  우리는 [2]&gt;[3], [3]&gt;[4]로부터 [2]&gt;[4]라는 것을 알 수 있다. 하지만, 물건 2와 물건 6을 비교하는 경우, 앞서의 결과만으로는 어느 것이 무거운지 알 수 없다. 이와 같이, 물건 2는 물건 1, 3, 4와의 비교 결과는 알 수 있지만, 물건 5, 6과의 비교 결과는 알 수 없다. 물건 4는 모든 다른 물건과의 비교 결과를 알 수 있다.   비교 결과가 모순되는 입력은 없다고 가정한다. 위 예제의 기존 측정 결과에 [3]&gt;[1]이 추가되었다고 가정하자. 이 경우 [1]&gt;[2], [2]&gt;[3]이므로 우리는 [1]&gt;[3]이라는 것을 예측할 수 있는데, 이는 기존에 측정된 결과 [3]&gt;[1]과 서로 모순이므로 이러한 입력은 가능하지 않다.   물건의 개수 N 과 일부 물건 쌍의 비교 결과가 주어졌을 때, 각 물건에 대해서 그 물건과의 비교 결과를 알 수 없는 물건의 개수를 출력하는 프로그램을 작성하시오.   입력  첫 줄에는 물건의 개수 N 이 주어지고, 둘째 줄에는 미리 측정된 물건 쌍의 개수 M이 주어진다. 단, 5 ≤ N ≤ 100 이고, 0 ≤ M ≤ 2,000이다. 다음 M개의 줄에 미리 측정된 비교 결과가 한 줄에 하나씩 주어진다. 각 줄에는 측정된 물건 번호를 나타내는 두 개의 정수가 공백을 사이에 두고 주어지며, 앞의 물건이 뒤의 물건보다 더 무겁다.  출력  여러분은 N개의 줄에 결과를 출력해야 한다. i 번째 줄에는 물건 i 와 비교 결과를 알 수 없는 물건의 개수를 출력한다.     문제 풀이   연결 그래프를 입력받을 때 대소 비교를 오름차순과 내림차순을 구분하여 입력했다. 기본 compareTo의 구현을 생각해 오름차순은 -1, 내림차순은 1로 설정해 2차원 배열에 입력했다. 이후 각 정점마다 dfs를 두번씩 실행해 각 방향에 대해서만 진행해 몇개의 정점을 갈 수 있는지 체크했다. 그 cnt값에 1을 더하면 본인 포함 대소비교가 가능한 정점의 개수가 나오고 문제에서 요구하는 값은 N-(cnt+1)값이므로 그렇게 Stringbuilder에 append해주었다.       코드   package BOJ_10159_저울;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M, board[][], cnt;     static boolean visited[];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_10159_저울/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         M = Integer.parseInt(br.readLine());         board = new int[N + 1][N + 1];         int u, v;         for (int i = 0; i &lt; M; i++) {             st = new StringTokenizer(br.readLine());             u = Integer.parseInt(st.nextToken());             v = Integer.parseInt(st.nextToken());             board[u][v] = -1;             board[v][u] = 1;         }          for (int i = 1; i &lt;= N; i++) {             cnt = 0;             // 오름차순             visited = new boolean[N + 1];             dfs(i, i, -1);              // 내림차순             visited = new boolean[N + 1];             dfs(i, i, 1);              sb.append(N - (cnt + 1)).append(\"\\n\");         }          System.out.println(sb);         bw.flush();         bw.close();         br.close();     }      private void dfs(int start, int curr, int dir) { // dir -1이면 더 큰수찾기, 1이면 더 작은수찾기         visited[start] = true;          for (int next = 1; next &lt;= N; next++) {             if (!visited[next] &amp;&amp; board[curr][next] == dir) {                 cnt++;                 visited[next] = true;                 dfs(start, next, dir);             }         }     } }  "
  },
  
  {
    "title": "PGMS_올바른 괄호의 갯수 (Java)",
    "url": "/posts/PGMS%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8%EC%9D%98-%EA%B0%AF%EC%88%98-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-02-15 04:03:30 +0900",
    "content": "[level 4] 올바른 괄호의 갯수 - 12929  문제 링크  성능 요약  메모리: 85.5 MB, 시간: 0.21 ms  구분  코딩테스트 연습 &gt; 연습문제  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 02월 15일 04:00:25  문제 설명  올바른 괄호란 (())나 ()와 같이 올바르게 모두 닫힌 괄호를 의미합니다. )(나 ())() 와 같은 괄호는 올바르지 않은 괄호가 됩니다. 괄호 쌍의 개수 n이 주어질 때, n개의 괄호 쌍으로 만들 수 있는 모든 가능한 괄호 문자열의 갯수를 반환하는 함수 solution을 완성해 주세요.  제한사항   괄호 쌍의 개수 N : 1 ≤ n ≤ 14, N은 정수     입출력 예           n result            2 2   3 5          입출력 예 설명  입출력 예 #1 2개의 괄호쌍으로 [ \"(())\", \"()()\" ]의 2가지를 만들 수 있습니다. 입출력 예 #2 3개의 괄호쌍으로 [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ]의 5가지를 만들 수 있습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        코드   import java.util.*;  class Solution {     public int solution(int n) {         int answer = 0;         int[] cnt = new int[n+1];                  cnt[0] = 1;         cnt[1] = 1;          for(int i=2; i&lt;=n; i++){             for(int j=0; j&lt;=i-1; j++){                 cnt[i] += cnt[j] * cnt[i-j-1];             }         }         System.out.print(Arrays.toString(cnt));         return cnt[n];     } }  "
  },
  
  {
    "title": "BOJ_2600_구슬게임 (Java)",
    "url": "/posts/BOJ2600%EA%B5%AC%EC%8A%AC%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-15 02:08:11 +0900",
    "content": "[Gold IV] 구슬게임 - 2600  문제 링크  성능 요약  메모리: 15164 KB, 시간: 132 ms  분류  다이나믹 프로그래밍, 게임 이론  제출 일자  2025년 2월 15일 02:05:23  문제 설명  두 사람 A와 B가 번갈아 가면서 두 개의 구슬 통에서 몇 개씩의 구슬을 꺼내는 게임을 한다.  한번에 한 사람이 한 통에서 꺼낼 수 있는 구슬의 개수는 세 가지 뿐이다. 그리고 구슬을 꺼낼 경우 두 개의 구슬 통 중에서 하나를 마음대로 선택해서 그 안에서만 꺼낼 수 있다. 즉 두 개의 통 모두에서 동시에 몇 개씩 꺼낼 수는 없다.  게임은 항상 A가 먼저하고 그 다음 B, 그 다음 A 순으로 번갈아가면서 진행된다. 그리고 자신의 차례가 되었을 때에 정해진 규칙대로 구슬을 꺼낼 수 없는 사람이 게임에서 지게 되고, 상대방은 승리하게 된다.  예를 들어 한번에 꺼낼 수 있는 구슬의 개수를 1개, 3개, 또는 4개라고 하자. 만일 두 개의 구슬 통에 각각 4개, 1개의 구슬이 있다고 하면 처음 선택을 하게 되는 A가 이긴다. 그러나 만일 두 통속의 구슬이 각각 5개, 5개라면 B가 이긴다.  즉 한번에 꺼낼 수 있는 구슬 개수인 b1, b2, b3가 주어지고, 두 구슬 통 속에 들어있는 구슬의 수인 k1, k2이 정해지면, 이러한 b1, b2, b3와 k1, k2에 따라서 승패는 결정된다. 문제는 주어진 b1, b2, b3와 k1, k2에 대하여 A, B중 누가 승자인지를 결정하는 것이다.  처음 두 통 속에 들어 있는 구슬의 수 k1, k2와 한 번에 꺼낼 수 있는 구슬의 수 b1, b2, b3에 대한 제한조건은 다음과 같다.   \t1 ≤ b1 &lt; b2 &lt; b3 ≤ 30  \t1 ≤ k1, k2 ≤500   입력  첫 줄에는 한번에 꺼낼 수 있는 구슬의 개수를 나타내는 세 개의 정수 b1, b2, b3 가 나타난다. 그 다음 5개의 각 줄에는 두 통속에 처음 담겨있는 구슬의 개수 k1, k2가 각각 표시되어 있다.  출력  각 5개의 k1, k2 경우에 대하여 그에 대응되는 승자(A 또는 B)를 각각 한 줄에 하나씩 차례대로 다섯 개를 출력해야 한다.     문제풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int[] marble = new int[3];     static boolean[][] dp;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2600_구슬게임/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         for(int i=0; i&lt;3; i++) {             marble[i] = Integer.parseInt(st.nextToken());         }          Arrays.sort(marble);         dp = new boolean[501][501]; // A입장에서 false패배 true승리          dp[0][0] = false;         for(int i=0; i&lt;501; i++) {             for(int j=0; j&lt;501; j++) {                 if(i &lt; marble[0] &amp;&amp; j &lt; marble[0]){                     dp[i][j] = false;                     continue;                 }                 boolean canwin = false;                  // 왼쪽주머니 선택                 for(int k=0; k&lt;3 &amp;&amp; !canwin; k++){                     if(i &gt;= marble[k] &amp;&amp; !dp[i-marble[k]][j]) canwin = true;                 }                  // 오른쪽주머니 선택                 for(int k=0; k&lt;3 &amp;&amp; !canwin; k++){                     if(j &gt;= marble[k] &amp;&amp; !dp[i][j-marble[k]]) canwin = true;                 }                  dp[i][j] = canwin;             }         }          for(int q=0; q&lt;5; q++){             st = new StringTokenizer(br.readLine());             int k1 = Integer.parseInt(st.nextToken());             int k2 = Integer.parseInt(st.nextToken());             sb.append(dp[k1][k2] ? \"A\" : \"B\").append(\"\\n\");         }         System.out.println(sb);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (9)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-9/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-02-13 03:06:42 +0900",
    "content": "   Transport Layer - (6)   TCP Intuition    보내는 TCP에서 받는 양을 조절한다. 파이프마다 굵기가 다 다른데 가장 얇은 파이프에서 병목현상이 발생할 확률이 높기 때문에 그 부분이 critical point이다. 하지만 그 부분을 우리가 알 순 없다.  처음에 1방울, 2방울 이렇게 천천히 늘려가본다. 그러다가 한계를 느끼게 되는 구간에 오면 그 구간에서 비슷하게 유지해본다.    TCP Congestion Control    TCP Congestion Control : 3 Phase  1. Slow Start    먼저 1부터 시작하여 2의 거듭제곱으로 키워간다. 1, 2, 4, …   그 후 조심해야할 포인트 Threshold에 다다르면 이제 조심해야한다. 그래서 linear한 직선으로 Addictive increase를 적용시킨다. 이렇게 전송하는 양 (Window Size)를 늘려나간다.   어느순간 패킷이 안가는 등의 Loss가 탐지되면 전송하는 Window Size를 절반으로 확 줄인다. (Multiplicative Decrease)   이 절반한 값을 새 Threshold로 설정한 뒤 다시 1부터 slow start부터 반복한다.   이 3단계 과정을 계속 반복한다 …   MSS(Maximum Segment Size)    500 Byte   즉 세그먼트는 최대 500바이트의 크기를 가질 수 있다.   위에서 언급한 1, 2, 4도 이 세그먼트 크기를 말한다.   TCP가 처음에 연결이 되면 Send Buffer, Receive Buffer 2개가 생긴다. 이걸로 데이터를 주고받고 하는것이다. 여기서 전송하는 데이터 양을 결정하는 것은 Window Size(ACK를 받지 않고 한번에 보낼 수 있는 데이터 양) 이다.  그래서 Slow Start가 1, 2, 4 인 것은 MSS가 1, 2, 4개라는 것을 의미.  1, 2, 4, 8, 16, 32, 64, 128, …      Q : 이렇게 왔다갔다 안하고 최적의 구간을 쭉 보내면 안될까? A : 불가능해서 이렇게 하는 것이다. 그 최적의 전송 양도 일정한게 아니라 네트워크 상황이나 라우터 등 여러 조건과 상황에 따라 달라지기 때문에 항상 변동되어야 한다. 최적의 구간을 찾기위해 이 3단계를 무한 반복 해야만 하는 상황.    TCP Congestion Control : Details   RTT는 전송 후 왔다갔다 시간. 그 시간만큼 Window Size만큼 보내니까 Rate를 계산가능.  RTT에 비해 CongWin 크기가 변동이 심하다. 1부터 거듭제곱으로 커지고 다시 줄어들고 반복하기 때문이다. 따라서 전송속도는 결국 Congestion Window Size에 의해 결정된다고 볼 수 있다. Congestion Window Size는 네트워크 상황이 결정한다. 즉, 네트워크가 전송속도를 결정한다!    TCP Slow Start   처음에 CongWin은 1 MSS 부터 2의 거듭제곱으로 개수를 키우면서 보낸다. 처음 Threshold는 매우 큰 값으로 설정한다. 그 이후 Loss/2로 변경한다.    TCP Tahoe VS TCP Reno  X 축은 시간, Y축은 CongWin Size다.  버전 1(Tahoe), 버전 2(Reno) 라고 볼 수 있다.  Tahoe에서는 1부터 Slow start를 다시 했었다. 패킷 유실이 탐지되는 경우는 2가지다.     Time Out 현상이 발생했을 때   3 Duplicate ACK일 때   네트워크 관점에서 보면 먼저 2번 3 Duplicate ACK는 운이 없이 다 잘 전달하는데 특정 ACK만 문제가 생긴 상황. 네트워크는 잘 운영되는 중이다. 1번인 Time out은 특정 ACK 이후 전부 전송 안되기 때문에 더 큰 문제이다. 그렇기 때문에 1번과 2번에 대해 다르게 대응해주어야한다.  이것이 바로 TCP Reno 버전이다.    Time Out이 발생했을 땐 버전 1처럼 똑같이 1부터 Loss/2를 Threshold로 찾아간다.   3 Duplicate ACK가 발생했을땐 Loss/2를 Threshold로 해서 그 Threshold부터 Linear하게 증가한다. 다르게 대응하는 것이다. 덜 크리티컬하기 때문이다.   MSS (Maximum Segment Size) = 한번에 전송할 수 있는 최대 데이터 크기    TCP에서 한번에 전송할 수 있는 최대 데이터 크기 (헤더없는 순수 데이터 크기)   처음 CongWin = 1 MSS   Window Size가 1000비트고, MSS가 10이라면, 나는 100개 크기 세그먼트를 연속으로 전송할 수 있는 것이다.  Window size = ACK 안 기다리고 보낼 수 있는 데이터 총량    TCP Fairness 어떤 한 컴퓨터가 혼자 네트워크를 쓰고 있는데, 동일한 경로로 어떤 컴퓨터가 추가될 경우, 이들은 공평하게 1/2씩 쓸 수 있을까? 답은 YES    1이 더 많이 쓰는 상황이라고 해보자. k만큼, 2는 R-k 만큼 사용할 것이고 k &gt; R-k이다.     Bandwidth가 충분해서(equal bandwidth share 선보다 작으므로 충분) linear하게 늘려갈 것이다.(가장 오른쪽 빨간 화살표)   Bandwidth 터진 지점을 (x1, y1) 이라고 해보자. (제일 오른쪽 첫번째 화살표 끝)   Bandwidth 넘어가면 1/2로 각각 줄인다. (x1 / 2, y1 / 2)   (x1/2, y1/2)에서 다시 linear하게 증가한다.   이 과정을 반복하면…   결국 Equal Bandwidth share에 수렴한다.   =&gt; 분산적으로 동작함에도 불구하고 TCP가 Fair하게 동작하게 된다. "
  },
  
  {
    "title": "BOJ_2482_색상환 (Java)",
    "url": "/posts/BOJ2482%EC%83%89%EC%83%81%ED%99%98-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-12 17:43:39 +0900",
    "content": "[Gold III] 색상환 - 2482  문제 링크  성능 요약  메모리: 16568 KB, 시간: 120 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 2월 12일 16:18:35  문제 설명  색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.    그림 1. 먼셀의 20색상환  색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.  주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.  주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.  입력  입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다.   출력  첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.     문제 풀이     원형 구조를 선형으로 바꿔 DP로 계산한 후, 원형 특성으로 인한 중복을 제거하는 방식     코드   2차원DP 풀이 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K;     static int[][] dp;     static final int MOD = (int)1e9 + 3;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2482_색상환/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         K = Integer.parseInt(br.readLine());          if(K &gt; N/2) {             System.out.println(0);             return;         }         if(K==1) {             System.out.println(N);             return;         }          dp = new int[N + 1][N/2 + 1];          for(int i=1; i&lt;=N; i++){             dp[i][0] = 1;             dp[i][1] = i;         }           for(int i=2; i&lt;=N; i++){             for(int j=2; j&lt;=N/2; j++){                 dp[i][j] = (dp[i-2][j-1] + dp[i-1][j]) % MOD;             }         }          int selectFrom1 = dp[N-3][K-1] % MOD;         int selectFrom2 = dp[N-1][K] % MOD;         bw.write(String.valueOf((selectFrom1 + selectFrom2) % MOD));         bw.flush();         bw.close();         br.close();     } }     1차원 DP 풀이  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K;     static int[] dp;     static final int MOD = (int)1e9 + 3;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2482_색상환/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         K = Integer.parseInt(br.readLine());          if(K &gt; N/2) {             System.out.println(0);             return;         }         if(K==1) {             System.out.println(N);             return;         }          dp = new int[K + 1];          for(int i=0; i&lt;=K; i++){             dp[i] = 1;         }          for(int len = 1; len &lt;= N-2*K+1; len++) {             for(int j=1; j&lt;=K; j++) {                 dp[j] = (dp[j] + dp[j-1]) % MOD;             }         }  //        System.out.println(Arrays.toString(dp));          System.out.println((dp[K] - dp[K-2] + MOD)%MOD);         bw.flush();         bw.close();         br.close();     } }   1. 바깥쪽 반복문 (len):          목적: 각 색을 하나씩 추가해가며 경우의 수를 누적합니다.           N - 2*K + 1 계산 이유:                      K개의 색을 선택하려면 최소 (K-1)개의 “건너뛸 색”이 필요합니다.                       예: K=2면 1칸 띄워야 하므로 최소 2K-1 = 3개의 색이 필요 → N &gt;= 3K-1                       이 조건을 만족하는 범위 내에서 색을 추가합니다.                  2. 안쪽 반복문 (j):          점화식 dp[j] = dp[j] + dp[j-1]의 의미:                      dp[j] (선택 안 함): 이전까지 j개 선택한 경우 그대로 유지                       dp[j-1] (선택 함): 새로운 색을 선택하면 j-1개에서 j로 증가                       → 두 경우를 합친 것!                     최종 결과 계산 (dp[K] - dp[K-2]):           dp[K]: 선형으로 계산한 모든 경우 (원형 고려 X)           dp[K-2]: 첫 번째와 마지막 색을 동시에 선택한 경우 (이를 제외해야 함)                      예: N=4, K=2일 때, dp[K] = 3 (1-3, 1-4, 2-4)                       dp[K-2] = dp[0] = 1 (첫 번째와 마지막을 선택하면 중간 2개는 선택 불가)                       3 - 1 = 2 (정답)                 "
  },
  
  {
    "title": "로드 밸런싱이란?",
    "url": "/posts/%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%8B%B1%EC%9D%B4%EB%9E%80/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-02-12 03:08:59 +0900",
    "content": "로드 밸런싱 애플리케이션을 지원하는 리소스 풀에 들어오는 네트워크 트래픽 (들어오는 요청) 을 균등하게 분산하는 것을 의미한다. 이를 수행하는 로드 밸런서는 애플리케이션 서버 앞단에 위치하며 클라이언트 요청을 지시하고 제어한다. 이를 통해서 애플리케이션의 가용성, 확장성, 보안 및 성능을 확보할 수 있다.  로드 밸런싱 알고리즘  1. 라운드 로빈 (Round Robin) 라운드 로빈 방식은 모든 요청이 순서대로 처리되는 방식이다. 서버가 3대(A, B, C)가 존재하면 요청은 A-B-C-A-B-C 순으로 전달된다. 모든 서버의 처리 능력이 동등하고, 요청의 고른 분산이 중요한 경우 고려해 볼 수 있다. 장점은 구현이 쉽고 고른 분산을 보장한다. 하지만 단점은 서버 부하나 응답 시간을 고려하지 않고 서버의 처리 능력이 다른 경우 비효율적이다.  2. 가중치 라운드 로빈 (Weighted Round Robin) 가중치 라운드 로빈 방식은 라운드 로빈 방식에 가중치라는 개념을 추가한다. 각 서버는 처리 능력과 가용 자원에 따라 가중치를 할당받게 된다. 그리고 라운드 로빈 방식을 사용하되 가중치가 높은 서버는 가중치에 비례해서 상대적으로 더욱 많은 요청을 받게된다.    라운드 로빈보다 상대적으로 구현이 복잡하지만 각 서버의 처리 능력을 고려하지 않는다는 라운드 로빈 방식의 단점을 개선한다. 하지만, 여전히 서버의 상태를 고려하지 않는 방식이라는 점을 유의해야한다.  3. 최소 연결 (Least Connections) 최소 연결(Least Connections) 방식은 각 서버의 활성 연결 수를 모니터링하고 있는 경우에 사용할 수 있다. 가장 적은 활성 연결이 존재하는 서버에게 요청을 전달한다. 각 서버의 처리 능력이 다른 경우에는 적합하지 않을 수 있다. 처리 능력이 큰 서버는 상대적으로 활성 연결을 더욱 많이 수립할 수 있기 때문이다. 최소 연결 방식은 각 서버의 처리 능력이 비슷하지만 특정 이유로 한 서버에 동시 연결 수가 많아 지는 상황이 존재하는 경우 고려해볼 수 있다.  로드 밸런싱 대상에 상대적으로 처리 능력이 큰 서버가 존재하는 경우에는 라운드 로빈과 마찬가지로 가중치라는 개념을 사용해볼 수 있다. 이를 가중치 최소 연결(Weighted Least Connections) 방식이라고 한다.  4. 최소 응답 시간(Least Response Time) 최소 응답 시간(Least Response Time) 방식은 각 서버의 응답 시간을 모니터링하고 있는 경우에 사용할 수 있다. 응답 시간이 가장 빠른 서버에 요청을 전달하는 방식이다. 서버들마다 응답 시간이 다양할 경우, 가장 빠른 서버에 요청을 전달하여 사용자 경험을 개선하는데 도움이 될 수 있다. 응답 시간을 기반으로 하기 때문에 서버의 부하 상태, 활성 연결 수와 같은 다른 요소들을 고려해야하는 경우에는 적합하지 않을 수 있다.  5. IP 해시 IP 해시 방식은 클라이언트 요청의 IP를 기반으로 요청을 전달한다. IP를 이용해 구한 해시값을 기반으로 요청을 전달할 서버를 결정한다. IP 해시 방식은 클라이언트와 서버 간의 친화성 유지에 초점을 맞춘 방식으로 클라이언트의 상태에 관리에 용이하다는 장점이 있다. 하지만, 상황에 따라서 부하가 균등하게 이루어지지 않는다는 단점이 존재한다.    References    로드 밸런싱이란 무엇인가요?   System Design Basics - Load Balancing Algorithms  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (8)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-8/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-02-12 02:54:57 +0900",
    "content": "   Transport Layer - (5)   TCP Flow Control  데이터를 보낼때 상대가 받을 수 있는 만큼 보내야한다. 받을 수 있는 공간이 얼마 없는데 많이 보내선 안된다. 이걸 어떻게 알 수 있는가? 상대의 Receive Buffer을 보면 된다.   Receive Buffer의 상태를 보고 데이터를 받을 수 있는 공간이 N만큼 남았다라고 전달을 해야한다. 이 정보는 어디에 있을까?  TCP Segment의 Header 부분에 Receive Buffer이라는 필드에 “얼마만큼의 빈공간이 있는지를 알려주는 정보” 가 담아 보낸다.  만약 남아있는 공간이 없다면? 빈 공간이 하나도 없다면 0byte를 보내야할까? 그리고 보내는것을 멈추고 멍하니 기다려야할까? 아니다 보내는 것을 멈추지는 않는다. 그 대신 보내는 Segment의 Data 부분은 비우고 보낸다. (아무 의미없는 세그먼트 )  이 텅 빈 의미없는 세그먼트를 왜 주기적으로 보내는가? 왜냐면 무엇인가를 보내야만 보내는것에 대한 Ack를 다시 보내올것이고, 그 피드백을 받아야 하기 때문이다.  그냥 빈 세그먼트라도 주기적으로 보내야 응답으로 Receive Buffer의 빈공간 정보를 보낼것이고 그것이 필요한 정보이기 때문에 받으려면 보내야 한다.    Connection Management TCP 3-way Handshake   3번 왔다갔다 한다고 해서 3-way handshake라 부름  클라이언트가 먼저 TCP connection을 열자고 요청.     SYN MSG전송 : Data부분은 비어있고, Header에 SYN이라는 1비트짜리 필드가 있는데 항상 0이다가 이때 1로 바꾼다. 이것을 SYN Packet이라한다. 여기에 추가로 첫 Sequence# 를 같이 담아 보낸다.  Sequence# = a, SYNbit = 1 (즉 TCP연결을 열고싶다는 의사표현 + 나의 Sequence# 알려주기 를 의미한다!)   SYN ACK 응답 : 역시 SYN비트는 1로 설정되어있고, ACK비트도 1이다. 자신의 Sequence# 담아 알려준다. SYNbit = 1, Sequence# = b; 즉, 응답으로 클라이언트가 준 Sequence#에 1을 더해 ACK Num= a+1, ACK Bit = 1로 응답한다.   클라이언트는 이 SYNACK에 대한 응답을 한다. 이때부턴 SYNbit가 1이 아니다. 응답으로 ACK Num = b+1, ACK bit = 1를 보낸다. 이거에다가 “메시지”를 담아서 보낸다. ex) HTTP면 HTTP Request를 보낸다   ACK Bit란? ACK Num은 다음에 기대하는 바이트의 Sequence번호를 의미하는데 ACKbit는 무엇인가? ACK Bit란 TCP헤더의 플래그 필드에서 확인 응답을 나타내는 비트다.  1인 경우 ACK Num 필드를 유효한 값으로 사용하고 있다는 것을 의미한다. “이전에 데이터를 잘 받았다. 지금 ACK Num을 잘 참고해라”라는 뜻. 즉, ACK를 보낼때 ACK Bit이 무조건 1이고 “ACK Num을 보냈다” 라는 의미다.  3-way handshake인 이유? 2-way handshake를 가정해보자. 클라이언트 입장에서는 “연결” 이라는 걸 보냈을 때 “연결됨”이라는 응답을 받으면 잘 연결되었구나라는걸 알 수 있다. 하지만 서버 입장에서는 “연결됨”을 보냈는데 이 응답을 받았는지 안 받았는지를 알 수가 없다. 이 이후에 아무 답장이 없다면 연결이 안된건지 연결은 됐는데 안 보내는지도 모른다. 그렇기 때문에 각각 한번씩 응답은 받아야 한다.  그리고 3번째부턴 우리가 알고있듯 클라이언트에서 서버에 요청을 보내는것이 맞다. 그것과 함께 TCP 3-way handshake가 포함되는 것이다. 즉, 3번째 과정은 TCP handshake이자 Request다. 이 세번째 과정 내부에 메시지를 함께 담아서 보내는 것이다. HTTP Request처럼 말이다.    Closing TCP connection           클라이언트가 보내고자 하는 데이터를 다 보냈으면 할 게 없다. 그래서 FIN이라는 Segment를 보낸다. 아무것도 없는 빈 세그먼트로 연결을 끊자는 신호다.      이것에 대한 ACK를 준다.   서버는 보낼 데이터를 전부 다 보낸 뒤 FIN을 보낸다. 그리고 닫는다. ACK, FIN , close   클라이언트는 알았다고 하고 timed wait만큼 기다린 뒤 연결을 끊는다. ACK, close   클라이언트는 왜 타임아웃만큼 기다리는가? FIN을 서버로부터 받기 전에 오기로 한 데이터가 있는데 안 온 상황에선 기다려야한다. 그리고 ACK를 보냈는데 서버가 이걸 받았는지 모르니까 기다리는 것이다. 서버에서 FIN 보냈는데 ACK가 유실되어서 못받았으면 계속 timeout 발생할것이다. 그러니까 ACK가 확실히 도달할 때 까지 timed wait만큼 기다린다.      Congestion Control  지금까지 나의 상태 및 상대방의 상태를 고려해서 메시지를 주고 받았다. 한가지 더 고려해야 할 항목이 있다. 바로 네트워크다. 네트워크 인프라를 통해 내 메시지가 이동할 수 있다.  하지만 이 영역은 내가 통제할 수 있는 영역이 아니다. Public한 영역이기 때문이다.  TCP에서 네트워크가 느리고, 중간에 유실되면 클라이언트는 “재전송”한다. 몇번이고 재전송을 한다. 이것은 나 뿐만 아니라 모든 클라이언트가 그렇다.  그런데 이렇게 무식하게 데이터를 쏟아붓는 것은 손해다. 내가 손해보는만큼 네트워크에도 손해를 끼치고 이는 모두의 손해로 이어지게 된다. 악순환의 반복이다.  그러면 네트워크가 혼잡한지 어떻게 알 수 있을까?      1. Network-Assisted Congestion Control   중간 라우터들이 자기 상태를 알려주는 방식, 그런데 라우터들은 전달하는것도 바쁜데 일일히 메시지까지 알려줄 수 있을까? 사실상 힘들다.   2. End-End Congestion Control 내가 알아서 상대방과 메시지가 오고가는 시간 등을 계산해서 “유추”하는 방식. 현실적인 방법이다. "
  },
  
  {
    "title": "BOJ_15661_링크와 스타트 (Java)",
    "url": "/posts/BOJ15661%EB%A7%81%ED%81%AC%EC%99%80-%EC%8A%A4%ED%83%80%ED%8A%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-11 20:47:15 +0900",
    "content": "[Gold V] 링크와 스타트 - 15661  문제 링크  성능 요약  메모리: 20332 KB, 시간: 1268 ms  분류  백트래킹, 비트마스킹, 브루트포스 알고리즘  제출 일자  2025년 2월 11일 20:38:37  문제 설명  오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이다. 이제 스타트 팀과 링크 팀으로 사람들을 나눠야 한다. 두 팀의 인원수는 같지 않아도 되지만, 한 명 이상이어야 한다.  BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.  N=4이고, S가 아래와 같은 경우를 살펴보자.   \t \t\t \t\t\ti\\j \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t4 \t\t \t \t \t\t \t\t\t1 \t\t\t  \t\t\t1 \t\t\t2 \t\t\t3 \t\t \t\t \t\t\t2 \t\t\t4 \t\t\t  \t\t\t5 \t\t\t6 \t\t \t\t \t\t\t3 \t\t\t7 \t\t\t1 \t\t\t  \t\t\t2 \t\t \t\t \t\t\t4 \t\t\t3 \t\t\t4 \t\t\t5 \t\t\t  \t\t \t   예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.   \t스타트 팀: S12 + S21 = 1 + 4 = 5 \t링크 팀: S34 + S43 = 2 + 5 = 7   1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다.   \t스타트 팀: S13 + S31 = 2 + 7 = 9 \t링크 팀: S24 + S42 = 6 + 4 = 10   축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.  입력  첫째 줄에 N(4 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.  출력  첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.     문제 풀이     이전 비슷한 문제인 스타트와 링크 를 조금만 개선하면된다. 팀마다 인원수 제한이 없으므로 1부터 N-1까지 고려하도록 변경해주었다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, board[][], res = Integer.MAX_VALUE;     static boolean[] visited;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15661_링크와스타트/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         board = new int[N][N];         visited = new boolean[N];         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; N; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());             }         }          dfs(0, 0);          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private void dfs(int depth, int idx) {         if(depth &gt;= 1) {             calAbility();         }          for(int i=idx; i&lt;N; i++) {             if(depth == N-1) continue;             if(!visited[i]){                 visited[i] = true;                 dfs(depth+1, i+1);                 visited[i] = false;             }         }     }      private void calAbility() {         int diff=0;         for(int i=0; i&lt;N; i++) {             for(int j=i+1; j&lt;N; j++) {                 if(visited[i] &amp;&amp; visited[j]) diff += (board[i][j] + board[j][i]);                 else if(!visited[i] &amp;&amp; !visited[j]) diff -= (board[i][j] + board[j][i]);             }         }         res = Math.min(Math.abs(diff), res);     } }  "
  },
  
  {
    "title": "SWEA_5653_줄기세포 배양 (Java)",
    "url": "/posts/SWEA5653%EC%A4%84%EA%B8%B0%EC%84%B8%ED%8F%AC-%EB%B0%B0%EC%96%91-Java/",
    "categories": "알고리즘",
    "tags": "Java, SWEA, 알고리즘",
    "date": "2025-02-11 20:43:50 +0900",
    "content": "[Unrated] [모의 SW 역량테스트] 줄기세포배양 - 5653   문제 링크  성능 요약  메모리: 100,876 KB, 시간: 2,361 ms, 코드길이: 3,798 Bytes  제출 일자  2025-02-11 19:24     출처: SW Expert Academy, https://swexpertacademy.com/main/code/problem/problemList.do      문제 풀이   Cell 클래스로 위치, 에너지, 시간, 세포타입을 관리했다. 우선순위는 에너지가 큰 순으로 내림차순이다.  이를 구현하면 된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */   import java.io.*; import java.util.*;   public class Solution {     class Cell implements Comparable&lt;Cell&gt; {         int r, c, energy, time, type;         public Cell(int r, int c, int energy, int time, int type) {             this.r = r;             this.c = c;             this.energy = energy;             this.time = time;             this.type = type; // 0:비활성, 1:활성, 2:죽음         }           @Override         public int compareTo(Cell o){             return o.energy - this.energy;         }       }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int T, N, M, K;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     public static void main(String[] args) throws Exception {         new Solution().solution();     }       public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/SWEA_5653_줄기세포배양/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                   T = Integer.parseInt(br.readLine());         for(int tc=1; tc&lt;=T; tc++) {             st = new StringTokenizer(br.readLine());             N = Integer.parseInt(st.nextToken());             M = Integer.parseInt(st.nextToken());             K = Integer.parseInt(st.nextToken());               int maxSize = Math.max(N, M) + K * 2;             Cell[][] board = new Cell[maxSize][maxSize];             for(int i=0; i&lt;N; i++){                 st = new StringTokenizer(br.readLine());                 for(int j=0; j&lt;M; j++){                     int energy = Integer.parseInt(st.nextToken());                     if(energy &gt; 0) board[i+K][j+K] = new Cell(i+K, j+K, energy, 0, 0);                 }             }             for(int t=0; t&lt;K; t++){                 List&lt;Cell&gt; growingCells = new ArrayList&lt;Cell&gt;();                 for(int i=0; i&lt;maxSize; i++){                     for(int j=0; j&lt;maxSize; j++){                         if(board[i][j] == null || board[i][j].type == 2) continue;                           Cell currCell = board[i][j];                         currCell.time++;                           if(currCell.type == 0 &amp;&amp; currCell.time == currCell.energy){                             currCell.type++;                             currCell.time = 0;                         }                           if(currCell.type == 1) {                             if(currCell.time == 1){                                 for(int k=0; k&lt;4; k++){                                     int nr = currCell.r + dr[k];                                     int nc = currCell.c + dc[k];                                     if(board[nr][nc] == null) {                                         growingCells.add(new Cell(nr, nc, currCell.energy, 0, 0));                                     }                                 }                             }                             if(currCell.time == currCell.energy) currCell.type++;                         }                     }                 }                 Collections.sort(growingCells);                 for(Cell c : growingCells){                     if(board[c.r][c.c] == null) board[c.r][c.c] = c;                 }             }               int res = 0;             for(int i=0; i&lt;maxSize; i++){                 for(int j=0; j&lt;maxSize; j++){                     if(board[i][j] != null &amp;&amp; board[i][j].type != 2) res++;                 }             }             sb.append(\"#\").append(tc).append(\" \").append(res).append(\"\\n\");         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_15683_감시 (Java)",
    "url": "/posts/BOJ15683%EA%B0%90%EC%8B%9C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-11 03:03:32 +0900",
    "content": "[Gold III] 감시 - 15683  문제 링크  성능 요약  메모리: 44284 KB, 시간: 292 ms  분류  백트래킹, 브루트포스 알고리즘, 구현, 시뮬레이션  제출 일자  2025년 2월 11일 02:47:05  문제 설명  스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.   \t \t\t \t\t\t \t\t\t \t\t\t \t\t\t \t\t\t \t\t \t\t \t\t\t1번 \t\t\t2번 \t\t\t3번 \t\t\t4번 \t\t\t5번 \t\t \t   1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.  CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.  CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.  0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0  지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '#'로 나타내면 아래와 같다.   \t \t\t \t\t\t \t\t\t0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 # 6 0 0 0 0 0 0 0 \t\t\t \t\t\t \t\t\t0 0 0 0 0 0 0 0 0 0 0 0 # # 1 0 6 0 0 0 0 0 0 0 \t\t\t \t\t\t \t\t\t0 0 # 0 0 0 0 0 # 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0 \t\t\t \t\t\t \t\t\t0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 # 0 0 0 \t\t\t \t\t \t\t \t\t\t→ \t\t\t← \t\t\t↑ \t\t\t↓ \t\t \t   CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.  0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 6 0 0 6 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 5  위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.   \t \t\t \t\t\t \t\t\t0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5 \t\t\t \t\t\t \t\t\t0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5 \t\t\t \t\t\t \t\t\t0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5 \t\t\t \t\t\t \t\t\t0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5 \t\t\t \t\t \t\t \t\t\t왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔ \t\t\t왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕ \t\t\t왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔ \t\t\t왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕ \t\t \t   CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.  0 0 2 0 3 0 6 0 0 0 0 0 6 6 0 0 0 0 0 0   위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.  # # 2 # 3 0 6 # 0 # 0 0 6 6 # 0 0 0 0 #   사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)  둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.   CCTV의 최대 개수는 8개를 넘지 않는다.  출력  첫째 줄에 사각 지대의 최소 크기를 출력한다.     문제 풀이   간단한 구현 문제     코드   package BOJ_15683_감시;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static class Node{         int r,c,type;         public Node(int r,int c,int type){             this.r=r;             this.c=c;             this.type=type;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, res = Integer.MAX_VALUE;     static int[] dr = {-1, 0, 1, 0}, dc = {0, 1, 0, -1};     static int[][] board;     static List&lt;Node&gt; cctv = new ArrayList&lt;&gt;();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15683_감시/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         board = new int[N][M];         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; M; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());                 if(1 &lt;= board[i][j] &amp;&amp; board[i][j] &lt;= 5 ) {                     cctv.add(new Node(i, j, board[i][j]));                 }             }         }          cctvComb(0, board);         bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }     private static void cctvComb(int depth, int[][] currBoard) {         if(depth == cctv.size()) {             res = Math.min(res, count(currBoard));             return;         }          Node currCCTV = cctv.get(depth);         int[][] newBoard = new int[N][M];          if(currCCTV.type == 1) {             for(int k=0; k&lt;4; k++){                 copyCurrBoard(currBoard, newBoard);                 changeCurrBoard(currCCTV, newBoard, k);                 cctvComb(depth+1, newBoard);             }         }         else if(currCCTV.type == 2) {             for(int k=0; k&lt;2; k++){                 copyCurrBoard(currBoard, newBoard);                 changeCurrBoard(currCCTV, newBoard, k);                 changeCurrBoard(currCCTV, newBoard, k+2);                 cctvComb(depth+1, newBoard);             }         }         else if(currCCTV.type == 3) {             for(int k=0; k&lt;4; k++){                 copyCurrBoard(currBoard, newBoard);                 changeCurrBoard(currCCTV, newBoard, k);                 changeCurrBoard(currCCTV, newBoard, (k+1)%4);                 cctvComb(depth+1, newBoard);             }         }         else if(currCCTV.type == 4) {             for(int k=0; k&lt;4; k++){                 copyCurrBoard(currBoard, newBoard);                 changeCurrBoard(currCCTV, newBoard, k);                 changeCurrBoard(currCCTV, newBoard, (k+1)%4);                 changeCurrBoard(currCCTV, newBoard, (k+2)%4);                 cctvComb(depth+1, newBoard);             }         }         else if(currCCTV.type == 5) {             copyCurrBoard(currBoard, newBoard);             for(int k=0; k&lt;4; k++){                 changeCurrBoard(currCCTV, newBoard, k);             }             cctvComb(depth+1, newBoard);         }     }      private static void changeCurrBoard(Node curr, int[][] currBoard, int k) { // cctv가 보는 한 방향 보기         int nr = curr.r, nc = curr.c;         while(true){             nr += dr[k];             nc += dc[k];             if(nr &lt; 0 || nr &gt;= N || nc &lt; 0 || nc &gt;= M) break;             if(currBoard[nr][nc] == 6) break;             if(currBoard[nr][nc] == 0) currBoard[nr][nc] = -1;         }     }      private static void copyCurrBoard(int[][] currBoard, int[][] newBoard) {         for(int i=0; i&lt;N; i++) {             for(int j=0; j&lt;M; j++) {                 newBoard[i][j] = currBoard[i][j];             }         }     }      private static int count(int[][] currBoard) {         int cnt = 0;         for(int i=0; i&lt;N; i++) {             for(int j=0; j&lt;M; j++) {                 if(currBoard[i][j] == 0) cnt++;             }         }         return cnt;     } }  "
  },
  
  {
    "title": "BOJ_4384_공평하게 팀 나누기 (Java)",
    "url": "/posts/BOJ4384%EA%B3%B5%ED%8F%89%ED%95%98%EA%B2%8C-%ED%8C%80-%EB%82%98%EB%88%84%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-11 00:28:28 +0900",
    "content": "[Gold I] 공평하게 팀 나누기 - 4384  문제 링크  성능 요약  메모리: 36892 KB, 시간: 188 ms  분류  다이나믹 프로그래밍, 배낭 문제  제출 일자  2025년 2월 10일 23:55:01  문제 설명  학생회장을 하고 있는 상근이는 이번 학교 축제 행사로 학우들간의 친밀감을 돈독히 하고자 줄다리기를 하려 한다.  하지만 이 줄다리기에 형평성을 최대한 고려하기위해 두 팀간의 사람 수 차이를 1 이하로 하려하며, 두 팀간의 몸무게의 차이가 최소화되도록 하고자 한다.  이때 상근이가 나누려 하는 두 팀의 몸무게를 각각 출력 하시오.  입력  가장 첫 번째 줄에 줄다리기를 하기 원하는 총 인원의 수(1 ≤ N ≤ 100)가 주어진다.  이후 N개의 줄에 줄다라기에 참여하기 원하는 사람의 몸무게(1 ≤ K ≤ 450)가 주어진다.  출력  두팀의 몸무게를 작은 순서대로 순차적으로 출력한다.     문제 풀이     각 사람(i)에 대해 두 가지 선택이 가능합니다     팀 A에 포함시키지 않는 경우 (팀 B에 포함)   팀 A에 포함시키는 경우      Math.abs(N/2 - (teamACnt[i-1][j-w[i]]+1)): i번째 사람을 팀 A에 추가했을 때, 이상적인 팀 크기(N/2)와의 차이   Math.abs(N/2 - teamACnt[i][j]): 현재 상태에서 팀 A의 크기와 이상적인 팀 크기(N/2)와의 차이   Math.abs((N-N/2) - (teamACnt[i-1][j-w[i]]+1)): i번째 사람을 팀 A에 추가했을 때, 팀 A의 크기와 팀 B의 이상적인 크기(N-N/2)와의 차이   Math.abs((N-N/2) - teamACnt[i][j]): 현재 상태에서 팀 A의 크기와 팀 B의 이상적인 크기(N-N/2)와의 차이   즉, i번째 사람을 팀 A에 포함시키는 것이 전체적으로 더 균형 잡힌 팀 구성을 만드는 경우에만 이 상태를 선택합니다.     코드   package BOJ_4384_공평하게팀나누기;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, w[], totalW, teamACnt[][], gap = Integer.MAX_VALUE, finalA, finalB;     static boolean[][] dp;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_4384_공평하게팀나누기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         w = new int[N+1];         for(int i = 1; i &lt;= N; i++) {             w[i] = Integer.parseInt(br.readLine());             totalW += w[i];         }          dp = new boolean[N+1][totalW+1]; // dp[i][j]: i명까지 고려했을 때, 팀 A의 몸무게 합이 j가 되는 경우가 가능한지         teamACnt = new int[N+1][totalW+1]; // teamACnt[i][j]: i명까지 고려했을 때, 팀 A의 몸무게 합이 j일 때 팀 A에 속한 사람 수          dp[0][0] = true;         for (int i = 1; i &lt;= N; i++) {             for(int j = 0; j &lt;= totalW; j++) {             \t// 경우 1: i번째 사람을 팀 A에 포함시키지 않음                 if(dp[i-1][j]) {                     dp[i][j] = true;                     teamACnt[i][j] = teamACnt[i-1][j];                 }                                  // 경우 2: i번째 사람을 팀 A에 포함시킴                 if(j-w[i]&gt;=0 &amp;&amp; dp[i-1][j-w[i]]) { // 더 균형잡힌 팀 구성도 고려해야함                     if(Math.abs(N/2 - (teamACnt[i-1][j-w[i]]+1)) &lt; Math.abs(N/2 - teamACnt[i][j])                     &amp;&amp; Math.abs((N-N/2) - (teamACnt[i-1][j-w[i]]+1)) &lt; Math.abs((N-N/2) - teamACnt[i][j])){                         dp[i][j] = true;                         teamACnt[i][j] = teamACnt[i-1][j-w[i]] +1;                     }                 }             }         }          for(int a_w = 1; a_w &lt;= totalW; a_w++) {         \t// 팀 A의 인원수가 조건(N/2 또는 N-N/2)에 맞고, 해당 몸무게 조합이 가능한 경우             if((teamACnt[N][a_w] == N/2 || teamACnt[N][a_w] == (N - N/2))&amp;&amp; dp[N][a_w]){                 if(Math.abs(a_w - (totalW - a_w)) &lt; gap){                     finalA = a_w;                     finalB = totalW - a_w;                     gap = Math.abs(a_w - (totalW - a_w));                 }             }         }         if(finalA &gt; finalB) {             int tmp = finalA;             finalA = finalB;             finalB = tmp;         }         bw.write(String.valueOf(finalA) + \" \" + finalB);         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_24231_해석 (Java)",
    "url": "/posts/BOJ24231%ED%95%B4%EC%84%9D-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-10 13:04:29 +0900",
    "content": "[Gold I] 해석 - 24231  문제 링크  성능 요약  메모리: 15216 KB, 시간: 148 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 2월 10일 13:01:01  문제 설명    $($ 와 $)$로만 이루어진 문자열을 괄호 문자열이라고 한다. 괄호 문자열 중, 다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 한다.  빈 문자열은 올바른 괄호 문자열이다.   $A$가 올바른 괄호 문자열이라면, $( A )$도 올바른 괄호 문자열이다. 이때 생성되는 괄호 쌍을 서로 매칭된다고 표현한다.   $A$와 $B$가 올바른 괄호 문자열이라면, $AB$도 올바른 괄호 문자열이다. 방에 들어가려다가 가방에 들어가 버린 승재는 올바른 괄호 문자열을 암호화했다.  열고 닫는 매칭되는 괄호 쌍이 01 또는 10으로 암호화됐다. 예를 들어 (()) 는 0011, 0101, 1010, 1100으로 암호화될 수 있다. 반면, 1001로 암호화될 수는 없다. 첫 번째 괄호와 마지막 괄호가 매칭되는데 11이기 때문이다. 암호화된 문자열이 주어졌을 때, 가능한 올바른 괄호 문자열의 개수를 출력하시오. 값이 너무 클 수 있으니 $10^9 + 7$로 나눈 나머지를 출력하시오.  입력                 첫 줄에 0과 1로만 이루어진 문자열 S가 주어진다. $( 2 \\le       S       \\le 300 )$            출력  첫 줄에 경우의 수를 $10^9 + 7$로 나눈 나머지를 출력하시오.     문제 풀이   길이 제한이 작아 for문을 여러번 돌려서 풀 수 있었다. 가운데 mid를 체크하며 ()가 완성되면 그때그때 경우의 수를 더해줬다.       코드   package BOJ_24231_해석;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static final int MOD = 1000000007;     static String str;     static int N;     static long[][] dp;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_24231_해석/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          str = br.readLine();         N = str.length();          dp = new long[N+1][N+1];         // 빈 문자열은 1         for(int i = 1; i &lt;= N; i++) {             dp[i][i-1] = 1;         }          for(int len = 2; len &lt;= N; len++) {             for(int left = 0; left &lt;= N-len; left++) {                 int right = left + len - 1;                 // 중간에 결합법칙 성립시 경우의수 추가                 // left-mid가 () 되면 ( [(left+1) ~ (mid-1)] ) [(mid+1) ~ right] 이런형태                 for(int mid = left+1; mid &lt;= right; mid++) {                     if(str.charAt(left) != str.charAt(mid)) dp[left][right] = (dp[left][right] + (dp[left+1][mid-1] * dp[mid+1][right]) % MOD) % MOD;                 }             }         }          System.out.println(dp[0][N-1]);         br.close();     } }  "
  },
  
  {
    "title": "BOJ_17613_점프 (Java)",
    "url": "/posts/BOJ17613%EC%A0%90%ED%94%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-10 12:15:28 +0900",
    "content": "[Platinum II] 점프 - 17613  문제 링크  성능 요약  메모리: 21952 KB, 시간: 212 ms  분류  분할 정복, 다이나믹 프로그래밍  제출 일자  2025년 2월 10일 12:07:56  문제 설명  개구리가 수직선 위의 0에서 출발해서 오른쪽(x좌표가 증가하는 방향)으로 점프들을 수행한 후 어떤 수 x &gt; 0에 도착하려 한다. 이 때, 점프 간격은 1로부터 시작해서 항상 직전 점프한 간격의 2배로 증가해야 한다.  만일 점프간격을 2배씩 계속 증가시켜 마지막 점프에서 목표 수 x를 지나칠 것 같으면, 필요한 경우 언제든지 점프 간격을 다시 처음 상태인 간격 1로 되돌아 갈 수 있다. 이것을 재시작이라고 부른다. 예를 들어, 아래 &lt;그림 1&gt;과 같이 x = 19에 도달하기 위해서 2번의 재시작을 수행해서 (1+2+4+8)+(1+2)+(1)= 19 와 같이 7번의 점프로 도착할 수 있다.    &lt;그림 1&gt;  개구리가 0에서 출발해서 어떤 양의 정수 N에 도달하기 위한 점프 횟수의 최솟값을 J(N)으로 나타내고 N의 점프넘버라고 부를 것이다. 예를 들어, &lt;그림 1&gt;을 보면 J(1) = 1, J(3) = 2, J(7) = 3, J(15) = 4, J(16) = 5, J(18) = 6, J(19) = 7과 같음을 알 수 있다.  여러분은 어떤 특정 구간 [x, y]안의 수들의 점프넘버들 중 최댓값을 찾아서 출력한다. 즉, 아래 조건을 만족하는 w를 찾아서 출력한다.  w = max{J(i) | x ≤ i ≤ y}  입력  첫 번째 줄에는 여러분에게 주어질 구간의 개수 T가 주어진다.(1 ≤ T ≤ 2,000) 이후 T개의 줄에 대해 답을 구해야 할 구간을 나타내는 두 정수 x, y가 공백을 사이에 두고 주어진다 (1 ≤ x ≤ y ≤ 109).  출력  T개의 줄에 각각 하나의 정수를 출력한다. 각 줄에 출력되는 정수는 구간 [x, y]안의 수들의 점프넘버들 중 최댓값이다. 각 정수는 입력으로 주어지는 구간의 순서에 맞게 출력되어야 한다. 즉, 첫 번째 줄에 출력되는 정답은 첫 번째로 주어지는 구간에 대응되어야 한다.     문제 풀이     아이디어는 겨우 떠올렸는데 분기가 어려웠다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*; public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int TC;     static long X, Y;     static long[] arr;     public static void main(String[] args) throws Exception {         new Main().solution();     }     public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17613_점프/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         TC = Integer.parseInt(br.readLine());         // int 가 2^31-1까지니까 최대 31번점프가능         arr = new long[31];         for(int i=1; i&lt;31; i++) {             arr[i] = (1L &lt;&lt; i) -1;         }         while(TC--&gt;0){             st = new StringTokenizer(br.readLine());             X = Long.parseLong(st.nextToken());             Y = Long.parseLong(st.nextToken());             sb.append(maxJ(X, Y)).append('\\n');         }         System.out.println(sb);         bw.flush();         bw.close();         br.close();     }     // x까지 최소점프횟수     private static int calJ(long x) {         long tmp = 1;         int j = 0;         while (x&gt;0) {             x -= tmp;             // 점프초기화             if (2 * tmp &gt; x) tmp = 1;             else tmp *= 2;             j++;         }         return j;     }     // [left ~ right] 최대점프횟수구하기     private static int maxJ(long left, long right) {         if(left == right) return calJ(right);         if(left + 1 == right) return Math.max(calJ(left), calJ(right));         // right보다 큰 2거듭제곱 J찾기         int idx;         for(idx=0; idx&lt;31; idx++){             if(arr[idx] &gt; right) break;         }         if(idx==1) return 1;         //J(i-1), J(i-2)         long J_1 = arr[idx-1]; // J(i-1)         long J_2 = arr[idx-2]; // J(i-2)         // case1: 20~100 (left &lt;= J2 인 경우)         // J2까지 가는 경우와 J1까지 가는 경우 중 더 큰 값 선택         if(left &lt;= J_2) return Math.max((idx-2) + maxJ(0, J_2), (idx-1) + maxJ(0, right-J_1));         // case4: 64~100 (left &gt; J1 인 경우)         // 예: [64~100] 구간처럼 시작점이 J1보다 큰 경우         // 전체 구간을 J1만큼 빼서 재귀적으로 처리         if(left &gt; J_1) return (idx-1) + maxJ(left-J_1, right-J_1);         // case3: 40~100 (J2 &lt; left &lt; J1 인 경우)         // 예: [32~62] 구간처럼 시작점이 J2와 J1 사이인 경우         // J2를 밟고 가는 경우와 J1까지 가는 경우 중 더 큰 값 선택         if(left &lt; J_1) return Math.max((idx-2) + maxJ(left-J_2, J_2), (idx-1) + maxJ(0, right-J_1));         // case2: (left == J1 인 경우)         // 예: [63~100] 구간처럼 시작점이 정확히 J1인 경우         // J1까지는 idx-1번의 점프로 도달, 나머지는 재귀로 처리         return (idx-1) + maxJ(0, right-J_1);     } }  "
  },
  
  {
    "title": "BOJ_15948_간단한 문제 (Java)",
    "url": "/posts/BOJ15948%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%AC%B8%EC%A0%9C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-10 04:54:45 +0900",
    "content": "[Platinum I] 간단한 문제 - 15948  문제 링크  성능 요약  메모리: 14212 KB, 시간: 104 ms  분류  애드 혹, 해 구성하기, 수학  제출 일자  2025년 2월 10일 03:36:23  문제 설명  자연수  $n$, $m$과 자연수 수열 $A_1, A_2, \\cdots, A_m$이 주어졌을 때, 다음 등식을 만족하는 자연수 수열 $B_1, B_2, \\cdots, B_m$을 구하라.       입력  첫 번째 줄에 자연수 $n$과 $m$이 공백으로 구분되어 주어진다. ($1 \\le n \\le 10^{15}, 1 \\le m \\le 50$) 두 번째 줄에 수열 $A_1, A_2, \\cdots, A_m$을 나타내는 정수 $m$개가 공백으로 구분되어 주어진다. ($1 \\le A_i \\le 1,000$)  출력  첫 번째 줄에 등식을 만족하는 수열 $B_1, B_2, \\cdots, B_m$을 공백으로 구분하여 출력한다. 각 $B_i$는  $1$ 이상 $3\\times10^{18}$ 이하여야 한다. 등식을 만족하는 수열이 여러 가지라면 그 중 아무거나 출력해도 된다. 만약 등식을 만족하는 수열이 존재하지 않는다면 첫 번째 줄에 $-1$을 출력한다.     문제 풀이     1. 왜 N이 홀수/짝수일 때 다르게 처리해야 하는가?          등식의 왼쪽에 있는 (2^m - 1)/n 항을 정수로 만들어야 하기 때문      N이 홀수일 때는 현재 값을 바로 계산하고   N+1을 해서 짝수로 만든 후 2로 나눔   N이 짝수일 때는 바로 2로 나눠서 더 작은 문제로 만듦   2. 왜 idx+M-1 위치에 값을 저장하는가?     짝수일 때 나중에 계산되는 값이 더 커져야 하기 때문   현재 남은 구간의 마지막 위치(idx+M-1)에 더 큰 값을 저장   3. 왜 (N + (1L « M) - 2) * A[idx + M - 1] 이런 계산을 하는가?     등식의 양변을 같게 만들기 위해 필요한 값을 계산해야 하기 때문   2의 M승을 사용하여 적절한 크기의 값을 만듦   4. 왜 M이 1일 때 따로 처리하는가?     마지막 하나 남은 값은 이전에 계산된 모든 값들과의 관계를 고려해야 하기 때문   N*A[idx]로 간단히 계산하여 등식을 만족시킴   5. 왜 originalM을 따로 저장해야 하는가?     M 값이 계속 감소하지만 최종 출력할 때는 원래 배열 크기가 필요하기 때문   처음 M 값을 originalM에 저장하여 출력에 사용      코드   코드 1 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static long N;     static int M, originalM;     static long[] A, B;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15948_간단한문제/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Long.parseLong(st.nextToken());         M = Integer.parseInt(st.nextToken());         originalM = M;         A = new long[M];         B = new long[M];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; M; i++) {             A[i] = Long.parseLong(st.nextToken());         }          // B 배열 계산         int idx = 0;  // B배열의 현재 위치         while(M &gt; 0) {             if(M == 1) {                 // 마지막 원소 처리                 B[idx] = N * A[idx];                 break;             }                          if(N % 2 == 1) {  // N 홀수                 B[idx] = N * A[idx];                 N = (N + 1) / 2;                 idx++;             } else {  // N 짝수                 // 마지막 원소는 따로 계산                 B[idx + M - 1] = (N + (1L &lt;&lt; M) - 2) * A[idx + M - 1];                 N /= 2;             }             M--;         }                  // 원래 길이(originalM)         for(int i = 0; i &lt; originalM; i++) {             sb.append(B[i]);             if(i &lt; originalM-1) sb.append(\" \");         }         sb.append('\\n');          System.out.println(sb);         bw.flush();         bw.close();         br.close();     } }    코드 2 (재귀) /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static long N;     static int M;     static long[] A, B;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15948_간단한문제/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Long.parseLong(st.nextToken());         M = Integer.parseInt(st.nextToken());          A = new long[M];         B = new long[M];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; M; i++) {             A[i] = Long.parseLong(st.nextToken());         }          solve(N, M, 0);          for(int i=0; i&lt;M; i++) {             sb.append(String.valueOf(B[i]));             if(i &lt; M-1) sb.append(\" \");         }         sb.append('\\n');         System.out.println(sb);         bw.flush();         bw.close();         br.close();     }      private static void solve(long n, int m, int k){         if(m == 1){             B[k] = n * A[k];             return;         }          if(n%2 == 1){             B[k] = n * A[k];             solve((n+1)/2, m-1, k+1);             return;         }         else{             solve(n/2, m-1, k);             B[k+m-1] = (n + (1L&lt;&lt;m) - 2) * A[k+m-1];         }     } }  "
  },
  
  {
    "title": "PGMS_동명 동물 수 찾기 (SQL)",
    "url": "/posts/PGMS%EB%8F%99%EB%AA%85-%EB%8F%99%EB%AC%BC-%EC%88%98-%EC%B0%BE%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-02-10 01:22:11 +0900",
    "content": "[level 2] 동명 동물 수 찾기 - 59041  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  Empty  제출 일자  2025년 02월 10일 01:19:49  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          동물 보호소에 들어온 동물 이름 중 두 번 이상 쓰인 이름과 해당 이름이 쓰인 횟수를 조회하는 SQL문을 작성해주세요. 이때 결과는 이름이 없는 동물은 집계에서 제외하며, 결과는 이름 순으로 조회해주세요.   예시  예를 들어 ANIMAL_INS 테이블이 다음과 같다면           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A396810 Dog 2016-08-22 16:13:00 Injured Raven Spayed Female   A377750 Dog 2017-10-25 17:17:00 Normal Lucy Spayed Female   A355688 Dog 2014-01-26 13:48:00 Normal Shadow Neutered Male   A399421 Dog 2015-08-25 14:08:00 Normal Lucy Spayed Female   A400680 Dog 2017-06-17 13:29:00 Normal Lucy Spayed Female   A410668 Cat 2015-11-19 13:41:00 Normal Raven Spayed Female           Raven 이름은 2번 쓰였습니다. Lucy 이름은 3번 쓰였습니다 Shadow 이름은 1번 쓰였습니다.   따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.            NAME COUNT            Lucy 3   Raven 2            본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      코드   SELECT ai.NAME, COUNT(*) AS COUNT     FROM ANIMAL_INS AS ai         WHERE ai.NAME IS NOT NULL             GROUP BY NAME                 HAVING COUNT(*) &gt;= 2                     ORDER BY NAME ASC;    "
  },
  
  {
    "title": "BOJ_2487_섞기 수열 (Java)",
    "url": "/posts/BOJ2487%EC%84%9E%EA%B8%B0-%EC%88%98%EC%97%B4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-09 22:39:13 +0900",
    "content": "[Gold IV] 섞기 수열 - 2487  문제 링크  성능 요약  메모리: 17116 KB, 시간: 160 ms  분류  유클리드 호제법, 수학, 정수론, 순열 사이클 분할  제출 일자  2025년 2월 9일 13:38:15  문제 설명  A1, A2, …, AN으로 표시된 N 개의 카드를 정해진 방법으로 섞고자 한다. 그 섞는 방법은 1에서 N까지의 숫자로 이루어진 수열로 표시된다. 이 수열을 섞기 수열이라 하자. 섞기는 현재 가지고 있는 카드에서 섞기 수열의 각 숫자가 나타내는 위치에 있는 카드를 순서대로 뽑아서 나열하는 것이다. 예를 들어, N = 6이고 섞기 수열이 [3, 2, 5, 6, 1, 4]라고 하자. 카드의 처음 상태가 [A1, A2, A3, A4, A5, A6]일 때, 섞기를 한 번 실행하면 카드의 순서가 다음과 같이 된다.  [A3, A2, A5, A6, A1, A4]  이 상태에서 다시 한 번 섞기를 실행하면 카드의 순서가 [A5, A2, A1, A4, A3, A6]이 되고, 다시 한 번 더 섞기를 실행하면 카드의 순서가 [A1, A2, A3, A6, A5, A4]가 된다. 이렇게 섞기를 반복하면 카드의 순서가 처음 상태인 [A1, A2, A3, A4, A5, A6]이 된다. 처음 상태로 돌아 올 때까지 반복한 섞기의 최소 횟수를 주어진 섞기 수열의 궤적이라 한다. 임의의 섞기 수열이 주어졌을 때, 그 섞기 수열의 궤적을 구하는 프로그램을 작성하시오.  입력  첫 번째 줄에 카드의 수 N이 주어진다. N은 1 이상 20,000 이하의 수이다. 두 번째 줄에 섞기 수열을 나타내는 N 개의 자연수가 빈칸을 사이에 두고 주어진다.  출력  첫 번째 줄에 입력으로 주어진 섞기 수열의 궤적을 출력한다. 단, 궤적이 1 이상 2,000,000,000 이하인 입력만 주어진다.     문제 풀이   각 위치마다 사이클이 있는데 이 사이클의 최소공배수를 구하면 된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;     static int[] arr;     static boolean[] visited;     static int res = 1;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2487_섞기수열/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         arr = new int[N + 1];         visited = new boolean[N + 1];          StringTokenizer st = new StringTokenizer(br.readLine());         for (int i = 1; i &lt;= N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }          for (int i = 1; i &lt;= N; i++) {             if (!visited[i]) {                 int len = 0;                 for (int j = i; !visited[j]; j = arr[j]) {                     visited[j] = true;                     len++;                 }                 res = LCM(res, len);             }         }          System.out.println(res);         bw.flush();         bw.close();         br.close();     }      private static int GCD(int a, int b){         while(b != 0){             int tmp = b;             b = a % b;             a = tmp;         }         return a;     }      private static int LCM(int a, int b){         return a / GCD(a, b) * b;     } }  "
  },
  
  {
    "title": "BOJ_2549_루빅의 사각형 (Java)",
    "url": "/posts/BOJ2549%EB%A3%A8%EB%B9%85%EC%9D%98-%EC%82%AC%EA%B0%81%ED%98%95-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-09 02:54:27 +0900",
    "content": "[Platinum II] 루빅의 사각형 - 2549  문제 링크  성능 요약  메모리: 86480 KB, 시간: 424 ms  분류  백트래킹, 양방향 탐색, 그래프 이론, 중간에서 만나기  제출 일자  2025년 2월 9일 02:42:05  문제 설명  4×4 격자판에 1에서 16까지 정수 번호가 매겨진 16개 타일이 임의로 놓여져 있다. 타일을 움직여 그림 1과 같이 타일을 놓이게 하려고 한다.   \t \t\t \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t4 \t\t \t\t \t\t\t5 \t\t\t6 \t\t\t7 \t\t\t8 \t\t \t\t \t\t\t9 \t\t\t10 \t\t\t11 \t\t\t12 \t\t \t\t \t\t\t13 \t\t\t14 \t\t\t15 \t\t\t16 \t\t \t   그림 1  타일을 움직이는 방법은 하나의 행(가로줄)을 오른쪽으로 원하는 칸 수만큼 순환적으로 움직이거나, 하나의 열(세로줄)을 원하는 칸 수만큼 아래쪽으로 순환적으로 움직이는 것이다. 그림 2는 그림 1의 2번째 행을 오른쪽으로 2칸 움직인 것이다. 그림 1의 2번째 행의 오른쪽 끝에 있는 7번 타일과 8번 타일이 오른쪽 경계를 넘어가서 왼쪽 끝으로 옮겨갔다.   \t \t\t \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t4 \t\t \t\t \t\t\t7 \t\t\t8 \t\t\t5 \t\t\t6 \t\t \t\t \t\t\t9 \t\t\t10 \t\t\t11 \t\t\t12 \t\t \t\t \t\t\t13 \t\t\t14 \t\t\t15 \t\t\t16 \t\t \t   그림 2  그림 3은 그림 2의 3번째 열을 아래쪽으로 1칸 움직인 것이다. 그림 2의 3번째 열의 가장 아래에 있는 15번 타일이 가장 위쪽으로 옮겨갔다.   \t \t\t \t\t\t1 \t\t\t2 \t\t\t15 \t\t\t4 \t\t \t\t \t\t\t7 \t\t\t8 \t\t\t3 \t\t\t6 \t\t \t\t \t\t\t9 \t\t\t10 \t\t\t5 \t\t\t12 \t\t \t\t \t\t\t13 \t\t\t14 \t\t\t11 \t\t\t16 \t\t \t   그림 3  그림 3과 같이 타일이 놓여진 격자판이 주어졌다면 3번째 열을 3칸 움직인 다음, 2번째 행을 2칸 움직이면 그림 1과 같이 타일이 놓이게 된다. 따라서 2번 움직이면 된다.  1에서 16까지 번호가 매겨진 타일이 임의로 놓여져 있을 때 그림 1과 같이 타일이 놓일 수 있도록 타일을 움직이는 순서를 출력하는 프로그램을 작성하시오. 여기서 움직이는 횟수는 최소로 하여야 한다.  입력  4×4 격자판에 놓여진 타일 번호가 행단 위로 4개 줄에 주어진다. 타일 번호는 1부터 16까지의 정수이다.  각 줄에는 해당하는 행에 놓여지는 4개 타일의 번호가 빈칸을 사이에 두고 순서대로 주어진다.  출력  첫 번째 줄에는 움직이는 횟수를, 두 번째 줄부터는 한 줄에 하나씩 타일을 움직이는 방법을 순서대로 출력한다.  이때, 격자판의 i번째 행을 k칸 움직였다면 정수 1과 i와 k를 빈칸을 사이에 두고 한 줄에 출력한다. 그리고 격자판의 i번째 열을 k칸 움직였다면 정수 2와 i와 k를 빈칸을 사이에 두고 한 줄에 출력한다. 여기서 i는 1 이상 4 이하, k는 1 이상 3 이하의 정수이다.     문제 풀이   한 줄 이동에 3가지 방법이 있다. 그러므로 8개의 선이 있으므로 24개의 방법이라고 할 수 있다. 완전탐색이면 최대 7번이라고 할 때 24^7 가지의 상태가 발생할 수 있고 약 40억개이므로 시간초과가 발생한다.  이에 2가지 방법이 정해라고 생각된다.    양방향 탐색 : O(24^3.5)   각 방향에서 24^3.5 번 탐색하므로 약 100만번의 연산이므로 가능하다.     휴리스틱을 이용한 가지치기 : 최악 O(24^7) 틀린 개수를 기반으로 가지치기 하기 때문에 실제 탐색에서 많이 감소된다. 예를들어 틀린 개수가 4개라고 해서 반드시 1번의 이동으로 해결되는 것은 아니지만 꽤나 많은 경우 1번으로 해결되고, 틀린갯수고 7개라고 해서 반드시 2번의 이동으로 해결되지는 않지만 꽤나 추정이 정확하다는 점에서, 이를 가지치기로 사용한다. 현재까지 이동횟수 + 예상필요이동횟수의 합이 지금까지의 최적해보다 크거나 같아지면 백트래킹을 하는 방식으로 말이다. 이렇게 실제로 정확하지는 않지만 가지치기를 많이 할 수 있기 때문에 휴리스틱도 가능하다.   1번 방법으로 생각해보자.  먼저 보드의 상태와 그 상태를 만들기위한 이동 경로를 저장해야하고 다른 클래스로 각 이동을 표현해야한다.  양방향 탐색은 시작 상태에서 정방향으로 bfs, 목표상태에서 역방향으로 bfs를 하여 중간에 두 탐색이 만나는 지점이 생기면 경로를 구성할 수 있다.  이 두 경로를 합치면서 역방향 이동은 반대방향으로 바꾸면 완전한 경로가 나온다.  구현 설명  1. 상태 클래스 (State)  각 보드의 상태와 그 상태에 도달하기까지의 이동경로를 저장하는 클래스  class State {     int[][] board;  // 4x4 보드 상태     List&lt;Move&gt; moves;  // 이동 경로      // 깊은 복사를 위한 생성자     public State(int[][] board, List&lt;Move&gt; moves) {         this.board = new int[4][4];         for(int i = 0; i &lt; 4; ++i) {             this.board[i] = Arrays.copyOf(board[i], 4);         }         this.moves = new ArrayList&lt;&gt;(moves);     } }  방문 체크를 위해 equals와 hashCode를 오버라이드했다. 보드의 상태만을 비교하며 이동경로는 비교하지 않는다.  2. 이동 클래스 (Move)  각각의 이동을 표현하는 클래스이다. class Move {     int type;  // 1: 가로줄 오른쪽, 2: 세로줄 아래쪽     int idx;   // 0-based로 몇 번째 줄인지     int cnt;   // 몇 칸 이동하는지 }   3. 양방향 BFS 구현 양방향 BFS :     시작점에서 출발하는 정방향 큐와 목표점에서 출발하는 역방향 큐를 운영   각 방향별로 방문 체크를 위한 맵을 따로 관리   각 단계마다 양쪽에서 한 번씩 탐색을 진행   두 탐색이 만나는 지점이 발견되면 경로를 구성   3-1. search 메서드 BFS의 메인 로직을 담당하는 메서드로 다음과 같이 동작 :     양방향 탐색을 위한 자료구조 초기화            정방향 큐(forwardQueue)와 역방향 큐(backwardQueue)       정방향 방문맵(forwardVisited)와 역방향 방문맵(backwardVisited)           초기 상태 설정     State initialState = new State(initialBoard, new ArrayList&lt;&gt;()); State targetState = new State(targetBoard, new ArrayList&lt;&gt;());           양방향 탐색 수행            정방향 탐색 수행 → expandSearch(forwardQueue, …)       역방향 탐색 수행 → expandSearch(backwardQueue, …)       두 탐색이 만나는 지점을 발견하면 경로 재구성           3-2. expandSearch 메서드 search 메서드에서 호출되는 실제 탐색을 수행하는 메서드 :     큐에서 현재 상태를 꺼낸다        가능한 모든 이동(24가지)을 시도한다             2가지 타입 (가로/세로)       4개의 줄       3가지 이동 칸수                각 이동에 대해:             새로운 보드 상태 생성       방문하지 않은 상태면 큐에 추가       다른 방향 탐색과 만나는지 체크           만나는 지점 발견시 해당 상태 반환, 없으면 null 반환  4. 이동 처리 (moveBoard)  보드의 이동은 다음과 같이 처리한다:     가로 이동의 경우 해당 행을 순환적으로 이동   세로 이동의 경우 해당 열을 순환적으로 이동   나머지 위치는 그대로 유지     private int[][] moveBoard(int[][] board, int type, int idx, int cnt) {   // 깊은 복사   int[][] newBoard = new int[N][N];   for(int i=0; i&lt;N; ++i) {       newBoard[i] = Arrays.copyOf(board[i], N);   }    if(type == 1) {  // 가로 이동       int[] tmp = new int[N];       for(int c=0; c&lt;N; c++) {           tmp[(c+cnt) % 4] = board[idx][c];       }       newBoard[idx] = tmp;   } else {  // 세로 이동       int[] tmp = new int[N];       for(int r=0; r&lt;N; r++) {           tmp[(r+cnt) % 4] = board[r][idx];       }       for(int r=0; r&lt;N; r++) {           newBoard[r][idx] = tmp[r];       }   }   return newBoard; }           5. 경로 재구성 (remakePath) 두 방향의 탐색이 만나면 경로를 다음과 같이 재구성 :     정방향 경로는 그대로 사용   역방향 경로는 반대로 뒤집어서 붙임   역방향 이동은 반대 방향으로 변환 (4-cnt 칸 이동)   List&lt;Move&gt; remakePath(State meetingState, Map&lt;String, State&gt; forwardVisited, Map&lt;String, State&gt; backwardVisited) {     String boardString = boardToString(meetingState.board);     List&lt;Move&gt; forwardMoves = forwardVisited.get(boardString).moves;     List&lt;Move&gt; backwardMoves = backwardVisited.get(boardString).moves;      List&lt;Move&gt; totalPath = new ArrayList&lt;&gt;(forwardMoves);     for(int i=backwardMoves.size()-1; i&gt;=0; i--) {         Move move = backwardMoves.get(i);         totalPath.add(new Move(move.type, move.idx, 4 - move.cnt));     }     return totalPath; }   시간복잡도  각 상태에서 24가지의 이동이 가능하다. 양방향 BFS를 사용하므로 24^(d/2)개의 상태만 탐색한다. (d는 최단거리) 따라서 시간복잡도는 O(24^3.5)이다.  공간복잡도  각 상태는 16개의 정수와 이동경로를 저장한다. 최대 24^3.5개의 상태를 저장한다. 따라서 공간복잡도는 O(24^3.5)이다.     코드   package BOJ_2549_루빅의사각형;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class State{         int[][] board;         List&lt;Move&gt; moves;          public State(int[][] board, List&lt;Move&gt; moves){             this.board = new int[4][4];             for(int i = 0; i &lt; 4; ++i){                 this.board[i] = Arrays.copyOf(board[i], 4);             }             this.moves = new ArrayList&lt;&gt;(moves);         }          @Override         public boolean equals(Object o){             if(this == o) return true;             if(!(o instanceof State)) return false;             State other = (State)o;             for(int i = 0; i &lt; 4; ++i){                 if(!Arrays.equals(this.board[i], other.board[i])) return false;             }             return true;         }          @Override         public int hashCode(){             return Arrays.deepHashCode(board);         }     }      class Move{         int type; // 1 : 오른쪽으로밀기, 2 : 아래로밀기         int idx; // 0-based         int cnt; // 이동한 칸 수         public Move(int type, int idx, int cnt){             this.type = type;             this.idx = idx;             this.cnt = cnt;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static final int N = 4;     static int[][] initialBoard, targetBoard;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2549_루빅의사각형/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          // 시작보드         initialBoard = new int[N][N];         for(int i = 0; i &lt; N; ++i){             st = new StringTokenizer(br.readLine());             for(int j = 0; j &lt; N; ++j){                 initialBoard[i][j] = Integer.parseInt(st.nextToken());             }         }          // 완성할 보드         targetBoard = new int[N][N];         int num = 1;         for(int i = 0; i &lt; N; ++i){             for(int j = 0; j &lt; N; ++j){                 targetBoard[i][j] = num++;             }         }          // 양방향탐색         List&lt;Move&gt; sol = search(initialBoard);          System.out.println(sol.size());         for(Move m : sol){             System.out.println(m.type + \" \" + (1+m.idx) + \" \" + m.cnt);         }         bw.flush();         bw.close();         br.close();     }      private List&lt;Move&gt; search(int[][] initialBoard){         Queue&lt;State&gt; forwardQueue = new LinkedList&lt;&gt;();         Queue&lt;State&gt; backwardQueue = new LinkedList&lt;&gt;();         Map&lt;String, State&gt; forwardVisited = new HashMap&lt;&gt;();         Map&lt;String, State&gt; backwardVisited = new HashMap&lt;&gt;();          State initialState = new State(initialBoard, new ArrayList&lt;&gt;());         State targetState = new State(targetBoard, new ArrayList&lt;&gt;());          forwardQueue.offer(initialState);         backwardQueue.offer(targetState);         forwardVisited.put(boardToString(initialBoard), initialState);         backwardVisited.put(boardToString(targetBoard), targetState);          while(!forwardQueue.isEmpty() &amp;&amp; !backwardQueue.isEmpty()){             // 정방향             State meetingState = expandSearch(forwardQueue, forwardVisited, backwardVisited, true);              if(meetingState != null) return remakePath(meetingState, forwardVisited, backwardVisited);              // 역방향             meetingState = expandSearch(backwardQueue, backwardVisited, forwardVisited, false);              if(meetingState != null) return remakePath(meetingState, forwardVisited, backwardVisited);          }         return new ArrayList&lt;&gt;(); // 못 찾았을때     }      private State expandSearch(Queue&lt;State&gt; queue, Map&lt;String, State&gt; visited, Map&lt;String, State&gt; otherVisited, boolean ifForward){         State curr = queue.poll();          //모든방법 시도         for(int type=1; type&lt;=2; type++){             for(int idx=0; idx&lt;4; idx++){                 for(int cnt=1; cnt&lt;=3; cnt++){                     int[][] newBoard = moveBoard(curr.board, type, idx, cnt);                     List&lt;Move&gt; newMoves = new ArrayList&lt;&gt;(curr.moves);                     newMoves.add(new Move(type, idx, cnt));                      State newState = new State(newBoard, newMoves);                     String boardString = boardToString(newBoard);                      if(!visited.containsKey(boardString)){                         visited.put(boardString, newState);                         queue.offer(newState);                          // 다른방향 탐색이랑 만나는지 체크                         if(otherVisited.containsKey(boardString)){                             return newState;                         }                     }                 }             }         }         return null;     }      private int[][] moveBoard(int[][] board, int type, int idx, int cnt){         int[][] newBoard = new int[N][N];         for(int i=0; i&lt;N; ++i){             newBoard[i] = Arrays.copyOf(board[i], N);         }          // 가로오른쪽으로         if(type == 1){             int[] tmp = new int[N];             for(int c=0; c&lt;N; c++){                 tmp[(c+cnt) % 4] = board[idx][c];             }             newBoard[idx] = tmp;         }         // 세로아래로         else{             int[] tmp = new int[N];             for(int r=0; r&lt;N; r++){                 tmp[(r+cnt) % 4] = board[r][idx];             }             for(int r=0; r&lt;N; r++){                 newBoard[r][idx] = tmp[r];             }         }         return newBoard;     }      String boardToString(int[][] board){         StringBuilder sb = new StringBuilder();         for(int i=0; i&lt;N; ++i){             for(int j=0; j&lt;N; ++j){                 sb.append(board[i][j]).append(\" \");             }         }         return sb.toString();     }      List&lt;Move&gt; remakePath(State meetingState, Map&lt;String, State&gt; forwardVisited, Map&lt;String, State&gt; backwardVisited){         String boardString = boardToString(meetingState.board);         List&lt;Move&gt; forwardMoves = forwardVisited.get(boardString).moves;         List&lt;Move&gt; backwardMoves = backwardVisited.get(boardString).moves;          List&lt;Move&gt; totalPath = new ArrayList&lt;&gt;(forwardMoves);         // 역방향을 반대로 붙이기         for(int i=backwardMoves.size()-1; i&gt;=0; i--){             Move move = backwardMoves.get(i);             // 반대방향 이동은 4-cnt칸 이동임             totalPath.add(new Move(move.type, move.idx, 4 - move.cnt));         }         return totalPath;     } }  "
  },
  
  {
    "title": "BOJ_1637_날카로운 눈 (Java)",
    "url": "/posts/BOJ1637%EB%82%A0%EC%B9%B4%EB%A1%9C%EC%9A%B4-%EB%88%88-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-08 22:54:52 +0900",
    "content": "[Platinum IV] 날카로운 눈 - 1637  문제 링크  성능 요약  메모리: 14916 KB, 시간: 136 ms  분류  이분 탐색, 매개 변수 탐색  제출 일자  2025년 2월 8일 22:44:20  문제 설명  동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 원숭이는 좀 특이한 원숭이였다. 어떤 것도 꿰뚫어볼 수 있는 날카로운 눈을 가진 기이한 원숭이였다. 부드러운 눈을 가진 멍멍이는 언제나 날카로운 눈을 가진 원숭이를 부러워했지만 한편으로는 매우 질투했다. 어느 날 멍멍이는 원숭이의 날카로운 눈이 너무 샘나서 원숭이를 직접 패고 싶었지만 날카로운 눈으로 찌를까봐 무서워서 때리지는 못하고 대신, 원숭이에게 문제 하나를 던져주었다. 그 문제는 다음과 같다. 정수가 여러 개 모여 있는 정수더미가 있다. 그 안에 어떤 특정한 정수 하나만 홀수개 존재하고 나머지 정수는 모두 짝수개 존재한다. 정수더미 속에서 날카로운 눈을 이용해 홀수개 존재하는 정수를 찾아야 하는 문제이다. 근데 멍멍이가 문제를 전달해 주려다가 생각해보니 정수더미 안에 정수가 적게 있으면 문제가 너무 쉬워지게 되는 것이다. 그래서 정수더미안에 정수를 무지막지하게 많이 넣기로 했다. 정수더미가 주어졌을 때, 그 안에 홀수개 존재하는 정수를 찾는 프로그램을 작성하시오.  입력  첫째 줄에 입력의 개수 N이 주어진다. N은 1이상 20,000이하인 수이다. 그 다음 줄부터 N줄에 걸쳐 세 개의 정수 A, C, B가 주어지는데, 이것은 A, A+B, A+2B, ..., A+kB (단, A+kB ≦ C) 의 정수들이 정수더미 안에 있다는 것을 나타낸다. A, B, C는 1보다 크거나 같고 2,147,483,647보다 작거나 같은 정수이다. 정수더미는 N개의 입력이 나타내는 정수들을 모두 포함한다.  출력  첫째 줄에 정수 두 개를 출력하는데, 첫 번째는 홀수개 존재하는 정수를 출력하고, 두 번째는 그 정수가 몇 개 들어있는지 출력한다. 만약 홀수개 존재하는 정수가 없다면 NOTHING을 출력한다.     문제 풀이     제한이 매우 크지만 모두 탐색해야하기 때문에 파라매트릭 서치를 사용했다.  mid를 이분탐색으로 갱신하면서 mid까지의 개수를 기준으로 짝수개면 mid 초과 부분에 홀수개가 있단것이므로 오른쪽 구간을 선택, 반대로 홀수면 홀수가 나왔단 의미이므로 왼쪽구간을 선택했다.  특정 숫자까지 개수가 몇개인지는 그림과 같은 수식을 통해 체크할 수 있었고 특정 숫자(mid)에서의 개수는 mid까지의 개수 - (mid-1)까지의 개수로 셀 수 있었다.     코드   package BOJ_1637_날카로운눈;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N;     static long res;     static boolean flag = false;     static int[][] board; // [A, C, B] 저장     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1637_날카로운눈/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         board = new int[N][3];         for(int i=0; i&lt;N; i++) {             st = new StringTokenizer(br.readLine());             board[i][0] = Integer.parseInt(st.nextToken());             board[i][1] = Integer.parseInt(st.nextToken());             board[i][2] = Integer.parseInt(st.nextToken());         }                  long left = 1;         long right = 2147483647;          while(left&lt;=right) {             long mid = left + (right - left)/2;             long cnt = getCnt(mid);              if(cnt % 2 == 0) left = mid + 1;             else {                 res = mid;                 right = mid - 1;                 if(!flag) flag = true;             }         }          if(!flag)  sb.append(\"NOTHING\");         else {             long ans = getCnt(res) - getCnt(res-1);             sb.append(res).append(\" \").append(ans);         }          bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private long getCnt(long mid) { // mid보다 작거나 같은 수들의 총 개수         if(mid &lt; 1) return 0;          long sum = 0;          long A, B, C;         for(int i=0; i&lt;N; i++){             A = board[i][0];             C = board[i][1];             B = board[i][2];             if(mid &lt; A) continue;             if(mid &gt; C) sum += (C-A)/B + 1;             else sum += (mid-A)/B + 1;         }         return sum;     } }    빠른 입출력 코드 package BOJ_1637_날카로운눈;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main2 {      static class FastReader {         private final DataInputStream din;         private final byte[] buffer;         private int bufferPointer, bytesRead;          public FastReader() {             din = new DataInputStream(System.in);             buffer = new byte[16384];             bufferPointer = bytesRead = 0;         }          private byte read() throws IOException {             if (bufferPointer == bytesRead)                 fillBuffer();             return buffer[bufferPointer++];         }          private void fillBuffer() throws IOException {             bytesRead = din.read(buffer, bufferPointer = 0, buffer.length);             if (bytesRead == -1)                 buffer[0] = -1;         }          public int nextInt() throws IOException {             int ret = 0;             byte c = read();             while (c &lt;= ' ')                 c = read();             boolean neg = (c == '-');             if (neg)                 c = read();             do {                 ret = ret * 10 + c - '0';             } while ((c = read()) &gt;= '0' &amp;&amp; c &lt;= '9');             return neg ? -ret : ret;         }     }      static class FastWriter {         private final BufferedOutputStream bos;          public FastWriter() {             this.bos = new BufferedOutputStream(System.out);         }          public void print(Object object) throws IOException {             bos.write(object.toString().getBytes());         }          public void println(Object object) throws IOException {             print(object);             bos.write('\\n');         }          public void flush() throws IOException {             bos.flush();         }     }     static StringBuilder sb = new StringBuilder();     static int N;     static long res;     static boolean flag = false;     static int[][] board; // [A, C, B] 저장     public static void main(String[] args) throws Exception {         new Main2().solution();     }      public void solution() throws Exception {         FastReader fr = new FastReader();         FastWriter fw = new FastWriter();                  N = fr.nextInt();         board = new int[N][3];         for(int i=0; i&lt;N; i++) {             board[i][0] = fr.nextInt();             board[i][1] = fr.nextInt();             board[i][2] = fr.nextInt();         }                  long left = 1;         long right = 2147483647;          while(left&lt;=right) {             long mid = left + (right - left)/2;             long cnt = getCnt(mid);              if(cnt % 2 == 0) left = mid + 1;             else {                 res = mid;                 right = mid - 1;                 if(!flag) flag = true;             }         }          if(!flag) fw.println(\"NOTHING\");         else {             long ans = getCnt(res) - getCnt(res-1);             fw.print(res);             fw.print(\" \");             fw.println(ans);         }         fw.flush();     }      private long getCnt(long mid) { // mid보다 작거나 같은 수들의 총 개수         if(mid &lt; 1) return 0;          long sum = 0;          long A, B, C;         for(int i=0; i&lt;N; i++){             A = board[i][0];             C = board[i][1];             B = board[i][2];             if(mid &lt; A) continue;             if(mid &gt; C) sum += (C-A)/B + 1;             else sum += (mid-A)/B + 1;         }         return sum;     } }     "
  },
  
  {
    "title": "BOJ_2234_성곽 (Java)",
    "url": "/posts/BOJ2234%EC%84%B1%EA%B3%BD-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-07 22:57:48 +0900",
    "content": "[Gold III] 성곽 - 2234  문제 링크  성능 요약  메모리: 168500 KB, 시간: 424 ms  분류  너비 우선 탐색, 비트마스킹, 그래프 이론, 그래프 탐색  제출 일자  2025년 2월 7일 22:47:03  문제 설명    대략 위의 그림과 같이 생긴 성곽이 있다. 굵은 선은 벽을 나타내고, 점선은 벽이 없어서 지나다닐 수 있는 통로를 나타낸다. 이러한 형태의 성의 지도를 입력받아서 다음을 계산하는 프로그램을 작성하시오.   \t이 성에 있는 방의 개수 \t가장 넓은 방의 넓이 \t하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기   위의 예에서는 방은 5개고, 가장 큰 방은 9개의 칸으로 이루어져 있으며, 위의 그림에서 화살표가 가리키는 벽을 제거하면 16인 크기의 방을 얻을 수 있다.  성은 M × N(1 ≤ M, N ≤ 50)개의 정사각형 칸으로 이루어진다. 성에는 최소 두 개의 방이 있어서, 항상 하나의 벽을 제거하여 두 방을 합치는 경우가 있다.  입력  첫째 줄에 두 정수 N, M이 주어진다. 다음 M개의 줄에는 N개의 정수로 벽에 대한 정보가 주어진다. 벽에 대한 정보는 한 정수로 주어지는데, 서쪽에 벽이 있을 때는 1을, 북쪽에 벽이 있을 때는 2를, 동쪽에 벽이 있을 때는 4를, 남쪽에 벽이 있을 때는 8을 더한 값이 주어진다. 참고로 이진수의 각 비트를 생각하면 쉽다. 따라서 이 값은 0부터 15까지의 범위 안에 있다.  출력  첫째 줄에 1의 답을, 둘째 줄에 2의 답을, 셋째 줄에 3의 답을 출력한다.     문제 풀이     bfs 와 비트마스킹으로 풀었다.     코드   package BOJ_2234_성곽;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M, board[][];     static int roomCnt=0, maxRoomSize=Integer.MIN_VALUE, maxRoomSizeWithBreak=Integer.MIN_VALUE;     static int[] dr = {0, -1, 0, 1}, dc = {-1, 0, 1, 0};     static boolean visited[][];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2234_성곽/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         M = Integer.parseInt(st.nextToken());         N = Integer.parseInt(st.nextToken());         board = new int[N+2][M+2];         visited = new boolean[N+2][M+2];          // edge padding         for(int i = 0; i &lt; N+2; i++){             board[i][0] = -1;             board[i][M+1] = -1;         }         for(int i = 0; i &lt; M+2; i++){             board[0][i] = -1;             board[N+1][i] = -1;         }          for(int i=1; i&lt;=N; i++){             st = new StringTokenizer(br.readLine());             for(int j=1; j&lt;=M; j++){                 board[i][j] = Integer.parseInt(st.nextToken());             }         }          // 1. 이 성에 있는 방의 개수         for(int i=1; i&lt;=N; i++){             for(int j=1; j&lt;=M; j++){                 if(!visited[i][j]){                     int size = bfs(i, j);                     roomCnt++;                     maxRoomSize = Math.max(maxRoomSize, size);                 }             }         }         sb.append(roomCnt).append(\"\\n\");          // 2. 가장 넓은 방의 넓이         sb.append(maxRoomSize).append(\"\\n\");          maxRoomSizeWithBreak = 0;         // 3. 하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기         // 특정 칸에서 사방탐색해서 벽있으면 부숴서 최대 넓이         visited = new boolean[N+2][M+2];         for(int i=1; i&lt;=N; i++){             for(int j=1; j&lt;=M; j++){                 int size = breakWall(i, j);                 maxRoomSizeWithBreak = Math.max(maxRoomSizeWithBreak, size);             }         }         sb.append(maxRoomSizeWithBreak).append(\"\\n\");         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private int bfs(int i, int j) {         int size = 1;         Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();         queue.add(new int[]{i, j});         visited[i][j] = true;          while(!queue.isEmpty()){             int[] curr = queue.poll();             int currWall = board[curr[0]][curr[1]];              for(int k=0; k&lt;4; k++){                 int[] next = new int[] {curr[0] + dr[k], curr[1] + dc[k]};                 int nextWall = board[next[0]][next[1]];                  if(nextWall != -1 &amp;&amp; !visited[next[0]][next[1]] &amp;&amp; checkDir(k, currWall)){                     queue.offer(next);                     visited[next[0]][next[1]] = true;                     size++;                 }             }         }         return size;     }      private boolean checkDir(int dir, int curr) { // 이동 가능하면 true         return (curr &amp; (1&lt;&lt;dir)) == 0;     }      private int breakWall(int i, int j) {         int totalSize = 0;         int currWall = board[i][j];          for(int r = 0; r &lt; N+2; r++) {             Arrays.fill(visited[r], false);         }          for(int k=0; k&lt;4; k++){             int[] next = new int[] {i + dr[k], j + dc[k]};             int nextWall = board[next[0]][next[1]];             if(nextWall != -1 &amp;&amp; !checkDir(k, currWall)){                  // 벽 부수고 크기재고 원상복구                 board[i][j] &amp;= ~(1&lt;&lt;k);                 if(k==0) board[next[0]][next[1]] &amp;= ~(1&lt;&lt;2);                 else if(k==1) board[next[0]][next[1]] &amp;= ~(1&lt;&lt;3);                 else if(k==2) board[next[0]][next[1]] &amp;= ~(1&lt;&lt;0);                 else board[next[0]][next[1]] &amp;= ~(1&lt;&lt;1);                  totalSize = Math.max(totalSize, bfs(i, j));                  board[i][j] |= (1&lt;&lt;k);                 if(k==0) board[next[0]][next[1]] |= (1&lt;&lt;2);                 else if(k==1) board[next[0]][next[1]] |= (1&lt;&lt;3);                 else if(k==2) board[next[0]][next[1]] |= (1&lt;&lt;0);                 else board[next[0]][next[1]] |= (1&lt;&lt;1);             }         }         return totalSize;     } }   "
  },
  
  {
    "title": "BOJ_17435_합성함수와 쿼리 (Java)",
    "url": "/posts/BOJ17435%ED%95%A9%EC%84%B1%ED%95%A8%EC%88%98%EC%99%80-%EC%BF%BC%EB%A6%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-05 05:11:09 +0900",
    "content": "[Gold I] 합성함수와 쿼리 - 17435  문제 링크  성능 요약  메모리: 103124 KB, 시간: 900 ms  분류  자료 구조, 희소 배열  제출 일자  2025년 2월 5일 05:07:06  문제 설명  함수 f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때 fn : {1, 2, ..., m}→{1, 2, ..., m}을 다음과 같이 정의하자.   \tf1(x) = f(x) \tfn+1(x) = f(fn(x))   예를 들어 f4(1) = f(f(f(f(1))))이다.  n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.  입력  첫 줄에 정수 m이 주어진다. (1 ≤ m ≤ 200,000)  다음 줄에 f(1), f(2), ..., f(m)이 차례대로 주어진다.  다음 줄에 쿼리의 개수 Q가 주어진다. (1 ≤ Q ≤ 200,000)  다음 Q개의 줄에 각각 정수 n과 x가 주어진다. (1 ≤ n ≤ 500,000; 1 ≤ x ≤ m)  출력  주어지는 n, x마다 fn(x)를 출력한다.     문제 풀이   희소 배열을 공부했다.    희소 배열이란?  2의 거듭제곱 단위로 건너뛰는 결과를 미리 저장해두는 배열입니다 dp[k][x] = x에서 시작해서 2^k번 이동했을 때의 도착점  예시로 이해하기 f = [3, 3, 5, 4, 3] (인덱스는 1부터 시작)           dp[0][x] = 한 번 이동             dp[0][1] = 3 (1→3)       dp[0][2] = 3 (2→3)       dp[0][3] = 5 (3→5)                dp[1][x] = 두 번 이동             dp[1][1] = 5 (1→3→5)       dp[1][2] = 5 (2→3→5)       dp[1][3] = 3 (3→5→3)                p[2][x] = 네 번 이동             dp[2][1] = 3 (1→3→5→3→5)           이런 식으로 2의 거듭제곱 단위로 몇 번 이동했을 때의 결과를 미리 계산해두는 것이 희소 배열의 핵심입니다.  장점     n번 이동해야 할 때, n을 이진수로 분해해서 필요한 부분만 사용   예: 7번 이동 = 4번 이동 + 2번 이동 + 1번 이동 (7 = 4 + 2 + 1)      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17435_합성함수와쿼리/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int m = Integer.parseInt(br.readLine());         int[][] dp = new int[19][m+1]; // 2^18 &gt; 500000 이므로 19도 충분함          st = new StringTokenizer(br.readLine());         for(int i = 1; i &lt;= m; i++) {             dp[0][i] = Integer.parseInt(st.nextToken());         }          for(int i=1; i&lt;19; i++) {             for(int j=1; j&lt;=m; j++){                 dp[i][j] = dp[i-1][dp[i-1][j]];             }         }          int q = Integer.parseInt(br.readLine());         while(q--&gt; 0) {             st = new StringTokenizer(br.readLine());             int n = Integer.parseInt(st.nextToken());             int x = Integer.parseInt(st.nextToken());              for(int i=0; i&lt;19; i++){                 if((n &amp; (1&lt;&lt;i)) != 0) x = dp[i][x];             }             sb.append(x).append(\"\\n\");         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }     입출력 가장빠르게 코드  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static StringBuilder sb = new StringBuilder();     static int m, q, n, x;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         m = read();         int[][] dp = new int[19][m+1];          // f(x) 입력 받기         for(int i = 1; i &lt;= m; i++) {             dp[0][i] = read();         }          // 희소 배열 계산         for(int i=1; i&lt;19; i++) {             for(int j=1; j&lt;=m; j++){                 dp[i][j] = dp[i-1][dp[i-1][j]];             }         }          q = read();         while(q--&gt; 0) {             n = read();             x = read();              for(int i=0; i&lt;19; i++){                 if((n &amp; (1&lt;&lt;i)) != 0) x = dp[i][x];             }             sb.append(x).append(\"\\n\");         }         System.out.println(sb);     }     public static int read() throws IOException {         int n = 0;         boolean isNegative = false;         int c;         while ((c = System.in.read()) &lt;= 32) ;         if (c == '-') {             isNegative = true;             c = System.in.read();         }         do n = (n &lt;&lt; 3) + (n &lt;&lt; 1) + (c &amp; 15);         while ((c = System.in.read()) &gt; 32);         return isNegative ? -n : n;     } }   로직 같은 코든데    이정도 차이난다. "
  },
  
  {
    "title": "BOJ_18513_샘터 (Java)",
    "url": "/posts/BOJ18513%EC%83%98%ED%84%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-04 23:40:40 +0900",
    "content": "[Gold IV] 샘터 - 18513  문제 링크  성능 요약  메모리: 56076 KB, 시간: 560 ms  분류  너비 우선 탐색, 자료 구조, 그래프 이론, 그래프 탐색  제출 일자  2025년 2월 4일 23:16:33  문제 설명  일직선 상의 공간에 N개의 샘터가 존재하며, K채의 집을 짓고자 한다. 모든 샘터 및 집이 존재하는 위치는 항상 정수 형태이다. 이때 일직선 상의 공간에서 N개의 샘터 및 K채의 집들은 모두 서로 다른 위치에 존재한다. 다시 말해 하나의 위치에는 샘터가 있거나, 집이 있거나, 혹은 아무것도 없다.  K채의 집을 지을 때, 가능하면 샘터의 주변에 집들을 지어서 K채의 모든 집에 대한 불행도의 합이 최소가 되도록 짓고자 한다. 이때 특정한 집에 대한 불행도란, 가장 가까운 샘터까지의 거리(Distance)로 정의된다. 예를 들어 특정한 집이 1에 위치하고, 그 집과 가장 가까운 샘터가 -5에 위치한다고 하면, 이 집의 불행도는 6이다.  N=2, K=5일 때, 모든 집에 대한 불행도의 합이 최소가 되도록 집을 짓는 경우를 고려해보자. 아래 그림과 같이 두 개의 샘터가 0, 3의 위치에 존재한다고 가정하자.    이때 다음과 같이 5채의 집을 설치하면, 각 집의 불행도의 합이 2+1+1+1+1=6로 최소가 된다. 집을 짓는 가능한 경우의 수는 여러 가지가 될 수 있지만, 불행도의 합을 6보다 작게 만드는 방법은 없다.    입력  첫째 줄에 자연수 N과 K가 공백을 기준으로 구분되어 주어진다. (1 ≤ N, K ≤ 100,000) 둘째 줄에 N개의 샘터의 위치가 공백을 기준으로 구분되어 정수 형태로 주어진다. (-100,000,000 ≤ 샘터의 위치 ≤ 100,000,000) 단, 모든 N개의 샘터의 위치들은 서로 다르게 주어진다.  출력  첫째 줄에 모든 집에 대한 불행도의 합의 최솟값을 출력한다.     문제 풀이   간단한 bfs 문제다. 처음에 한참 삽질한 방법은 아직도 왜 틀린지 모르겠다. 그림과 같은 방법으로 풀었었는데 이 방법으로 모든 예제를 찾아보고 만들어서 테스트해봤는데 다 맞지만 틀려서 방법을 변경했다.   모든 샘물에서 bfs동시에 돌리면서 K개까지 탐색했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Node{ \tint x; \tint cnt; \tpublic Node(int x, int cnt) { \t\tthis.x = x; \t\tthis.cnt = cnt; \t} }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K;     static int[] arr, dx = {-1, 1}; \tstatic long res = 0;     static Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); \tpublic static HashSet&lt;Integer&gt; visited = new HashSet&lt;&gt;();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_18513_샘터/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());     \tK = Integer.parseInt(st.nextToken());      \tarr = new int[N];     \tst = new StringTokenizer(br.readLine());     \tfor(int i=0;i&lt;N;i++) {     \t\tarr[i] = Integer.parseInt(st.nextToken());     \t}          for(int i=0;i&lt;N;i++) {     \t\tqueue.offer(new Node(arr[i], 0)); //BFS 시작위치     \t\tvisited.add(arr[i]);     \t}          bfs();          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private void bfs() {         int houseCnt = 0;         while(!queue.isEmpty()) {             Node curr = queue.poll();             int currX = curr.x;             int currCnt = curr.cnt;             res += currCnt;             for(int k=0; k&lt;2; k++) {                 int nx = currX + dx[k];                 if(visited.contains(nx)) continue;                 if(houseCnt &gt;= K) continue;                 queue.offer(new Node(nx, currCnt+1));                 visited.add(nx);                  houseCnt++;             }         }     } }  "
  },
  
  {
    "title": "BOJ_22862_가장 긴 짝수 연속한 부분 수열 (large) (Java)",
    "url": "/posts/BOJ22862%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A7%9D%EC%88%98-%EC%97%B0%EC%86%8D%ED%95%9C-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-large-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-03 05:20:50 +0900",
    "content": "[Gold V] 가장 긴 짝수 연속한 부분 수열 (large) - 22862  문제 링크  성능 요약  메모리: 92168 KB, 시간: 448 ms  분류  두 포인터  제출 일자  2025년 2월 3일 05:02:12  문제 설명  길이가 $N$인 수열 $S$가 있다. 수열 $S$는 1 이상인 정수로 이루어져 있다.  수열 $S$에서 원하는 위치에 있는 수를 골라 최대 $K$번 삭제를 할 수 있다.  예를 들어, 수열 $S$가 다음과 같이 구성되어 있다고 가정하자.    수열 $S$에서 4번째에 있는 4를 지운다고 하면 아래와 같다.    수열 $S$에서 최대 $K$번 원소를 삭제한 수열에서 짝수로 이루어져 있는 연속한 부분 수열 중 가장 긴 길이를 구해보자.  입력  수열 $S$의 길이 $N$와 삭제할 수 있는 최대 횟수인 $K$가 공백으로 구분되어 주어진다.  두 번째 줄에는 수열 $S$를 구성하고 있는 $N$개의 수가 공백으로 구분되어 주어진다.  출력  수열 $S$에서 최대 $K$번 원소를 삭제한 수열에서 짝수로 이루어져 있는 연속한 부분 수열 중 가장 긴 길이를 출력한다.  제한   $1 \\le N \\le 1,000,000$    $1 \\le K \\le 100,000$    $1 \\le$ 원소의 값 $\\le 10^6$      문제 풀이        코드   package BOJ_22862_가장긴짝수연속한부분수열large;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, K, oddCnt;     static boolean[] isOdd;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_22862_가장긴짝수연속한부분수열large/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());          isOdd = new boolean[N];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             isOdd[i] = Integer.parseInt(st.nextToken()) % 2 == 1;             if(isOdd[i]) oddCnt++;         }          if(N == 1){             bw.write(isOdd[0] ? \"0\" : \"1\");         }         else{             if(oddCnt &lt;= K) {                 bw.write(String.valueOf(N-oddCnt));             }             else{                 int left=0, right=0;                 int cnt = K;                 int evenCnt = 0;                 int maxLen = 0;                  while(right &lt; N &amp;&amp; left &lt;= right){                     if(!isOdd[right]){ // 오른쪽 짝수일때                         evenCnt++;                         right++;                     }                     else{ // 오른쪽 홀수일때                         if(cnt &gt; 0) { // 홀수 더 지울 수 있을때                             cnt--;                             right++;                         }                         else{ // 홀수 지울 수 없을때는 왼쪽줄여야됨                             if(!isOdd[left]) { // 왼쪽짝수없애기                                 evenCnt--;                                 left++;                             }                             else{ // 왼쪽홀수없애기                                 cnt++;                                 left++;                             }                         }                     }                     maxLen = Math.max(maxLen, evenCnt);                 }                 sb.append(maxLen).append(\"\\n\");             }         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }   "
  },
  
  {
    "title": "BOJ_15576_큰 수 곱셉 (2), BOJ_22289_큰 수 곱셈 (3) (C++, Java)",
    "url": "/posts/BOJ15576%ED%81%B0-%EC%88%98-%EA%B3%B1%EC%85%89-2-BOJ22289%ED%81%B0-%EC%88%98-%EA%B3%B1%EC%85%88-3-C-Java/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-02-02 21:04:56 +0900",
    "content": "[Platinum I] 큰 수 곱셈 (2) - 15576  문제 링크  성능 요약  메모리: 48496 KB, 시간: 332 ms  분류  고속 푸리에 변환, 수학  제출 일자  2025년 2월 2일 20:08:33  문제 설명  두 정수 A와 B가 주어졌을 때, 두 수의 곱을 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 정수 A와 B가 주어진다. 두 정수는 0보다 크거나 같은 정수이며, 0을 제외한 정수는 0으로 시작하지 않으며, 수의 앞에 불필요한 0이 있는 경우도 없다. 또한, 수의 길이는 300,000자리를 넘지 않는다.  출력  두 수의 곱을 출력한다.     문제 풀이   FFT 공부중입니다. 부족한 부분이나 틀린 부분이 있다면 지적해주세요.  A. 기본 접근 방식 일반적인 O(n²) 곱셈 알고리즘으로는 300,000자리의 곱셈을 2초 안에 처리할 수 없다. 따라서 FFT를 이용한 O(n log n) 알고리즘을 사용한다.  1. 복소수 연산  typedef complex&lt;double&gt; base; const double PI = acos(-1);  C++의 STL complex 클래스 사용으로 복소수 연산 구현  2. FFT 알고리즘 void fft(vector&lt;base&gt;&amp; a, bool invert) {     // bit-reversal permutation     // butterfly operations     // scaling for inverse FFT }  문제풀이 구현     수가 크기때문에 문자열로 입력받아 자릿수로 쪼갠다.   FFT 다항식 곱셈을 위해 내가 공부한 바로는 요약하자면 두 a, b, 다항식을 FFT로 한 뒤 convolution하여 다시 역방향으로 FFT하면 계수가 다 나온다.     fft(fa, false);  // 순방향 FFT fft(fb, false); for(int i = 0; i &lt; n; i++)  fa[i] *= fb[i];  // 점별 곱셈 fft(fa, true);   // 역방향 FFT           결과처리 각 자릿수이므로 0~9숫자로 만들기. 올림처리도       코드   BOJ_15576_큰 수 곱셉 (2) C++ 코드   /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  typedef complex&lt;double&gt; base; typedef long long ll; const double PI = acos(-1);  void fft(vector&lt;base&gt;&amp; a, bool invert) {     int n = a.size(), j = 0;     vector&lt;base&gt; roots(n / 2);      for (int i = 1; i &lt; n; i++) {         int bit = (n &gt;&gt; 1);         while (j &gt;= bit) {             j -= bit;             bit &gt;&gt;= 1;         }         j += bit;         if (i &lt; j) swap(a[i], a[j]);     }      double ang = 2 * PI / n * (invert ? -1 : 1);     for (int i = 0; i &lt; n / 2; i++) {         roots[i] = base(cos(ang * i), sin(ang * i));     }      for (int i = 2; i &lt;= n; i &lt;&lt;= 1) {         int step = n / i;         for (int j = 0; j &lt; n; j += i) {             for (int k = 0; k &lt; i / 2; k++) {                 base u = a[j + k], v = a[j + k + i / 2] * roots[step * k];                 a[j + k] = u + v;                 a[j + k + i / 2] = u - v;             }         }     }     if (invert) {         for (int i = 0; i &lt; n; i++) a[i] /= n;     } }  void solve() {     string s1, s2;     cin &gt;&gt; s1 &gt;&gt; s2;      if (s1 == \"0\" || s2 == \"0\") {         cout &lt;&lt; \"0\\n\";         return;     }      vector&lt;ll&gt; a(s1.size()), b(s2.size());     for (int i = 0; i &lt; s1.size(); i++) a[s1.size() - i - 1] = s1[i] - '0';     for (int i = 0; i &lt; s2.size(); i++) b[s2.size() - i - 1] = s2[i] - '0';      vector&lt;base&gt; fa(a.begin(), a.end()), fb(b.begin(), b.end());     int n = 2;     while (n &lt; a.size() + b.size()) n &lt;&lt;= 1;     fa.resize(n);     fb.resize(n);      fft(fa, false);     fft(fb, false);     for (int i = 0; i &lt; n; i++) fa[i] *= fb[i];     fft(fa, true);      vector&lt;ll&gt; result(n);     for (int i = 0; i &lt; n; i++) result[i] = (ll)round(fa[i].real());      for (int i = 0; i &lt; result.size() - 1; i++) {         result[i + 1] += result[i] / 10;         result[i] %= 10;     }      int idx = result.size() - 1;     while (idx &gt; 0 &amp;&amp; result[idx] == 0) idx--;     for (; idx &gt;= 0; idx--) cout &lt;&lt; result[idx];     cout &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }     BOJ_22289_큰 수 곱셈 (3) Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     public static class NTT {         static final long MOD = 998244353;         static final long PRIMITIVE_ROOT = 3;          static long pow(long a, long b) {             long res = 1;             while (b &gt; 0) {                 if ((b &amp; 1) == 1) {                     res = res * a % MOD;                 }                 a = a * a % MOD;                 b &gt;&gt;= 1;             }             return res;         }          static void ntt(long[] a, boolean invert) {             int n = a.length;              // bit-reversal permutation             for (int i = 1, j = 0; i &lt; n; i++) {                 int bit = n &gt;&gt; 1;                 while (j &gt;= bit) {                     j -= bit;                     bit &gt;&gt;= 1;                 }                 j += bit;                 if (i &lt; j) {                     long temp = a[i];                     a[i] = a[j];                     a[j] = temp;                 }             }              // NTT computation             for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {                 long wlen = pow(PRIMITIVE_ROOT, (MOD - 1) / len);                 if (invert) {                     wlen = pow(wlen, MOD - 2);                 }                  for (int i = 0; i &lt; n; i += len) {                     long w = 1;                     for (int j = 0; j &lt; len/2; j++) {                         long u = a[i + j];                         long v = a[i + j + len/2] * w % MOD;                          a[i + j] = (u + v) % MOD;                         a[i + j + len/2] = (u - v + MOD) % MOD;                          w = w * wlen % MOD;                     }                 }             }              if (invert) {                 long inv_n = pow(n, MOD - 2);                 for (int i = 0; i &lt; n; i++) {                     a[i] = a[i] * inv_n % MOD;                 }             }         }          static long[] multiply(long[] a, long[] b) {             int n = 1;             while (n &lt; a.length + b.length) n &lt;&lt;= 1;              long[] fa = Arrays.copyOf(a, n);             long[] fb = Arrays.copyOf(b, n);              ntt(fa, false);             ntt(fb, false);              for (int i = 0; i &lt; n; i++) {                 fa[i] = fa[i] * fb[i] % MOD;             }              ntt(fa, true);             return fa;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15576_큰수곱셈2/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         String A = st.nextToken();         String B = st.nextToken();          int lenA = A.length();         int lenB = B.length();         int maxLen = Math.max(lenA, lenB);          int n = 1;         while (n &lt; lenA + lenB - 1) n &lt;&lt;= 1;          long[] LL_A = new long[n];         long[] LL_B = new long[n];          for(int i=0; i&lt;lenA; i++) {             LL_A[i] = A.charAt(lenA-1-i) - '0';         }          for(int i=0; i&lt;lenB; i++) {             LL_B[i] = B.charAt(lenB-1-i) - '0';         }          NTT.ntt(LL_A, false);         NTT.ntt(LL_B, false);          for (int i = 0; i &lt; n; i++) {             LL_A[i] = LL_A[i] * LL_B[i] % NTT.MOD;         }          NTT.ntt(LL_A, true);          long[] res = new long[lenA + lenB];         for (int i = 0; i &lt; lenA + lenB - 1; i++) {             res[i] = LL_A[i];         }          for (int i = 0; i &lt; lenA + lenB - 1; i++) {             if (res[i] &gt;= 10) {                 res[i + 1] += res[i] / 10;                 res[i] %= 10;             }         }         boolean leadingZero = true;          for(int i=res.length-1; i&gt;=0; i--) {             if(leadingZero &amp;&amp; res[i] == 0) continue;             leadingZero = false;             sb.append(res[i]);         }          if(sb.length()==0) sb.append(0);          bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1067_이동 (Java)",
    "url": "/posts/BOJ1067%EC%9D%B4%EB%8F%99-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-02 09:27:10 +0900",
    "content": "[Platinum I] 이동 - 1067  문제 링크  성능 요약  메모리: 28436 KB, 시간: 444 ms  분류  고속 푸리에 변환, 수학  제출 일자  2025년 2월 2일 09:03:38  문제 설명  N개의 수가 있는 X와 Y가 있다. 이때 X나 Y를 순환 이동시킬 수 있다. 순환 이동이란 마지막 원소를 제거하고 그 수를 맨 앞으로 다시 삽입하는 것을 말한다. 예를 들어, {1, 2, 3}을 순환 이동시키면 {3, 1, 2}가 될 것이고, {3, 1, 2}는 {2, 3, 1}이 된다. 순환 이동은 0번 또는 그 이상 할 수 있다. 이 모든 순환 이동을 한 후에 점수를 구하면 된다. 점수 S는 다음과 같이 구한다.  S = X[0]×Y[0] + X[1]×Y[1] + ... + X[N-1]×Y[N-1]  이때 S를 최대로 하면 된다.   입력  첫째 줄에 N이 주어진다. 둘째 줄에는 X에 들어있는 N개의 수가 주어진다. 셋째 줄에는 Y에 있는 수가 모두 주어진다. N은 60,000보다 작거나 같은 자연수이고, X와 Y에 들어있는 모든 수는 100보다 작은 자연수 또는 0이다.  출력  첫째 줄에 S의 최댓값을 출력한다.     문제 풀이   예전에 풀어보고싶었던 주제인 고속 푸리에 변환을 공부해보았다. PS에서 FFT를 convolution을 O(nlogn)에 계산해야 할 상황에 필요한 지식이다. 사실 이 코드는 코테처럼 안보고 푼 문제가 아니라 여러 자료들을 찾아가며 고치고 고쳐 구현한 공부용 코드다. koosaga님, kundol님 등 다양한 블로그들을 보고 공부했으며 그 중 가장 도움 되었던 PPT 자료를 최하단 reference에 첨부하겠다.  나름 이론 공부한 내용도 차후에 다른 게시글에 차근차근 정리하겠다. 이해하면 쉽지만 이를 증명하는 과정을 모두 머리에 넣기가 어려웠다.  일단 문제에 대해 알아보자면, 이 문제는 순환 컨볼루션 개념으로 접근할 수 있다. X를 이동시키면서 S를 구하는 과정은 신호 처리에서의 컨볼루션과 동일한 형태를 가진다. 이를 위해 FFT를 활용한 빠른 곱셈을 사용한다.  핵심 개념    순환 이동 (Circular Shift): 배열의 원소를 순환시키는 연산.        ex) 배열 {1, 2, 3}을 순환 이동시키면 {3, 1, 2}, 그 다음엔 {2, 3, 1}이 된다. 이러한 순환 이동을 여러 번 한 뒤 각 이동에 대해 점수 S를 계산해야 한다.           점수 계산 (S): 점수 S는 두 배열 X와 Y의 대응되는 원소들의 곱의 합이다. 즉, S = X[0] * Y[0] + X[1] * Y[1] + … + X[N-1] * Y[N-1].      고속 푸리에 변환 (FFT): FFT는 이 문제를 해결하기 위한 주요 기법.   X와 Y를 주파수 영역으로 변환하고, 그 후 각각의 원소들을 곱한 뒤, 역 FFT를 수행하여 점수 S를 계산하는 방법이다. 이 방법을 사용하면 순환 이동을 고려한 점수 계산을 O(N log N)의 시간 복잡도로 해결할 수 있다.   풀이 과정     배열 크기 확장:            주어진 배열 X와 Y를 두 배 크기로 확장한다. X는 자기 자신을 이어붙여서 원형 이동을 구현하고, Y는 역순으로 저장한다. 이건 배열 순환 이동을 자연스럽게 처리하려고 하는 방법이다.           FFT 변환:            X와 Y 배열을 각각 FFT로 주파수 영역으로 변환한다. FFT는 주파수 성분을 빠르게 추출하는 방법으로, 이를 이용해 순환 이동된 배열의 점수를 빠르게 계산할 수 있다.           원소별 곱셈:            변환된 주파수 영역의 X와 Y 배열을 원소별로 곱한다. 이 곱셈은 순환 이동된 배열에 대한 점수 계산과 같은 역할을 한다.           역 FFT (IFFT):            곱셈을 끝낸 후, 역 FFT를 사용해서 다시 시간 영역으로 변환한다. 이 변환된 값들이 순환 이동된 배열의 점수 S를 나타낸다.           최댓값 계산:            계산된 점수들 중에서 최댓값을 구한다.           구현 세부 사항         배열 확장 및 Y의 역순 저장: X는 두 배 크기로 확장하고 Y는 역순으로 저장한다. 이 방법으로 FFT 결과가 순환 이동을 반영하게 된다.           NTT (Number Theoretic Transform): NTT는 FFT와 비슷하지만 모듈러 연산을 사용하는 특징이 있다. 이 문제에서는 큰 수의 곱셈을 빠르게 계산하기 위해 NTT를 활용한다.           최댓값 계산: 점수 S는 배열 간의 곱을 더한 결과인데, 음수 값이 나올 수 있어서 모듈러 연산을 이용해 양수로 만든다. 최댓값을 찾을 때 음수가 나오면 MOD를 더해 양수로 변환한다.         코드   BasicFFT 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static class Complex {         double real, imag;         static final double EPS = 1e-9;          Complex(double real, double imag) {             this.real = real;             this.imag = imag;         }          Complex add(Complex o) {             return new Complex(real + o.real, imag + o.imag);         }          Complex subtract(Complex o) {             return new Complex(real - o.real, imag - o.imag);         }          Complex multiply(Complex o) {             double r = real * o.real - imag * o.imag;             double i = real * o.imag + imag * o.real;             if (Math.abs(r) &lt; EPS) r = 0;             if (Math.abs(i) &lt; EPS) i = 0;             return new Complex(r, i);         }          Complex divide(double d) {             return new Complex(real / d, imag / d);         }     }      static void fft(Complex[] a, boolean invert) {         int n = a.length;          for (int i = 1, j = 0; i &lt; n; i++) {             int bit = n &gt;&gt; 1;             while (j &gt;= bit) {                 j -= bit;                 bit &gt;&gt;= 1;             }             j += bit;             if (i &lt; j) {                 Complex temp = a[i];                 a[i] = a[j];                 a[j] = temp;             }         }          for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {             double ang = 2 * Math.PI / len * (invert ? -1 : 1);             Complex wlen = new Complex(Math.cos(ang), Math.sin(ang));              for (int i = 0; i &lt; n; i += len) {                 Complex w = new Complex(1, 0);                 for (int j = 0; j &lt; len/2; j++) {                     Complex u = a[i + j];                     Complex v = a[i + j + len/2].multiply(w);                      a[i + j] = u.add(v);                     a[i + j + len/2] = u.subtract(v);                      w = w.multiply(wlen);                 }             }         }          if (invert) {             for (int i = 0; i &lt; n; i++) {                 a[i] = a[i].divide(n);             }         }     }          static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static final double EPS = 1e-9;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1067_이동/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int n = Integer.parseInt(br.readLine());         int size = 1;         while (size &lt; 2 * n) size &lt;&lt;= 1;          Complex[] x = new Complex[size];         Complex[] y = new Complex[size];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; n; i++) {             long val = Long.parseLong(st.nextToken());             x[i] = new Complex(val, 0);             x[i + n] = new Complex(val, 0);         }         for (int i = 2*n; i &lt; size; i++) {             x[i] = new Complex(0, 0);         }          st = new StringTokenizer(br.readLine());         long[] temp = new long[n];         for (int i = 0; i &lt; n; i++) {             temp[i] = Long.parseLong(st.nextToken());         }          for (int i = 0; i &lt; n; i++) {             y[i] = new Complex(temp[n-1-i], 0);         }         for (int i = n; i &lt; size; i++) {             y[i] = new Complex(0, 0);         }          fft(x, false);         fft(y, false);          for (int i = 0; i &lt; size; i++) {             x[i] = x[i].multiply(y[i]);         }          fft(x, true);          long max = Long.MIN_VALUE;         for (int i = n-1; i &lt; 2*n-1; i++) {             double val = Math.abs(x[i].real) &lt; EPS ? 0 : x[i].real;             max = Math.max(max, Math.round(val));         }          bw.write(String.valueOf(max));         bw.flush();         bw.close();         br.close();     } }   기본 FFT 버전 이 버전은 FFT(고속 푸리에 변환) 을 사용해서 문제를 해결한다. FFT는 실수와 복소수를 다룬다는 점에서 NTT와 다르고, 모듈러 연산을 필요로 하지 않는다. Complex 클래스:     - 복소수를 나타내는 클래스다. 실수(real)와 허수(imag) 값을 가지고 있으며, 기본적인 연산인 더하기, 빼기, 곱셈, 나누기 등이 구현되어 있다.     - multiply() 함수는 복소수 곱셈을, add()와 subtract()는 복소수 덧셈과 뺄셈을 구현한다.  fft() 함수:     - 주어진 복소수 배열에 대해 고속 푸리에 변환을 수행하는 함수다.     - 이진 반사 정렬을 하고, 이후 계단식으로 길이를 확장하면서 FFT를 계산한다.     - 역변환을 위한 invert 처리 부분도 있다.  main() 메소드:     - x와 y 배열을 복소수 배열로 변환한 후 fft()를 적용한다.     - x와 y의 각 값들을 곱한 후 역 푸리에 변환을 다시 한다.     - 변환된 값들 중에서 최댓값을 찾아 출력한다.  핵심 아이디어:     - 배열 X와 Y를 복소수로 변환하고, FFT를 적용한다.     - FFT로 얻은 배열을 원소별로 곱하고, 역 FFT를 적용하여 최댓값을 찾는다.    NTT 활용 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static class NTT {         static final long MOD = 998244353;         static final long PRIMITIVE_ROOT = 3;          static long pow(long a, long b) {             long res = 1;             while (b &gt; 0) {                 if ((b &amp; 1) == 1) {                     res = res * a % MOD;                 }                 a = a * a % MOD;                 b &gt;&gt;= 1;             }             return res;         }          static void ntt(long[] a, boolean invert) {             int n = a.length;              for (int i = 1, j = 0; i &lt; n; i++) {                 int bit = n &gt;&gt; 1;                 while (j &gt;= bit) {                     j -= bit;                     bit &gt;&gt;= 1;                 }                 j += bit;                 if (i &lt; j) {                     long temp = a[i];                     a[i] = a[j];                     a[j] = temp;                 }             }              for (int len = 2; len &lt;= n; len &lt;&lt;= 1) {                 long wlen = pow(PRIMITIVE_ROOT, (MOD - 1) / len);                 if (invert) {                     wlen = pow(wlen, MOD - 2);                 }                  for (int i = 0; i &lt; n; i += len) {                     long w = 1;                     for (int j = 0; j &lt; len/2; j++) {                         long u = a[i + j];                         long v = a[i + j + len/2] * w % MOD;                          a[i + j] = (u + v) % MOD;                         a[i + j + len/2] = (u - v + MOD) % MOD;                          w = w * wlen % MOD;                     }                 }             }              if (invert) {                 long inv_n = pow(n, MOD - 2);                 for (int i = 0; i &lt; n; i++) {                     a[i] = a[i] * inv_n % MOD;                 }             }         }          static long[] multiply(long[] a, long[] b) {             int n = 1;             while (n &lt; a.length + b.length) n &lt;&lt;= 1;              long[] fa = Arrays.copyOf(a, n);             long[] fb = Arrays.copyOf(b, n);              ntt(fa, false);             ntt(fb, false);              for (int i = 0; i &lt; n; i++) {                 fa[i] = fa[i] * fb[i] % MOD;             }              ntt(fa, true);             return fa;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1067_이동/input.txt\")));                 bw = new BufferedWriter(new OutputStreamWriter(System.out));                  int n = Integer.parseInt(br.readLine());         int size = 1;         while (size &lt; 2 * n) size &lt;&lt;= 1;          long[] x = new long[size];         long[] y = new long[size];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; n; i++) {             x[i] = Long.parseLong(st.nextToken());             x[i + n] = x[i];         }          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; n; i++) {             long val = Long.parseLong(st.nextToken());             y[(2*n-1-i) % n] = val;         }          NTT.ntt(x, false);         NTT.ntt(y, false);          for (int i = 0; i &lt; size; i++) {             x[i] = x[i] * y[i] % NTT.MOD;         }          NTT.ntt(x, true);          long max = Long.MIN_VALUE;         for (int i = n-1; i &lt; 2*n-1; i++) {             long val = x[i];             if (val &lt; 0) val += NTT.MOD;             max = Math.max(max, val);         }          bw.write(String.valueOf(max));         bw.flush();         bw.close();         br.close();     } }  NTT 활용 버전 이 코드는 Number Theoretic Transform (NTT) 를 이용해서 문제를 해결한다. NTT는 정수 수학에서 빠른 변환을 제공하는 방법이고, 모듈러 연산을 고려하기 때문에 큰 수의 연산을 할 때 유리하다.  NTT 클래스:     - MOD: 모든 계산에서 모듈러 연산을 할 값이야. 이 문제에서는 998244353이 사용된다.     - PRIMITIVE_ROOT: 원시 근을 나타내는 값인데, 여기서는 3을 사용한다.     - pow(): 큰 수의 거듭제곱을 빠르게 계산하는 함수로, 모듈러 거듭제곱을 구현한다. 시간 복잡도는 O(log b)로 효율적이다.     - ntt(): NTT 변환을 실제로 수행하는 함수다. 여기서 이진 반사 정렬과 고속 변환이 이루어진다.     - multiply(): 두 배열을 곱하는 함수다. 이 함수에서 중요한 점은 NTT를 두 번 사용해서 변환 후 곱셈을 하고 다시 변환하여 원래의 값으로 돌아오게 만든다는 것이다.  main() 메소드:     - x와 y 배열을 순환 이동 가능하게 만들기 위해 x는 두 배 크기로 만들어서 자기 자신을 반복시킨다.     - y는 역순으로 저장해서, 실제로 X와 Y의 순환 이동을 구현하는 효과를 낸다.     - ntt() 함수 두 번 호출하고, 그 결과로 나온 값들 중에서 최댓값을 찾는다.  핵심 아이디어:     - 배열 X와 Y를 순환 이동을 고려해 확장한다.     - NTT로 변환하고 곱셈을 한 후 다시 NTT로 역변환해서 최댓값을 찾는다.   References    Fast Fourier Transform Algorithm   Fast Fourier Transform Explained   Fast Fourier Transform  "
  },
  
  {
    "title": "BOJ_13710_XOR 합 3 (Java)",
    "url": "/posts/BOJ13710XOR-%ED%95%A9-3-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-02 04:04:32 +0900",
    "content": "[Gold I] XOR 합 3 - 13710  문제 링크  성능 요약  메모리: 26200 KB, 시간: 324 ms  분류  비트마스킹, 누적 합  제출 일자  2025년 2월 2일 03:55:42  문제 설명  수열의 XOR 합이란 수열에 들어있는 모든 원소를 다 XOR한 값이다.  수열 A 주어졌을 때, A의 모든 연속하는 부분 수열의 XOR 합을 더한 값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에는 배열의 크기 N (1 ≤ N ≤ 100,000), 둘째 줄에는 수열 A에 들어있는 수가 주어진다. 수열 A에 들어있는 수는 109보다 작거나 같은 음이 아닌 정수이다.  출력  첫째 줄에 A의 모든 연속하는 부분 수열의 XOR 합을 더한 값을 출력한다.     문제 풀이     XOR의 핵심 성질     같은 수를 두 번 XOR하면 0   XOR은 순서가 바뀌어도 결과 동일   누적 XOR 배열 만들기 구간 [L,R]의 XOR 합 = refixSumXOR[R] ^ prefixSumXOR[L-1]  비트별로 계산하기 각 비트 위치에서:     1의 개수 세기   0의 개수 세기 (전체 개수 ( n+1 ) - 1의 개수) 이 둘을 곱하면 그 비트에서 XOR 결과가 1이 되는 구간의 개수임   특정 자리에서 XOR결과가 1이려면 하나는 0이고 하나는 1이어야한다. 결국 0의 개수 × 1의 개수로 계산가능.  비트 위치 반영 각 비트별로:     1이 되는 구간의 개수를 구하고   그 비트의 값(2^i) 곱하기   모든 비트에 대해 이 값을 더하기 입력되는 수가 10^9 이하이므로 2^10이 1024인 점을 감안하여 2^30이 10억은 감당이 되므로 가능.   시간복잡도  누적 XOR 배열 만들기: O(N) 각 비트별로 1의 개수 세기: O(N * 30) 최종 답 계산: O(30) 전체 시간 복잡도 = O(N * 30)     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;     static long[] prefixSumXOR;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_13710_XOR합3/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());                  // 누적 XOR 배열 (XOR합 위해 0 포함)         prefixSumXOR = new long[N+1];                  st = new StringTokenizer(br.readLine());         for(int i = 1; i &lt;= N; i++){             int a = Integer.parseInt(st.nextToken());             prefixSumXOR[i] = prefixSumXOR[i-1] ^ a;         }                  // 각 비트별 1 개수         int[] oneCnt = new int[30];                  for(int i=0; i&lt;30; i++){             for(int j=0; j&lt;=N; j++){                 if((prefixSumXOR[j] &amp; (1L&lt;&lt;i)) != 0) oneCnt[i]++;             }         }                  long res = 0;         for(int i=0; i&lt;30; i++){             // i번쨰 비트에서 : 1개수 x 0개수 x 2^i             res += (1L&lt;&lt;i) * oneCnt[i] * (N+1-oneCnt[i]);         }                  bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1261_알고스팟 (Java)",
    "url": "/posts/BOJ1261%EC%95%8C%EA%B3%A0%EC%8A%A4%ED%8C%9F-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-01 21:38:45 +0900",
    "content": "[Gold IV] 알고스팟 - 1261  문제 링크  성능 요약  메모리: 14776 KB, 시간: 124 ms  분류  0-1 너비 우선 탐색, 데이크스트라, 그래프 이론, 그래프 탐색, 최단 경로  제출 일자  2025년 2월 1일 21:27:46  문제 설명  알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.  알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.  벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.  만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다.  현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.  입력  첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다.  (1, 1)과 (N, M)은 항상 뚫려있다.  출력  첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.     문제 풀이     다익스트라 문제다. breakCnt를 우선순위로 정렬기준을 삼아 PriorityQueue를 사용했다. 경계처리를 편하게 하기 위해 padding처리도 1-로 해 주었다.     코드   package BOJ_1261_알고스팟;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static class Node implements Comparable&lt;Node&gt;{         int r, c, breakCnt;         public Node(int r, int c, int breakCnt) {             this.r = r;             this.c = c;             this.breakCnt = breakCnt;         }          @Override         public int compareTo(Node o){             return this.breakCnt - o.breakCnt;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, board[][], dr[] = {-1, 1, 0, 0}, dc[] = {0, 0 ,-1, 1};     static boolean visited[][];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1261_알고스팟/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         M = Integer.parseInt(st.nextToken());         N = Integer.parseInt(st.nextToken());         board = new int[N+2][M+2];         visited = new boolean[N+2][M+2];          // padding with -1         for(int i = 0; i &lt;= M+1; i++) {             board[0][i] = -1;             board[N+1][i] = -1;         }         for(int i = 0; i &lt;= N+1; i++) {             board[i][0] = -1;             board[i][M+1] = -1;         }          for(int i = 1; i &lt; N+1; i++){             String line = br.readLine();             for(int j = 1; j &lt; M+1; j++){                 board[i][j] = line.charAt(j-1) - '0';             }         }                  int res = bfs(1, 1);         bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private int bfs(int r, int c) {         PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();         pq.offer(new Node(r, c, 0));         visited[r][c] = true;          while(!pq.isEmpty()){             Node currNode = pq.poll();              if(currNode.r == N &amp;&amp; currNode.c == M) return currNode.breakCnt;              for(int k=0; k&lt;4; k++){                 int nextR = currNode.r + dr[k];                 int nextC = currNode.c + dc[k];                 int currBreakCnt = currNode.breakCnt;                  if(board[nextR][nextC] == -1) continue;                  if(!visited[nextR][nextC] &amp;&amp; board[nextR][nextC] == 0){                     pq.offer(new Node(nextR, nextC, currBreakCnt));                     visited[nextR][nextC] = true;                 }                  if(!visited[nextR][nextC] &amp;&amp; board[nextR][nextC] == 1){                     pq.offer(new Node(nextR, nextC, currBreakCnt+1));                     visited[nextR][nextC] = true;                 }             }         }         return 0;     } }     다시 풀어본 코드  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     public static void main(String[] args) throws Exception {         new Main().solution();     }      class Node implements Comparable&lt;Node&gt; {         int r, c, breakCnt;         public Node(int r, int c, int breakCnt){             this.r = r;             this.c = c;             this.breakCnt = breakCnt;         }          public int compareTo(Node o) {             return this.breakCnt - o.breakCnt;         }     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1261_알고스팟/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         M = Integer.parseInt(st.nextToken());         N = Integer.parseInt(st.nextToken());         int[][] board = new int[N][M];          for(int i = 0; i &lt; N; i++){             String line = br.readLine();             for(int j = 0; j &lt; M; j++){                 board[i][j] = line.charAt(j) - '0';             }         }          PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();         boolean[][] visited = new boolean[N][M];         pq.add(new Node(0, 0, 0));         visited[0][0] = true;          int res = 0;          while(!pq.isEmpty()){             Node curr = pq.poll();              if(curr.r == N-1 &amp;&amp; curr.c == M-1) {                 res = curr.breakCnt;                 System.out.println(res);                 return;             }              for(int k=0; k &lt; 4; k++){                 int nr = curr.r + dr[k];                 int nc = curr.c + dc[k];                 if(isValid(nr, nc) &amp;&amp; !visited[nr][nc]){                     if(board[nr][nc] == 0){                         pq.add(new Node(nr, nc, curr.breakCnt));                     }                     else{                         pq.add(new Node(nr, nc, curr.breakCnt + 1));                     }                     visited[nr][nc] = true;                 }             }         }     }      private boolean isValid(int r, int c){         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     } }  "
  },
  
  {
    "title": "BOJ_3190_뱀 (Java)",
    "url": "/posts/BOJ3190%EB%B1%80-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-01 03:37:57 +0900",
    "content": "[Gold IV] 뱀 - 3190  문제 링크  성능 요약  메모리: 14636 KB, 시간: 112 ms  분류  자료 구조, 덱, 구현, 큐, 시뮬레이션  제출 일자  2025년 2월 1일 03:28:43  문제 설명   'Dummy' 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.  게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.  뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.   \t먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다. \t만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다. \t만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다. \t만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.   사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.  입력  첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)  다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.  다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)  다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 'L') 또는 오른쪽(C가 'D')로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.  출력  첫째 줄에 게임이 몇 초에 끝나는지 출력한다.     문제풀이   공백은 0, 벽은 -1, 사과는 9, 상하좌우 이동한 뱀의 칸마다 1, 2, 3, 4 를 부여했다. 이로써 2차원 배열 하나로 모든걸 끝낼 수 있게 되었다. 귀찮기 때문에 패딩을 -1로 걸어주었다. deque로 뱀을 관리해도 편하지만 그냥 이 방법으로 꼬리칸의 움직임을 O(1)로 제어할 수 있었다.    how?            뱀 꼬리칸 값이 어디로 이동해야할지 알려주는 dir 값이기 때문에 tail배열을 이 dir값으로 dr, dc배열을 통해 갱신해준다. 그럼 그 이동한 r, c, 좌표가 새 꼬리좌표.                    코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K, L, dir, res=0;     static int[] dr = {0, -1, 1, 0, 0}, dc = {0, 0, 0, -1, 1};     static int[][] board;     static Map&lt;Integer, String&gt; dirCommand = new HashMap&lt;&gt;();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_3190_뱀/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         K = Integer.parseInt(br.readLine());         board = new int[N+2][N+2];         for(int i=0; i&lt;N+2; i++) {             board[0][i] = -1;             board[N+1][i] = -1;             board[i][0] = -1;             board[i][N+1] = -1;         }          for(int i=0; i&lt;K; i++) {             st = new StringTokenizer(br.readLine());             int r = Integer.parseInt(st.nextToken());             int c = Integer.parseInt(st.nextToken());             board[r][c] = 9;         }          L = Integer.parseInt(br.readLine());         for(int i=0; i&lt;L; i++){             st = new StringTokenizer(br.readLine());             int t = Integer.parseInt(st.nextToken());             String s = st.nextToken();             dirCommand.put(t, s);         }          playGame();  //        // 디버깅용 //        for(int i=1; i&lt;=N; i++) { //            for(int j=1; j&lt;=N; j++) { //                System.out.print(board[i][j] + \" \"); //            } //            System.out.println(); //        }          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private void playGame() {         int dir = 4; // dr dc 인덱스 상1 하2 좌3 우4         int[] head = new int[]{1, 1};         int[] tail = new int[]{1, 1};         board[head[0]][head[1]] = 4;          while(true){             res++;              int[] nextHead = new int[] {head[0] + dr[dir], head[1] + dc[dir]};              // 종료조건             if(board[nextHead[0]][nextHead[1]] == -1) break;             if(1 &lt;= board[nextHead[0]][nextHead[1]] &amp;&amp; board[nextHead[0]][nextHead[1]] &lt;= 4) break;              // 사과찾았는지 여부             boolean flag = board[nextHead[0]][nextHead[1]] == 9;              // 머리이동             board[nextHead[0]][nextHead[1]] = dir;             head = nextHead;              // 사과 없을때 꼬리당기기             if(!flag){                 int tailDir = board[tail[0]][tail[1]];                 int[] nextTail = new int[] {tail[0] + dr[tailDir], tail[1] + dc[tailDir]};                 board[tail[0]][tail[1]] = 0;                 tail = nextTail;             }              // 머리방향 돌리기             if(dirCommand.containsKey(res)){                 // 시계방향 1-4-2-3-1                 if(dirCommand.get(res).equals(\"D\")) {                     if(dir==1) dir=4;                     else if(dir==2) dir=3;                     else if(dir==3) dir=1;                     else if(dir==4) dir=2;                 }                 // 반시계방향 1-3-2-4-1                 else{                     if(dir==1) dir=3;                     else if(dir==2) dir=4;                     else if(dir==3) dir=2;                     else if(dir==4) dir=1;                 }                 board[head[0]][head[1]] = dir;             }         }     } }  "
  },
  
  {
    "title": "BOJ_14889_스타트와 링크 (Java)",
    "url": "/posts/BOJ14889%EC%8A%A4%ED%83%80%ED%8A%B8%EC%99%80-%EB%A7%81%ED%81%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-01 02:12:28 +0900",
    "content": "[Silver I] 스타트와 링크 - 14889  문제 링크  성능 요약  메모리: 22400 KB, 시간: 408 ms  분류  백트래킹, 브루트포스 알고리즘  제출 일자  2024년 4월 27일 18:22:12  문제 설명  오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다.  BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.  N=4이고, S가 아래와 같은 경우를 살펴보자.   \t \t\t \t\t\ti\\j \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t4 \t\t \t \t \t\t \t\t\t1 \t\t\t  \t\t\t1 \t\t\t2 \t\t\t3 \t\t \t\t \t\t\t2 \t\t\t4 \t\t\t  \t\t\t5 \t\t\t6 \t\t \t\t \t\t\t3 \t\t\t7 \t\t\t1 \t\t\t  \t\t\t2 \t\t \t\t \t\t\t4 \t\t\t3 \t\t\t4 \t\t\t5 \t\t\t  \t\t \t   예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.   \t스타트 팀: S12 + S21 = 1 + 4 = 5 \t링크 팀: S34 + S43 = 2 + 5 = 7   1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다.   \t스타트 팀: S13 + S31 = 2 + 7 = 9 \t링크 팀: S24 + S42 = 6 + 4 = 10   축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.  입력  첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.  출력  첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.     문제 풀이   두 팀으로 반반씩 조합으로 나눠 각각 점수를 매긴 뒤 차이를 min갱신해줬다. dfs로 조합만들기.     코드   package BOJ_14889_스타트와링크;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, board[][], res= Integer.MAX_VALUE;     static boolean[] visited;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14889_스타트와링크/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         board = new int[N][N];         visited = new boolean[N];         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; N; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());             }         }          dfs(0, 0);          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private void dfs(int depth, int idx) {         if(depth == N/2) {             calAbility();             return;         }          for(int i=idx; i&lt;N; i++) {             if(!visited[i]){                 visited[i] = true;                 dfs(depth+1, i+1);                 visited[i] = false;             }         }     }      private void calAbility() {         int diff=0;         for(int i=0; i&lt;N; i++) {             for(int j=i+1; j&lt;N; j++) {                 if(visited[i] &amp;&amp; visited[j]) diff += (board[i][j] + board[j][i]);                 else if(!visited[i] &amp;&amp; !visited[j]) diff -= (board[i][j] + board[j][i]);             }         }         res = Math.min(Math.abs(diff), res);     } }  "
  },
  
  {
    "title": "BOJ_2295_세 수의 합 (Java)",
    "url": "/posts/BOJ2295%EC%84%B8-%EC%88%98%EC%9D%98-%ED%95%A9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-02-01 00:01:04 +0900",
    "content": "[Gold IV] 세 수의 합 - 2295  문제 링크  성능 요약  메모리: 16932 KB, 시간: 196 ms  분류  이분 탐색, 자료 구조, 해시를 사용한 집합과 맵, 중간에서 만나기  제출 일자  2025년 1월 31일 23:53:19  문제 설명  N(5 ≤ N ≤ 1,000)개의 자연수들로 이루어진 집합 U가 있다. 이 중에서 적당히 세 수를 골랐을 때, 그 세 수의 합 d도 U안에 포함되는 경우가 있을 수 있다. 이러한 경우들 중에서, 가장 큰 d를 찾으라.  예를 들어 {2, 3, 5, 10, 18}와 같은 집합이 있다고 하자. 2+3+5 = 10이 되고, 이 수는 집합에 포함된다. 하지만 3+5+10 = 18이 되고, 이 경우가 세 수의 합이 가장 커지는 경우이다.  입력  첫째 줄에 자연수 N이 주어진다. 다음 N개의 줄에 차례로 U의 원소가 하나씩 주어진다. 주어진 U는 집합이 되므로 입력되는 두 수가 같아서는 안 된다. U의 원소는 200,000,000보다 작거나 같은 자연수이다. 답이 항상 존재하는 경우만 입력으로 주어진다.  출력  우리가 x번째 수, y번째 수, z번째 수를 더해서 k번째 수를 만들었다라고 하자. 위의 예제에서 2+3+5=10의 경우는 x, y, z, k가 차례로 1, 2, 3, 4가 되며, 최적해의 경우는 2, 3, 4, 5가 된다. k번째 수가 최대가 되도록 하는 것이 목적이다. x, y, z, k가 서로 같아도 된다. 이때, k번째 수를 출력하면 된다.     문제 풀이   첫 풀이는 세 수의 합을 O(N^3)으로 구현하지 않고 a+b+c=k일 때 a+b를 O(N^2)로 구해놓고 k-c도 O(N^2)로 구해 풀었다.  하지만 이를 더 보완하여  k-a-b를 만족하는 c를 이분탐색으로 찾아보았다.    이분탐색 코드가 훨씬 효율적이었다. 시간 복잡도는 O(N³ log N) 로 늘었다고 생각했는데 HashSet의 오버헤드가 더 큰건가 생각했다.  두가지 코드 모두 첨부하겠다.     코드   Java a+b와 K-c로 찾기 package BOJ_2295_세수의합;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, arr[];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2295_세수의합/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         arr = new int[N];         for(int i = 0; i &lt; N; i++){             arr[i] = Integer.parseInt(br.readLine());         }         Arrays.sort(arr);          HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();          for(int i = 0; i &lt; N; i++){             for(int j= 0; j &lt; N; j++){                 set.add(arr[i] + arr[j]);             }         }  //        System.out.println(set);          int res = 0;         for(int k=N-1; k&gt;=0; k--){             for(int i=0; i&lt;N; i++){                 if(set.contains(arr[k]-arr[i])){                     res = Math.max(res, arr[k]);                 }             }         }         bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }     이분탐색 사용 코드 package BOJ_2295_세수의합;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main2 {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, arr[];     public static void main(String[] args) throws Exception {         new Main2().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2295_세수의합/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         arr = new int[N];         for(int i = 0; i &lt; N; i++){             arr[i] = Integer.parseInt(br.readLine());         }         Arrays.sort(arr);          int left, right, res=0;         for(int i = N-1; i &gt;= 0; i--){             for(int j=i-1; j&gt;=0; j--){                 for(int k=0; k&lt;=j; k++){                     if(arr[i]-(arr[j]+arr[k]) &lt;= 0) break;                     left = 0;                     right = k;                     while(left &lt;= right){                         int mid = left + (right - left)/2;                         if(arr[mid] &gt;= arr[i]-(arr[j]+arr[k])){                             right = mid - 1;                             res = mid;                         }                         else{                             left = mid + 1;                         }                     }                      if(arr[res] == arr[i]-(arr[j]+arr[k])){                         System.out.println(arr[i]);                         return;                     }                 }             }         }            bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_2212_센서 (Java, C++)",
    "url": "/posts/BOJ2212%EC%84%BC%EC%84%9C-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-31 15:41:38 +0900",
    "content": "[Gold V] 센서 - 2212  문제 링크  성능 요약  메모리: 16220 KB, 시간: 168 ms  분류  그리디 알고리즘, 정렬  제출 일자  2025년 1월 31일 15:34:27  문제 설명  한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.  각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.  편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.  입력  첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.  출력  첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.     문제 풀이        코드   Java 코드  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K, arr[], len[], res;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2212_센서/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         K = Integer.parseInt(br.readLine());         // K&gt;=Ndl면 각각 설치할 수 있으므로 0         if (K &gt;= N) {             bw.write(\"0\");             bw.flush();             bw.close();             br.close();             return;         }                  arr = new int[N];         len = new int[N-1];         st = new StringTokenizer(br.readLine());         res = 0;         for(int i=0; i&lt;N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }         Arrays.sort(arr);          for(int i=0; i&lt;N-1; i++) {             len[i] = arr[i+1]-arr[i];             res += len[i];         }          Arrays.sort(len);         for(int i=len.length-1; i&gt;len.length-1-(K-1); i--){             res -= len[i];         }         bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }     C++ 코드  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, K;     cin &gt;&gt; N &gt;&gt; K;     if (K &gt;= N) {         cout &lt;&lt; 0;         return;     }      vector&lt;int&gt; arr(N);     vector&lt;int&gt; len(N - 1);     int res = 0;      for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; arr[i];     }      sort(ALL(arr));      for (int i = 0; i &lt; N - 1; i++) {         len[i] = arr[i + 1] - arr[i];         res += len[i];     }      sort(ALL(len));      for (int i = len.size() - 1; i &gt; len.size() - 1 - (K - 1); i--) {         res -= len[i];     }      cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_6087_레이저 통신 (Java)",
    "url": "/posts/BOJ6087%EB%A0%88%EC%9D%B4%EC%A0%80-%ED%86%B5%EC%8B%A0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-31 14:58:34 +0900",
    "content": "[Gold III] 레이저 통신 - 6087  문제 링크  성능 요약  메모리: 18580 KB, 시간: 168 ms  분류  너비 우선 탐색, 데이크스트라, 그래프 이론, 그래프 탐색, 최단 경로  제출 일자  2025년 1월 31일 14:49:56  문제 설명  크기가 1×1인 정사각형으로 나누어진 W×H 크기의 지도가 있다. 지도의 각 칸은 빈 칸이거나 벽이며, 두 칸은 'C'로 표시되어 있는 칸이다.  'C'로 표시되어 있는 두 칸을 레이저로 통신하기 위해서 설치해야 하는 거울 개수의 최솟값을 구하는 프로그램을 작성하시오. 레이저로 통신한다는 것은 두 칸을 레이저로 연결할 수 있음을 의미한다.  레이저는 C에서만 발사할 수 있고, 빈 칸에 거울('/', '\\')을 설치해서 방향을 90도 회전시킬 수 있다.   아래 그림은 H = 8, W = 7인 경우이고, 빈 칸은 '.', 벽은 '*'로 나타냈다. 왼쪽은 초기 상태, 오른쪽은 최소 개수의 거울을 사용해서 두 'C'를 연결한 것이다.  7 . . . . . . .         7 . . . . . . . 6 . . . . . . C         6 . . . . . /-C 5 . . . . . . *         5 . . . . . | * 4 * * * * * . *         4 * * * * * | * 3 . . . . * . .         3 . . . . * | . 2 . . . . * . .         2 . . . . * | . 1 . C . . * . .         1 . C . . * | . 0 . . . . . . .         0 . \\-------/ .   0 1 2 3 4 5 6           0 1 2 3 4 5 6   입력  첫째 줄에 W와 H가 주어진다. (1 ≤ W, H ≤ 100)  둘째 줄부터 H개의 줄에 지도가 주어진다. 지도의 각 문자가 의미하는 것은 다음과 같다.   \t.: 빈 칸 \t*: 벽 \tC: 레이저로 연결해야 하는 칸   'C'는 항상 두 개이고, 레이저로 연결할 수 있는 입력만 주어진다.  출력  첫째 줄에 C를 연결하기 위해 설치해야 하는 거울 개수의 최솟값을 출력한다.     문제 풀이   벽 부수고 이동하기와 비슷하다고 생각했으며, 거울에 대한 우선순위가 있기 때문에 다익스트라 문제라고 생각했다.  구현은 처음에는 int[][] 배열 visited를 사용한 기본적 다익스트라에 Node 클래스를 만들어 mirror개수에 대한 우선순위로 정렬하고자 했다. 하지만 이때 어떤 방향으로 특정 칸에 들어왔느냐에 따라 4가지 상태가 있는데, 이때 모든 경우의 수를 2차원 visited로 해결할 수가 없었다.  예를 들어 왼쪽으로 마무리 한 Node와 위쪽으로 마무리한 Node가 그때까지 사용한 거울의 개수가 차이날 때 거울 적게 쓴 방향을 골라야하지만 향후 미래를 생각해봤을 때 모든 경우의 수를 고려해야 한다는 점에서 visited를 4가지 방향을 고려한 3차원으로 만들어주었다.     코드   package BOJ_6087_레이저통신;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main{     class Node implements Comparable&lt;Node&gt;{         int r, c, direction, mirror;         public Node(int r, int c, int direction, int mirror){             this.r = r;             this.c = c;             this.direction = direction;             this.mirror = mirror;         }          @Override         public int compareTo(Node o){             return this.mirror - o.mirror;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int W, H;     static char board[][];     static int visited[][][];     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static List&lt;int[]&gt; C_List = new ArrayList&lt;&gt;();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_6087_레이저통신/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         W = Integer.parseInt(st.nextToken());         H = Integer.parseInt(st.nextToken());         board = new char[H+2][W+2];         visited = new int[H+2][W+2][4];          for(int i = 0; i &lt; H+2; i++){             Arrays.fill(board[i], '*');             for(int j=0; j&lt;W+2; j++){                 for(int k=0; k&lt;4; k++){                     visited[i][j][k] = Integer.MAX_VALUE;                 }             }         }          for (int i = 1; i &lt;= H; i++) {             String str = br.readLine();             for (int j = 1; j &lt;= W; j++) {                 board[i][j] = str.charAt(j-1);                 if(board[i][j] == 'C') C_List.add(new int[]{i, j});             }         }          int res = findMinMirror();                  bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private int findMinMirror() {         int[] C_Start = C_List.get(0);         int[] C_End = C_List.get(1);          PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;();         pq.offer(new Node(C_Start[0], C_Start[1], -1, 0));         for(int k=0; k&lt;4; k++){             visited[C_Start[0]][C_Start[1]][k] = 0;         }          while(!pq.isEmpty()){             Node currNode = pq.poll();             if(currNode.r == C_End[0] &amp;&amp; currNode.c == C_End[1]) return currNode.mirror;              for(int k = 0; k &lt; 4; k++){                 int[] nextPos = new int[]{currNode.r + dr[k], currNode.c + dc[k]};                 int currMirrorCnt = currNode.mirror;                  if(board[nextPos[0]][nextPos[1]] == '*') continue;                  if(currNode.direction != -1 &amp;&amp; currNode.direction != k) currMirrorCnt++;                  if(currMirrorCnt &lt; visited[nextPos[0]][nextPos[1]][k]) {                     pq.offer(new Node(nextPos[0], nextPos[1], k, currMirrorCnt));                     visited[nextPos[0]][nextPos[1]][k] = currMirrorCnt;                 }             }         }         return -1;     } }  "
  },
  
  {
    "title": "PGMS_베스트앨범 (Java)",
    "url": "/posts/PGMS%EB%B2%A0%EC%8A%A4%ED%8A%B8%EC%95%A8%EB%B2%94-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-31 03:15:20 +0900",
    "content": "[level 3] 베스트앨범 - 42579   문제 링크  성능 요약  메모리: 78.8 MB, 시간: 1.37 ms  구분  코딩테스트 연습 &gt; 해시  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 01월 31일 03:01:14  문제 설명  스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다.   속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.   노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요.  제한사항   genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다.   입출력 예           genres plays return            [\"classic\", \"pop\", \"classic\", \"classic\", \"pop\"] [500, 600, 150, 800, 2500] [4, 1, 3, 0]          입출력 예 설명  classic 장르는 1,450회 재생되었으며, classic 노래는 다음과 같습니다.   고유 번호 3: 800회 재생 고유 번호 0: 500회 재생 고유 번호 2: 150회 재생   pop 장르는 3,100회 재생되었으며, pop 노래는 다음과 같습니다.   고유 번호 4: 2,500회 재생 고유 번호 1: 600회 재생   따라서 pop 장르의 [4, 1]번 노래를 먼저, classic 장르의 [3, 0]번 노래를 그다음에 수록합니다.   장르 별로 가장 많이 재생된 노래를 최대 두 개까지 모아 베스트 앨범을 출시하므로 2번 노래는 수록되지 않습니다.   ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   Genre클래스에    장르별 총합 sum   최대 재생 노래 2곡 songs   LinkedHashSet `orderedGenre`: 장르들의 순서를 유지하기 위한 Set HashMap&lt;String, Genre&gt; `genreMap`: 장르별 정보를 저장할 Map  각 노래를 순회하면서     새로운 장르면 Genre 객체를 생성하여 저장   기존 장르면 재생 횟수를 더하고 top 2 노래를 업데이트 updateMax2Songs      코드   import java.util.*;  class Solution {          class Genre{         int sum;         int[] songs;         Genre(int sum, int order){             this.sum = sum; // 장르별 총합             this.songs = new int[2]; // 장르별 내림차순 2개             songs[0] = order;             songs[1] = -1;         }                       }          static Set&lt;String&gt; orderedGenre = new LinkedHashSet&lt;&gt;(); // 장르별 고유번호 순서     static Map&lt;String, Genre&gt; genreMap = new HashMap&lt;&gt;();     public int[] solution(String[] genres, int[] plays) {         String g;         int p;                  for(int i=0; i&lt;genres.length; i++){             g = genres[i];             p = plays[i];             orderedGenre.add(g);                          if(!genreMap.containsKey(g)) genreMap.put(g, new Genre(p, i));             else{                 Genre genre = genreMap.get(g);                 genre.sum += p;                                  updateMax2Songs(genres, plays, genre, i, p);             }         }                  // 정답순으로 정렬         List&lt;String&gt; orderedGenreList = new ArrayList&lt;&gt;(orderedGenre);         orderedGenreList.sort((o1, o2) -&gt; genreMap.get(o2).sum - genreMap.get(o1).sum);                  // 정답리스트         List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();         for(String s : orderedGenreList){             Genre genre = genreMap.get(s);             tmp.add(genre.songs[0]);             if(genre.songs[1] != -1) tmp.add(genre.songs[1]);         }                  // 정답리스트를 배열로         int[] res = new int[tmp.size()];         for(int i=0; i&lt;tmp.size(); i++){             res[i] = tmp.get(i);         }         return res;     }          // 두 곡 내림차순 업데이트     private void updateMax2Songs(String[] genres, int[] plays, Genre G, int i, int p){         int firstSong = G.songs[0];         int secondSong = G.songs[1];                                                                // 1위 곡 변경 : 현재 곡이 1위 곡보다 재생수가 많거나, 재생수가 같고 고유번호가 더 작은 경우         if(p &gt; plays[firstSong] || (p == plays[firstSong] &amp;&amp; i &lt; firstSong)){             G.songs[1] = firstSong;             G.songs[0] = i;         }                                                                                       // 2위 곡 변경 : 2위곡 비어있거나, 이번 곡이 이전 2위곡보다 많이 재생됐거나, 재생수 같고 고유번호가 더 작은 경우         else if(secondSong == -1 || plays[secondSong] &lt; p || (plays[secondSong] == p &amp;&amp; i &lt; secondSong)) G.songs[1] = i;     } }    "
  },
  
  {
    "title": "PGMS_기지국 설치 (Java)",
    "url": "/posts/PGMS%EA%B8%B0%EC%A7%80%EA%B5%AD-%EC%84%A4%EC%B9%98-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-31 00:15:23 +0900",
    "content": "[level 3] 기지국 설치 - 12979  문제 링크  성능 요약  메모리: 54.5 MB, 시간: 1.05 ms  구분  코딩테스트 연습 &gt; Summer／Winter Coding（～2018）  채점결과  정확성: 70.5효율성: 29.5합계: 100.0 / 100.0  제출 일자  2025년 01월 31일 00:10:27  문제 설명  N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다.  예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.)   초기에, 1, 2, 6, 7, 8, 9번째 아파트에는 전파가 전달되지 않습니다.      1, 7, 9번째 아파트 옥상에 기지국을 설치할 경우, 모든 아파트에 전파를 전달할 수 있습니다.      더 많은 아파트 옥상에 기지국을 설치하면 모든 아파트에 전파를 전달할 수 있습니다.     이때, 우리는 5g 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다.  아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요  제한사항   N: 200,000,000 이하의 자연수 stations의 크기: 10,000 이하의 자연수 stations는 오름차순으로 정렬되어 있고, 배열에 담긴 수는 N보다 같거나 작은 자연수입니다. W: 10,000 이하의 자연수     입출력 예           N stations W answer            11 [4, 11] 1 3   16 [9] 2 3          입출력 예 설명  입출력 예 #1 문제의 예시와 같습니다  입출력 예 #2   초기에, 1~6, 12~16번째 아파트에는 전파가 전달되지 않습니다.      3, 6, 14번째 아파트 옥상에 기지국을 설치할 경우 모든 아파트에 전파를 전달할 수 있습니다.        출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   먼저 풀이 방법의 핵심은 빈 구간의 길이로 개수를 찾는다 이다.  세 파트로 나누었다.    좌측 빈 구간(첫 기지국보다 왼쪽 빈 구간)   기지국들 사이사이 빈 구간   우측 빈 구간(마지막 기지국 우측부터 빈 구간)   빈 구간이 있는지 없는지 길이가 1이상인지로 체크하고 있으면 $w*2+1$씩 나누어보고 나머지가 있으면 1을 추가로 더 더해준다.     코드   class Solution {     static int left, right, width, len, res;     public int solution(int n, int[] stations, int w) {         res = 0;         width = 2*w+1;                      left = 1; right = stations[0] - w - 1;         add5G();                  for(int i=1; i&lt;stations.length; i++){             left = stations[i-1]+w+1; right = stations[i]-w-1;             add5G();         }                  left = stations[stations.length-1]+w+1; right = n;         add5G();                  return res;     }          private void add5G(){               if(left&lt;=right) {             len = right-left+1;             res += len / width;             res += (len % width) == 0 ? 0 : 1;             return;         }         return;     } }  "
  },
  
  {
    "title": "BOJ_1135_뉴스 전하기 (Java, C++)",
    "url": "/posts/BOJ1135%EB%89%B4%EC%8A%A4-%EC%A0%84%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-30 22:02:02 +0900",
    "content": "[Gold II] 뉴스 전하기 - 1135  문제 링크  성능 요약  메모리: 14372 KB, 시간: 108 ms  분류  다이나믹 프로그래밍, 트리에서의 다이나믹 프로그래밍, 그리디 알고리즘, 정렬, 트리  제출 일자  2025년 1월 30일 21:35:53  문제 설명  민식이는 회사의 매니저이다. 그리고, 민식이는 회사의 중요한 뉴스를 모든 직원에게 빠르게 전달하려고 한다. 민식이의 회사는 트리 구조이다. 모든 직원은 정확하게 한 명의 직속 상사가 있다. 자기자신은 그들 자기 자신의 직접 또는 간접 상사가 아니고, 모든 직원은 민식이의 직접 또는 간접적인 부하이다.  민식이는 일단 자기 자신의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 뉴스를 들은 후에, 각 부하는 그의 직속 부하에게 한 번에 한 사람씩 전화를 한다. 이 것은 모든 직원이 뉴스를 들을 때 까지 계속된다. 모든 사람은 자신의 직속 부하에게만 전화를 걸 수 있고, 전화는 정확하게 1분 걸린다. 이때 모든 직원이 소식을 듣는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.  오민식의 사원 번호는 0이고, 다른 사원의 번호는 1부터 시작한다.  입력  첫째 줄에 직원의 수 N이 주어진다. 둘째 줄에는 0번 직원부터 그들의 상사의 번호가 주어진다. 0번 직원 (오민식)은 상사가 없기 때문에 -1이고, 나머지 직원 i의 상사 번호는 i보다 작거나 같은 음이 아닌 정수이다. N은 50보다 작거나 같은 자연수이다.  출력  첫째 줄에 모든 소식을 전하는데 걸리는 시간의 최솟값을 출력한다.     문제 풀이     일단 정답을 찾기 위해 maxDepth를 사용해야 하는줄 알았다. 하지만 1번부모에 30명의 자식이 있고 depth가 5인 경우 의미가 없었다. 즉, 가장 많은 자식을 가진 노드를 생각해야했다. 이후 각 분기마다 1초가 걸리므로 어떤 분기를 선택해야하는가도 중요했다. 이에, 시간이 많이 걸리는(자식이 가장 많은) 순으로 분기를 따라가는것을 최우선으로 했다.  그림에서 보면 두번째줄 1에 3, 4, 5의 자식이 있다. 이 자식들은 각각 2, 2, 3 의 시간이 걸린다. 그래서 우선순위를 1-5 분기를 1순위, 1-3 분기를 2순위, 1-4 분기를 3순위로 뒀다. 사실 같은 time이 걸리면 상관없다. 이후 우선순위 + 시간 을 계산하여 최댓값을 갱신한 뒤 부모에 넣어준다.     코드   Java 코드 package BOJ_1135_뉴스전하기;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, parent[], maxT, time[];     static ArrayList&lt;Integer&gt; childList;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1135_뉴스전하기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         parent = new int[N];         time = new int[N];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             int num = Integer.parseInt(st.nextToken());             parent[i] = num;         }          // 자식부터 시간 업데이트         for(int i=N-1; i&gt;=0; i--){             updateTime(i);         }          bw.write(String.valueOf(time[0]));         bw.flush();         bw.close();         br.close();     }      private void updateTime(int num) {         childList = new ArrayList&lt;&gt;();         for(int i=0; i&lt;N; i++){             if(parent[i] == num) childList.add(time[i]);         }          Collections.sort(childList, Collections.reverseOrder());          maxT = 0;         for(int order = 1; order&lt;=childList.size(); order++){             maxT = Math.max(maxT, order + childList.get(order-1));         }         time[num] = maxT;     } }     C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N; vector&lt;int&gt; parent; vector&lt;int&gt; childTime; int maxT = 0;  void updateTime(int num) {     vector&lt;int&gt; childList;     for (int i = 0; i &lt; N; i++) {         if (parent[i] == num) childList.push_back(childTime[i]);     }      sort(ALL(childList), greater&lt;int&gt;());      maxT = 0;     for (int order = 1; order &lt;= childList.size(); order++) {         maxT = max(maxT, order + childList[order - 1]);     }     childTime[num] = maxT; }  void solve() {     cin &gt;&gt; N;     parent.resize(N);     childTime.resize(N);      for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; parent[i];     }      for (int i = N - 1; i &gt;= 0; i--) {         updateTime(i);     }     cout &lt;&lt; childTime[0] &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "PGMS_조건에 맞는 사용자 정보 조회하기 (SQL)",
    "url": "/posts/PGMS%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-01-30 19:59:15 +0900",
    "content": "[level 3] 조건에 맞는 사용자 정보 조회하기 - 164670   문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; String， Date  채점결과  Empty  제출 일자  2025년 01월 30일 19:57:13  문제 설명  다음은 중고 거래 게시판 정보를 담은 USED_GOODS_BOARD 테이블과 중고 거래 게시판 첨부파일 정보를 담은 USED_GOODS_USER 테이블입니다. USED_GOODS_BOARD 테이블은 다음과 같으며 BOARD_ID, WRITER_ID, TITLE, CONTENTS, PRICE, CREATED_DATE, STATUS, VIEWS는 게시글 ID, 작성자 ID, 게시글 제목, 게시글 내용, 가격, 작성일, 거래상태, 조회수를 의미합니다.           Column name Type Nullable            BOARD_ID VARCHAR(5) FALSE   WRITER_ID VARCHAR(50) FALSE   TITLE VARCHAR(100) FALSE   CONTENTS VARCHAR(1000) FALSE   PRICE NUMBER FALSE   CREATED_DATE DATE FALSE   STATUS VARCHAR(10) FALSE   VIEWS NUMBER FALSE          USED_GOODS_USER 테이블은 다음과 같으며 USER_ID, NICKNAME, CITY, STREET_ADDRESS1, STREET_ADDRESS2, TLNO는 각각 회원 ID, 닉네임, 시, 도로명 주소, 상세 주소, 전화번호를 의미합니다.           Column name Type Nullable            USER_ID VARCHAR(50) FALSE   NICKANME VARCHAR(100) FALSE   CITY VARCHAR(100) FALSE   STREET_ADDRESS1 VARCHAR(100) FALSE   STREET_ADDRESS2 VARCHAR(100) TRUE   TLNO VARCHAR(20) FALSE            문제  USED_GOODS_BOARD와 USED_GOODS_USER 테이블에서 중고 거래 게시물을 3건 이상 등록한 사용자의 사용자 ID, 닉네임, 전체주소, 전화번호를 조회하는 SQL문을 작성해주세요. 이때, 전체 주소는 시, 도로명 주소, 상세 주소가 함께 출력되도록 해주시고, 전화번호의 경우 xxx-xxxx-xxxx 같은 형태로 하이픈 문자열(-)을 삽입하여 출력해주세요. 결과는 회원 ID를 기준으로 내림차순 정렬해주세요.     예시  USED_GOODS_BOARD 테이블이 다음과 같고           BOARD_ID WRITER_ID TITLE CONTENTS PRICE CREATED_DATE STATUS VIEWS            B0001 dhfkzmf09 칼라거펠트 코트 양모 70%이상 코트입니다. 120000 2022-10-14 DONE 104   B0002 lee871201 국내산 볶음참깨 직접 농사지은 참깨입니다. 3000 2022-10-02 DONE 121   B0003 dhfkzmf09 나이키 숏패팅 사이즈는 M입니다. 40000 2022-10-17 DONE 98   B0004 kwag98 반려견 배변패드 팝니다 정말 저렴히 판매합니다. 전부 미개봉 새상품입니다. 12000 2022-10-01 DONE 250   B0005 dhfkzmf09 PS4 PS5 구매로인해 팝니다. 250000 2022-11-03 DONE 111          USED_GOODS_USER 테이블이 다음과 같을 때           USER_ID NICKNAME CITY STREET_ADDRESS1 STREET_ADDRESS2 TLNO            dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 01053422914   dlPcks90 썹썹 성남시 분당구 수내로 74 401호 01034573944   cjfwls91 점심만금식 성남시 분당구 내정로 185 501호 01036344964   dlfghks94 희망 성남시 분당구 내정로 101 203동 102호 01032634154   rkdhs95 용기 성남시 분당구 수내로 23 501호 01074564564          SQL을 실행하면 다음과 같이 출력되어야 합니다.           USER_ID NICKNAME 전체주소 전화번호            dhfkzmf09 찐찐 성남시 분당구 수내로 13 A동 1107호 010-5342-2914              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   일단 3개 이상이라는 것은 GROUP BY 로 해결하고자 했고 두 테이블에서 필요한 정보들이 있으니 JOIN을 사용했다. 문자열을 가공하는 함수로 CONCAT과 SUBSTR이 있으므로 이를 적절히 사용해주었다. SUBSTR의 경우 주의할 점은 1부터 시작한다는 것이고, 첫번째 숫자는 시작위치, 두번째 숫자는 개수다.     코드   SELECT u.USER_ID, u.NICKNAME, CONCAT(u.CITY, ' ', u.STREET_ADDRESS1, ' ', u.STREET_ADDRESS2\t) AS 전체주소, CONCAT(SUBSTR(u.TLNO, 1, 3), '-', SUBSTR(u.TLNO, 4, 4), '-', SUBSTR(u.TLNO, 8, 4)) AS 전화번호     FROM USED_GOODS_USER AS u         JOIN USED_GOODS_BOARD AS b             ON u.USER_ID = b.WRITER_ID                 GROUP BY u.USER_ID                     HAVING COUNT(*) &gt;= 3                         ORDER BY u.USER_ID DESC;  "
  },
  
  {
    "title": "다중 서버 환경에서 세션 기반 인증 방식의 위험성",
    "url": "/posts/%EB%8B%A4%EC%A4%91-%EC%84%9C%EB%B2%84-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EC%84%B8%EC%85%98-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%9C%84%ED%97%98%EC%84%B1/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-30 02:16:01 +0900",
    "content": "세션 불일치 문제  다중 서버 환경에서 세션 기반 인증 방식은 세션 불일치 문제를 초래할 수 있다. 만약 서버 A, B를 관리하고 있을 때, 로드 밸런서는 사용자의 요청을 상황에 맞게 A, B 중 한 곳으로 전달한다. 유효한 로그인 요청이 A 서버로 처음 도착하면 사용자에 대한 세션 정보는 A 서버에 저장된다. 이후 해당 사용자의 또 다른 요청이 로드 밸런서에 도착했을 때, B 서버로 도착하게 되면 사용자의 세션 데이터가 존재하지 않기 때문에 요청이 제대로 처리되지 않는다. 이를 세션 불일치 문제라고 한다.  해결 방법  1. 스티키 세션 방식 스티키 세션 방식 은 사용자 요청이 항상 사용자 세션 정보가 저장된 서버로 가도록 고정하는 방식이다. 사용자 요청의 쿠키나 IP를 통해서 어느 서버로 고정 시킬지 결정한다. 장점은 단순하다는 것이다. 반면, 단점으로는 특정 서버에 트래픽이 집중될 수 있다는 문제점과 사용자의 세션 정보를 가지고 있는 서버가 다운되면 해당 서버에 고정된 사용자는 다시 로그인해야하는 문제점이 존재한다.  2. 세션 클러스터링 방식 세션 클러스터링 방식은 특정 서버에 사용자 세션 정보가 생성될 때, 다른 서버로 정보를 복제하는 방식이다. 장점은 여러 서버에 세션 정보를 중복으로 저장하므로 스티키 세션의 트래픽 몰림 현상과 세션 정보 유실 문제를 해결한다는 점이다. 반면, 단점은 세션 정보를 중복 저장한다는 점에서 메모리를 비효율적으로 사용하며, 세션 정보 복제 과정에서 발생하는 네트워크 트래픽 문제, 세션 정보 복제 지연으로 인한 일시적인 세션 정보 유실 문제가 발생할 수 있다.  3. 스토리지 분리 방식 스토리지 분리 방식은 세션 정보를 저장하는 공간을 외부로 분리하는 방식이다. 세션 클러스터링 방식, 스티키 세션 방식에서 발생하는 문제를 해결할 수 있다. 해당 방식의 단점은 스토리지에 대한 단일 장애 지점(Single Point Of Failure)이 문제가 될 수 있으며, 클러스터링과 같은 HA 구성으로 단일 장애 지점을 해소하여도 복제 지연으로 인한 일시적인 세션 정보 유실 문제는 발생할 수 있다. 또한, 외부 스토리지를 관리하기 위한 추가적인 리소스가 요구될 수 있다.  References    다중 서버 환경에서의 세션 불일치 문제와 해결 방법  "
  },
  
  {
    "title": "SOLID 원칙",
    "url": "/posts/SOLID-%EC%9B%90%EC%B9%99/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-30 01:38:34 +0900",
    "content": "SOLID 원칙 SOLID 원칙은 객체지향 설계 5원칙이라고도 불리며, 각 원칙의 앞 글자를 따서 만들어졌다. 객체지향 설계의 핵심 중 하나인 의존성 관리를 잘 하기 위해 SOLID 원칙을 준수해야한다.  S : Single Responsibility Principle 단일 책임 원칙 (Single Responsibility Principle) 은 클래스가 오직 하나의 목적/이유로만 변경되어야 한다는 것을 강조한다. 여기서 책임 이란 단순히 메서드의 개수를 뜻하지 않고, 특정 사용자나 기능 요구사항에 따라 소프트웨어의 변경 요청을 처리하는 역할을 의미한다.  즉 클래스는 한 가지 변화의 이유만 가져야 하며, 이를 통해 변경이 발생했을 때 다른 기능에 영향을 덜 미치도록 설계된다. 이렇게 하면 유지보수가 쉬워지고 코드가 더 이해하기 쉬워진다.  O : Open-Closed Principle 개방 폐쇄 원칙 (Open-Closed Principle)은 확장에는 열려있고, 변경에는 닫혀 있어야 함을 강조합니다. 이때 확장이란 새로운 타입을 추가함으로써 새로운 기능을 추가하는 것을 의미하며, 폐쇄란 확장이 일어날 때 상위 레벨의 모듈이 영향을 받지 않아야 함을 의미한다. 이를 통해서 모듈의 행동을 쉽게 변경할 수 있다. 모듈이란 크기와 상관없이 클래스, 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.  L : Liskov Substitution Principle 리스코브 치환 원칙(Liskov Substitution Principle) 은 서브 타입은 언제나 상위 타입으로 교체할 수 있어야한다. 즉, 서브 타입은 상위 타입이 약속한 규약을 지켜야 함을 강조한다. 이 원칙은 부모 쪽으로 업 캐스팅을 하는 것이 안전함을 보장하기 위해 존재한다. 상위 타입에 대해 기대되는 역할과 행동 규약이 있는데 이를 벗어나면 안된다. 만약, 하위타입이 상위 타입에 기대되는 역할을 만족하지 않는다면, 상위 타입을 사용하는 클라이언트 코드에서는 하위 타입이 누구인지 물어봐야 하는데, 이는 OCP를 달성하기 어렵게 한다. LSP를 위반하는 대표적인 사례로는 Rectangle 예제가 있다.  다음은 직사각형 Rectangle을 구현한 클래스다. 너비와 높이 값을 지정, 반환 할 수 있으며 넓이를 계산할 수 있다.  public class Rectangle {      public int width;     public int height;      // 너비 반환, Width Getter     public int getWidth() {         return width;     }     // 너비 할당, Width Setter     public void setWidth(int width) {         this.width = width;     }      // 높이 반환, Height Getter     public int getHeight() {         return height;     }     // 높이 할당, Height Setter     public void setHeight(int height) {         this.height = height;     }          //직사각형 넓이 반환 함수     public int getArea() {     \treturn width * height;     } }   정사각형은 직사각형의 범주에 포함되는데, 그렇다면 직사각형을 상속하여 정사각형 객체를 만들면 정상적으로 작동할까? 직사각형 클래스를 상속 받아 정사각형 객체를 구현해보자. public class Square extends Rectangle{          @Override     public void setWidth(int Width) {         super.setWidth(width);         super.setHeight(getWidth());     }          @Override     public void setHeight(int height) {         super.setHeight(height);         super.setWidth(getHeight());     }      }   Rectangle 객체를 상속 받은 Square 클래스에서는 정사각형의 너비와 높이가 같다는 특징을 구현했다. 너비와 높이 둘 중 하나를 입력해도 나머지 값이 일치되도록 메서드를 오버라이드 해주었다.  이제 확인을 해보면 public class Main {     public static void main(String[] args) {          Rectangle rectangle = new Rectangle();         rectangle.setHeight(5);         rectangle.setWidth(10);          System.out.println(rectangle.getArea());                  Rectangle square = new Square();              square.setWidth(10);         square.setHeight(5);   \t\tSystem.out.println(square.getArea());      } }      출력값 :  50 25   Rectangle 클래스의 동작과 그것을 상속받은 Square 클래스의 동작이 전혀 다르다는 사실을 알 수 있다. 이는 Square 이 Rectangle 을 상속받는것이 올바른 상속관계가 아니라는 것을 의미하며, 자식 객체가 부모 객체의 역할을 완전히 대체하지 못한다는 의미다.  이는 리스코프 치환 원칙을 위배하므로 변경해보면  Shape 클래스 public class Shape {      public int width;     public int height;      // 너비 반환, Width Getter     public int getWidth() {         return width;     }     // 너비 할당, Width Setter     public void setWidth(int width) {         this.width = width;     }      // 높이 반환, Height Getter     public int getHeight() {         return height;     }     // 높이 할당, Height Setter     public void setHeight(int height) {         this.height = height;     }      // 사각형 넓이 반환     public int getArea() {         return width * height;     } }  //직사각형 클래스 public class Rectangle extends Shape {      public Rectangle(int width, int height) {         setWidth(width);         setHeight(height);     }  }  //정사각형 클래스 public class Square extends Shape{          public Square(int length) {         setWidth(length);         setHeight(length);     }      }  Shape 클래스를 상속 받는 Rectangle 클래스와 Square 클래스입니다. public class Main {     public static void main(String[] args) {              Shape rectangle = new Rectangle(10, 5);         Shape square = new Square(5);                  System.out.println(rectangle.getArea());         System.out.println(square.getArea());     } }     출력 :  50 25   이제 리스코프 치환 법칙을 준수한다.  I : Interface Segregation Principle 인터페이스 분리 원칙(Interface Segregation Principle) 은 클라이언트 입장에서 인터페이스를 분리해야 함을 강조한다. 사용하지 않지만 의존성을 가지고 있다면 해당 인터페이스가 변경되는 경우 영향을 받는다. 따라서, 독립적인 개발과 배포가 불가능하다. 사용하는 기능만 제공하도록 인터페이스를 분리해 변경의 여파를 최소화할 수 있다.  D : Dependency Inversion Principle 의존성 역전 원칙(Dependency Inversion Principle) 은 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 되며, 모두 추상화에 의존해야 함을 강조해야한다. SOLID는 서로 연관이 있는데, 의존성 역전 원칙을 통해서 하위 레벨의 모듈은 개방 폐쇄 원칙을 준수하면서 새로운 타입이 추가 가능하다.  OCP는 개발 이전에 설계를 완료해야 하는것일까?  소프트웨어에는 특정 기능이 추가되고 변경될지 예측을 하기 어렵기때문에 미래의 변경을 예상하고, 준비하기 보단 고객이 원하는 부분을 빠르게 완성해서 전달한 뒤 피드백을 수용하는 방법을 사용해 볼 수 있다. 변화에 대한 가장 좋은 예측은 변화를 경험하는 것이다. 발생할 것 같은 변화를 발견한다면 향후 해당 변화와 같은 종류의 변화로부터 코드를 보호하거나 예방하여 설계할 수 있다.  즉, 고객이 요구할 모든 종류의 변경을 완벽히 예측하고, 이에대한 변경에 대응하기 위해 추상화를 적용하기 보단, 고객이 변경을 요구할 때까지 기다리고 추상화를 만들어서 향후 추가로 재발하는 변화로부터 보호될 수 있도록 하는 것이다.  References    SOLID (객체 지향 설계)   Square, Rectangle and the Liskov Substitution Principle  "
  },
  
  {
    "title": "BOJ_7570_줄 세우기 (Java, C++)",
    "url": "/posts/BOJ7570%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-29 03:46:31 +0900",
    "content": "[Gold II] 줄 세우기 - 7570  문제 링크  성능 요약  메모리: 5928 KB, 시간: 104 ms  분류  다이나믹 프로그래밍, 그리디 알고리즘  제출 일자  2025년 1월 29일 03:37:46  문제 설명  대한 어린이집에 올해 입학한 어린이들이 놀이터에 한 줄로 서있다. 모든 어린이들에게는 입학할 때 주어진 번호가 있고 모두 옷에 번호표를 달고 있다. 그런데 어린이들은 아직 번호 순서대로 줄을 잘 서지 못하므로 선생님이 다음과 같은 방법을 사용해서 번호순서대로 줄을 세우려고 한다.  방법: 줄 서있는 어린이 중 한 명을 선택하여 제일 앞이나 제일 뒤로 보낸다.  위의 방법을 사용할 때 어린이가 이동해서 빈자리가 생기는 경우에는 빈자리의 뒤에 있는 어린이들이 한 걸음씩 앞으로 걸어와서 빈자리를 메꾼다.  예를 들어, 5명의 어린이들에게 1부터 5까지의 번호가 주어져 있고, 다음과 같은 순서로 줄 서있다고 하자.   5 2 4 1 3  위 방법을 이용해서 다음과 같이 번호순서대로 줄을 세울 수 있다.    \t1번 어린이를 제일 앞으로 보낸다. (5 2 4 1 3 → 1 5 2 4 3) \t4번 어린이를 제일 뒤로 보낸다. (1 5 2 4 3 → 1 5 2 3 4) \t5번 어린이를 제일 뒤로 보낸다. (1 5 2 3 4 → 1 2 3 4 5)   위의 예에서는 세 명의 어린이를 제일 앞이나 제일 뒤로 보내 번호순서대로 줄을 세웠다. 그리고 두 명 이하의 어린이를 제일 앞이나 제일 뒤로 보내는 방법으로는 번호순서대로 줄을 세울 수 없다. 그러므로 이 경우에는 최소한 세 명의 어린이를 이동하여야 번호순서대로 줄을 세울 수 있다.  이 문제는 처음에 줄서있는 상태에서 위 방법을 이용해서 번호순서대로 줄을 세울 때 앞이나 뒤로 보내는 어린이 수의 최솟값을 찾는 것이다.  입력  입력은 2 개의 줄로 이루어져 있다. 첫 줄에는 어린이 수를 나타내는 정수가 주어진다. 둘째 줄에는 처음에 줄서있는 어린이들의 번호가 차례대로 주어진다. 주어진 번호들 사이에는 공백이 하나씩 들어있다. 단, 어린이 수는 1이상 1,000,000이하의 정수로 제한되고, 어린이 수가 N이면 어린이들의 번호는 1부터 N까지의 정수이다.  출력  입력에서 주어진 어린이들의 줄에 대해 번호순서대로 줄을 세우기 위해 제일 앞이나 제일 뒤로 보내는 어린이 수의 최솟값을 출력해야 한다.     문제 풀이     아이디어는 LIS알고리즘이다. LIS알고리즘을 사용하면서 1씩 증가하는 최장 수열을 찾으면 나머지 숫자을 앞뒤에 최적으로 붙일 수 있기 때문에다. O ( $N^2$ ) 이 원래의 LIS지만 시간초과가 발생했다. 그래서 이 문제의 경우엔 특별히 O(N)으로 1씩 증가하는 LIS를 구하도록 dp를 설계했다.  dp[i] = dp[i-1] + 1, 기본 0으로 초기화. dp[i] = i로 끝나는 1씩 증가하는 최장 증가하는 수열 (연속하지 않아도 됨)     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, dp[], maxLISLen=1;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_7570_줄세우기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         dp = new int[N + 1]; // dp[i] = i로 끝나는 LIS길이         Arrays.fill(dp, 0);         st = new StringTokenizer(br.readLine());          for(int i=1; i &lt;= N; i++){             int n = Integer.parseInt(st.nextToken());             dp[n] = dp[n-1] + 1;             maxLISLen = Math.max(maxLISLen, dp[n]);         }         bw.write(String.valueOf(N - maxLISLen));         bw.flush();         bw.close();         br.close();     } }     C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N, maxLISLen = 1; vector&lt;int&gt; dp;  void solve() {     cin &gt;&gt; N;     dp.resize(N + 1, 0);     for (int i = 1; i &lt;= N; i++) {         int n;         cin &gt;&gt; n;         dp[n] = dp[n - 1] + 1;         maxLISLen = max(maxLISLen, dp[n]);     }     cout &lt;&lt; N - maxLISLen &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "PGMS_PCCP 3번_충돌위험 찾기 (Java)",
    "url": "/posts/PGMSPCCP-3%EB%B2%88%EC%B6%A9%EB%8F%8C%EC%9C%84%ED%97%98-%EC%B0%BE%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-28 06:49:53 +0900",
    "content": "[level 2] [PCCP 기출문제] 3번 / 충돌위험 찾기 - 340211  문제 링크  성능 요약  메모리: 183 MB, 시간: 195.24 ms  구분  코딩테스트 연습 &gt; PCCP 기출문제  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 01월 28일 06:38:38  문제 설명  어떤 물류 센터는 로봇을 이용한 자동 운송 시스템을 운영합니다. 운송 시스템이 작동하는 규칙은 다음과 같습니다.   물류 센터에는 (r, c)와 같이 2차원 좌표로 나타낼 수 있는 n개의 포인트가 존재합니다. 각 포인트는 1~n까지의 서로 다른 번호를 가집니다. 로봇마다 정해진 운송 경로가 존재합니다. 운송 경로는 m개의 포인트로 구성되고 로봇은 첫 포인트에서 시작해 할당된 포인트를 순서대로 방문합니다. 운송 시스템에 사용되는 로봇은 x대이고, 모든 로봇은 0초에 동시에 출발합니다. 로봇은 1초마다 r 좌표와 c 좌표 중 하나가 1만큼 감소하거나 증가한 좌표로 이동할 수 있습니다. 다음 포인트로 이동할 때는 항상 최단 경로로 이동하며 최단 경로가 여러 가지일 경우, r 좌표가 변하는 이동을 c 좌표가 변하는 이동보다 먼저 합니다. 마지막 포인트에 도착한 로봇은 운송을 마치고 물류 센터를 벗어납니다. 로봇이 물류 센터를 벗어나는 경로는 고려하지 않습니다.   이동 중 같은 좌표에 로봇이 2대 이상 모인다면 충돌할 가능성이 있는 위험 상황으로 판단합니다. 관리자인 당신은 현재 설정대로 로봇이 움직일 때 위험한 상황이 총 몇 번 일어나는지 알고 싶습니다. 만약 어떤 시간에 여러 좌표에서 위험 상황이 발생한다면 그 횟수를 모두 더합니다.   운송 포인트 n개의 좌표를 담은 2차원 정수 배열 points와 로봇 x대의 운송 경로를 담은 2차원 정수 배열 routes가 매개변수로 주어집니다. 이때 모든 로봇이 운송을 마칠 때까지 발생하는 위험한 상황의 횟수를 return 하도록 solution 함수를 완성해 주세요.    제한사항   2 ≤ points의 길이 = n ≤ 100   points[i]는 i + 1번 포인트의 [r 좌표, c 좌표]를 나타내는 길이가 2인 정수 배열입니다. 1 ≤ r ≤ 100 1 ≤ c ≤ 100 같은 좌표에 여러 포인트가 존재하는 입력은 주어지지 않습니다.  2 ≤ routes의 길이 = 로봇의 수 = x ≤ 100   2 ≤ routes[i]의 길이 = m ≤ 100 routes[i]는 i + 1번째 로봇의 운송경로를 나타냅니다. routes[i]의 길이는 모두 같습니다. routes[i][j]는 i + 1번째 로봇이 j + 1번째로 방문하는 포인트 번호를 나타냅니다. 같은 포인트를 연속으로 방문하는 입력은 주어지지 않습니다. 1 ≤ routes[i][j] ≤ n      입출력 예           points routes result            [[3, 2], [6, 4], [4, 7], [1, 4]] [[4, 2], [1, 3], [2, 4]] 1   [[3, 2], [6, 4], [4, 7], [1, 4]] [[4, 2], [1, 3], [4, 2], [4, 3]] 9   [[2, 2], [2, 3], [2, 7], [6, 6], [5, 2]] [[2, 3, 4, 5], [1, 3, 4, 5]] 0            입출력 예 설명  입출력 예 #1    그림처럼 로봇들이 움직입니다. 3초가 지났을 때 1번 로봇과 2번 로봇이 (4, 4)에서 충돌할 위험이 있습니다. 따라서 1을 return 해야 합니다.  입출력 예 #2    그림처럼 로봇들이 움직입니다. 1, 3, 4번 로봇의 경로가 같아 이동하는 0 ~ 2초 내내 충돌 위험이 존재합니다. 3초에는 1, 2, 3, 4번 로봇이 모두 (4, 4)를 지나지만 위험 상황은 한 번만 발생합니다.   4 ~ 5초에는 1, 3번과 2, 4번 로봇의 경로가 각각 같아 위험 상황이 매 초 2번씩 발생합니다. 6초에 2, 4번 로봇의 충돌 위험이 발생합니다. 따라서 9를 return 해야 합니다.  입출력 예 #3    그림처럼 로봇들이 움직입니다. 두 로봇의 경로는 같지만 한 칸 간격으로 움직이고 2번 로봇이 5번 포인트에 도착할 때 1번 로봇은 운송을 완료하고 센터를 벗어나 충돌 위험이 없습니다. 따라서 0을 return 해야 합니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     구현 문제이므로 코드에 자세한 주석을 작성해놓겠다. 자료구조나 구현 방법을 위주로 보면 도움이 될 것이다.    코드   import java.util.*;  class Solution {     class Robot{         int r, c;         boolean isEnd;         public Robot(int r, int c, boolean isEnd){             this.r = r;             this.c = c;             this.isEnd = isEnd;         }     }     static int hitCnt=0;     static int[] routeIdx;     static Robot[] robot;     static Map&lt;Integer, List&lt;Integer&gt;&gt; robotList; // r*100 + c, 로봇번호     public int solution(int[][] points, int[][] routes) {         robot = new Robot[routes.length];         routeIdx = new int[routes.length]; // 다음 목적지 가리키는 Idx, 0 ~ routes[0].length-1 임                  // 시작점          for(int i=0; i&lt;routes.length; i++){             robot[i] = new Robot(points[routes[i][0]-1][0], points[routes[i][0]-1][1], false);         }         Arrays.fill(routeIdx, 1);                           //시작점도 같이 시작하면 충돌카운트 해줘야함         robotList = new HashMap&lt;&gt;();         for(int i = 0; i &lt; routes.length; i++) {             makeRobotList(i);         }         hitCount();                  while(true){             robotList = new HashMap&lt;&gt;();                          for(int i=0; i&lt;routes.length; i++){                 if(robot[i].isEnd) continue;                                  int currPointIdx = routes[i][routeIdx[i]-1] - 1;                 int[] currPoint = points[currPointIdx];                 int nextPointIdx = routes[i][routeIdx[i]] - 1;                 int[] nextPoint = points[nextPointIdx];                                  move(currPoint, nextPoint, robot[i]);                                  // 이동칸을 robotList에 기록                 makeRobotList(i);                                  // 다음포인트 도착체크                 checkNextPointArrival(i, nextPoint, routes);             }             // 충돌카운트             hitCount();                          boolean flag = true;             for(Robot r : robot){                 if(!r.isEnd){                     flag = false;                     break;                 }             }             if(flag) break;         }         return hitCnt;     }          void move(int[] start, int[] next, Robot robot){         if(robot.r != next[0]) robot.r += (robot.r &gt; next[0]) ? -1 : 1;         else if(robot.r == next[0] &amp;&amp; robot.c != next[1]) robot.c += (robot.c &gt; next[1]) ? -1 : 1;     }          void makeRobotList(int i){         int pos = robot[i].r * 100 + robot[i].c;         if(!robotList.containsKey(pos)) robotList.put(pos, new ArrayList&lt;&gt;());         robotList.get(pos).add(i);     }          void checkNextPointArrival(int i, int[] nextPoint ,int[][] routes){         if(robot[i].r == nextPoint[0] &amp;&amp; robot[i].c == nextPoint[1]){             routeIdx[i]++;             if(routeIdx[i] &gt;= routes[i].length) robot[i].isEnd = true;         }     }          void hitCount(){         for(List&lt;Integer&gt; rList : robotList.values()){             if(rList.size() &gt;= 2) hitCnt++;         }     } }  "
  },
  
  {
    "title": "BOJ_15684_사다리 조작 (Java, C++)",
    "url": "/posts/BOJ15684%EC%82%AC%EB%8B%A4%EB%A6%AC-%EC%A1%B0%EC%9E%91-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-28 01:19:45 +0900",
    "content": "[Gold III] 사다리 조작 - 15684  문제 링크  성능 요약  메모리: 14652 KB, 시간: 112 ms  분류  백트래킹, 브루트포스 알고리즘, 구현  제출 일자  2025년 1월 28일 00:52:40  문제 설명  사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다. 인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다.    초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다.    위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다.  사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.  위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다.   \t \t\t \t\t\t \t\t\t \t\t \t\t \t\t\t1번 세로선 \t\t\t2번 세로선 \t\t \t   사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 세로선의 개수 N, 가로선의 개수 M, 세로선마다 가로선을 놓을 수 있는 위치의 개수 H가 주어진다. (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)  둘째 줄부터 M개의 줄에는 가로선의 정보가 한 줄에 하나씩 주어진다.  가로선의 정보는 두 정수 a과 b로 나타낸다. (1 ≤ a ≤ H, 1 ≤ b ≤ N-1) b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결했다는 의미이다.  가장 위에 있는 점선의 번호는 1번이고, 아래로 내려갈 때마다 1이 증가한다. 세로선은 가장 왼쪽에 있는 것의 번호가 1번이고, 오른쪽으로 갈 때마다 1이 증가한다.  입력으로 주어지는 가로선이 서로 연속하는 경우는 없다.  출력  i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야 하는 가로선 개수의 최솟값을 출력한다. 만약, 정답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다.     문제 풀이        코드   첫 Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, H, a, b, res=-1;     static int[][] ladder;     static boolean flag;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15684_사다리조작/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         H = Integer.parseInt(st.nextToken());         ladder = new int[H+1][N+1];          if(M==0) {             bw.write(String.valueOf(0));             bw.flush();             bw.close();             br.close();             return;         }         else if(M==1) {             if(H==1) bw.write(String.valueOf(-1));             else bw.write(String.valueOf(1));             bw.flush();             bw.close();             br.close();             return;         }          for(int i=0; i&lt;M; i++){             st = new StringTokenizer(br.readLine());             a = Integer.parseInt(st.nextToken());             b = Integer.parseInt(st.nextToken());             // a번째 높이에 b와 b+1을 연결             ladder[a][b] = 1; // 오른쪽으로 연결             ladder[a][b+1] = -1; // 왼쪽으로 연결         }          if(needMoreThan4()){             bw.write(String.valueOf(-1));             bw.flush();             bw.close();             br.close();             return;         }          if(check()) {             bw.write(String.valueOf(0));             bw.flush();             bw.close();             br.close();             return;         }          dfs(0, 1);          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private boolean needMoreThan4(){         int sum = 0;         for(int i=1; i&lt;N; i++){             int cnt = 0;             for(int j=1; j&lt;=H; j++){                 if(ladder[j][i] == 1) cnt++;             }             // 한 사다리에서 우측으로 짝수개가 붙어있어야함.             if(cnt %2 != 0) sum++;         }         return sum &gt;= 4;     }      private int goDown(int start) {         int r = 1;         int c = start;         while(r &lt;= H) {             c += ladder[r][c];             r++;         }         return c;     }      private boolean check(){         for(int i=1; i&lt;=N; i++){             if(goDown(i) != i) return false;         }         return true;     }      private void dfs(int cnt, int depth){         if(cnt &gt; 3) return;          if(check()){             if(res == -1 || cnt &lt; res) res = cnt;             return;         }          for(int i=depth; i&lt;=H; i++){             for(int j=1; j&lt;N; j++){                 if(ladder[i][j] == 0 &amp;&amp; ladder[i][j+1]==0){                     if(j&gt;=2 &amp;&amp; ladder[i][j-1] == 1) continue; // 본인꺼 이전 -&gt; 본인꺼 연결 x                     if(j&lt;N-1 &amp;&amp; ladder[i][j+2] == -1) continue; // 본인꺼 다음 &lt;- 다다음꺼 연결 x                      ladder[i][j] = 1;                     ladder[i][j+1] = -1;                      dfs(cnt+1, i);                      ladder[i][j] = 0;                     ladder[i][j+1] = 0;                 }             }         }     } }   발전된 Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, H, a, b, res=-1;     static int[][] ladder;     static boolean flag;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15684_사다리조작/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         H = Integer.parseInt(st.nextToken());         ladder = new int[H+1][N+1];          if(M==0) {             bw.write(String.valueOf(0));             bw.flush();             bw.close();             br.close();             return;         }         else if(M==1) {             if(H==1) bw.write(String.valueOf(-1));             else bw.write(String.valueOf(1));             bw.flush();             bw.close();             br.close();             return;         }          for(int i=0; i&lt;M; i++){             st = new StringTokenizer(br.readLine());             a = Integer.parseInt(st.nextToken());             b = Integer.parseInt(st.nextToken());             // a번째 높이에 b와 b+1을 연결             ladder[a][b] = 1; // 오른쪽으로 연결             ladder[a][b+1] = -1; // 왼쪽으로 연결         }          if(needMoreThan4()){             bw.write(String.valueOf(-1));             bw.flush();             bw.close();             br.close();             return;         }          if(check()) {             bw.write(String.valueOf(0));             bw.flush();             bw.close();             br.close();             return;         }          for(int i=0; i&lt;=3; i++) {             dfs(0, 1, i);  // i는 목표 가로선 개수             if(res != -1) break;  // 답을 찾으면 즉시 종료         }          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private boolean needMoreThan4(){         int sum = 0;         for(int i=1; i&lt;N; i++){             int cnt = 0;             for(int j=1; j&lt;=H; j++){                 if(ladder[j][i] == 1) cnt++;             }             // 한 사다리에서 우측으로 짝수개가 붙어있어야함.             if(cnt %2 != 0) sum++;         }         return sum &gt;= 4;     }      private int goDown(int start) {         int r = 1;         int c = start;         while(r &lt;= H) {             c += ladder[r][c];             r++;         }         return c;     }      private boolean check(){         for(int i=1; i&lt;=N; i++){             if(goDown(i) != i) return false;         }         return true;     }      private void dfs(int cnt, int depth, int line){ // line개만큼 둬야하는데 dfs돌리기         if(cnt &gt; line) return;          if(cnt == line){             if(check()){                 res = cnt;                 return;             }             return;         }          for(int i=depth; i&lt;=H; i++){             for(int j=1; j&lt;N; j++){                 if(ladder[i][j] == 0 &amp;&amp; ladder[i][j+1]==0){                     if(j&gt;=2 &amp;&amp; ladder[i][j-1] == 1) continue; // 본인꺼 이전 -&gt; 본인꺼 연결 x                     if(j&lt;N-1 &amp;&amp; ladder[i][j+2] == -1) continue; // 본인꺼 다음 &lt;- 다다음꺼 연결 x                      ladder[i][j] = 1;                     ladder[i][j+1] = -1;                      dfs(cnt+1, i, line);                     if(res != -1) return;                      ladder[i][j] = 0;                     ladder[i][j+1] = 0;                 }             }         }     } }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N, M, H, a, b, res = -1; vector&lt;vector&lt;int&gt;&gt; ladder; bool flag;  bool needMoreThan4() {     int sum = 0;     for (int i = 1; i &lt; N; i++) {         int cnt = 0;         for (int j = 1; j &lt;= H; j++) {             if (ladder[j][i] == 1) cnt++;         }         if (cnt % 2 != 0) sum++;     }     return sum &gt;= 4; }  int goDown(int start) {     int r = 1;     int c = start;     while (r &lt;= H) {         c += ladder[r][c];         r++;     }     return c; }  bool check() {     for (int i = 1; i &lt;= N; i++) {         if (goDown(i) != i) return false;     }     return true; }  void dfs(int cnt, int depth, int line) {     if (cnt &gt; line) return;     if (cnt == line) {         if (check()) {             res = cnt;             return;         }         return;     }      for (int i = depth; i &lt;= H; i++) {         for (int j = 1; j &lt; N; j++) {             if (ladder[i][j] == 0 &amp;&amp; ladder[i][j + 1] == 0) {                 if (j &gt;= 2 &amp;&amp; ladder[i][j - 1] == 1) continue;                 if (j &lt; N - 1 &amp;&amp; ladder[i][j + 2] == -1) continue;                  ladder[i][j] = 1;                 ladder[i][j + 1] = -1;                  dfs(cnt + 1, i, line);                 if (res != -1) return;                  ladder[i][j] = 0;                 ladder[i][j + 1] = 0;             }         }     } }  void solve() {     cin &gt;&gt; N &gt;&gt; M &gt;&gt; H;     ladder.resize(H + 1, vector&lt;int&gt;(N + 1, 0));      if (M == 0) {         cout &lt;&lt; 0 &lt;&lt; endl;         return;     } else if (M == 1) {         if (H == 1)             cout &lt;&lt; -1 &lt;&lt; endl;         else             cout &lt;&lt; 1 &lt;&lt; endl;         return;     }      for (int i = 0; i &lt; M; i++) {         cin &gt;&gt; a &gt;&gt; b;         ladder[a][b] = 1;         ladder[a][b + 1] = -1;     }      if (needMoreThan4()) {         cout &lt;&lt; -1 &lt;&lt; endl;         return;     }      if (check()) {         cout &lt;&lt; 0 &lt;&lt; endl;         return;     }      for (int i = 0; i &lt;= 3; i++) {         dfs(0, 1, i);         if (res != -1) break;     }      cout &lt;&lt; res &lt;&lt; endl; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (7)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-7/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-27 04:08:27 +0900",
    "content": "   Transport Layer - (4)       TCP 특징    Point-to-point            한 프로세스와 한 프로세스(한 소켓 쌍) 간의 연결만 처리 (One Sender, One Receiver)           Reliable, in-order byte stream : 신뢰 가능하게 유실되지 않으면서, 순서대로 처리   pipelined : 한방에 덩어리로 보냄   full-duplex data : 양쪽다 서로 보냄(ACK도 보내는거니까)   Send &amp; Receive Buffer : 양쪽 다 2개의 버퍼가 있음            Sender에선 재전송하기 위해서.       Receiver에선 Out of Order로 들어오는 패킷들 Sequence # 체크해서 버리지 않고 잘 보관해두려고.           connection-oriented : Hand Shake   flow controlled : Receiver에서 받을 수 있는만큼 조절해서 보냄   Congestion controlled : 내부 네트워크 상황 보고 네트워크가 받아들일 수 있는 양만큼 네트워크에 보냄     TCP Segment Structure  Transport (TCP) 계층 전송단위는 Segment, Header에 메타데이터, Data에 application계층의 Data 들어감. 전송하는 입장에선 Header(메타데이터) 만 보고 전송하면 된다. 내부 데이터는 보지않는다. 예를들어 우편배달부가 편지를 전송할 때 편지봉투에 적힌 이름, 주소정보(메타데이터) 들을 보고 전달하지 편지봉투를 열어 편지 내용을 보고 전달하지 않는 것과 같다.  Header이 layer에서 매우매우 중요함.   TCP 세그먼트 구조    Source Port (16 bits): 송신자의 포트 번호. Sender Application이 사용하는 포트 번호.   Destination Port (16 bits): 수신자의 포트 번호를 나타냅니다. 데이터를 Receiver Application이 사용하는 포트 번호.            16bit -&gt; 0 ~ $2^{16} - 1$ 개 -&gt; 동시에 동작할 수 있는 네트워크 애플리케이션 수 이론상 65536개           Sequence Number (32 bits): 데이터의 순서를 추적하는 번호. 처음 연결 시에는 랜덤한 값으로 시작하며, 이후 전송된 바이트 수에 따라 증가한다. 수신자가 데이터의 순서를 정확히 재조립할 수 있게 함.   Acknowledgment Number (32 bits): 송신자가 수신한 데이터의 다음 예상 시퀀스 번호. 이전에 받은 데이터에 대한 확인 응답을 나타낸다.   Data Offset (4 bits): TCP 헤더의 크기. 일반적으로 20 바이트가 기본이지만, 선택적으로 헤더가 확장될 수 있기 때문에 이 필드는 데이터가 시작되는 위치를 나타낸다.   Window Size (16 bits): 수신자가 한 번에 받을 수 있는 데이터의 양. 흐름 제어를 위해 사용한다.   Checksum (16 bits): 헤더와 데이터의 무결성을 확인하기 위한 오류 검사 값. 송신자는 이 필드를 계산하고, 수신자는 이 값으로 데이터가 손상되었는지 확인한다.   Urgent Data Pointer (16 bits): URG 플래그가 설정된 경우, 긴급 데이터의 끝을 나타낸다. 일반적으로 잘 사용되지 않지만, 긴급 데이터를 처리할 때 유용하다.   Options (Variable Length): 선택적으로 사용하는 필드로, TCP 연결을 설정할 때 다양한 추가 정보를 제공하는 데 사용됩니다. 대표적으로 Maximum Segment Size (MSS)와 Window Scaling 옵션이 있습니다.   Padding: 옵션 필드를 32비트 경계로 맞추기 위해 사용된다. 옵션 필드의 길이가 32비트로 나누어 떨어지지 않으면 패딩을 추가한다.     TCP seq# &amp; ACKs     C 라는 char이 TCP Segment에 담긴다.   TCP에서 사용하는 Sequence Number은 Data를 Window Size만큼 잘라보낼때 제일 앞에 있는 데이터 Byte 번호다.   ex) 100Byte짜리 메시지를 10Byte짜리 Segment씩 보낸다고 가정해보자. 그럼 [ 0~9 ], [ 10~19 ], . . .  이런식으로 나뉘어 질 것이다. 그러면 첫번째 [ 0~9 ] 의 Sequence # 는 이 중 맨 앞인 0번이 된다. 다음 세그먼트의 Seqence # 는 10번이 된다. TCP는 이런식으로 번호가 매겨지게된다.   TCP에서 ACK는 이전 Go-Back-N의 ACK와 헷갈리게도 좀 다르다. 이전에 GBN에서는 ACK 10은 “10번까지 잘 받았다” 라는 의미였다. 하지만 TCP에서는 ACK 10의 의미는 “9까지 잘 받았고 다음 10번을 받을 차례다” 라는 의미다. 그래서 그림에서 호스트 A에 보이는 Seq #  = 42, ACK = 79라는 의미는 Send Buffer이 있는 C의 Byte번호가 42라는 뜻이고, Receive Buffer에 78번까지 잘 받았으니 79을 받아야한다는 뜻이다.   A의 ACK = 79였으므로 (78까지 받았고 79 필요함) B가 응답할 Sequence #는 79번이다. B의 ACK = 43 이었으므로 (42까지 받았고 43필요함) 다음에 A가 응답하는 Sequenc # 는 43번이다.   *Advanced A의 응답에 대해 ACK를 보내고 B가 보낼때 Data보내고 이런방식인데 그냥 한번에 데이터보낼때 응답도 한번에 보내면 안되는가? -&gt; 바로 ACK하지 않고 기다릴 Time을 설정하도록 권고한다 (500ms정도 기다리고 ACK를 보내라)    이유 1 : 내가 보내는 데이터가 생길 수 있으므로 거기에 같이 ACK를 한번에 보내면 되니까.   이유 2 : 실제로 Pipeline방식이기 때문에 데이터가 마구잡이로 들어온다. 그것에 대해 일일이 응답하지 않고 cumulative ACKs로 동작하는게 이득이다. 예를들어 segment 0~99를 보내면 ACK 1, ACK 2, … ACK 100이 아니라 마지막에 ACK 100만 보내면 되기 때문.     Timeout - function of RTT  중간에 Segment가 유실됐을 때 Timer을 통해 탐지한다고 했었다.  Timeout Value를 작게 크게할 때 장단점 복습    값 작을때 : Recovery 빠르지만 네트워크 오버헤드 줄 수 있음   값 클때 : 네트워크 오버헤드 적지만 Recovery 느림.   적절한 Timer 값 설정 방법은?     왕복 시간 (Round Trip Time, RTT) 은 데이터 패킷이 대상으로 전송되는 데 걸리는 시간과 해당 패킷에 대한 승인이 원본에서 다시 수신되는 데 걸리는 시간을 더한 것   RTT값이 각 세그먼트마다 다르다. 각각 지나는 경로가 다르면 RTT값이 다르고, 같은 라우터를 지나는 패킷 경로라 하더라도 Queueing Delay에 따라 값이 바뀔 수 있다.  (편차가 매우 큼)    그래서 사용하는 것이 EstimatedRTT 우리가 측정한 SampleRTT값을 사용하면 너무 편차가 크기 때문에 여기 가중치 $α$ 를 곱해 보정해서 사용한다.  실제로 이렇게 Estimated RTT값을 사용해도 괜찮을까? 이렇게 사용해도 위 그래프를 보면 알 수 있듯 튀는 Peak들이 있고, 실제 유실이 일어나지 않아도 timeout이 발생한다. Timeout이라는 것은 유실이 확실시 되었을때만 발생해야하는 엄격한 조건이기 때문에 마진을 붙였다.  아래 식에서 볼 수 있듯 Estimated RTT 에 4 * DevRTT라는 마진을 붙여 보정해서 사용한다.     Reliable Data Transfer     Pipeline 방식   Cumulative ACKs (ACK 10 이면 9까지 잘 받았고 10을 받아야한다는 뜻!)   Timer 1개 사용 -&gt; Go-Back-N과 유사함            GBN에서는 Timeout된 Window크기 버퍼 전체 재전송이지만 TCP는 그 세그먼트 하나만 재전송.            Case 1) Lost ACK    A가 8Byte짜리 데이터로 Sequence # 92 세그먼트를 보낸다. ( 92~99 )   B에서 92~99번을 받고 100번 기다리므로 ACK 100을 보낸다.   ACK가 유실되었으므로 A는 ACK를 받지 못했고 다시 92번과 데이터를 보낸다.   B는 ACK 100을 다시 보낸다.   Case 2) Premature Timeout    A가 8Byte짜리 데이터로 Sequence # 92인 세그먼트를 보낸다. ( 92~99 )   A가 추가로 다음데이터 20Byte짜리 Sequence # 100인 세그먼트를 보낸다 ( 100~119 )   B는 잘 받았기 때문에 먼저 ACK 100을 보내고 다음으로 ACK 120을 보낸다.   모종의 네트워크 이슈로 ACK가 A에 너무 늦게 도착하는 상황이다. 즉, ACK가 도착하기 전에 Time out이 발생.   A가 ACK 100을 받지 못했으므로, 다시 처음과 같은 8Byte짜리 데이터로 Sequence # 92인 세그먼트를 재전송한다. ( 92~99 )   B는 ACK 120을 보냈으므로 재전송한 Sequence# 92 는 버린다.   원하는 데이터를 받지 못한 B는 다시 필요한 걸 받기위해 ACK 120을 재전송한다.   재전송한 후 ACK 100을 받는다.   여기서 재전송한 ACK를 받은 A는 Sequence# 92를 재전송한 상황이기에 ( Sequence# 92에 해당하는 Timeout만 터짐. 타이머 하나임 ) ACK 120을 보고 이 타임아웃은 해결되었음을 알게됨( ACK 100아니므로 ). 타임아웃을 초기화하여 종료함.   Case 3) Cumulative ACK    A가 8Byte짜리 데이터로 Sequence # 92인 세그먼트를 보낸다. ( 92~99 )   A가 추가로 다음데이터 20Byte짜리 Sequence # 100인 세그먼트를 보낸다 ( 100~119 )   B는 잘 받았기 때문에 먼저 ACK 100을 보내고 다음으로 ACK 120을 보낸다.   ACK 100은 유실되었고, ACK 120은 잘 보내진 상황이다.   데이터 순서가 Sequence# 92, Sequence# 100이고, 앞선 데이터의 ACK 100은 받지 못했지만 뒤쪽 ACK 120은 잘 받았기 때문에 “119번까지 잘 받았고 120번을 주면 되겠구나!” 라고 생각함.        문제 없다고 판단하고 정상 진행됨. (Cumulative ACK의 장점이다. 마지막 ACK 하나만 잘 받으면 된다!)      TCP가 좀 더 스마트 하려면? RTT보정하기위해 더해준 마진 4 * DevRTT는 꽤나 넉넉한 값이다. 즉, Timeout이 생기기까지 시간이 매우 널널한 편. 그래서 0번부터 99번까지 보냈는데 10번에서 유실되었다고 가정해보자. 사실 타이머는 이 100개가 도착하기에 충분한 값이기 때문에 다시 ACK를 받고 재전송하기까지 너무 오래 기다려야한다. **타이머 시간이 너무 길기 때문에 비효율적인 상황이 발생할 수 있다. **  타이머가 터지기 전에 패킷 유실을 판단할 수 있다. 위의 상황을 다시 생각해보자. 0 ~ 99번까지 100개를 한번에 보냈고 10번이 유실되었다.     B에게 0부터 9번까지 유실없이 잘 전달되었으므로 A에서는 달라고 하는 번호인 ACK 1, ACK 2, … ACK 8, ACK 10까지 다시 잘 받는다.   A에서 10을 보내다가 유실되었다.   받지못한 B에서 Receiver는 반드시 ACK는 보내줘야 하므로 ACK 10을 보낸다. (10 필요해 보내줘)   Receiver에서는 버퍼에 10번 자리만 비워놓고 11, 12, 13, … 이렇게 쌓여간다.   A는 계속 11, 12, 13, … 을 보내며 Timeout발생하기 전까지 진행한다.   A가 이렇게 진행해도 B에서 응답하는 ACK는 필요한 것의 번호이기 때문에 ACK 10, ACK 10, ACK 10, … 이다.   같은 Duplicate ACK가 여러번 오는 상황이 발생하고, 이것을 “중간에 10이 유실되었구나” 라고 해석할 수 있다.  이를 Fast Retransmit 라고 한다.  권고 사항으로 Duplicate ACK가 3번 반복되면 ( 총 같은 ACK를 4번 받으면! ) 타이머에 관계없이 재전송하라고 권장한다.  Fast Retransmit은 없어도 문제되지 않는 메커니즘이다. 다만, 최적화를 위한 권고 사항이다. "
  },
  
  {
    "title": "BOJ_23351_물주기 (Java, C++)",
    "url": "/posts/BOJ23351%EB%AC%BC%EC%A3%BC%EA%B8%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-26 22:58:51 +0900",
    "content": "[Silver III] 물 주기 - 23351  문제 링크  성능 요약  메모리: 14312 KB, 시간: 128 ms  분류  그리디 알고리즘, 구현, 시뮬레이션  제출 일자  2025년 1월 26일 08:35:59  문제 설명  랑이 집사는 고양이들이 좋아한다는 캣닢을 직접 재배하려고 한다.  랑이 집사는 고양이들이 좋아한다는 캣닢을 직접 재배하려고 한다.  일직선으로 놓여진 $N$개의 화분에 캣닢이 하나씩 심어져 있다.  각 화분은 초기에 $K$만큼의 수분을 머금고 있고, 매일 아래와 같은 일이 순서대로 일어난다.  랑이 집사가 연속된 $A$개의 화분에 물을 준다. 이 때 물을 준 화분의 수분은 $B$만큼씩 증가한다. 모든 화분의 수분이 1씩 감소한다. 수분이 0이 된 화분에 있는 캣닢은 죽는다. 모든 캣닢이 살아 있는 기간이 최대한 길어지도록 물을 줄 때, 첫 캣닢이 죽는 날짜를 출력하는 프로그램을 작성하시오. 첫 날은 1일이다.  입력  첫째 줄에 자연수 $N$, $K$, $A$, $B$가 공백을 사이에 두고 주어진다. ($2 \\le N \\le 100$, $1 \\le K \\le 100$, $1 \\le A \\times B &lt; N$, $A$는 $N$의 약수)  출력  모든 캣닢이 살아 있는 기간이 최대한 길어지도록 물을 줄 때, 첫 캣닢이 죽는 날짜를 출력한다.     문제 풀이   제한 조건이 100이기때문에 단순 구현으로 풀 수 있다. 하지만 세그먼트트리를 연습하고싶었다. 그래서 두가지 버전을 사용해보았다.  이 문제의 경우 단순히 최소 구간합을 구하는 것 뿐만 아니라 전체 구간에 -1을 뒤늦게 적용해야하는 Lazy Propagation 까지 사용해야한다.       코드   Java 코드     단순 구현   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K, A, B, arr[], res;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_23351_물주기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());         A = Integer.parseInt(st.nextToken());         B = Integer.parseInt(st.nextToken());          arr = new int[N];         Arrays.fill(arr, K);         boolean flag = false;         while(!flag){             res++;              int startIdx = findMinSet();             waterPlants(startIdx);             flag = checkEnd();         }                  bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private int findMinSet() {         int idx = -1;         int sum = Integer.MAX_VALUE;         for (int i = 0; i &lt;= N-A; i++) {             int tmp = 0;             for (int j = i; j &lt; i+A; j++) {                 tmp += arr[j];             }             if(tmp &lt; sum){                 sum = tmp;                 idx = i;             }         }         return idx;     }      private void waterPlants(int startIdx) {         for(int i = startIdx; i &lt; startIdx + A; i++){             arr[i] += B;         }     }      private boolean checkEnd() {         for(int i = 0; i &lt; N; i++){             arr[i]--;             if(arr[i] &lt;= 0) return true;         }         return false;     } }      세그먼트 트리 + Lazy Propagation   // 세그먼트트리 + lazy propagation 풀이  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K, A, B, arr[], res;     static int[] tree;     static long[] lazy;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_23351_물주기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());         A = Integer.parseInt(st.nextToken());         B = Integer.parseInt(st.nextToken());          arr = new int[N];         Arrays.fill(arr, K);         boolean flag = false;          int h = (int) Math.ceil(Math.log(N) / Math.log(2));         int size = (1 &lt;&lt; (h+1));          tree = new int[size];         lazy = new long[size];          init(1, 0, N-1);                  while(!flag){             res++;              // 최소구간찾기             int minSum = Integer.MAX_VALUE;             int minIdx = 0;             for(int i=0; i&lt;N-A+1; i++){                 int sum = query(1, 0, N-1, i, i+A-1);                 if(sum &lt; minSum){                     minSum = sum;                     minIdx = i;                 }             }             update(1, 0, N-1, minIdx, minIdx+A-1, B);              update(1, 0, N-1, 0, N-1, -1);              int minValue = query(1, 0, N-1, 0, 0);             for(int i=1; i&lt;N; i++) {                 minValue = Math.min(minValue, query(1, 0, N-1, i, i));             }             if(minValue &lt;= 0) flag = true;         }          bw.write(String.valueOf(res));          bw.flush();         bw.close();         br.close();     }      // segment tree 초기화     private int init(int node, int start, int end){         if(start == end) return tree[node] = arr[start];          int mid = start + (end - start)/2;         return tree[node] = init(node * 2, start, mid) + init(node * 2 + 1, mid+1, end);     }      // lazy propagation. 원리는 특정 지연값을 특정구간에 포함되는 노드에 전파해두고     // 그 구간 조회/업데이트 쿼리 있으면 그때 구간길이만큼 곱해서 반영, 그 외에는 반영안함.     private void propagate(int node, int start, int end){         if(lazy[node] != 0) { // 지연된 업데이트가 있다면             tree[node] += (end-start+1) * lazy[node]; // 현재 구간(end-start+1)에 지연된 값을 적용              if(start != end) { // 리프노드 아니면 자식있으므로 자식에게 전파                 lazy[node * 2] += lazy[node];                 lazy[node * 2 + 1] += lazy[node];             }             lazy[node] = 0;         }     }      // 구간합조회     private int query(int node, int start, int end, int left, int right){         propagate(node, start, end);         if(start &gt; right || end &lt; left) return 0;         if(start &gt;= left &amp;&amp; end &lt;= right) return tree[node];          int mid = start + (end - start)/2;         return query(node*2, start, mid, left, right) + query(node*2 + 1, mid+1, end, left, right);     }      // 구간업데이트     private void update(int node, int start, int end, int left, int right, int value){         propagate(node, start, end);          if(start &gt; right || end &lt; left) return;         if(start &gt;= left &amp;&amp; end &lt;= right) {             tree[node] += (end - start + 1) * value;             if(start != end) {                 lazy[node * 2] += value;                 lazy[node * 2 + 1] += value;             }             return;         }          int mid = start + (end - start)/2;         update(node*2, start, mid, left, right, value);         update(node*2 + 1, mid+1, end, left, right, value);         tree[node] = tree[node*2] + tree[node*2 + 1];     } }    C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N, K, A, B; vector&lt;int&gt; tree, lazy;  void propagate(int node, int start, int end) {     if (lazy[node]) {         tree[node] += (end - start + 1) * lazy[node];     }      if (start != end) {         lazy[node * 2] += lazy[node];         lazy[node * 2 + 1] += lazy[node];     }     lazy[node] = 0; }  int init(vector&lt;int&gt;&amp; arr, int node, int start, int end) {     if (start == end) return tree[node] = arr[start];     int mid = start + (end - start) / 2;     return tree[node] = init(arr, node * 2, start, mid) +                         init(arr, node * 2 + 1, mid + 1, end); }  int query(int node, int start, int end, int left, int right) {     propagate(node, start, end);     if (start &gt; right || end &lt; left) return 0;     if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node];      int mid = start + (end - start) / 2;      return query(node * 2, start, mid, left, right) +            query(node * 2 + 1, mid + 1, end, left, right); }  void update(int node, int start, int end, int left, int right, int value) {     propagate(node, start, end);     if (start &gt; right || end &lt; left) return;     if (start &gt;= left &amp;&amp; end &lt;= right) {         tree[node] += (end - start + 1) * value;         if (start != end) {             lazy[node * 2] += value;             lazy[node * 2 + 1] += value;         }         return;     }     int mid = start + (end - start) / 2;     update(node * 2, start, mid, left, right, value);     update(node * 2 + 1, mid + 1, end, left, right, value);     tree[node] = tree[node * 2] + tree[node * 2 + 1]; }  void solve() {     cin &gt;&gt; N &gt;&gt; K &gt;&gt; A &gt;&gt; B;     vector&lt;int&gt; arr(N, K);      int h = ceil(log2(N));     int size = (1 &lt;&lt; (h + 1));     tree.resize(size);     lazy.resize(size);      init(arr, 1, 0, N - 1);      int res = 0;     while (true) {         res++;          int minSum = INT_MAX, minIdx = 0;         for (int i = 0; i &lt;= N - A; i++) {             int sum = query(1, 0, N - 1, i, i + A - 1);             if (sum &lt; minSum) {                 minSum = sum;                 minIdx = i;             }         }          update(1, 0, N - 1, minIdx, minIdx + A - 1, B);         update(1, 0, N - 1, 0, N - 1, -1);          int minValue = query(1, 0, N - 1, 0, 0);         for (int i = 1; i &lt; N; i++) {             minValue = min(minValue, query(1, 0, N - 1, i, i));         }          if (minValue &lt;= 0) break;     }      cout &lt;&lt; res &lt;&lt; '\\n'; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_15912_우주선 만들기 (Java, C++)",
    "url": "/posts/BOJ15912%EC%9A%B0%EC%A3%BC%EC%84%A0-%EB%A7%8C%EB%93%A4%EA%B8%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-25 23:03:49 +0900",
    "content": "[Gold III] 우주선 만들기 - 15912  문제 링크  성능 요약  메모리: 2156 KB, 시간: 0 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 1월 25일 22:59:23  문제 설명  &lt;스타로드와 토끼는 토르를 구출하기 위해서 우주선을 만들고 있다.  우주선을 만들기 위해서는 총 N개의 부품을 상점에서 모두 구입해야 한다. 모든 부품은 무게 W와 에너지 E를 갖고 있다. 상점에서는 모든 부품을 1부터 N번까지 부품을 순서대로 나열해놓고 판매하고 있다.  이 상점에서는 특이하게도 부품의 가격을 W x E의 비용으로 팔고 있다. 상점에서는 또한 특이한 방식의 판매를 하는데, L 부품부터 R 부품중 최대 무게 W_max 와 최대 에너지 E_max의 곱 W_max * E_max의 비용을 지불한다면 L부터 R사이의 모든 부품을 한번에 구입할 수 있다. 또한 이 상점은 X부품과 Y부품 (X&lt;Y)을 동시에 구입하거나 X부품을 Y부품 보다 먼저 구입할 순 있지만, Y부품을 X부품보다 먼저 구입할 순 없다.  그렇다면 스타로드와 토끼가 모든 부품을 살 수 있는 최소의 비용을 구해보도록 하자.  입력  첫 번째  줄에는 부품의 개수 N(1 ≤ N ≤ 1,000)가 주어진다.   두 번째 줄에는 각 부품의 무게 W(0 ≤ W ≤ 1,000,000)가 주어진다.  세 번째 줄에는 각 부품의 에너지 E(0 ≤ E ≤ 1,000,000)가 주어진다.  출력  스타로드와 토끼가 모든 부품을 살 수 있는 최소비용을 한줄에 출력하라.     문제 풀이        코드   Java 코드  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, Weight[], Energy[];     static long maxBoard[][], dp[][];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_15912_우주선만들기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         Weight = new int[N];         Energy = new int[N];         dp = new long[N][N];         maxBoard = new long[N][N];          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             Weight[i] = Integer.parseInt(st.nextToken());         }          st = new StringTokenizer(br.readLine());         for(int i = 0; i &lt; N; i++) {             Energy[i] = Integer.parseInt(st.nextToken());         }          long maxW=0, maxE=0;         for (int i = 0; i &lt; N; i++) {             maxW = Weight[i];             maxE = Energy[i];             for (int j = i; j &lt; N; j++) {                 maxW = Math.max(maxW, Weight[j]);                 maxE = Math.max(maxE, Energy[j]);                 maxBoard[i][j] = maxW * maxE;                 if(i == j) dp[i][j] = maxBoard[i][j];             }         }          for(int len=2; len&lt;=N; len++) {             for(int start=0; start&lt;=N-len; start++) {                 int end = start+len-1;                 dp[start][end] = maxBoard[start][end]; // 한번에 구매                 for(int idx=start; idx&lt;end; idx++) {                     dp[start][end] = Math.min(dp[start][end], dp[start][idx] + dp[idx+1][end]); // 분할구매                 }             }         }          bw.write(String.valueOf(dp[0][N-1]));         bw.flush();         bw.close();         br.close();     } }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;     vector&lt;long long&gt; W(N + 1), E(N + 1), dp(N + 1);      for (int i = 1; i &lt;= N; i++) {         cin &gt;&gt; W[i];     }     for (int i = 1; i &lt;= N; i++) {         cin &gt;&gt; E[i];     }      for (int i = 1; i &lt;= N; i++) {         dp[i] = LLONG_MAX;         long long maxW = 0, maxE = 0;         for (int j = i; j &gt;= 1; j--) {             maxW = max(maxW, W[j]);             maxE = max(maxE, E[j]);             dp[i] = min(dp[j - 1] + maxW * maxE, dp[i]);         }     }      cout &lt;&lt; dp[N] &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (6)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-6/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-25 05:15:30 +0900",
    "content": "   Transport Layer - (3)   Pipelining : Increased Utilization    Go-Back-N    한번에 여러개를 보낼것이다.   Window Size 만큼 패킷을 덩어리로 보낸다. 이 사이즈만큼은 Feedback 받지 않고 그냥 보낼 수 있다.   ACKs : cummulative한 방식 (쌓는다는 의미)            ex : ACKs 11 : 0~11까지 잘 받았다는 의미           Sender 부담이 크다            Window Size만큼 패킷을 덩어리로 보내는데 패킷별 타이머 중 특정 패킷타이머가 작동하면 그 윈도우 안에 들어있고 번호가 큰 패킷들을 전부 재전송한다.       ex) window size = 4, [0, 1, 2, 3] 전송할 때 timer 0 이 터졌으면 0이상의 모든 패킷들 다 재전송           GBN : sedoer extended FSM         receiver이 매우 단순하다. 자기가 받아야 할 Sequence # 만 주구장창 기다린다. 모든 결정과 업무를 Sender가 한다. 예시를 그림으로 보자           win size = 4라고 가정            sender는 덩어리로 패킷 0,1,2,3을 보냄.       receiver는 0이 와서 ACK 0 응답       그 다음 패킷 1이 와서 ACK 1 응답,       근데 패킷 2가 오는 도중 Loss 발생!       그 후 3이 오긴 했으나 Receiver는 2를 기다리므로 무시한다…, 그대로 ACK 1을 보낸다. 패킷 2가 올때까진 계속 ACK 1이 전송된다.           Sender 입장.    ACK0, ACK1이 왔으니 패킷 4, 패킷 5를 보냄   그런데 이에대한 응답으로 ACK1이 왔다. 이 말인 즉슨, “2가 중간에 유실됬구나” 를 의미한다.   패킷 2에 대한 타이머가 울린다. 다시 2부터 win size (N) 만큼 보낸다.   여기서 왜 Go-Back-N인지 알 수 있다. window size N만큼 돌아와서 다시 거기부터 덩어리로 보내야하기 때문이다.  window의 의미    한번에 보낼 수 있는 크기   window안에 있는 패킷들은 버퍼에 저장하고 있어야 한다. 아직 재전송 확률이 있기 때문에 버퍼에 담고있어야한다는 의미. 하나 잘못 보냈다고 다시 여러개를 재전송한다는 것은 매우 비효율적이다.     Selective Repeat     Receiver가 개별적으로 패킷에 대한 응답 (&lt;=&gt; cummulative 와 대조됨)            ex) ACK 11 : 11만 왔어요           Sender는 응답이 오지 않은 패킷만 재전송! 효율적임.       이번엔 Sender 뿐만 아니라 Receiver도 순서대로 안 왔을 경우 임시 저장을 위한 버퍼가 있다.   어떤 패킷이 안 왔는지 판별해야 하기 때문이다. 이번엔 Receiver의 부담이 크다.   아래 예시를 통해 알아보자.     패킷 0이 와서 ACK 0 전송, 패킷 1이 와서 ACK 1 전송   패킷 2가 안 왔고 (Loss), 패킷 3이 왔다 ACK는 무조건 보내야하므로 ACK3 을 전송.   이 때 Receiver는 패킷 3을 버퍼에 저장.** Sender가 패킷 2의 타이머로 타임아웃을 해서 패킷2를 다시 보내기 전까지 기다리기 위해 패킷3을 버퍼에 저장한다.**   패킷 2가 오기전에 패킷 4와 패킷 5가 왔다. 이것도 버퍼에 저장하고  ACK 4, ACK 5 를 전송.   드디어 패킷2가 왔다. 버퍼에 2,3,4,5 순서 맞춰서 한꺼번에 Application Layer 로 보낸다.        그다음 진행은 안받은 ACK 6 해야하니까 패킷 6부터 다시 시작하는것.      1 - 2 - 3 - 4 - 5 - 2 - 6 - 7 - ……        Selective Repeat : 딜레마    패킷의 Sequence #는 패킷 번호처럼 쭉 늘어난다고 생각해보자.   Sequence #는 Header의 필드고, 이 크기는 작으면 작을수록 좋다. (오버헤드문제)   우리가 원하는건 최소한의 크기를 가진 Sequence # 를 설정해두고 계속 재사용해서 쓰는게 Best            이 # 범위가 어떻게 될까            1번 케이스 그림 (a)  window size 3이니까 Seq #를 4 ( [0, 1, 2, 3] )로 설정해보았다. 패킷 0, 1, 2 를 잘 보냈고 잘 받았다. ACK 0, 1, 2를 전송. 그런데 ACK들이 유실되었다.    먼저 패킷 0의 타이머가 타임아웃이 터질것이다. 그래서 패킷 0을 재전송하는것인데 이것의 Sequence # 가 0이기 때문에 3 다음의 번호가 다시 0으로 반복되니까 새로운 패킷인줄 알게 되는 것이다.   이때 원래같으면 받아야할 패킷이 올 때 까지 들어오는 패킷들은 버퍼에 2번째칸부터 순서대로 저장하고 원하는 패킷이 오면 버퍼 맨 앞에 넣어 다시 순서대로 보내는것이 정석이다.   이 상황에선 오히려 독이 된 것이다. 재전송했기 때문에 해결되어야 하는데 새로운 패킷인줄 알고 버퍼에 저장해버려 오류상황이 끝나지 않게 된 것.   즉 N개의 win size일 때 N+1은 불가능하다! Sequence # 를 더 늘리자! 얼마쯤 될까? 2N이라고 예상이 된다.  2N개를 사용하면:    송신자: 0,1,2,3,4,5(N=3 기준)   지연된 패킷이 도착해도 새로운 패킷과 번호가 겹치지 않음  "
  },
  
  {
    "title": "DB Replication이란?",
    "url": "/posts/DB-Replication%EC%9D%B4%EB%9E%80/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-25 00:50:09 +0900",
    "content": "DB Replication DB Replication은 데이터베이스의 고가용성과 데이터 안정성을 보장하기 위해 활용되는 핵심 기술이다. 특히, 대규모 애플리케이션 환경에서는 데이터의 지속적인 가용성과 신뢰성이 매우 중요하기 때문에, 원본(Source) 서버와 복제(Replica) 서버간의 데이터 동기화는 필수다.  바이너리 로그(Binary Log) 저장 방식 MySQL 기준 Replication은 Source 서버에서 발생하는 모든 데이터 변경사항을 Replica 서버로 복제하여 두 서버간의 데이터 일관성을 유지하는 메커니즘이다. 이러한 과정은 주로 Binary Log 를 기반으로 이루어지며, Binary Log를 저장하는 방식으로 Row , Statement , Mixed 의 세 가지 방식을 제공하며, 각 방식은 각각 장단점이 있다.  Row Row 방식은 데이터베이스의 각 행별로 변경된 내용을 정확히 기록한다.    장점 : 데이터 일관성을 매우 높게 유지할 수 있다.            ex) 특정 행이 수정되었을 때 그 행의 이전 상태와 변경된 상태를 모두 기록하므로, 복제 서버에서도 원본 서버와 동일한 데이터 상태를 유지할 수 있다.           단점 : 모든 행의 변경 사항을 저장하기 때문에 Binary Log 파일의 크기가 급격히 증가할 수 있기 때문에 저장공간에 부담을 줄 수 있다.   Statement Statement 방식은 데이터 변경을 일으킨 SQL문 자체를 Binary Log에 기록한다.    장점 : 로그 파일의 크기를 상대적으로 작게 유지할 수 있어 저장공간을 절약할 수 있다.   단점 : 실행할 때 마다 다른값을 반환하는 함수와 같이 비확정적(non-deterministic) SQL 쿼리가 실행될 경우, 동일한 쿼리가 Source와 Replica 서버에서 다른 결과를 초래할 수 있어 데이터 불일치 문제가 발생할 수 있다.            ex) SELECT NOW() 와 같은 함수는 실행 시점에 따라 다른 결과를 반환할 수 있기 때문에, 이를 포함한 쿼리는 복제 시 문제가 될 수 있다.           Mixed 이러한 문제를 보완하기 위해 MySQL은 Mixed 방식을 제공한다. Mixed 방식은 상황에 따라 row기반과 statement 기반을 혼합하여 로그를 기록한다. 비확정적인 SQL이 아닌 경우에는 statement 방식을 사요하여 저장 공간을 절약하고, 비확정적 SQL이 실행되는 경우에는 row 방식을 사용하여 데이터 일관성을 유지한다. 이를 통해 두 방식의 장점을 모두 활용할 수 있으며, 데이터 불일치 문제를 최소화 할 수 있다. 다만, 구현이 다소 복잡할 수 있다는 단점이 존재한다.  복제 과정 Source 서버에서 데이터 변경 쿼리가 실행되고, 선택된 로그 저장방식에 따라 Binary Log 에 기록된 후, Replica 서버의 IO Thread가 Binary Log를 읽어와 Replica 서버의 Relay Log로 전송한다. Relay Log는 Replica 서버에서 Source 서버의 Binary Log를 저장하는 임시 저장소 역할을 하며, 이곳에 저장된 로그를 기반으로 Replica 서버의 SQL 스레드가 실제 데이터베이스에 변경사항을 적용한다. 이 과정은 매우 효율적으로 설계되어있으며 일반적으로 약 100ms 이내에 데이터 동기화가 완료된다. 이러한 빠른 동기화 속도 덕분에 원본과 복제 서버간의 데이터 일관성이 실시간에 가깝게 유지될 수 있다.  References    What is Database Replication and How Does it Work?  "
  },
  
  {
    "title": "BOJ_17302_흰색으로 만들기 (Java, C++)",
    "url": "/posts/BOJ17302%ED%9D%B0%EC%83%89%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-24 21:27:24 +0900",
    "content": "[Gold I] 흰색으로 만들기 - 17302  문제 링크  성능 요약  메모리: 44860 KB, 시간: 668 ms  분류  애드 혹  제출 일자  2025년 1월 24일 21:23:54  문제 설명  N행 M열 격자판의 각 격자가 흰색 또는 검은색으로 칠해져 있다. 각 칸에 대해 다음의 3가지 중 1가지 행동을 취할 수 있다.   \t아무 변화도 주지 않는다. \t선택한 칸과 인접한 모든 칸의 색을 반전시킨다. 단, 선택한 칸은 반전시키지 않는다. \t선택한 칸 및 그 칸과 인접한 모든 칸의 색을 반전시킨다.   당신은 모든 칸을 흰색으로 만들고자 한다. 모든 칸을 흰색으로 만드는 방법을 구하여라.  입력  첫 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 2,000)  다음 줄부터 N개의 줄에 걸쳐 각 행의 상태를 나타내는 길이 M의 문자열이 주어진다. 모든 문자열은 'B'와 'W'로 이루어져 있다. i 번째 줄, j 번째 문자가 'B'일 경우 해당 칸이 검은색이며 'W'일 경우 해당 칸이 흰색임을 의미한다.  출력  만약 모든 칸을 흰색으로 만드는 것이 불가능하다면 첫 줄에 -1을 출력한다.  가능하다면 첫 줄에 1을 출력하고, 다음 줄부터 N개의 줄에 걸쳐 M개의 수를 공백 없이 출력한다.  i 번째 줄의 j 번째 수는 i 번째 줄, j 번째 칸에 취한 행동을 나타낸다. 1은 아무런 변화를 주지 않은 것, 2는 인접한 모든 칸을 반전시킨 것, 3은 그 칸 및 인접한 모든 칸을 반전시킨 것을 의미한다.  만약 가능한 답이 여럿이라면 그 중 아무것이나 출력한다.     문제 풀이        코드   Java 코드 package BOJ_17302_흰색으로만들기;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M;     static char[][] board;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static StringBuilder sb = new StringBuilder();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17302_흰색으로만들기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          board = new char[N][M];         for (int i = 0; i &lt; N; i++) {             String str = br.readLine();             for (int j = 0; j &lt; M; j++) {                 board[i][j] = str.charAt(j);             }         }          for (int i = 0; i &lt; N; i++) {             for (int j = 0; j &lt; M; j++) {                 for(int k=0; k&lt;4; k++) {                     int nr = i + dr[k];                     int nc = j + dc[k];                     if(isValid(nr, nc)) command2(nr, nc);                 }             }         }          sb.append(1).append(\"\\n\");          for (int i = 0; i &lt; N; i++) {             for (int j = 0; j &lt; M; j++) {                 if(board[i][j] == 'B') sb.append(3);                 else sb.append(2);             }             sb.append(\"\\n\");         }          bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private void command2(int r, int c) {         if(board[r][c] == 'W') board[r][c] = 'B';         else board[r][c] = 'W';     }      private boolean isValid(int r, int c) {         return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M;     } }     C++ 코드  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N, M; vector&lt;vector&lt;char&gt;&gt; board; int dr[4] = {-1, 1, 0, 0}, dc[4] = {0, 0, -1, 1};  bool isValid(int r, int c) { return r &gt;= 0 &amp;&amp; r &lt; N &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; M; }  void command2(int r, int c) { board[r][c] = (board[r][c] == 'W') ? 'B' : 'W'; }  void solve() {     cin &gt;&gt; N &gt;&gt; M;      board.resize(N, vector&lt;char&gt;(M));      for (int i = 0; i &lt; N; i++) {         string str;         cin &gt;&gt; str;         for (int j = 0; j &lt; M; j++) {             board[i][j] = str[j];         }     }      for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             for (int k = 0; k &lt; 4; k++) {                 int nr = i + dr[k];                 int nc = j + dc[k];                 if (isValid(nr, nc)) command2(nr, nc);             }         }     }      cout &lt;&lt; 1 &lt;&lt; \"\\n\";     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             cout &lt;&lt; (board[i][j] == 'B' ? 3 : 2);         }         cout &lt;&lt; \"\\n\";     } }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (5)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-5/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-24 03:58:52 +0900",
    "content": "   Transport Layer - (2)    전송 계층은 Reliable 하다고 말할 수 있다. 이 뜻은 application 계층으로부터 내려온 데이터들이 application 계층까지 데이터 유실 없이 도달할 수 있다는 뜻.  네트워크 레이어를 보면, Transport layer를 통해 Reliable한 데이터 전송이 가능하다. 근데 이 하위 계층을 타고 전달되는데 그 아래 계층은 Unreliable하다. 데이터 전송이 Unreliable하다는 뜻은     Message Error 가능   Message Loss 가능 라는 뜻이다. 네트워크 계층에서는 Packet 에러와 Packet 손실로 볼 수 있겠다.   그럼 어떻게 Transport layer에서 위 2가지를 방지할 수 있을까?     Final State Machine : 각 State가 있고 어떤 이벤트가 발생하면 나는 이러한 Action을 취하고 다음 화살표가 가리키는 State로 이동한다.     RDT v1.0 : Error, Loss 없는 상황         sender : 그냥 보낸다.           Receiver : 그냥 받는다.        RDT v2.0 : Error만 발생할 수 있는 상황( No Loss )         1. Error Detection            보내는 Packet header에 CheckSum을 담아보낸다. 이 CheckSum은 보내는 데이터에 에러가 있는지 없는지를 확인할 수 있는 장치. (ex. 모든 데이터의 합을 CheckSum으로 사용하면 위변조 판단 가능)                2. Feedback            Acknowledgements (ACKs) : 잘 받았음 을 전달 ex) 배달앱 주문 넣으면 주문 접수됨 알림을 표시       Negative Acknowledgements (NAKs) : 에러 있음 을 전달 ex) 주문이 접수 안되면 접수되지 않았음을 표시                3. Retransmission            NAKs을 받으면 다시 전송           즉 Error 발생은 checksum, feedback,retransmission으로 커버할 수 있다. 강의예시로 전화통화시 통화가 잘 진행중이면 어, 응 등의 대답을 하지만 통화가 원할하지 않아 전달이 제대로 되지 않으면 뭐라고? 등의 표현을 다시 전달한다. 이를 ACKs, NAKs라고 볼 수 있다.  하지만 여기서도 아직 부족한 점이 있다.  우측 Diagram에서 아래로 시간의 흐름을 따라 진행하고, 좌측화살표는 Sender, 우측화살표는 Receiver이다. Sender이 Hello! 라는 데이터를 보내고 Feedback으로 ACKs를 보낸다는 상황을 가정해보자. 이 Feedback에 문제가 생기면 어떻게 될까? 받은 데이터가 에러가 있는지 없는지를 확인할 방법이 없어진다.  이러한 상황을 위해서는 Feedback 자체에서 CheckSum을 도입해야 Feedback이 정상인지 아닌지를 확인 할 수 있다.  일단 이러한 상황을 위해 Sender는 다시 동일한 데이터 Hello!를 Receiver에게 보낸다. Receiver은 이때     이전에 보낸 Hello! 와 같은 데이터 Hello!를 다시 한번 더 보낸건지 (Duplicate packets)   진짜로 전달하고자 하는 데이터가 Hello!Hello! 인지 (Normal)   알 수가 없다.    RDT v2.1 Error 해결방법  구별하는 방법    패킷에 번호 붙이기 ( = Sequence Number )   패킷의 헤더에 포함된다.   Q ) 만약 패킷을 하나씩 보내면서 통실하는 경우, Sequence # 몇개 필요할까? A ) 답은 2개다. 0부터 계속 증가시켜나가면 무한대로 커질 수 있지만 실제로는 숫자 0 , 1 로 1비트만 있으면 된다. 0 보내고 잘 받았으면 다음에는 1 보내고, 다시 0 보내고 반복하면 된다.      RDT v2.2 : NAK-Free Protocol  무조건 ACK를 사용하되, 가장 마지막으로 받은 정상 Sequence Number을 다시 보냄.  요약 : 패킷 에러 대처 방안 : Error detection, Feedback, Retransmission, Seqence Number 4가지    RDT v3.0 Channel with Loss &amp; Packet Errors  이전까지 Error는 잘 대처했다. 이제 Loss에 집중해보자. Sender 입장에서 메시지를 보낸 후 이것이 중간에 유실됐는지 어떻게 확인할 수 있는가?   Timer : 적절한 타이머를 설정하고, 피드백이 오지 않으면 재전송.    시간 설정에는 정답이 없다.            너무 짧게 설정했을때는 회복이 빠르다는 장점이 있지만 오류없이 오래 걸리는 상황에서도 중복된 패킷을 계속 보내므로 네트워크 오버헤드가 발생한다.                    이때 처음보낸 오래걸리는 패킷이 되돌아오면 2번째로 다시 보낸 패킷과 Sequence # 가 같은데 어떻게 처리할까? 이것은 receiver에서 같은 숫자가 들어왔으므로 버린다. 그래서 신경쓰지 않아도 된다. 그림(d)케이스                       너무 길게 설정했을때는 반대로 네트워크 오버헤드가 발생할 확률이 매우 낮지만 너무 신중하기 때문에 Loss가 발생한 상황에도 늦게 반응하여 회복이 느리다.           Sender 입장에서는 보낸 패킷이 유실되거나, Feedback이 유실되거나 같은 상황이다. 이때 문제가 생겼다고 (유실되었구나) 판단하고 무식하게 재전송 하면 모든것이 해결된다.        Summary     Unreliable : Loss , Error   Error : Error detection , Feedback , Retransmission , Seqence Number   Loss : Timer   Limitation : 그러나, 이 모든 과정은 패킷을 딱 1개씩 주고 받고 할 때고, 실제로는 패킷을 여러개를 Batch 단위로 보내고, 각각 패킷에 대해 피드백을 한다.   "
  },
  
  {
    "title": "BOJ_13504_XOR 합 (Java)",
    "url": "/posts/BOJ13504XOR-%ED%95%A9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-23 15:59:47 +0900",
    "content": "[Platinum III] XOR 합 - 13504  문제 링크  성능 요약  메모리: 366500 KB, 시간: 2060 ms  분류  자료 구조, 누적 합, 트리, 트라이  제출 일자  2025년 1월 23일 15:54:10  문제 설명  N개의 수로 이루어진 수열 A가 주어진다.   수열 A에서 연속된 부분 수열을 고르려고 한다. 부분 수열의 XOR 합이란, 부분 수열에 들어있는 모든 원소를 XOR한 값을 의미한다.  수열 A가 주어졌을 때, XOR 합이 가장 큰 부분 수열을 찾는 프로그램을 작성하시오.  입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 10)  각 테스트 케이스의 첫째 줄에는 배열의 크기 N (1 ≤ N ≤ 100,000), 둘째 줄에는 수열 A에 들어있는 수가 주어진다. 수열 A에 들어있는 수는 32비트 부호있는 정수 범위 안에 들어가는 음이 아닌 정수이다.  출력  각각의 테스트 케이스마다 수열 A의 연속된 부분 수열 중에서 XOR 합이 가장 큰 부분 수열의 XOR 합을 출력한다.     문제 풀이        코드   package BOJ_13504_XOR합;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Trie{         Trie[] childred = new Trie[2];          void insert(int num){             Trie node = this; // 현재노드부터 시작             // 32비트 정수의 각 비트를 순회 (MSB부터 LSB까지)             // i = 31부터 이유: int는 32비트이므로 가장 왼쪽 비트 31             for(int i=31; i&gt;=0; i--){                 int bit = (num &gt;&gt; i) &amp; 1; // x의 i번째 비트                 if(node.childred[bit]==null){ // 가려고하는 그 경로 없으면 새로 생성                     node.childred[bit] = new Trie();                 }                 node = node.childred[bit]; // 다음으로 이동             }         }          int getMaxXOR(int num){             Trie node = this;             int res=0;             for(int i=31; i&gt;=0; i--){                 int bit = (num &gt;&gt; i) &amp; 1;                 if(node.childred[1-bit] != null){ // XOR을 위해 반대비트값 찾는데 있으면                     res |= (1 &lt;&lt; i);                     node = node.childred[1-bit]; // 다음으로 이동                 }                 else{                     node = node.childred[bit];                 }             }             return res;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int T, N, arr[], maxXOR, cumulativeXOR;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_13504_XOR합/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  T = Integer.parseInt(br.readLine());         while (T-- &gt; 0) {             N = Integer.parseInt(br.readLine());             arr = new int[N];              st = new StringTokenizer(br.readLine());             for(int i = 0; i &lt; N; i++){                 arr[i] = Integer.parseInt(st.nextToken());             }              Trie trie = new Trie();             trie.insert(0);             maxXOR = 0;             cumulativeXOR = 0;              for(int i = 0; i &lt; N; i++){                 cumulativeXOR ^= arr[i]; // 누적 XOR                 trie.insert(cumulativeXOR); // 현재까지 누적 XOR 넣기                 maxXOR = Math.max(maxXOR, trie.getMaxXOR(cumulativeXOR));             }              sb.append(maxXOR).append(\"\\n\");         }          bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1868_보물찾기 (Java)",
    "url": "/posts/BOJ1868%EB%B3%B4%EB%AC%BC%EC%B0%BE%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-23 04:10:20 +0900",
    "content": "[Ruby V] 보물찾기 - 1868  문제 링크  성능 요약  메모리: 34856 KB, 시간: 300 ms  분류  다이나믹 프로그래밍, 트리에서의 다이나믹 프로그래밍, 그래프 이론, 그래프 탐색, 그리디 알고리즘, 트리  제출 일자  2025년 1월 23일 01:37:28  문제 설명  n개의 방으로 이루어진 미로가 있다. 이 미로 내의 임의의 두 방 사이에는 반드시 하나의 경로가 존재하고, 그 경로는 유일하다.  이 방들 중 한 방에는 김주성 조교가 보물을 숨겨 놓았는데, 김진영 조교는 이 보물을 찾길 원한다. 그러기 위해서, 김진영 조교는 김주성 조교에게 특정한 방에 보물이 있는지 물어 본다. 친절한 김주성 조교는 김진영 조교가 옳은 방을 골랐으면 그렇다고 말해 주고, 옳은 방을 고르지 않았다면 그 방에 연결된 복도 중 어느 복도를 따라 가야만 보물을 찾을 수 있는지 말해 준다.  여러분이 할 일은 미로의 구조가 주어졌을 때 김진영 조교가 최악의 경우에 몇 번의 질문을 던져야 하는지 계산해 내는 것이다. 물론, 영리한 김진영 조교는 항상 최선의 질문을 한다.  입력  첫째 줄에 n이 주어진다. (1 ≤ n ≤ 50,000) 이후 n-1개의 줄에는 각각 두 개의 숫자가 주어진다. a와 b가 주어졌다면, a번 방과 b번 방 사이에 복도가 있어 왕래할 수 있다는 의미이다. 방의 번호는 1번부터 n번까지 연속해서 붙어 있다.  출력  첫 줄에 김진영 조교가 최선을 다하더라도, 최악의 경우 몇 번의 질문을 던져야 하는지 출력한다.     문제 풀이     접근    비트마스크를 사용하여 각 서브트리의 “깊이 정보”를 관리   DFS를 통해 트리를 순회하며 각 노드에서 필요한 질문 횟수를 계산   서브트리들이 겹치는 경우를 처리하여 최적의 질문 횟수를 도출   비트마스크 활용 // 비트마스크의 의미 0001 (1) = 깊이 0 = 바로 인접한 방 확인 0010 (2) = 깊이 1 = 2번의 질문 필요 0100 (4) = 깊이 2 = 3번의 질문 필요   예시  예시와 설명 다음과 같은 트리 구조를 생각해봅시다:     1    / \\   2   3  /     \\ 4       5     노드 4와 5는 리프 노드로, 비트마스크 0001 을 반환   노드 2와 3은 각각 하나의 자식을 가지므로, 비트마스크를 조정   루트 노드 1에서는 두 서브트리의 정보를 합치고 필요한 질문 횟수 계산   시간 복잡도     DFS를 사용하여 트리를 한 번 순회: O(N)   각 노드에서의 비트 연산: O(1)   전체 시간 복잡도: O(N)      코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, a, b, res;     static ArrayList&lt;Integer&gt;[] tree;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1868_보물찾기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());         tree = new ArrayList[N+1];         for(int i = 1; i &lt; N+1; i++){             tree[i] = new ArrayList&lt;&gt;();         }          for(int i = 0; i &lt; N-1; i++) {             st = new StringTokenizer(br.readLine());             a = Integer.parseInt(st.nextToken());             b = Integer.parseInt(st.nextToken());              tree[a].add(b);             tree[b].add(a);         }          res = dfs(1, 0);          bw.write(String.valueOf(31 - Integer.numberOfLeadingZeros(res)));         bw.flush();         bw.close();         br.close();     }      private int dfs(int curr, int parent){         int currBitMask = 0; // 비트마스크를 사용하여 서브트리의 상태를 관리 (깊이)         /*             이진수: 0001 = 깊이 0 = 바로 옆 방을 확인하면 됨             이진수: 0010 = 깊이 1 = 2번의 질문이 필요함             이진수: 0100 = 깊이 2 = 3번의 질문이 필요함          */         int maxHeight = 0;          /*             각 노드에서:               - 자식 노드들의 결과를 비트마스크로 합침               - 겹치는 부분이 있으면 그 중 가장 높은 비트 위치를 찾음               - 현재 노드의 비트마스크를 적절히 조정          */          // 현재 노드의 모든 자식 노드들 순회         for(int child : tree[curr]){             if(child == parent) continue;              // 자식서브트리 결과             int childBitMask = dfs(child, curr);              // 현재 비트마스크와 자식 결과 사이에 겹치는 서브트리 있으면             if((childBitMask &amp; currBitMask) != 0){                 // 겹치는 비트 중 가장 높은 위치 찾기, 즉 더 깊은 깊이가 필요함                 maxHeight = Math.max(maxHeight, 31- Integer.numberOfLeadingZeros(childBitMask &amp; currBitMask));             }              // 현재 비트마스크에 자식결과 합침             currBitMask |= childBitMask;         }          // 현재 노드의 최종 비트마스크 계산         currBitMask += 1 &lt;&lt; maxHeight; // 갈래가 2개면 (4, 5), 한번 더 진행해야한다는 것이므로 깊이 하나 증가한다는 의미          // maxHeight가 0이 아니면 비트마스크 조정 (겹치는 깊이 정보를 제거하기 위해)         /*             1            / \\           2   3          /     \\         4       5         이런 트리가 있을 때 조정하지 않은 경우:             - 2번 노드에서: 0001 (깊이 0)             - 3번 노드에서: 0001 (깊이 0)             - 1번 노드에서 이 값들을 합치면: 0011         문제점: 이렇게 되면 \"같은 깊이에서 두 개의 선택지가 있다\"고 잘못 해석됨          */         if(maxHeight &gt; 0){             currBitMask &gt;&gt;= maxHeight;             currBitMask &lt;&lt;= maxHeight;         }         return currBitMask;     } }  "
  },
  
  {
    "title": "BOJ_1484_다이어트 (Java)",
    "url": "/posts/BOJ1484%EB%8B%A4%EC%9D%B4%EC%96%B4%ED%8A%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-22 20:09:25 +0900",
    "content": "[Gold V] 다이어트 - 1484  문제 링크  성능 요약  메모리: 14428 KB, 시간: 104 ms  분류  수학, 두 포인터  제출 일자  2025년 1월 22일 19:22:13  문제 설명  성원이는 다이어트를 시도중이다. 성원이는 정말 정말 무겁기 때문에, 저울이 부셔졌다. 성원이의 힘겨운 다이어트 시도를 보고만 있던 엔토피아는 성원이에게 새로운 저울을 선물해 주었다. 성원이는 엔토피아가 선물해준 저울 위에 올라갔다. “안돼!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! G 킬로그램이나 더 쪘어ㅜㅠ”라고 성원이가 말했다. 여기서 말하는 G킬로그램은 성원이의 현재 몸무게의 제곱에서 성원이가 기억하고 있던 몸무게의 제곱을 뺀 것이다.  성원이의 현재 몸무게로 가능한 것을 모두 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 G가 주어진다. G는 100,000보다 작거나 같은 자연수이다.  출력  첫째 줄부터 한 줄에 하나씩 가능한 성원이의 현재 몸무게를 오름차순으로 출력한다. 가능한 몸무게가 없을 때는 -1을 출력한다. 현재 몸무게는 자연수로 떨어지지 않을 수도 있는데, 이런 경우는 제외해야 한다.     문제 풀이        코드    /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     int G, maxN;     int a, b, n, m;     static TreeSet&lt;Integer&gt; tset;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1484_다이어트/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          G = Integer.parseInt(br.readLine());         maxN = (G + 1) / 2;          tset = new TreeSet&lt;&gt;();          for (int i = 1; i &lt;= (int) Math.sqrt(G); i++) {             if (G % i == 0) {                 a = G / i;                 b = i;                  n = (a + b)/2;                 m = (a - b)/2;                  if((a + b) % 2 == 0 &amp;&amp; (a - b) % 2 == 0) {                     if(m &gt; 0)                         tset.add(n);                 }             }         }          sb.append(tset.isEmpty() ? -1 : print());          bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private String print(){         StringBuilder tmp = new StringBuilder();         for (int n : tset) {             tmp.append(n).append(\"\\n\");         }         return tmp.toString();     } }   "
  },
  
  {
    "title": "Record를 DTO로 사용하는 이유",
    "url": "/posts/Record%EB%A5%BC-DTO%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-22 00:50:04 +0900",
    "content": "Record는 Java 16에서 정식 출시된 특별한 유형의 클래스로 불변성(Immutable)을 기본으로 한다.  기존의 클래스와 달리 모든 필드가 final 키워드로 선언되며, 객체 생성 후 변경할 수 없다. 또한 필드 선언만으로 자동으로 생성자, getter , equals() , hashCode() , toString() 등 메서드를 자동으로 생성해주기 때문에 보일러 플레이트 코드를 줄일 수 있다. 이러한 특성으로 인해 멀티 쓰레드 환경에서 데이터가 의도치 않게 변경되지 않도록 하고 안전하게 전달할 수 있다.  기존 클래스 기반 DTO // 기존 클래스 기반 DTO public class MemberDTO { \t     private final String name;     private final String email;     private final int age;          public MemberDto(String name, String email, int age) { \t\tthis.name = name; \t\tthis.email = email; \t\tthis.age = age; \t}  \tpublic String getName() { \t\treturn name; \t} \t \tpublic String getEamil() { \t\treturn email; \t} \t \tpublic int getAge() { \t\treturn age; \t} }  Record // Record. 생성자, getter, hashCode(), equals(), toString() 자동 완성 public record MemberDto(String name, String email, int age) {}   Record로 생성한 모든 객체는 DTO일까? 모든 Record 객체가 DTO는 아니다. Record는 단순히 데이터를 캡슐화하는 역할을 하는데, DTO 외에도 값 객체 (Value Objects) 등의 다양한 용도로 사용될 수 있다.  // Value Objects 로 사용 public record Coordinates(double x, double y) {}   DTO는 계층 간 데이터 전송을 목적으로 하는 객체인 반면, VO는 도메인 모델 내에서 특정 값을 표현하는 객체로 사용된다. 따라서, Record는 이 두 가지 모두에 적합하게 사용할 수 있지만, 그 목적에 따라 사용 방법이 달라진다.  Record vs. VO Record와 VO는 모두 객체의 상태가 변경되지 않는 것을 보장한다. 또 데이터의 캡슐화를 표현하는데 초점을 맞춘다. 마지막으로 VO는 값 기반의 동등성을 가지며, Record도 동일한 필드 값을 가지면 동일한 객체로 간주된다는 점이 공통점이다.  VO는 도메인 모델 내에서 특정 개념을 표현하고, 도메인 로직과 밀접하게 관련이 있다. 즉, VO는 비즈니스 로직이나 규칙을 가질 수 있다. 하지만 Record는 단순히 데이터를 캡슐화하여 전달하는데 의미가 있다.  결론적으로 Record는 VO를 구현하는데 적합하지만, VO의 모든 특성을 완벽히 대체하지는 않는다. VO는 더 넓은 도메인 맥락에서 사용되며, 비즈니스 로직을 포함할 수 있다.  Record의 한계 Record는 extends를 사용하여 다른 클래스를 상속할 수 없고, 필드가 final로 선언되기 때문에 확장이 어렵다. 또 주로 데이터를 전달하려는 목적으로 설계되었기 때문에 비즈니스 로직을 포함하기에 적절하지 않다. 마지막으로 Java 14 or 16 이전 버전에서 호환이 불가능하다는 단점이 있다.  References    DTO vs Record in Java: Which Should You Use?   Records In Java - Full Tutorial - The Best New Java Feature You’re Not Using  "
  },
  
  {
    "title": "BOJ_18427_함께 블록 쌓기 (Java)",
    "url": "/posts/BOJ18427%ED%95%A8%EA%BB%98-%EB%B8%94%EB%A1%9D-%EC%8C%93%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-21 20:23:27 +0900",
    "content": "[Gold IV] 함께 블록 쌓기 - 18427  문제 링크  성능 요약  메모리: 17560 KB, 시간: 160 ms  분류  다이나믹 프로그래밍, 배낭 문제  제출 일자  2025년 1월 21일 20:14:25  문제 설명  1번부터 N번까지의 학생들은 각각 블록들을 가지고 있다. 학생마다 최대 M개의 블록을 가지고 있을 수 있으며, 한 명의 학생이 가지고 있는 모든 블록들의 높이는 서로 다르다. 이 때 1번부터 N번까지의 학생들이 가진 블록을 차례대로 사용하여 바닥에서부터 쌓아올려 하나의 탑을 만들고자 한다.  단, 어떤 학생의 블록은 사용하지 않아도 되며 한 학생당 최대 1개의 블록만을 사용할 수 있다.  1번부터 N번까지의 학생들이 가지고 있는 블록들에 대한 정보가 주어졌을 때, 높이가 정확히 H인 탑을 만들 수 있는 경우의 수를 계산하는 프로그램을 작성하시오.  예를 들어 N=3, M=3, H=5일 때, 각 학생마다 가지고 있는 블록들의 높이가 다음과 같다고 가정하자.   \t1번 학생: 2, 3, 5 \t2번 학생: 3, 5 \t3번 학생: 1, 2, 3   이 때, 탑의 높이가 정확히 5가 되도록 블록을 쌓는 경우로는 다음의 6가지가 존재한다. (블록을 사용하지 않는 경우는 X로 표시하였다.)    입력  첫째 줄에 자연수 N, M, H가 공백을 기준으로 구분되어 주어진다. (1 ≤ N ≤ 50, 1 ≤ M ≤ 10, 1 ≤ H ≤ 1,000) 둘째 줄부터 N개의 줄에 걸쳐서 각 학생이 가진 블록들의 높이가 공백을 기준으로 구분되어 주어진다.  단, 모든 블록의 높이는 1,000 이하의 자연수이며 한 명의 학생이 가지고 있는 모든 블록들의 높이는 서로 다르게 주어진다.  출력  첫째 줄에 높이가 H인 탑을 만드는 경우의 수를 10,007로 나눈 나머지를 출력한다.     문제 풀이     dp로 메모이제이션하며 모든 경우의수에 대한 개수를 세주었다.     코드   package BOJ_18427_함께블록쌓기;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static final int MOD = 10007;     static int N, M, H, dp[][];     static ArrayList&lt;Integer&gt;[] block;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_18427_함께블록쌓기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());         H = Integer.parseInt(st.nextToken());          block = new ArrayList[N + 1];         for (int i = 1; i &lt;= N; i++) {             block[i] = new ArrayList&lt;&gt;();         }         for(int i = 1; i &lt;= N; i++) {             st = new StringTokenizer(br.readLine());             while(st.hasMoreTokens()) {                 block[i].add(Integer.parseInt(st.nextToken()));             }         }          dp = new int[N + 1][H+1];         dp[1][0] = 1;         for(int b : block[1]){             if(b &lt;= H) dp[1][b] = 1;         }          for(int i=2; i&lt;=N; i++){             for(int j=0; j&lt;=H; j++){                 // i번째 안 쌓으면                 dp[i][j] = dp[i-1][j];                  // i번째에 쌓으면                 for(int b : block[i]){                      // 이번에 j높이까지 쌓기위해 height를 쌓는데 이 값이 쌓기전에 높이가 음수면 말이 안됨. 쌓기전 값 최소 0 (인덱스 문제도 해결)                     if(j-b&gt;=0) dp[i][j] = (dp[i][j] + dp[i-1][j-b]) % MOD; // 이전것도 고려해서 더해줌                 }             }         }          bw.write(String.valueOf(dp[N][H]));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_5557_1학년 (Java, C++)",
    "url": "/posts/BOJ55571%ED%95%99%EB%85%84-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-21 19:33:08 +0900",
    "content": "[Gold V] 1학년 - 5557  문제 링크  성능 요약  메모리: 2020 KB, 시간: 0 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 1월 21일 19:29:21  문제 설명  상근이가 1학년 때, 덧셈, 뺄셈을 매우 좋아했다. 상근이는 숫자가 줄 지어있는 것을 보기만 하면, 마지막 두 숫자 사이에 '='을 넣고, 나머지 숫자 사이에는 '+' 또는 '-'를 넣어 등식을 만들며 놀고 있다. 예를 들어, \"8 3 2 4 8 7 2 4 0 8 8\"에서 등식 \"8+3-2-4+8-7-2-4-0+8=8\"을 만들 수 있다.  상근이는 올바른 등식을 만들려고 한다. 상근이는 아직 학교에서 음수를 배우지 않았고, 20을 넘는 수는 모른다. 따라서, 왼쪽부터 계산할 때, 중간에 나오는 수가 모두 0 이상 20 이하이어야 한다. 예를 들어, \"8+3+2-4-8-7+2+4+0+8=8\"은 올바른 등식이지만, 8+3+2-4-8-7이 음수이기 때문에, 상근이가 만들 수 없는 등식이다.  숫자가 주어졌을 때, 상근이가 만들 수 있는 올바른 등식의 수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 숫자의 개수 N이 주어진다. (3 ≤ N ≤ 100) 둘째 줄에는 0 이상 9 이하의 정수 N개가 공백으로 구분해 주어진다.  출력  첫째 줄에 상근이가 만들 수 있는 올바른 등식의 개수를 출력한다. 이 값은 263-1 이하이다.     문제 풀이        코드   Java 코드 package BOJ_5557_1학년;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, end, arr[];     static long dp[][], res;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_5557_1학년/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         arr = new int[N];         dp = new long[N][21];          st = new StringTokenizer(br.readLine());         for(int i = 1; i &lt;= N-1; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }         end = Integer.parseInt(st.nextToken());          dp[1][arr[1]] = 1;         long up, down;          for(int i = 2; i &lt;= N-1; i++) {             for(int j=0; j&lt;=20; j++) {                 up = j - arr[i] &gt;= 0 ? dp[i-1][j - arr[i]] : 0;  // 이전에 j-arr[i]였다가 더해서 j가 됨                 down = j + arr[i] &lt;= 20 ? dp[i-1][j + arr[i]] : 0;  // 이전에 j+arr[i]였다가 빼서 j가 됨                  // dp[i][j]: i번째 까지의 숫자로 j를 만드는 경우의 수 (Bottom-Up)                 dp[i][j] = up + down;             }         }          res = dp[N-1][end];          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }     C++ 코드  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N, end_num;  void solve() {     cin &gt;&gt; N;     int arr[N];     for (int i = 1; i &lt; N; i++) {         cin &gt;&gt; arr[i];     }     cin &gt;&gt; end_num;      long long dp[N + 1][21];     memset(dp, 0, sizeof(dp));      dp[1][arr[1]] = 1;      long long up, down;     for (int i = 2; i &lt;= N - 1; i++) {         for (int j = 0; j &lt;= 20; j++) {             up = (j - arr[i] &gt;= 0) ? dp[i - 1][j - arr[i]] : 0;             down = (j + arr[i] &lt;= 20) ? dp[i - 1][j + arr[i]] : 0;             dp[i][j] = up + down;         }     }      cout &lt;&lt; dp[N - 1][end_num]; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (4)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-4/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-21 16:11:58 +0900",
    "content": "   Transport Layer - (1)     1. Multiplexing and Demultiplexing          Multiplexing : 보내는 측의 Application Layer으로부터 여러 소켓에서 오는 메시지들이 아래로 Transport Layer으로 내려올 것이다. 이 메시지들이 어디서 오든지 간에 Transport Layer은 메시지들을 segment(Header + Data) 로 처리해주고 아래(Network Layer)로 내려줘야한다.           Demultiplexing : 받는곳에서 segment를 받고, 특정 프로세스에 특정 메시지를 올려줘야한다. 프로세스들이 많을거고 소켓을 각각 열고 기다릴텐데 알맞은 메시지를 줘야한다. 들어오는 Segment는 하난데 실제로 output은 여러개로 demultiplexing되어 여러개다.            알맞은 프로세스에 알맞은 메시지를 전달하는 방법은 세그먼트에 있는 Header 를 사용한다. Header에 적힌 정보를 가지고 어떤 소켓에 올려줘야 할지 찾을 수 있다.               How demultiplexing works    헤더에 여러 필드들이 있다.            Source Port 필드, Destination Port 필드 등등..             Connectionless Demux : UDP 사용시 Demultiplexing     UDP소켓을 연다   Source Port는 자기자신, Dest Port는 도착지 포트를 작성한다.   컴퓨터에대한 정보는 Network Layer의 저장단위인 Packet에 Header 부분에 IP주소 형태로 작성된다.   UDP를 사용할 경우 Demultiplexing이 이루어지는 방식    Dest IP와 Dest Port 2개를 사용해서 어떤 소켓으로 올릴지 Demultiplexing이 이루어진다.     Connection - Oriented Demux : TCP 사용시 Demultiplexing   UDP를 사용할 경우 Demultiplexing이 이루어지는 방식    Dest IP와 Dest Port# 뿐만 아니라 Source IP, Source Port# 4개를 사용해서 어떤 소켓으로 올릴지 Demultiplexing이 이루어진다.   4개의 정보 중 1개라도 다르면 다른 소켓 Demultiplexing된다.   실제 구현은 웹 서버 프로세스가 하나 있고 각 사용자별로 쓰레드가 있을 것이다.        TCP는 각 사용자별로 공간이 필요하기 때문에 자원이 많이 소모되는 것.            Connectionless Transport : UDP           UDP   UDP : Segment Header     4개의 헤더 필드 ( 각 16 bit ) -&gt; 포트넘버 최대 개수 2^16개            Source Port #       Destination Port #       Length       Checksum : 에러체킹. 데이터가 전송 도중 에러가 있었는지 없었는지 확인하는 필드                    Checksum 필드로 체크시 에러가 있었다면 올리지 않고 바로 Drop시킨다.                           즉 UDP는 Multiplexing, Demultiplexing, Error Checking을 할 수 있다.   헤더의 중요성!    각 프로토콜이 중요하고 특정 프로토콜의 동작을 이해하기 위해서는 Header가 중요하고 각 Header에 어떤 필드들이 있는지 봐야하며 그 정보가 무엇을 의미하는지 이해해야 프로토콜이 어떻게 동작하는지 이해할 수 있다.  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (3)",
    "url": "/posts/Chapter-1/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-21 03:46:04 +0900",
    "content": "   Application Layer   ## Socket Programming     어플리케이션과 네트워크 사이의 통신을 위한 인터페이스   2가지 타입의 소켓 : 소켓 타입이 소통 방식을 결정 (TCP 소켓 / UDP 소켓)        생성후 소켓을 통해 데이터를 전달하고 전달받을 수 있음     Two Essential Types of Sockets          Socket API      1. socket() : 웹서버가 소켓을 생성한다.  2. bind() : 생성한 소켓을 특정 포트에 연결하겠다.  3. listen() : 이 소켓으로 listen 하겠다. non-blocking(함수 호출 시 조건이 만족되지 않더라도 함수가 리턴하므로 해당 스레드는 계속 진행)  4. accept() : 클라이언트로부터 받을 준비가 되었다. blocking(함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)  5. block until connection from client : 서버는 클라이언트로부터 연결이 들어올 때까지 block된다  6. socket() and connect() : 클라이언트가 소켓을 열고 원하는 서버의 프로세스에 connect한다. connect는 blocking  7. read() and write() : 연결이 되었으므로 읽기, 쓰기 등여러 작업 가능. 통신이 된다는 의미  $…$    8. close() : 필요한 통신이 충분히 완료되면 소켓을 닫아 연결을 끊는다.    Sockets API         1. Creation and Setup           2. Establishing a Connection (TCP)           3. Sending and Receiving Data           4. Tearing Down a Connection (TCP)           1. Socket Creation and Setup       create 함수와 bind 함수 있다.   3개의 파라미터            소켓 특정하는 인덱스가 있음           socket() function         type 파라미터 : TCP/UDP를 결정, 중요함!! - TCP : SOCK_STREAM - UDP : SOCK_DGRAM           리턴값으로 소켓의 ID값을 반환 - 이 소켓의 주소라고 보면 됨        Bind() function    방금 생성한 소켓 아이디를 통해서 이 소켓을 특정 address(포트)에 바인드 하겠다.     accept() function    non-blocking (함수 호출 시 조건이 만족되지 않더라도 함수가 리턴하므로 해당 스레드는 계속 진행)    클라이언트로부터 연결을 기다리겠다.   Listen() function    non-blocking (함수 호출 시 조건이 만족되지 않더라도 함수가 리턴하므로 해당 스레드는 계속 진행)    소켓을 listen용도로 사용할것이고, 동시에 여러 요청이 들어오면 최대 backlog 개만큼 queue에 담아서 처리하겠다.        2. Establishing a Connection (TCP)   Connect() function    bloking (함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)    bind쓰는게 아닌 이유는 클라이언트는 아무 포트나 쓰면 되기 때문. 서버처럼 특정 포트일 필요가 없다. 서버는 특정(ex. 80번 포트) 를 써야할 이유가 있지만 클라이언트는 필요없다.     TCP Socket Connection Setup    Code : Server  Code : Client       3. Sending and Receiving Data   Write() function    bloking (함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)    Read() function    bloking (함수 호출 시 조건이 만족되지 않으면 함수는 리턴하지 않고 해당 스레드는 대기 상태가 되는 것)      UDP Socket Functions         UDP는 훨씬 단순하다. 소켓 생성하고 바로 보낸다.         4. Tearing Down a Connection (TCP)   close() function     데이터 교환후에 마지막으로 사용했던 소켓을 release해준다. 그래야 다른 프로세스가 사용할 수 있다.     Release of Ports     실제로 프로세스를 죽여도, 바인딩된 포트는 죽지 않고 남아 있는 경우가 있다.   코드에 프로세스를 실행을 멈출때 포트 바인딩을 풀어주자.     "
  },
  
  {
    "title": "PGMS_2022 KAKAO_주차 요금 계산 (Java)",
    "url": "/posts/PGMS2022-KAKAO%EC%A3%BC%EC%B0%A8-%EC%9A%94%EA%B8%88-%EA%B3%84%EC%82%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-21 00:07:09 +0900",
    "content": "[level 2] 주차 요금 계산 - 92341  문제 링크  성능 요약  메모리: 76.7 MB, 시간: 8.39 ms  구분  코딩테스트 연습 &gt; 2022 KAKAO BLIND RECRUITMENT  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2025년 01월 21일 00:05:21  문제 설명  문제 설명  주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.   요금표            기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원)            180 5000 10 600          &nbsp;   입/출차 기록            시각(시:분) 차량 번호 내역            05:34 5961 입차   06:00 0000 입차   06:34 0000 출차   07:59 5961 출차   07:59 0148 입차   18:59 0000 입차   19:09 0148 출차   22:59 5961 입차   23:00 5961 출차          &nbsp;   자동차별 주차 요금            차량 번호 누적 주차 시간(분) 주차 요금(원)            0000 34 + 300 = 334 5000 + ⌈(334 - 180) / 10⌉ x 600 = 14600   0148 670 5000 +⌈(670 - 180) / 10⌉x 600 = 34400   5961 145 + 1 = 146 5000           어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.   0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.  00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.  누적 주차 시간이 기본 시간이하라면, 기본 요금을 청구합니다. 누적 주차 시간이 기본 시간을 초과하면, 기본 요금에 더해서, 초과한 시간에 대해서 단위 시간 마다 단위 요금을 청구합니다.   초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다. ⌈a⌉ : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다.    주차 요금을 나타내는 정수 배열 fees, 자동차의 입/출차 내역을 나타내는 문자열 배열 records가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.  제한사항   fees의 길이 = 4   fees[0] = 기본 시간(분) 1 ≤ fees[0] ≤ 1,439  fees[1] = 기본 요금(원) 0 ≤ fees[1] ≤ 100,000 fees[2] = 단위 시간(분) 1 ≤ fees[2] ≤ 1,439 fees[3] = 단위 요금(원)  1 ≤ fees[3] ≤ 10,000  1 ≤ records의 길이 ≤ 1,000   records의 각 원소는 \"시각 차량번호 내역\" 형식의 문자열입니다. 시각, 차량번호, 내역은 하나의 공백으로 구분되어 있습니다. 시각은 차량이 입차되거나 출차된 시각을 나타내며, HH:MM 형식의 길이 5인 문자열입니다.   HH:MM은 00:00부터 23:59까지 주어집니다. 잘못된 시각(\"25:22\", \"09:65\" 등)은 입력으로 주어지지 않습니다.  차량번호는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다. 내역은 길이 2 또는 3인 문자열로, IN 또는 OUT입니다. IN은 입차를, OUT은 출차를 의미합니다.  records의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다. records는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다. 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다. 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다. 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.   주차장에 없는 차량이 출차되는 경우 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우       입출력 예           fees records result            [180, 5000, 10, 600] [\"05:34 5961 IN\", \"06:00 0000 IN\", \"06:34 0000 OUT\", \"07:59 5961 OUT\", \"07:59 0148 IN\", \"18:59 0000 IN\", \"19:09 0148 OUT\", \"22:59 5961 IN\", \"23:00 5961 OUT\"] [14600, 34400, 5000]   [120, 0, 60, 591] [\"16:00 3961 IN\",\"16:00 0202 IN\",\"18:00 3961 OUT\",\"18:00 0202 OUT\",\"23:58 3961 IN\"] [0, 591]   [1, 461, 1, 10] [\"00:00 1234 IN\"] [14841]            입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.  입출력 예 #2   요금표            기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원)            120 0 60 591          &nbsp;   입/출차 기록            시각(시:분) 차량 번호 내역            16:00 3961 입차   16:00 0202 입차   18:00 3961 출차   18:00 0202 출차   23:58 3961 입차          &nbsp;   자동차별 주차 요금            차량 번호 누적 주차 시간(분) 주차 요금(원)            0202 120 0   3961 120 + 1 = 121 0 +⌈(121 - 120) / 60⌉x 591 = 591           3961번 차량은 2번째 입차된 후에는 출차된 내역이 없으므로, 23:59에 출차되었다고 간주합니다.    &nbsp;  입출력 예 #3   요금표            기본 시간(분) 기본 요금(원) 단위 시간(분) 단위 요금(원)            1 461 1 10          &nbsp;   입/출차 기록            시각(시:분) 차량 번호 내역            00:00 1234 입차          &nbsp;   자동차별 주차 요금            차량 번호 누적 주차 시간(분) 주차 요금(원)            1234 1439 461 +⌈(1439 - 1) / 1⌉x 10 = 14841           1234번 차량은 출차 내역이 없으므로, 23:59에 출차되었다고 간주합니다.     ​  제한시간 안내   정확성 테스트 : 10초      출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제풀이   Map만 쓸 줄 알면 쉽게 풀 수 있는 문제라고 생각한다. 그래도 문제가 더럽고 세세한 조건이 많기 때문에 시간이 짧게 걸리진 않았다. 그래도 어려운 거 없이 구현문제라 바로 맞출 수 있었다.      코드   import java.util.*; /*   map으로 관리    Integer, ArrayList&lt;Integer&gt; 로 입출차관리 -&gt; 길이 홀수면 23:59로채움   Integer, Integer로 합 관리 */ class Solution {     static int cTime, cNumber;     static String cActivity;     static Map&lt;Integer, Integer&gt; timeSumMap = new TreeMap&lt;&gt;();     static Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; timeTableMap = new HashMap&lt;&gt;();     static List&lt;Integer&gt; carNums;     static int[] res;     public int[] solution(int[] fees, String[] records) {         for(String s : records){             // s = s.subString(1, s.length()-1);             String[] split = s.split(\" \");                          String[] cTimeSplit = split[0].split(\":\");             cTime = Integer.parseInt(cTimeSplit[0]) * 60 + Integer.parseInt(cTimeSplit[1]);             cNumber = Integer.parseInt(split[1]);             cActivity = split[2];                          if(cActivity.equals(\"IN\")){                 timeTableMap.putIfAbsent(cNumber, new ArrayList&lt;Integer&gt;());                 timeTableMap.get(cNumber).add(cTime); //입차시간             }             else{                 ArrayList&lt;Integer&gt; timeList = timeTableMap.get(cNumber);                                  int timeGap = cTime - timeList.get(timeList.size()-1); // 출차 - 마지막입차                 int sum = timeSumMap.getOrDefault(cNumber, 0) + timeGap;                 timeSumMap.put(cNumber, sum);                 timeList.add(cTime); // 출차시             }         }                  for(int num : timeTableMap.keySet()){             ArrayList&lt;Integer&gt; timeList = timeTableMap.get(num);             if(timeList.size() % 2 == 1){                 int timeGap = 23 * 60 + 59 - timeList.get(timeList.size()-1);                 int sum = timeSumMap.getOrDefault(num, 0) + timeGap;                 timeSumMap.put(num, sum);             }         }                  res = new int[timeSumMap.size()];         int idx = 0;         for(int num : timeSumMap.keySet()){             int money = fees[1];             if(timeSumMap.get(num) &gt; fees[0]){                 money += (int) Math.ceil((double) (timeSumMap.get(num)-fees[0]) / fees[2]) * fees[3];             }             res[idx++] = money;         }         return res;     } }  "
  },
  
  {
    "title": "BOJ_1781_컵라면 (Java)",
    "url": "/posts/BOJ1781%EC%BB%B5%EB%9D%BC%EB%A9%B4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-20 21:40:31 +0900",
    "content": "[Gold II] 컵라면 - 1781  문제 링크  성능 요약  메모리: 71064 KB, 시간: 708 ms  분류  자료 구조, 그리디 알고리즘, 우선순위 큐, 정렬  제출 일자  2025년 1월 20일 21:09:35  문제 설명  상욱 조교는 동호에게 N개의 문제를 주고서, 각각의 문제를 풀었을 때 컵라면을 몇 개 줄 것인지 제시 하였다. 하지만 동호의 찌를듯한 자신감에 소심한 상욱 조교는 각각의 문제에 대해 데드라인을 정하였다.                 문제 번호       1       2       3       4       5       6       7                       데드라인       1       1       3       3       2       2       6                 컵라면 수       6       7       2       1       4       5       1           위와 같은 상황에서 동호가 2, 6, 3, 1, 7, 5, 4 순으로 숙제를 한다면 2, 6, 3, 7번 문제를 시간 내에 풀어 총 15개의 컵라면을 받을 수 있다.  문제는 동호가 받을 수 있는 최대 컵라면 수를 구하는 것이다. 위의 예에서는 15가 최대이다.  문제를 푸는데는 단위 시간 1이 걸리며, 각 문제의 데드라인은 N이하의 자연수이다. 또, 각 문제를 풀 때 받을 수 있는 컵라면 수와 최대로 받을 수 있는 컵라면 수는 모두 231보다 작은 자연수이다.  입력  첫 줄에 숙제의 개수 N (1 ≤ N ≤ 200,000)이 들어온다. 다음 줄부터 N+1번째 줄까지 i+1번째 줄에 i번째 문제에 대한 데드라인과 풀면 받을 수 있는 컵라면 수가 공백으로 구분되어 입력된다.  출력  첫 줄에 동호가 받을 수 있는 최대 컵라면 수를 출력한다.     문제 풀이        코드   package BOJ_1781_컵라면;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     class Work implements Comparable&lt;Work&gt; {         int deadline, ramen;         public Work(int deadline, int ramen) {             this.deadline = deadline;             this.ramen = ramen;         }          @Override         public int compareTo(Work o) {             if(this.deadline == o.deadline){                 return o.ramen - this.ramen;             }             return this.deadline - o.deadline;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, d, r, beforeTime=0, currTime=0;     static long maxRamen;     static PriorityQueue&lt;Work&gt; pq = new PriorityQueue&lt;Work&gt;();     static PriorityQueue&lt;Integer&gt; ramens = new PriorityQueue&lt;Integer&gt;();     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1781_컵라면/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         for(int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             d = Integer.parseInt(st.nextToken());             r = Integer.parseInt(st.nextToken());             beforeTime = Math.max(beforeTime, d);             pq.add(new Work(d, r));         }          while(!pq.isEmpty()) {             Work currW = pq.poll();             /*             데드라인까지 개수 부족하게는 넣을 수 있음 (데드라인 1 3 5 세개면 다 가능)             근데 데드라인 오버되도록 진행하면 문제가 발생             예를들어             1 4             2 5             3 6             3 7                                          1일차 4             2일차 4 5             3일차 4 5 7 (x)                  5 6 7 (o)                          이런경우에는 최적해가 5 6 7 로 진행해야함../ 데드라인이 최대 그날까진 해야한다이므로 그 전에 더 높은거 해도됨             그러므로 이런 경우에는 고른 라면중에 제일 적게 받은과제를 빼고 이번에 고른걸 선택              */             if(ramens.size() &lt; currW.deadline) {                 ramens.add(currW.ramen);                 maxRamen += currW.ramen;             }             else if(!ramens.isEmpty() &amp;&amp; ramens.peek() &lt; currW.ramen) { // 최저 컵라면 교체                 maxRamen -= ramens.poll();                 ramens.add(currW.ramen);                 maxRamen += currW.ramen;             }         }          bw.write(String.valueOf(maxRamen));         bw.flush();         bw.close();         br.close();     } }   "
  },
  
  {
    "title": "BOJ_1939_중량 제한 (Java)",
    "url": "/posts/BOJ1939%EC%A4%91%EB%9F%89-%EC%A0%9C%ED%95%9C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-19 20:35:18 +0900",
    "content": "[Gold III] 중량제한 - 1939  문제 링크  성능 요약  메모리: 50688 KB, 시간: 516 ms  분류  너비 우선 탐색, 이분 탐색, 자료 구조, 분리 집합, 그래프 이론, 그래프 탐색, 최단 경로  제출 일자  2025년 1월 19일 20:27:43  문제 설명  N(2 ≤ N ≤ 10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.  영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.  한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 N, M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1 ≤ A, B ≤ N), C(1 ≤ C ≤ 1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 섬 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.  출력  첫째 줄에 답을 출력한다.     문제 풀이    전에 풀어본 분리집합문제와 비슷했다. 같은 집합으로 형성되는지를 체크했고 이때 조건만족하면 끝내기 위해 정렬했다. 가장 튼튼한 다리를 고르기때문에 내림차순으로 찾은 다리가 최선이기 때문이다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main  {     class Node implements Comparable&lt;Node&gt;{         int from, to, weight;         public Node(int from, int to, int weight){             this.from = from;             this.to = to;             this.weight = weight;         }          @Override         public int compareTo(Node o){             return o.weight - weight;         }     }     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, p[];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1939_중량제한/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          p = new int[N + 1];         for (int i=1; i&lt;=N; i++) {             p[i] = i;         }          ArrayList&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();         for(int i=0; i&lt;M; i++){             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             int w = Integer.parseInt(st.nextToken());             nodes.add(new Node(a, b, w));         }         Collections.sort(nodes);          st = new StringTokenizer(br.readLine());         int start = Integer.parseInt(st.nextToken());         int end = Integer.parseInt(st.nextToken());          int res = 0;         for(Node n : nodes){             union(n.from, n.to);             if(find(start) == find(end)){                 res = n.weight;                 break;             }         }                  bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      static int find(int x){         if(x != p[x]) return p[x] = find(p[x]);         return p[x];     }      static void union(int x, int y){         int px = find(x);         int py = find(y);         if(px != py) {             if(px &gt; py) p[py] = p[px];             else p[px] = py;         }     } }  "
  },
  
  {
    "title": "PGMS_부서별 평균 연봉 조회하기 (SQL)",
    "url": "/posts/PGMS%EB%B6%80%EC%84%9C%EB%B3%84-%ED%8F%89%EA%B7%A0-%EC%97%B0%EB%B4%89-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-01-19 03:48:10 +0900",
    "content": "[level 3] 부서별 평균 연봉 조회하기 - 284529   문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  합계: 100.0 / 100.0  제출 일자  2025년 01월 19일 03:45:05  문제 설명  HR_DEPARTMENT 테이블은 회사의 부서 정보를 담은 테이블입니다. HR_DEPARTMENT 테이블의 구조는 다음과 같으며 DEPT_ID, DEPT_NAME_KR, DEPT_NAME_EN, LOCATION은 각각 부서 ID, 국문 부서명, 영문 부서명, 부서 위치를 의미합니다.           Column name Type Nullable            DEPT_ID VARCHAR FALSE   DEPT_NAME_KR VARCHAR FALSE   DEPT_NAME_EN VARCHAR FALSE   LOCATION VARCHAR FLASE          HR_EMPLOYEES 테이블은 회사의 사원 정보를 담은 테이블입니다. HR_EMPLOYEES 테이블의 구조는 다음과 같으며 EMP_NO, EMP_NAME, DEPT_ID, POSITION, EMAIL, COMP_TEL, HIRE_DATE, SAL은 각각 사번, 성명, 부서 ID, 직책, 이메일, 전화번호, 입사일, 연봉을 의미합니다.           Column name Type Nullable            EMP_NO VARCHAR FALSE   EMP_NAME VARCHAR FALSE   DEPT_ID VARCHAR FALSE   POSITION VARCHAR FALSE   EMAIL VARCHAR FALSE   COMP_TEL VARCHAR FALSE   HIRE_DATE DATE FALSE   SAL NUMBER FALSE            문제  HR_DEPARTMENT와 HR_EMPLOYEES 테이블을 이용해 부서별 평균 연봉을 조회하려 합니다. 부서별로 부서 ID, 영문 부서명, 평균 연봉을 조회하는 SQL문을 작성해주세요.  평균연봉은 소수점 첫째 자리에서 반올림하고 컬럼명은 AVG_SAL로 해주세요. 결과는 부서별 평균 연봉을 기준으로 내림차순 정렬해주세요.    예시  HR_DEPARTMENT 테이블이 다음과 같고           DEPT_ID DEPT_NAME_KR DEPT_NAME_EN LOCATION            D0005 재무팀 Finance 그렙타워 5층   D0006 구매팀 Purchasing 그렙타워 5층   D0007 마케팅팀 Marketing 그렙타워 6층          HR_EMPLOYEES 테이블이 다음과 같을 때           EMP_NO EMP_NAME DEPT_ID POSITION EMAIL COMP_TEL HIRE_DATE SAL            2019003 한동희 D0005 팀장 donghee_han@grep.com 031-8000-1122 2019-03-01 57000000   2020032 한명지 D0005 팀원 mungji_han@grep.com 031-8000-1123 2020-03-01 52000000   2022003 김보라 D0005 팀원 bora_kim@grep.com 031-8000-1126 2022-03-01 47000000   2018005 이재정 D0006 팀장 jaejung_lee@grep.com 031-8000-1127 2018-03-01 60000000   2019032 윤성희 D0006 팀원 sunghee_yoon@grep.com 031-8000-1128 2019-03-01 57000000   2020009 송영섭 D0006 팀원 yungseop_song@grep.com 031-8000-1130 2020-03-01 51000000   2021006 이성주 D0006 팀원 sungju_lee@grep.com 031-8000-1131 2021-03-01 49000000   2018004 이주리 D0007 팀장 joori_lee@grep.com 031-8000-1132 2018-03-01 61000000   2020012 김사랑 D0007 팀원 sarang_kim@grep.com 031-8000-1133 2020-03-01 54000000   2021018 김히라 D0007 팀원 heera_kim@grep.com 031-8000-1136 2021-03-01 49000000          SQL을 실행하면 다음과 같이 출력되어야 합니다.                            DEPT_ID             DEPT_NAME_EN             AVG_SAL                                         D0007             Marketing             54666667                               D0006             Purchasing             54250000                               D0005             Finance             52000000                    출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제풀이           테이블 연결 방식 결정             두 테이블의 공통 컬럼인 DEPT_ID를 기준으로 JOIN       HR_DEPARTMENT와 HR_EMPLOYEES 테이블을 INNER JOIN                데이터 그룹화             GROUP BY 절에는 집계함수를 제외한 SELECT 절의 모든 컬럼이 포함되어야 함       부서별로 그룹화하므로 DEPT_ID와 DEPT_NAME_EN을 GROUP BY에 포함                연봉 계산 및 정렬             AVG(SAL)로 평균 연봉 계산       ROUND 함수로 소수점 첫째 자리에서 반올림 (뒤에 적는 숫자는 나타내는 자릿수 숫자이므로 0으로)       ORDER BY로 평균 연봉 기준 내림차순 정렬              코드   SELECT hd.DEPT_ID, hd.DEPT_NAME_EN, ROUND(AVG(SAL), 0) AS AVG_SAL     FROM HR_DEPARTMENT AS hd         JOIN HR_EMPLOYEES AS he             ON hd.DEPT_ID = he.DEPT_ID                 GROUP BY hd.DEPT_ID, hd.DEPT_NAME_EN                     ORDER BY AVG_SAL DESC;  "
  },
  
  {
    "title": "HTTPS 란?",
    "url": "/posts/HTTPS-%EB%9E%80/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-19 03:33:08 +0900",
    "content": "HTTP HTTP는 Hypertext Transfer Protocol의 약자로 서버와 클라이언트간 통신을 위한 통신 규약이다. 하지만, HTTP는 암호화되지 않는 평문 데이터를 전송하기 때문에 제 3자가 정보를 조회할 수 있다는 위험이 있다. 이를 해결하기 위해 HTTPS가 등장했다.  HTTPS는 Hypertext Transfer Protocol Secure의 약자로 HTTP에 데이터 암호화가 추가된 것이다. 암호화된 데이터를 전송하기 때문에 제 3자가 볼 수 없도록 할 수 있다.  HTTPS는 어떻게 적용할 수 있을까? HTTPS를 적용하기 위해서는 인증된 기관(Certificate Authority, CA)에게 인증서를 발급받아야한다. CA에 인증서를 요청하면 CA 이름, 서버의 공개키, 서버의 정보를 활용해서 인증서를 만들고, 이를 CA 개인키로 암호화해서 서버로 전송한다. 이때 인증서는 CA 개인키로 암호화하기 때문에 신뢰성을 확보할 수 있다. 이러한 인증서를 서버측에서 발급받으면 HTTPS를 적용할 수 있다.  HTTPS 동작 원리 클라이언트가 서버로 최초 요청할 때 암호화 알고리즘, 프로토콜 버전, 무작위 값을 전달한다. 이를 받은 서버는 클라이언트에게 암호화 알고리즘, 인증서, 무작위 값을 전달하고, 클라이언트는 서버의 인증서를 CA의 공개로 복화하하여 검증한다. 검증이 끝난 후 클라이언트와 서버에서 생성된 무작위 값을 조합해 Pre Master Secret 값을 생성하여 서버 공개키로 암호화하여 전달한다.  서버는 전달받은 암호화된 데이터를 개인키로 복호화하여 Pre Master Secret를 얻는다. 서버와 클라이언트는 일련의 과정을 통해서 Pre Master Secret을 Master Secret으로 변경하고, 해당 정보를 이용해 세션키를 생성한다. 이러한 과정을 TLS 핸드쉐이크라고 하며, 이후부터 클라이언트와 서버는 세션키를 활용한 대칭키 암호화 방식으로 데이터를 송수신한다.  References    HTTPS란 무엇입니까?  "
  },
  
  {
    "title": "PGMS_선입 선출 스케줄링 (Java)",
    "url": "/posts/PGMS%EC%84%A0%EC%9E%85-%EC%84%A0%EC%B6%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-18 20:39:46 +0900",
    "content": "[level 3] 선입 선출 스케줄링 - 12920  문제 링크  성능 요약  메모리: 54.3 MB, 시간: 8.18 ms  구분  코딩테스트 연습 &gt; 연습문제  채점결과  정확성: 70.0효율성: 30.0합계: 100.0 / 100.0  제출 일자  2025년 01월 18일 20:36:40  문제 설명  처리해야 할 동일한 작업이 n 개가 있고, 이를 처리하기 위한 CPU가 있습니다.  이 CPU는 다음과 같은 특징이 있습니다.   CPU에는 여러 개의 코어가 있고, 코어별로 한 작업을 처리하는 시간이 다릅니다. 한 코어에서 작업이 끝나면 작업이 없는 코어가 바로 다음 작업을 수행합니다. 2개 이상의 코어가 남을 경우 앞의 코어부터 작업을 처리 합니다.   처리해야 될 작업의 개수 n과, 각 코어의 처리시간이 담긴 배열 cores 가 매개변수로 주어질 때, 마지막 작업을 처리하는 코어의 번호를  return 하는 solution 함수를 완성해주세요.  제한 사항   코어의 수는 10,000 이하 2이상 입니다. 코어당 작업을 처리하는 시간은 10,000이하 입니다. 처리해야 하는 일의 개수는 50,000개를 넘기지 않습니다.     입출력 예           n cores result            6 [1,2,3] 2          입출력 예 설명  입출력 예 #1 처음 3개의 작업은 각각 1,2,3번에 들어가고, 1시간 뒤 1번 코어에 4번째 작업,다시 1시간 뒤 1,2번 코어에 5,6번째 작업이 들어가므로 2를 반환해주면 됩니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     10000 x 10000이라 생각했지만 아니었다. 시간복잡도 계산을 먼저 깊게 해보고 구현해야겠다.     코드   1. 시간초과 코드 (최대 10000x10000이라 바로 써본 코드) -&gt; 정확도는 다 맞았지만 효율성 (시간복잡도) 가 틀림. class Solution {     static boolean[][] work;     static int r, c;     public int solution(int n, int[] cores) {                  if (n &lt;= cores.length) return n;                  int res=0;         work = new boolean[cores.length + 1][10001];                  r = 1;         c = 1;                  while(n&gt;0 &amp;&amp; isValid(r, c)){                          if(!work[r][c] &amp;&amp; c + cores[r-1] - 1 &lt;= 10000) {                 checkWork(cores);                 n--;                              if(n==0){                     res = r;                     break;                 }             }             convertCoord();         }                  return res;     }          private void checkWork(int[] cores){         for(int j=c; j&lt;c+cores[r-1]; j++){             work[r][j] = true;         }     }          private boolean isValid(int r, int c){         return r &gt;= 1 &amp;&amp; r &lt;= work.length-1 &amp;&amp; c &gt;= 1 &amp;&amp; c &lt;= 10000;     }          private void convertCoord(){         if(r == work.length-1) {             if(isValid(1, c+1)){                 r=1;                 c++;             }         }         else {             if(isValid(r+1, c)) r++;         }     } }   2. 시간초과코드 : 메모리때문일까싶어 다르게 나머지로 구현해본 코드 class Solution {     public int solution(int n, int[] cores) {         int res = 0;         int time = 0;         while(n&gt;0){             for(int i=0; i&lt;cores.length; i++){                 if(time%cores[i] == 0){                     n--;                      if(n==0) {                         res = i+1;                         break;                     }                 }             }             time++;         }         return res;     } }   정답 코드 O(NlogN으로 시간복잡도 줄였음) class Solution {     public int solution(int n, int[] cores) {         if(n &lt;= cores.length) return n;                  n -= cores.length;                  int left = 1, right =  250000000;                  int res = 0;         while(left &lt;= right){             int mid = left + (right - left)/2;                          long cnt = 0;             for(int i=0; i&lt;cores.length; i++){                 cnt += (long) mid / cores[i];             }                          if(cnt &gt;= n){                 res = mid;                 right = mid-1;             }             else{                 left = mid + 1;             }         }                  // 일단 res시간까진 작업이 완료된다는걸 찾음                  long work = 0;         for(int i=0; i&lt;cores.length; i++){             work += (long) (res-1) / cores[i];         }                  int ans = cores.length;                  for(int i=0; i&lt;cores.length; i++){             if(res % cores[i] == 0) {                 work++;                 if(work == n) {                     ans = i+1;                     break;                 }             }         }         return ans;     } }  "
  },
  
  {
    "title": "BOJ_20955_민서의 응급 수술 (Java)",
    "url": "/posts/BOJ20955%EB%AF%BC%EC%84%9C%EC%9D%98-%EC%9D%91%EA%B8%89-%EC%88%98%EC%88%A0/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-18 19:02:38 +0900",
    "content": "[Gold IV] 민서의 응급 수술 - 20955  문제 링크  성능 요약  메모리: 42356 KB, 시간: 336 ms  분류  자료 구조, 분리 집합, 그래프 이론, 트리  제출 일자  2025년 1월 18일 18:42:20  문제 설명  민서는 강원대학교 컴퓨터공학과의 신임 교수이다. 그녀가 저술한 효율적인 택배 배달을 위한 최적 경로 설계에 관한 연구 논문은 아직도 널리 인용되고 있다. 오늘도 열심히 강의를 하던 민서는 놀라 자빠질 수밖에 없었다. 한 학생이 꾸벅꾸벅 졸다가 책상에 머리를 아주 세게 박았기 때문이다. 한시라도 수술이 시급한 상황, 민서는 의사가 되어 수술을 집도하기로 결심하였다.  사람의 뇌는 수백억 개의 뉴런으로 구성되며, 각 뉴런은 시냅스를 통하여 연결된다. 민서의 진찰 결과, 학생은 뇌 속의 일부 뉴런의 연결이 끊어져 잠이 든 것으로 확인되었다. 끊어진 시냅스만 복구된다면 학생은 잠에서 깨어나겠지만, 알다시피 민서는 컴퓨터공학과 교수이다.  민서는 끊어진 시냅스를 복구하는 대신 뇌 속의 모든 뉴런을 하나의 트리 형태로 연결해보고자 한다. 여기서 트리란 사이클이 존재하지 않는 연결 그래프를 의미한다.  민서는 손기술이 뛰어나기 때문에 다음과 같은 연산을 무한히 수행할 수 있다. 연결되지 않은 두 뉴런을 연결하거나 이미 연결된 두 뉴런의 연결을 끊는다.  뉴런의 연결 정보가 주어졌을 때, 모든 뉴런을 하나의 트리 형태로 연결하기 위하여 필요한 최소 연산 횟수를 구하는 프로그램을 작성하시오.  입력  첫 번째 줄에 뉴런의 개수 N과 시냅스의 개수 M이 주어진다.  이후 M개의 줄에 걸쳐 시냅스로 연결된 두 뉴런의 번호 u, v가 주어진다.  모든 입력은 공백으로 구분되어 주어진다.  출력  첫 번째 줄에 모든 뉴런을 트리 형태로 연결하기 위하여 필요한 최소 연산 횟수를 출력한다.     문제 풀이    그림처럼 사이클은 끊고, 연결되지 않은 그룹은 이어주는 연산을 세면 되는데 딱 필요한 알고리즘이 union-find라고 생각했고, 사이클을 어떻게 셀까 고민하던 찰나 find함수로 두 함수의 부모노드가 일치하는지만 비교하면 된다고 생각했다. 이걸 몰랐다면 dfs든 뭐든 연결리스트를 다 저장해놓고 돌면서 탐색을 해야할것이다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, u, v;     static int[] parent;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_20955_민서의응급수술/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          parent = new int[N+1];         for (int i = 0; i &lt; N+1; i++) {             parent[i] = i;         }          int res = 0; // 연산횟수          for (int i = 0; i &lt; M; i++) {             st = new StringTokenizer(br.readLine());             int u = Integer.parseInt(st.nextToken());             int v = Integer.parseInt(st.nextToken());              if(find(u) == find(v)) res++;             else union(u, v);         }          Set&lt;Integer&gt; set = new HashSet&lt;&gt;();         for(int i=1; i&lt;=N; i++) {             set.add(find(i));         }         res += set.size()-1;          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private int find(int x) {         if(parent[x] != x) return parent[x] = find(parent[x]);         return x;     }      private void union(int x, int y) {         x = find(x);         y = find(y);          if(x != y) {             if(x &gt; y) parent[x] = y;             else parent[y] = x;         }     } }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (2)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-2/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-18 02:59:56 +0900",
    "content": "     Computer Network Introduction - (2)   Caravan analogy    자동차10대(패킷)가 나가기 위해 12s X 10 = 120s 즉 2분만큼 걸림.   toll booth를 쭉 따라 가는데 100km / 속력(100km/h) = 1hour 즉 1시간 걸림.   패킷 스위칭에 걸리는 전체 시간 : 1시간 2분.                     앞에 bit가 link에 도달하는 시간에 비해 link에서 전달되는 속도는 광속이기에 상대적으로 매우빠르다. 그냥 link에 도착하면 바로 다음 라우터로 전달된다고 봐도 된다. 그렇지만 패킷 단위로 움직이기 때문에 모든 bit들이 다음 라우터에 전달되어야 다시 다음 step이 진행된다. 일부분만 도달되어선 진행되지 않는다. 따라서 패킷 스위칭은** 패킷 단위로 진행되어야 한다는 점에 유의!**         네트워크 계층          예시                  Application Layer : HTTP, 우리가 코드짜서 컴파일한 프로그램, 프로세스   Transport Layer : TCP/UDP   Network Layer : IP   Data Layer : LTE/3G, Wifi, Eternet   Physical layer   이러한 많은 계층은 Network Edge(클라이언트, 서버)에 존재하고 중간에 이를 이어주는 라우터들에는 없다. 라우터에는 physical-link-network 계층까지만 존재한다.   Client-Server Architecture 서버    웹 서버   24시간 동작해야한다.   영구적인 고정된 IP 주소를 가져야한다.            인터넷에 존재하는 각 컴퓨터는 고유의 주소를 가져야 하는데 이를 IP 주소라고 한다.           클라이언트         웹 브라우저     Process Communicating          Sockets      소켓은 통신을 가능하게 하는 통로다.   예를들면 두 프로세스가 있고 이 사이에서 데이터를 주고받아야 할 때 OS에 있는 소켓을 통해 주고받을 수 있다.   소켓을 연결시켜놓으면 한쪽에서 write하면 반대쪽에선 read가 되는 느낌으로 데이터가 전달된다.   이렇게 하기위에 사전에 양쪽 소켓에 서로 연결하고싶다는 의사표현을 해야한다. Process A와 Process B를 통신하기 위해 양쪽 소켓을 연결하기 위해선 그 소켓들의 주소를 알아야한다. 이 소켓 주소를 인덱싱하는 과정이 필요하다.            Socket Indexing = IP 주소(어떤 컴퓨턴지 특정하는 주소) + 포트 (컴퓨터에 여러 프로세스들 중 특정 프로세스 지칭하는 주소)       좀 더 정확히 표현하면 특정 프로세스 연결하기 위해 소켓 연결 할건데 이 포트에 물린 소켓의 주소가 무엇인지 찾는것           어플리케이션 개발자가 Application layer를 컨트롤한다면, 나머지 계층은 OS가 컨트롤한다.   왜 80번이란 공통된 포트를 사용할까?    서버는 24시간 켜져있어야하고, 주소가 변하면 안된다. 그런데 구글, 네이버 각각의 주소는 다르다. DNS를 통해 IP주소를 변역해준다. 그런데 Port번호도 찾아야하는데 이거까지 찾기엔 너무 귀찮기 때문에 포트번호는 통일하자! 라는 의미로 공통된 포트번호를 회사들이 사용한다고 한다.     What Transport Service Does An Application Need?     계층 = 하위 계층의 기능을 상위 계층에서 가져다 사용한다는 뜻, 즉 하위 계층의 기능들을 서비스 받아 사용하는것이다.   Application Layer에서는 어떤 서비스를 Transport Layer로부터 제공받고싶어할까?  1. data integrity : 내가 보내는 데이터가 유실되지 않고 온전하게 목적지까지 도착 2. timing : 내가 보내는 데이터가 제한 시간 내에 도착 (시간 중심) 3. throughput : 1초에 어느 정도의 데이터가 도착되어야 함 (양 중심) 4. security : 안전성  이 중 Transport Layer 가 제공하는 기능은 1번 Data Integrity밖에 없다. TCP는 이걸 제공해주고 UDP는 이것마저 없다.   Internet Apps  Web and HTTP     HTTP : Hypertext Transfer Protocol   하이퍼텍스트            말 그대로 텍스트. 내용 중간중간에 다른 텍스트를 지칭하는 링크가 있다.       HTTP request(내가 원하는 하이퍼텍스트 이름)와 HTTP response(요청하는 파일을 찾아서 줌)로 메시지 주고받음.                HTTP는 TCP를 사용해서 통신하기 때문에, HTTP 메시지 교환 이전에 TCP 연결을 먼저 생성해야한다!      HTTP는 상태가 없다. (Stateless)            HTTP는 단순해서 request들어오면 단순히 그 요청에 해당하는 파일을 디스크에서 읽어서 response로 보내주고 끝이다. 이 상태에 대해 기억하지 않고 다음 요청으로 넘어간다.             HTTP Connections     HTTP가 TCP 커넥션을 사용하는 방식에 따라서 2가지로 나뉜다.   1. non-persistent HTTP    매번 요청마다 새로운 연결(TCP-connection)을 생성하고, 응답후 끊는 방식이다. (HTTP 1.0)   2. persistent HTTP    일정 시간동안 연결 유지해 다수 요청을 처리할 수 있도록 하나의 TCP 연결을 재사용함. (HTTP 1.1)    Non-persistent HTTP     사용자가 다음 URL을 입력한다고 가정: www.someSchool.edu/someDepartment/home.index (텍스트와 10개의 jpeg 이미지 포함)   **1. **    (a) HTTP 클라이언트가 HTTP 서버(프로세스)와 www.someSchool.edu의 80번 포트로 TCP 연결을 시작   (b) www.someSchool.edu의 HTTP 서버가 80번 포트에서 TCP 연결 대기 중. 연결을 “수락”하고 클라이언트에게 통지   2. HTTP 클라이언트가 HTTP 요청 메시지(URL 포함)를 TCP 연결 소켓으로 전송. 메시지는 클라이언트가 someDepartment/home.index 객체를 원한다고 표시 3. HTTP 서버가 요청 메시지를 수신하고, 요청된 객체를 포함하는 응답 메시지를 생성하여 소켓으로 전송 4. HTTP 서버가 TCP 연결을 종료 5. HTTP 클라이언트가 html 파일이 포함된 응답 메시지를 수신하고 html을 표시. html 파일을 파싱하여 10개의 참조된 jpeg 객체를 발견 6. 1-5단계가 10개의 jpeg 객체 각각에 대해 반복됨   Non-persistent HTTP : response time  "
  },
  
  {
    "title": "웹 서버 vs 웹 어플리케이션 서버(WAS)",
    "url": "/posts/%EC%9B%B9-%EC%84%9C%EB%B2%84-vs-%EC%9B%B9-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%84%9C%EB%B2%84WAS/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-18 00:09:32 +0900",
    "content": "웹 서버 웹 서버 는 정적 컨텐츠(HTML, CSS, JS, Image, … etc) 를 제공하는 역할을 수행한다. 동적 컨텐츠를 요청하면 그 요청을 WAS로 전달할 수도 있다. 대표적인 웹 서버로 Apache, Nginx 등이 있다.  웹 어플리케이션 서버 (WAS) 웹 어플리케이션 서버 (Web Application Server) ** 는 자바같은 경우엔 서블릿 컨테이너 기능을 제공하고, 동적 컨텐츠를 생성하거나, 어플리케이션 로직을 실행하는데 특화되어있다. 대표적인 WAS로 **Tomcat이 있다.   즉 Web Server는 정적 컨텐츠 제공에 특화되어있고, WAS는 동적인 컨텐츠 생성과 데이터 처리에 특화되어 있다.  WAS에서 정적 컨텐츠를 제공하지 않고 웹 서버를 따로 두는 이유 WAS의 역할에 집중시키기 위해서다. WAS에 너무 많은 역할을 부여하면 서버가 과부화될 수 있다. 웹 서버를 따로 분리하면 WAS는 어플리케이션 중요 로직에 집중할 수 있고, 웹 서버는 정적 리소스를 처리하면서 업무 분담이 가능하다. 또한, 시스템 자원을 효율적으로 관리할 수 있다. 정적 컨텐츠가 많이 사용되는 경우 웹 서버를 증설하고, 어플리케이션 자원이 많이 사용되는 경우는 WAS를 증설하면 된다. 이외에도 로드 밸런싱을 하거나, 캐싱/압축, HTTPS 등을 웹 서버에서 처리하게 할 수도 있다.  References    웹 서버와 WAS(Web Application Server)  "
  },
  
  {
    "title": "Stack 자료구조",
    "url": "/posts/Stack-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-17 23:55:58 +0900",
    "content": "스택(Stack) 은 후입선출이라는 개념을 가진 선형 자료구조다. 스택 자료구조에서 삭제(pop)는 가장 최상단(top)에서만 이루어진다. 비어있는 스택에서 값을 추출하려고 시도하는 경우를 스택 언더플로우라고 하며, 스택이 넘치는 경우를 스택 오버플로우라고 한다. 대표적인 활용 사례는 스택 메모리, 브라우저 뒤로가기 기능, 언두 기능, 수식 괄호 검사 등이 있다.   Java에서의 Stack Stack이라는 클래스를 사용할 수 있다. 하지만, Deque 인터페이스 구현체를 사용하는 것이 권장된다. 왜냐하면, Stack 클래스는 내부적으로 Vector를 상속 받고 있기 때문이다. Vector를 상속받은 Stack은 인덱스를 통한 접근, 삽입, 제거 등이 실질적으로 가능하다. 이는 후입선출 특징에 맞지 않기 때문에 개발자가 실수할 여지가 있다.  또한, Vector의 메소드들은 synchronized로 구현되어 있어 멀티 스레드 환경에서는 동기화의 이점이 있으나, 단일 스레드 환경에서는 불필요한 동기화 작업으로 인해 성능 측면에서 좋지 않다. 반면에, Deque 인터페이스는 후입선출의 특성을 완전히 유지하면서도 동기화 작업을 가지는 구현체와 그렇지 않은 구현체를 선택할 수 있다. 이는 개발자가 필요에 따라 동기화 작업의 오버헤드를 회피하고 성능을 최적화할 수 있도록 한다.  References    Stack  "
  },
  
  {
    "title": "BOJ_1417_국회의원 선거 (Java, C++)",
    "url": "/posts/BOJ1417%EA%B5%AD%ED%9A%8C%EC%9D%98%EC%9B%90-%EC%84%A0%EA%B1%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-17 23:18:49 +0900",
    "content": "[Silver V] 국회의원 선거 - 1417  문제 링크  성능 요약  메모리: 2020 KB, 시간: 0 ms  분류  자료 구조, 그리디 알고리즘, 구현, 우선순위 큐, 시뮬레이션  제출 일자  2025년 1월 17일 23:14:40  문제 설명  다솜이는 사람의 마음을 읽을 수 있는 기계를 가지고 있다. 다솜이는 이 기계를 이용해서 2008년 4월 9일 국회의원 선거를 조작하려고 한다.  다솜이의 기계는 각 사람들이 누구를 찍을 지 미리 읽을 수 있다. 어떤 사람이 누구를 찍을 지 정했으면, 반드시 선거때 그 사람을 찍는다.  현재 형택구에 나온 국회의원 후보는 N명이다. 다솜이는 이 기계를 이용해서 그 마을의 주민 M명의 마음을 모두 읽었다.  다솜이는 기호 1번이다. 다솜이는 사람들의 마음을 읽어서 자신을 찍지 않으려는 사람을 돈으로 매수해서 국회의원에 당선이 되게 하려고 한다. 다른 모든 사람의 득표수 보다 많은 득표수를 가질 때, 그 사람이 국회의원에 당선된다.  예를 들어서, 마음을 읽은 결과 기호 1번이 5표, 기호 2번이 7표, 기호 3번이 7표 라고 한다면, 다솜이는 2번 후보를 찍으려고 하던 사람 1명과, 3번 후보를 찍으려고 하던 사람 1명을 돈으로 매수하면, 국회의원에 당선이 된다.  돈으로 매수한 사람은 반드시 다솜이를 찍는다고 가정한다.  다솜이가 매수해야하는 사람의 최솟값을 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 후보의 수 N이 주어진다. 둘째 줄부터 차례대로 기호 1번을 찍으려고 하는 사람의 수, 기호 2번을 찍으려고 하는 수, 이렇게 총 N개의 줄에 걸쳐 입력이 들어온다. N은 50보다 작거나 같은 자연수이고, 득표수는 100보다 작거나 같은 자연수이다.  출력  첫째 줄에 다솜이가 매수해야 하는 사람의 최솟값을 출력한다.     문제 풀이   Priority Queue 자료구조를 이용하면 쉽게 풀 수 있다. 다솜이가 다른사람의 최댓값보다 클 때까지 최대인사람을 -1해주고 다솜이를 +1해주면서 표 res를 +1 해주면된다.     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, dasom, res = 0;     static PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder());     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1417_국회의원선거/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         if(N == 1){             System.out.println(0);             return;         }          dasom = Integer.parseInt(br.readLine());         for(int i = 1; i &lt; N; i++) {             int num = Integer.parseInt(br.readLine());             pq.add(num);         }          while(!pq.isEmpty() &amp;&amp; dasom &lt;= pq.peek()) {             int tmp = pq.poll();             dasom ++;             res ++;             pq.add(tmp-1);         }          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }    C++ 코드  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, dasom, res = 0;     cin &gt;&gt; N;      if (N == 1) {         cout &lt;&lt; \"0\" &lt;&lt; \"\\n\";         return;     }      cin &gt;&gt; dasom;     priority_queue&lt;int&gt; pq;     for (int i = 1; i &lt; N; i++) {         int num;         cin &gt;&gt; num;         pq.push(num);     }      while (!pq.empty() &amp;&amp; dasom &lt;= pq.top()) {         int tmp = pq.top();         pq.pop();         dasom++;         res++;         pq.push(tmp - 1);     }      cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Computer Networking: a Top Down Approach - (1)",
    "url": "/posts/Computer-Networking-a-Top-Down-Approach-1/",
    "categories": "네트워크",
    "tags": "네트워크",
    "date": "2025-01-17 22:01:19 +0900",
    "content": "   Computer Network Introduction - (1)             Network Edge            우리들이 위치하는 곳                Network Core            라우터 : 데이터를 목적지까지 전달                Access Noetworks, Physical media            구성요소들을 이어주는 링크들            Network Edge          end systems(hosts)            컴퓨터, 노트북, 스마트 폰 등 사용자가 상호작용 하는 장치            Network Edge : 연결 지향형 서비스    네트워크 엣지의 목적은 시스템 간 데이터를 주고 받는 것인데, 이 때 데이터를 순서대로, 전송을 보장하는 목적인 TCP를 사용한다.   TCP    신뢰성 있게 내가 보낸 데이터를 순서대로, 전송을 보장한다.   받는 컴퓨터 능력치에 맞춰 받을 수 있는 양만큼 데이터를 보낸다.   네트워크 사정에 맞게 속도를 조절할 수 있다.   UDP    connectionless   unreliable data transfer   no flow control   no congestion control   유실되든 상관없이 데이터 막 보낼거면 사용해도된다!   그럼 UDP 언제 사용?  음성 RTC 보이스톡 같은 것 (디스코드). 몇 패킷 없어져도 귀가 민감하지 않은 음역대면 괜찮다. TCP는 엄격하기 때문에 컴퓨터 리소싱 자원을 많이 소모하므로 이에 민감하지 않은 데이터라면 UDP로 막 보내도 될 때 사용한다.   Protocol          약속(규약)이란 의미로 서로 통신할 때 지켜야 하는 규칙이다.     Network Core      라우터들이 데이터를 목적지까지 전달해줌.   이렇게 얽히고 섥힌 라우터들의 집합   어떤 방법으로 데이터를 전송할까?    서킷 스위칭 : 출발지부터 목적지까지 가는 길을 미리 예약을 해놓고 특정 사용자만을 위해 사용하도록 만들어놓는것.        패킷 스위칭 : 데이터를 패킷 단위로 받아서 그때그때 올바른 방향으로 포워딩해준다. 인터넷에서 사용.     Circuit Switching      통신할 때 두 노드 사이에 물리적인 경로(회선)을 정해놓고 사용한다. ex) 전화   장점 : 신뢰성, 전송 속도 보장   단점 : 비효율성, 자원 낭비(데이터 전송 안해도 회선이 낭비됨)   Packet Switching    데이터를 패킷 단위로 나누어 전송. 각 패킷마다 개별적인 최적 루트를 그때그때 찾아 전송한다. ex) 인터넷   Circuit Switching vs Packet Switching    주요 포인트는 “점유” 유무다. 서킷 스위칭은 데이터 전송 전에 경로를 정하고 “점유”한다. 그리고 연결 끊기기 전까지 내가 “점유”한다. 만약 1Mbps를 한번에 보낼 수 있는 대역폭을 가진 회선이 있는데, 한 컴퓨터가 100kbs를 사용한다면 10명밖에 이용을 못하게된다.        반대로 패킷 스위칭은 “점유”하지 않는다. 그리고 데이터를 뭉탱이로 보내는 게 아니라 패킷으로 “잘라서 각각” 보내기 때문이다.      Packet Delay  1. nodal processing    라우터에서 패킷을 처음에 받으면 패킷 검사를 해야한다. 패킷을 검사하고 목적지가 어딘지 검사하는 delay   2. queueing    라우터에 데이터가 들어오는 속도가 전송해서 빠져나가는 속도보다 커져서 들어오는 데이터가 많아지면 너무 데이터가 많기 때문에 줄을 서야된다. 라우터에서는 queue라는 저장공간에 줄을 세운다.   대부분의 패킷 손실이 일어나는 곳   한번에 나갈 수 있는 대역폭이 한정적이기 때문에, 라우터마다 대기 공간인 queue 혹은 buffer가 존재하는데, 이 대기시간의 delay   queue의 크기도 한정적이기 때문에, 꽉차면 그냥 패킷을 버린다.            TCP는 안전한 전송을 보장하는데 버리면 어떻게 해야할까?       클라이언트 단인 Network Edge에서 데이터를 다시 전송해야한다.           3. Transmission delay    패킷은 비트의 집합이므로 그 길이만큼 link로 뿜어져 나가야한다. 첫번째 bit가 나가는 순간부터 마지막 bit가 나가는 순간까지의 시간 delay   패킷을 1비트로 나눠야 빛으로 쏠 수 있으므로 이 때문에 패킷 길이만큼 걸리는 전송 시간을 의미한다.   transmission delay = 패킷 길이 / 대역폭 -&gt; 대역폭은 병렬처리하는 넓이라고 볼 수 있겠다.   4. Propagation delay    물리적으로 다음 라우터까지 전달하기 위한 빛의 속도   link길이만큼을 빛의 속도로 이동해야하기 때문에 걸리는 시간 delay   어떻게 delay를 줄일 수 있을까?  Processiong Delay    좋은 하드웨어 (좋은 라우터) : 라우터 성능을 개선하면 처리 성능이 개선된다.   ex) 톨게이트 요금소에서 사람이 돈 계산하던 것을 하이패스로 바꾸는 느낌   Queueing Delay    전송하는 클라이언트가 기여하는 부분이므로 개선하기 어려운 부분. 사람들이 많이 사용할 때 줄을 많이 서기 때문.   Transmission Delay    대역폭을 늘려 동시 처리 비트 개수가 늘어나면된다.   하이패스로도 부톡해서 차선을 더 늘린 느낌.  "
  },
  
  {
    "title": "서버 사이드 렌더링 vs 클라이언트 사이드 렌더링 (SSR과 CSR)",
    "url": "/posts/%EC%84%9C%EB%B2%84-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-vs-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-SSR%EA%B3%BC-CSR/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-17 04:12:06 +0900",
    "content": "  서버 사이드 렌더링(SSR) 은 서버 측에서 렌더링하는 방식이다. 클라이언트가 서버에 컨텐츠를 요청하면, 서버는 페이지에 필요한 데이터를 즉시 얻어와 모두 삽입하고, CSS까지 모두 적용해 렌더링 준비를 마친 HTML과 JS 코드를 응답한다. 브라우저에서는 JS 코드를 다운로드하고, HTML에 JS를 연결한다.  이처럼 모든 데이터가 이미 HTML에 담긴 채로 브라우저에 전달되기 때문에 SEO에 유리하다. 또한 JS 코드를 다운로드 받고 실행하기 전에 사용자가 이미 렌더링된 HTML을 볼 수 있으므로, JS 다운로드를 기다려야 하는 CSR에 비해 초기 구동 속도가 빠르다.  클라이언트 사이드 렌더링(CSR) 은 클라이언트 측에서 렌더링하는 방식이다. 클라이언트가 서버에 컨텐츠를 요청하면, 서버는 빈 뼈대만 있는 HTML을 응답한다. 클라이언트는 연결된 JS 링크를 통해 서버로부터 다시 JS 파일을 다운로드 받은 뒤, JS를 통해 동적으로 페이지를 만들어 브라우저에 보여준다.  빈 뼈대만 있는 HTML을 받아오기 때문에 웹 크롤러 봇 입장에서 색인할만한 콘텐츠가 존재하지 않아 SEO에 불리하다는 단점이 있다. 또 브라우저가 JS 파일을 다운로드하고, 동적으로 DOM을 생성하는 시간을 기다려야 하기 때문에 초기 로딩 속도가 느리다는 단점이 존재한다. 하지만 초기 로딩 이후 페이지 일부를 변경할 때에는 서버에 해당 데이터만 요청하면 되기 때문에 이후 구동 속도가 빠르다. 서버는 HTML 뼈대를 넘겨주는 역할만 수행하면 되므로 서버 측의 부하가 적고, 클라이언트 측에서 연산과 라우팅 등을 직접 처리하기 때문에 반응속도가 빠르고 UX도 우수하다는 장점이 있다.                 SSR 적용       CSR 적용                       SEO가 중요한 웹사이트       실시간 상호작용이 많은 애플리케이션                 초기 로딩 속도가 중요한 경우       서버 부하를 줄여야 하는 경우                 네트워크가 느린 환경       단일 페이지 애플리케이션(SPA)                 콘텐츠 중심 웹사이트       동적 데이터 처리가 많은 웹사이트           References    SSR vs CSR  "
  },
  
  {
    "title": "BOJ_17411_가장 긴 증가하는 부분 수열 6 (Java)",
    "url": "/posts/BOJ17411%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-6-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-17 04:00:08 +0900",
    "content": "[Platinum II] 가장 긴 증가하는 부분 수열 6 - 17411  문제 링크  성능 요약  메모리: 495940 KB, 시간: 3084 ms  분류  이분 탐색, 자료 구조, 가장 긴 증가하는 부분 수열: O(n log n), 세그먼트 트리  제출 일자  2025년 1월 17일 03:38:31  문제 설명  수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열과 개수를 구하는 프로그램을 작성하시오.  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이고, 1개이다. A = {10, 20, 30, 10, 20, 30}인 경우에는 가장 긴 증가하는 부분 수열의 길이는 3이고, 4개가 있다.  입력  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)  출력  첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이와 개수를 출력한다. 개수는 매우 커질 수 있기 때문에 109+7로 나눈 나머지를 출력한다.     문제 풀이     접근 방식 일반적인 LIS는 이분 탐색을 사용하여 O(N log N)에 해결할 수 있다. 하지만 이 문제는 개수도 세야 하므로, 세그먼트트리를 사용해야한다.  세가지 전략으로 접근해보겠다.     좌표 압축   세그먼트 트리   개수 세기를 위한 DP적 접근   1. 좌표 압축 TreeSet&lt;Integer&gt; uniqueSet = new TreeSet&lt;&gt;(); for(int n : arr) uniqueSet.add(n); ArrayList&lt;Integer&gt; unique = new ArrayList&lt;&gt;(uniqueSet);     Why?            입력값의 범위가 -10^9부터 10^9까지로 매우 큼.       세그먼트 트리를 만들기 위해서는 이 범위를 압축해야 함.           How?            TreeSet으로 중복을 제거하고 정렬.       각 숫자를 1부터 시작하는 인덱스로 매핑.           세그먼트트리 static class Pair {     int length;    // LIS의 길이     long count;    // 해당 길이를 가진 LIS의 개수     public Pair(int length, long count) {         this.length = length;         this.count = count;     } }     length: 현재까지의 최대 LIS 길이   count: 해당 길이를 가진 LIS의 개수     static Pair merge(Pair a, Pair b) {     if(a.length &gt; b.length) return a;     else if(a.length &lt; b.length) return b;     return new Pair(a.length, (a.count + b.count) % MOD); }     세그먼트 트리의 각 노드는 Pair 객체를 저장.   merge 함수는 두 구간의 정보를 합칠 때 사용 :            길이가 다르면 더 긴 쪽을 선택                길이가 같으면 개수를 더함 (MOD 연산)         for(int i=0; i&lt;N; i++) { Pair curr = query(1, compressed[i]-1, 1, uniqueSize, 1); Pair newValue = new Pair(curr.length + 1, Math.max(curr.count, 1)); update(compressed[i], newValue, 1, uniqueSize, 1); }                  arr 수열의 각 숫자를 순회하면서 :              현재 숫자보다 작은 모든 숫자들 중에서 최대 LIS 정보를 가져온다.       현재 숫자를 포함하는 새로운 LIS를 만든다. ( 그 개수 그대로 하나 붙이는것임은 자명하다)       세그먼트 트리를 업데이트.            단계별 과정    Step 1: 첫 번째 숫자 (10)   현재 숫자: 10 (압축값: 1) 1. 이전 작은 숫자들 조회 (query(1, 0))    - 결과: length = 0, count = 0 (아무것도 없음) 2. 새로운 상태    - length = 1 (0 + 1)    - count = 1 (새로운 수열 시작) 3. 세그먼트 트리 업데이트    - 위치 1에 (length=1, count=1) 저장  현재까지 찾은 LIS들: - {10} (길이 1, 개수 1)     Step 2: 두 번째 숫자 (20)   현재 숫자: 20 (압축값: 2) 1. 이전 작은 숫자들 조회 (query(1, 1))    - 결과: length = 1, count = 1 (10으로 끝나는 수열) 2. 새로운 상태    - length = 2 (1 + 1)    - count = 1 (이전 수열에서 이어짐) 3. 세그먼트 트리 업데이트    - 위치 2에 (length=2, count=1) 저장  현재까지 찾은 LIS들: - {10} (길이 1, 개수 1) - {10, 20} (길이 2, 개수 1)      Step 3: 세 번째 숫자 (10)   현재 숫자: 10 (압축값: 1) 1. 이전 작은 숫자들 조회 (query(1, 0))    - 결과: length = 0, count = 0 (더 작은 수 없음) 2. 새로운 상태    - length = 1 (0 + 1)    - count = 1 (새로운 수열 시작) 3. 세그먼트 트리 업데이트    - 위치 1의 상태 유지 (merge 결과 변화 없음)  현재까지 찾은 LIS들: - {10} (길이 1, 개수 1) - {10, 20} (길이 2, 개수 1) - {10} (새로운 시작점)      Step 4: 네 번째 숫자 (30)   현재 숫자: 30 (압축값: 3) 1. 이전 작은 숫자들 조회 (query(1, 2))    - 결과: length = 2, count = 1 ({10, 20}으로 끝나는 수열) 2. 새로운 상태    - length = 3 (2 + 1)    - count = 1 (이전 수열에서 이어짐) 3. 세그먼트 트리 업데이트    - 위치 3에 (length=3, count=1) 저장  현재까지 찾은 LIS들: - {10} (길이 1) - {10, 20} (길이 2) - {10, 20, 30} (길이 3, 개수 1)     Step 5: 다섯 번째 숫자 (20)   현재 숫자: 20 (압축값: 2) 1. 이전 작은 숫자들 조회 (query(1, 1))    - 결과: length = 1, count = 1 (10으로 끝나는 수열) 2. 새로운 상태    - length = 2 (1 + 1)    - count = 1 (이전 수열에서 이어짐) 3. 세그먼트 트리 업데이트    - 위치 2의 상태 갱신 (merge로 count 합산)  현재까지 찾은 LIS들: - {10} (길이 1) - {10, 20} (길이 2) - {10, 20, 30} (길이 3) - {10, 20} (새로운 경로)     Step 6: 마지막 숫자 (50)   ```현재 숫자: 50 (압축값: 4)    이전 작은 숫자들 조회 (query(1, 3))            결과: length = 3, count = 1 ({10, 20, 30}으로 끝나는 수열)           새로운 상태            length = 4 (3 + 1)       count = 1 (이전 수열에서 이어짐)           세그먼트 트리 업데이트            위치 4에 (length=4, count=1) 저장           최종 LIS들:    {10, 20, 30, 50} (길이 4, 개수 1)    3. 세그먼트 트리 최종 각 위치는 해당 값을 마지막으로 하는 LIS의 정보를 저장:  위치 1 (값 10): length=1, count=1 위치 2 (값 20): length=2, count=1 위치 3 (값 30): length=3, count=1 위치 4 (값 50): length=4, count=1 ![](/assets/posts/bdf8698d1474355c2df9cb5b5d2d73e26efa75ac758b7462b3e68276d0b075f7.png)  &gt; ## 코드  ```java /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static final int MOD = 1000000007;      static class Pair{         int length;         long count;         public Pair(int length, long count){             this.length = length;             this.count = count;         }     }      static Pair merge(Pair a, Pair b){         if(a.length &gt; b.length) return a;         else if (a.length &lt; b.length) return b;         // 같은 길이일때는 count를 더함         return new Pair(a.length, (a.count + b.count) % MOD);     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, arr[], compressed[];     static Pair segment[];     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17411_가장긴증가하는부분수열6/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  N = Integer.parseInt(br.readLine());          arr = new int[N];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }          // 좌표압축         TreeSet&lt;Integer&gt; uniqueSet = new TreeSet&lt;&gt;();         for(int n : arr) uniqueSet.add(n);         ArrayList&lt;Integer&gt; unique = new ArrayList&lt;&gt;(uniqueSet); // 중복제거         compressed = new int[N];         for(int i = 0; i &lt; N; i++){             int pos = binarySearch(unique, arr[i]);             compressed[i] = pos + 1; // 1-based         }          int uniqueSize = unique.size();         segment = new Pair[4*uniqueSize];         for (int i=0; i&lt;4*uniqueSize; i++) {             segment[i] = new Pair(0, 0);         }          for(int i=0; i&lt;N; i++){             // 지금i위치보다 앞에있는 작은수들 중 LIS 찾기             Pair curr = query(1, compressed[i]-1, 1, uniqueSize, 1);              /*             지금위치i까지 포함해서 길이 1 증가             count가 0일땐 새로운수열 시작 (1)             count가 0아닐땐 이전까지 count 다 더함             */             Pair newValue = new Pair(curr.length + 1, Math.max(curr.count, 1));              update(compressed[i], newValue, 1, uniqueSize, 1);         }          Pair result = query(1, uniqueSize, 1, uniqueSize, 1);                  bw.write(result.length + \" \" + result.count + \"\\n\");         bw.flush();         bw.close();         br.close();     }      private int binarySearch(ArrayList&lt;Integer&gt; unique, int target) {         int left = 0, right = unique.size() - 1;         int res = 0;          while(left &lt;= right){             int mid = left + (right-left)/2;             if(unique.get(mid) &gt;= target) {                 res = mid;                 right = mid - 1;             }              else left = mid + 1;         }         return res;     }      /*     구간 [left, right]에서 최댓값 찾기      */     static Pair query(int left, int right, int start, int end, int node){         if(left &gt; end || right &lt; start) return new Pair(0, 0);          if(left &lt;= start &amp;&amp; end &lt;= right) return segment[node];          int mid = start + (end-start)/2;         Pair leftRes = query(left, right, start, mid, node*2);         Pair rightRes = query(left, right, mid+1, end, node*2 + 1);                  return merge(leftRes, rightRes);     }      /*     pos 위치를 value로 업데이트      */     static void update(int pos, Pair value, int start, int end, int node){         if(pos &gt; end || pos &lt; start) return;          if(start == end){             segment[node] = merge(segment[node], value);             return;         }          int mid = start + (end-start)/2;         update(pos, value, start, mid, node * 2);         update(pos, value, mid+1, end, node * 2 + 1);          segment[node] = merge(segment[node * 2], segment[node * 2 + 1]);     }  }  "
  },
  
  {
    "title": "타임 아웃 (Connection Timeout, Socket Timeout, Read Timeout)",
    "url": "/posts/%ED%83%80%EC%9E%84-%EC%95%84%EC%9B%83-Connection-Timeout-Socket-Timeout-Read-Timeout/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-16 03:57:17 +0900",
    "content": "Connection Timeout  Connection Timeout은 클라이언트가 서버에 연결을 시도할 때, 일정 시간 내에 연결이 이루어지지 않으면 발생하는 타임아웃이다. TCP 소켓 통신에서 클라이언트와 서버가 연결될 때, 정확한 전송을 보장하기 위해 사전에 세션을 수립하는데, 이 과정을 3-way-handshake라고 한다. Connection Timeout은 이 3-way-handshake가 일정 시간 내에 완료되지 않을 때 발생한다. 즉, 서버의 장애나 응답 지연으로 인해 연결을 맺지 못하면 Connection Timeout이 발생한다.  Socket Timeout Socket Timeout은 Connection Timeout 이후에 발생할 수 있는 타임아웃이다.  클라이언트와 서버가 연결된 후, 서버는 데이터를 클라이언트에게 전송한다. 이때 하나의 데이터 덩어리가 아니라 여러 개의 패킷 단위로 쪼개서 전송되는데, 각 패킷이 전송될 때의 시간 차이 제한을 Socket Timeout이라고 한다. 만약 서버가 일정 시간 내에 다음 패킷을 보내지 않으면, 클라이언트는 Socket Timeout을 발생시키고 연결을 종료할 수 있다.  Read Timeout Read Timeout은 클라이언트와 서버가 연결된 후, 특정 I/O 작업이 일정 시간 내에 완료되지 않으면 발생하는 타임아웃이다.  클라이언트와 서버가 연결된 상태에서, 서버의 응답이 지연되거나 I/O 작업이 길어져 요청이 처리되지 않을 때 클라이언트는 연결을 끊는다. Read Timeout은 이러한 상황을 방지하기 위해 설정된 타임아웃으로, 일정 시간 내에 데이터가 읽혀지지 않으면 클라이언트가 연결을 종료한다.    네트워크 통신에 타임아웃이 필요한 이유 타임아웃이 필요한 이유는 자원을 절약하기 위함 이다. 외부 서비스로 요청을 보냈지만 해당 요청이 무한정 길어질 수 있는데, 이때 서비스의 요청이 자원을 가지고 있으면, 서비스의 자원이 고갈되어 장애가 발생할 수 있다. 타임아웃을 설정하면 이렇게 요청이 무한정 길어지는 상황을 예방할 수 있다.  타임아웃 테스트 방법 가상 서버를 띄우고 임의로 지연을 추가하여 타임아웃을 테스트할 수 있다. 하지만, 테스트 환경을 구축하기 위한 시간이 들며 자동화된 테스트에 지연 시간이 추가되는 것이 단점이다.  References    타임아웃(Timeout)  "
  },
  
  {
    "title": "Reverse Proxy vs. Forward Proxy",
    "url": "/posts/Reverse-Proxy-vs.-Forward-Proxy/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-16 03:50:44 +0900",
    "content": "   포워드 프록시(Forward Proxy)   포워드 프록시는 주로 클라이언트 측에 위치하여, 사용자가 인터넷에 접근할 때 중개자 역할을 한다.  예를 들어, 회사 내부 네트워크에서 근무하는 직원이 외부 웹사이트에 접속하려고 할 때, 포워드 프록시 서버를 통해 요청이 전달된다. 이 과정에서 사용자의 실제 IP 주소는 숨겨지고, 프록시 서버의 IP 주소가 대신 사용된다.  포워드 프록시의 핵심 기능 중 하나는 익명성 제공 이다. 사용자의 실제 IP를 숨김으로써 개인정보 보호와 보안 측면에서 큰 장점을 제공한다.  또한 캐싱을 통해 네트워크 성능을 향상 시킨다. 자주 요청되는 웹 페이지나 파일을 프록시 서버에 저장해두면, 동일한 요청이 다시 들어올 때 빠르게 응답할 수 있어 네트워크 대역폭을 절약할 수 있다.  이와 함께 보안 강화 기능도 포워드 프록시의 중요한 역할 중 하나다. 악성 웹사이트나 불법적인 콘텐츠에 대한 접근을 차단하여 네트워크 보안을 강화하고, 바이러스나 악성 코드의 유입을 예방할 수 있다.     리버스 프록시(Reverse Proxy)   리버스 프록시는 서버 측에 위치하여 외부에서 들어오는 클라이언트의 요청을 내부 서버로 전달하는 역할을 한다.  리버스 프록시의 핵심 기능 중 하나는 로드 밸런싱 이다. 다수의 백엔드 서버로 트래픽을 분산시켜 서버 과부하를 방지하고, 서비스의 고가용성을 유지할 수 있다.  또한 외부에서 직접 백엔드 서버에 접근하지 못하게 하여 DDoS 공격이나 해킹 시도로부터 서버를 보호할 수 있다.  SSL 종료는 리버스 프록시의 또 다른 중요한 기능이다. SSL/TLS 암호화를 리버스 프록시에서 처리함으로써 백엔드 서버의 부담을 줄이고, 중앙에서 인증서를 관리할 수 있다.  또한, 리버스 프록시는 캐싱 및 콘텐츠 최적화 기능을 통해 정적 콘텐츠를 캐싱하여 응답 속도를 향상시키고 서버 부하를 줄일 수 있다.  References    Forward Proxy vs. Reverse Proxy: The Difference Explained   Difference between Forward Proxy and Reverse Proxy in System design  "
  },
  
  {
    "title": "BOJ_14003_가장 긴 증가하는 부분 수열 5 (Java)",
    "url": "/posts/BOJ14003%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-5-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-16 03:41:19 +0900",
    "content": "[Platinum V] 가장 긴 증가하는 부분 수열 5 - 14003  문제 링크  성능 요약  메모리: 155836 KB, 시간: 736 ms  분류  이분 탐색, 가장 긴 증가하는 부분 수열: O(n log n)  제출 일자  2025년 1월 16일 02:53:33  문제 설명  수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.  입력  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)  출력  첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.  둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.     문제 풀이   BOJ_12738_가장 긴 증가하는 부분 수열 3 (Java) 와 이어지는 문제다.  어떻게 배열을 구상해야할지 참고했고, 이분탐색은 남들 코드와는 다르게 항상 작성하던데로 left&lt;=right와 res를 반환하는 형태로 고민하여 작성해보았다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     int N;     static int[] arr, dp, LIS;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_12015_가장긴증가하는부분수열2/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         N = Integer.parseInt(br.readLine());         arr = new int[N+1];         LIS = new int[N+1];         dp = new int[N+1];         st = new StringTokenizer(br.readLine());         for (int i = 1; i &lt;= N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }         int idx = 1;         LIS[1] = arr[1];         dp[1] = 1;          int maxLen = 1;         for(int i = 2; i &lt;= N; i++) {             if(arr[i] &gt; LIS[idx]) {                 LIS[++idx] = arr[i];                 dp[i] = idx;             }             else{                 int pos = binarySearch(1, idx, arr[i]);                 LIS[pos] = arr[i];                 dp[i] = pos;             }             maxLen = Math.max(maxLen, dp[i]);         }         sb.append(maxLen).append(\"\\n\");         ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();         for(int i = N; i &gt;= 1; i--) {             if(dp[i] == maxLen) {                 res.add(arr[i]);                 maxLen--;             }         }         Collections.reverse(res);         for(int num : res) {             sb.append(num).append(\" \");         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private int binarySearch(int left, int right, int target) {         int res = 0;         while(left &lt;= right){             int mid = left + (right - left) / 2;             if(LIS[mid] &lt; target){                 left = mid + 1;             }             else {                 res = mid;                 right = mid - 1;             }         }         return res;     } }  "
  },
  
  {
    "title": "BOJ_12738_가장 긴 증가하는 부분 수열 3 (Java)",
    "url": "/posts/BOJ12738%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-3-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-16 03:39:14 +0900",
    "content": "[Gold II] 가장 긴 증가하는 부분 수열 3 - 12738  문제 링크  성능 요약  메모리: 125548 KB, 시간: 528 ms  분류  이분 탐색, 가장 긴 증가하는 부분 수열: O(n log n)  제출 일자  2025년 1월 16일 02:52:31  문제 설명  수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.  입력  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)  출력  첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.     문제 풀이   BOJ_12015_가장 긴 증가하는 부분 수열 2 (Java) 와 이어지는 문제다.  어떻게 배열을 구상해야할지 참고했고, 이분탐색은 남들 코드와는 다르게 항상 작성하던데로 left&lt;=right와 res를 반환하는 형태로 고민하여 작성해보았다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     int N;     static int[] arr, dp, LIS;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_12015_가장긴증가하는부분수열2/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         N = Integer.parseInt(br.readLine());         arr = new int[N+1];         LIS = new int[N+1];         dp = new int[N+1];         st = new StringTokenizer(br.readLine());         for (int i = 1; i &lt;= N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }         int idx = 1;         LIS[1] = arr[1];         dp[1] = 1;          int maxLen = 1;         for(int i = 2; i &lt;= N; i++) {             if(arr[i] &gt; LIS[idx]) {                 LIS[++idx] = arr[i];                 dp[i] = idx;             }             else{                 int pos = binarySearch(1, idx, arr[i]);                 LIS[pos] = arr[i];                 dp[i] = pos;             }             maxLen = Math.max(maxLen, dp[i]);         }         sb.append(maxLen).append(\"\\n\");         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private int binarySearch(int left, int right, int target) {         int res = 0;         while(left &lt;= right){             int mid = left + (right - left) / 2;             if(LIS[mid] &lt; target){                 left = mid + 1;             }             else {                 res = mid;                 right = mid - 1;             }         }         return res;     } }  "
  },
  
  {
    "title": "BOJ_12015_가장 긴 증가하는 부분 수열 2 (Java)",
    "url": "/posts/BOJ12015%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-16 03:36:46 +0900",
    "content": "[Gold II] 가장 긴 증가하는 부분 수열 2 - 12015  문제 링크  성능 요약  메모리: 100136 KB, 시간: 496 ms  분류  이분 탐색, 가장 긴 증가하는 부분 수열: O(n log n)  제출 일자  2025년 1월 16일 02:50:23  문제 설명  수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.  입력  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)  출력  첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.     문제 풀이   LIS알고리즘을 이분탐색을 적용해보았다. N이 클때 O(NlogN)으로 완료해야한다.   어떻게 배열을 구상해야할지 참고했고, 이분탐색은 남들 코드와는 다르게 항상 작성하던데로 left&lt;=right와 res를 반환하는 형태로 고민하여 작성해보았다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     int N;     static int[] arr, dp, LIS;     public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_12015_가장긴증가하는부분수열2/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         N = Integer.parseInt(br.readLine());         arr = new int[N+1];         LIS = new int[N+1];         dp = new int[N+1];         st = new StringTokenizer(br.readLine());         for (int i = 1; i &lt;= N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }         int idx = 1;         LIS[1] = arr[1];         dp[1] = 1;          int maxLen = 1;         for(int i = 2; i &lt;= N; i++) {             if(arr[i] &gt; LIS[idx]) {                 LIS[++idx] = arr[i];                 dp[i] = idx;             }             else{                 int pos = binarySearch(1, idx, arr[i]);                 LIS[pos] = arr[i];                 dp[i] = pos;             }             maxLen = Math.max(maxLen, dp[i]);         }         sb.append(maxLen).append(\"\\n\");         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private int binarySearch(int left, int right, int target) {         int res = 0;         while(left &lt;= right){             int mid = left + (right - left) / 2;             if(LIS[mid] &lt; target){                 left = mid + 1;             }             else {                 res = mid;                 right = mid - 1;             }         }         return res;     } }   "
  },
  
  {
    "title": "BOJ_14002_가장 긴 증가하는 부분 수열 4  (Java, C++)",
    "url": "/posts/BOJ14002%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-4-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-15 23:23:38 +0900",
    "content": "[Gold IV] 가장 긴 증가하는 부분 수열 4 - 14002  문제 링크  성능 요약  메모리: 2020 KB, 시간: 0 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 1월 15일 23:07:25  문제 설명  수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.  입력  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)  출력  첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.  둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 그러한 수열이 여러가지인 경우 아무거나 출력한다.     문제 풀이   유명한 유형인 LIS 유형이다. 이제 역추적까지 곁들인 문제다. 역추적 부분은 dp 배열에서 최대 길이찾고 -1길이 찾고 … 순으로 진행했다.     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint N = Integer.parseInt(br.readLine()); \t\tint[] arr = new int[N+1]; \t\tint[] dp = new int[N+1]; \t\tArrays.fill(dp, 1); \t\t \t\tst = new StringTokenizer(br.readLine());         for(int i=1; i&lt;=N; i++) {             arr[i] = Integer.parseInt(st.nextToken());         }          \t\tList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); \t\tint maxLen = 1; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tfor(int j=1; j&lt;i; j++) { \t\t\t\tif(arr[i] &gt; arr[j]) dp[i] = Math.max(dp[i], dp[j]+1); \t\t\t} \t\t\tmaxLen = Math.max(maxLen, dp[i]); \t\t}  \t\t// 역추적 \t\tint len = maxLen;         for(int i=N; i&gt;=1; i--) {             if(dp[i] == len) {                 res.add(arr[i]);                 len--;             }         } \t\tsb.append(maxLen).append(\"\\n\"); \t\tfor(int i=res.size()-1; i&gt;=0; i--) {             sb.append(res.get(i) + \" \");         } \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }    C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int n;     cin &gt;&gt; n;     vector&lt;int&gt; arr(n + 1);     vector&lt;int&gt; dp(n + 1, 1);      for (int i = 1; i &lt;= n; i++) {         cin &gt;&gt; arr[i];     }      int maxLen = 1;     for (int i = 1; i &lt;= n; i++) {         for (int j = 1; j &lt; i; j++) {             if (arr[i] &gt; arr[j]) {                 dp[i] = max(dp[i], dp[j] + 1);             }         }         maxLen = max(maxLen, dp[i]);     }      // 역추적     vector&lt;int&gt; result;     int len = maxLen;     for (int i = n; i &gt;= 1; i--) {         if (dp[i] == len) {             result.push_back(arr[i]);             len--;         }     }      cout &lt;&lt; maxLen &lt;&lt; \"\\n\";     for (int i = result.size() - 1; i &gt;= 0; i--) {         cout &lt;&lt; result[i] &lt;&lt; \" \";     } }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_2565_전깃줄 (Java, C++)",
    "url": "/posts/BOJ2565%EC%A0%84%EA%B9%83%EC%A4%84-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-15 15:36:50 +0900",
    "content": "[Gold V] 전깃줄 - 2565  문제 링크  성능 요약  메모리: 2024 KB, 시간: 0 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 1월 15일 15:32:23  문제 설명  두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.  예를 들어, &lt; 그림 1 &gt;과 같이 전깃줄이 연결되어 있는 경우 A의 1번 위치와 B의 8번 위치를 잇는 전깃줄, A의 3번 위치와 B의 9번 위치를 잇는 전깃줄, A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면 남아있는 모든 전깃줄이 서로 교차하지 않게 된다.    &lt; 그림 1 &gt;  전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.  출력  첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.     문제 풀이     최장 증가 부분 수열(LIS, Longest Increasing Subsequence) 문제로 변환할 수 있다.  정렬의 의미 A 전봇대를 기준으로 오름차순 정렬하면, B 전봇대의 연결 위치들이 증가하는 순서로 있을 때 전깃줄이 교차하지 않는다.  교차하지 않는 조건 A 전봇대의 위치가 증가할 때 B 전봇대의 위치도 증가해야 전깃줄이 교차하지 않는다. 이는 곧 B 전봇대 위치들의 최장 증가 부분 수열을 찾는 문제가 된다.  답의 도출 LIS 길이 = 교차하지 않고 남길 수 있는 최대 전깃줄 개수 전체 전깃줄 수 - LIS 길이 = 제거해야 할 최소 전깃줄 개수  구현 단계     A 전봇대 기준으로 전깃줄 정보를 정렬   DP 배열을 이용해 LIS 계산   dp[i] = i번째 전깃줄을 마지막으로 하는 LIS의 길이   전체 전깃줄 개수에서 LIS 길이를 뺀 값이 정답  시간 복잡도     정렬: O(N log N)   LIS 계산: O(N²)   전체 시간 복잡도: O(N²)   LIS를 사용하는 이유 교차하지 않는 전깃줄들의 집합은 다음 성질을 만족해야함 :    A 전봇대의 번호가 증가할 때   B 전봇대의 번호도 증가해야 함      코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint N = Integer.parseInt(br.readLine()); \t\tint[][] board = new int[N+1][2]; \t\tint[] dp = new int[N+1]; \t\tArrays.fill(dp, 1); \t\t \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tboard[i][0] = Integer.parseInt(st.nextToken()); \t\t\tboard[i][1] = Integer.parseInt(st.nextToken()); \t\t} \t\tint res = 1; \t\t \t\tArrays.sort(board, (o1, o2) -&gt; o1[0] - o2[0]); \t\t \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tfor(int j=1; j&lt;i; j++) { \t\t\t\tif(board[i][1] &gt; board[j][1]) dp[i] = Math.max(dp[i], dp[j] + 1); \t\t\t} \t\t\tres = Math.max(dp[i], res); \t\t}  \t\tbw.write(String.valueOf(N - res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }    C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;      vector&lt;pair&lt;int, int&gt;&gt; board(N + 1);     vector&lt;int&gt; dp(N + 1, 1);      for (int i = 1; i &lt;= N; i++) {         cin &gt;&gt; board[i].first &gt;&gt; board[i].second;     }      sort(ALL(board));      int res = 0;     for (int i = 1; i &lt;= N; i++) {         for (int j = 1; j &lt; i; j++) {             if (board[i].second &gt; board[j].second)                 dp[i] = max(dp[i], dp[j] + 1);         }         res = max(res, dp[i]);     }     cout &lt;&lt; N - res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Operating System Concepts - (13)",
    "url": "/posts/Operating-System-Concepts-13/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-15 02:33:32 +0900",
    "content": "   Disk Management and Scheduling   Disk Structure    Logical block            디스크의 외부에서 보는 디스크의 단위 정보 저장 공간들       주소를 가진 1차원 배열처럼 취급       정보를 전송하는 최소 단위           Sector            Logical block이 물리적인 디스크에 매핑된 위치       Sector 0은 최외곽 실린더의 첫 트랙에 있는 첫 번째 섹터이다.       Logical Block과 Sector는 매핑되어 있음. 0번 섹터는 무조건 부팅과 관련된 데이터 저장.           Disk Management    Physical Formatting (low-level formatting)            디스크를 컨트롤러가 읽고 쓸 수 있도록 섹터들로 나누는 과정       각 섹터는 header + data(512bytes) + trailer로 구성       header와 trailer는 sector number, ECC(Error-Correcting Code) 등의 정보가 저장되며 controller가 직접 접근 및 운영.           Partitioning            디스크를 하나 이상의 실린더 그룹으로 나누는 과정       OS는 이것을 독립적인 disk로 취급함 (logical disk)           Logical Formatting            파일 시스템을 만드는 것       FAT, inode, free space등의 구조 포함           Booting            ROM에 있는 “small bootstrap loader”의 실행 (CPU의 instruction 형태로 실행됨.)       sector 0(boot block)을 memory에 load하여 실행       sector 0은 “full Bootstrap loader program”       OS를 디스크에서 load하여 실행           Disk Scheduling     Access time의 구성            Seek time                    같은 트랙에 위치하는 것을 실린더라고 하는데, 해당 실린더로 헤드를 움직이는 데 걸리는 시간을 의미한다.                       Rotational latency                    seek time보다 1/10정도의 적은 시간 소요                       Transfer time                    실제 데이터의 전송 시간. 매우 작은 시간 소요                           Disk bandwidth            단위 시간 당 전송된 바이트의 수           Disk Scheduling            seek time을 최소화하는 것이 목표 (디스크 접근 시간이 거의 seek time에 따라 좌우되기 때문에)       seek time = seek distance           Disk Scheduling Algorithm 큐에 다음과 같은 실린더 위치의 요청이 존재하는 경우 디스크 헤드 53번에서 시작한 각 알고리즘의 수행 결과는? (실린더 위치는 0-199) 98, 183, 37, 122, 14, 124, 65, 67  1. FCFS     처음부터 순서대로 진행   디스크가 상당히 많이 이동하는 것을 볼 수 있음.   비효율적   2. SSTF (Shortest Seek Time First)    head의 위치에서 가장 가까운 요청부터 처리. (seek time이 가장 적기 때문에)   디스크 헤드의 이동거리는 줄어들지만 starvation 문제 발생 가능성 높음.   3. SCAN (= elevator scheduling)      disk arm이 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 골목에 있는 모든 요청을 처리한다.   다른 한쪽의 끝에 도달하면 역방향으로 이동하며 오는 길목에 있는 모든 요청을 처리하며 다시 반대쪽 끝으로 이동한다.   문제점 : 실린더 위치에 따라 대기 시간이 다르다.   엘레베이터 작동 원리에 비유함.   4. C-SCAN (circular scan)    헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리   다른쪽 끝에 도달했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동   SCAN보다 균일한 대기 시간을 제공한다.     5. N-SCAN      SCAN의 변형 알고리즘   일단 arm이 한 방향으로 움직이기 시작하면 그 시점 이후에 도착한 job은 되돌아올 때 service   6. LOOK, C-LOOK    SCAN이나 C-SCAN은 헤드가 디스크 끝에서 끝으로 이동   LOOK과 C-LOOK은 헤드가 진행 중이다가 그 방향에 더 이상 기다리는 요청이 없으면 헤드의 이동방향을 즉시 반대로 이동한다.    Disk Scheduling Algorithm의 결정    SCAN, C-SCAN 및 그 응용 알고리즘은 LOOK, C-LOOK 등이 일반적으로 디스크 입출력이 많은 시스템에서 효율적인 것으로 알려져 있음.   file의 할당 방법에 따라 디스크 요청이 영향을 받음.   디스크 스케쥴링 알고리즘은 필요할 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 OS와 별도의 모듈로 작성되는 것이 바람직하다.   Swap-Space Management     메모리가 휘발성인 특성을 가지고 있기 때문에 비휘발성인 디스크를 사용하는 것   메모리의 공간이 부족하기 때문에 메모리의 연장 공간으로 SWAP Space를 할당하여 사용함.   Swap-space            물리적인 디스크를 파티셔닝하여 논리적인 디스크를 만든 후 그 논리적인 디스크 하나를 swap으로 할당하는 것.       보통 큰 단위의 데이터를 올리고 내리면서 짧은 시간에 빠르게 서비스를 사용함. (512K)           RAID    RAID (Redundant Array of Independent Disks)            여러 개의 디스크를 묶어서 사용           RAID의 사용 목적            디스크 처리 속도 향상                    여러 디스크에 block의 내용을 분산 저장           병렬적으로 읽어 옴 (interleaving, striping)                       신뢰성 (reliability) 향상                    동일 정보를 여러 디스크에 중복 저장           하나의 디스크가 고장(failure) 시 다른 디스크에서 읽어옴(Mirroring, shadowing)           단순한 중복 저장이 아니라 일부 디스크에 parity를 저장하여 공간의 효율성을 높일 수 있다.                           UNIX 파일 시스템     inode에는 메타데이터 정보를 보관하고 있다.    현재 가장 많이 사용되는 파일시스템은 EXT4이다.   현재 가장 많이 사용되는 파일시스템은 EXT4이다.     indirect pointer는 큰 파일을 지원하기 위해서이다.       원래 파일에 접근하기 위해서는 메타데이터에 접근하고, 실제 파일에 접근하는데 i-node block과 data block을 왔다갔다하는 것은 디스크 헤더가 많이 움직인다. 이러한 단점을 보완하기 위해서 블록의 그룹화가 나왔다.       그룹에 대한 총체적인 정보를 담고 있는 것이 Group descriptor이다.   사용적인 블록과 비어있는 그룹은 block bitmap으로 구분한다.    Ext4 파일시스템   What happened?     버퍼캐시는 휘발성   전원이 나가서 메모리의 내용이 휘발되면 파일시스템의 내용이 깨질 수 있다.   How to solve this problem?     버퍼캐시에서 쫓겨날때 파일에 저장을 해주는 것이 아니라, 주기적으로 스토리지에 써주는 것이다. 파일시스템에 쓰는것이 아니라 저널 영역이라는 것에 써주는 것이다. 도중에 크래쉬가 나더라도 저널영역에 있는 것을 옮겨쓰면 된다.    Ext4의 저널링 (메타데이터 저널링 모드)     이건 메타데이터만 저널링하는 방법이다. 메타데이터만 저널링했기 때문에 파일의 위치정보는 깨지지않는다. 일반 데이터는 깨질 수 있다.   Ext4의 저널링 (데이터 저널링 모드)   파일시스템을 위한 버퍼캐시 알고리즘     LRU와 LFU 둘다 일부분의 정보만 사용하기 때문에 단점이 있다.   LRFU 알고리즘   LRFU 알고리즘의 실효성     어떤 것을 쫓아낼지 logn 안에 결정 할 수 있어야하는데 이렇게하면 O(n)이다.   LRFU의 효율적인 구현 방법   "
  },
  
  {
    "title": "BOJ_11973_Angry Cows (Silver) (Java)",
    "url": "/posts/BOJ11973Angry-Cows-Silver-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-14 23:13:35 +0900",
    "content": "[Silver I] Angry Cows (Silver) - 11973  문제 링크  성능 요약  메모리: 22528 KB, 시간: 248 ms  분류  이분 탐색, 매개 변수 탐색  제출 일자  2025년 1월 14일 22:54:46  문제 설명  Bessie the cow has designed what she thinks will be the next big hit video game: “Angry Cows”. The premise, which she believes is completely original, is that the player shoots cows with a slingshot into a one-dimensional scene consisting of a set of hay bales located at various points on a number line. Each cow lands with sufficient force to detonate the hay bales in close proximity to her landing site. The goal is to use a set of cows to detonate all the hay bales.  There are \\(N\\) hay bales located at distinct integer positions \\(x_1, x_2, \\ldots, x_N\\) on the number line. If a cow is launched with power \\(R\\) landing at position \\(x\\), this will cause a blast of “radius \\(R\\)”, destroying all hay bales within the range \\(x-R \\ldots x+R\\).  A total of \\(K\\) cows are available to shoot, each with the same power \\(R\\). Please determine the minimum integer value of \\(R\\) such that it is possible to use the \\(K\\) cows to detonate every single hay bale in the scene.  입력 The first line of input contains \\(N(1≤N≤50,000)\\) and \\(K(1≤K≤10)\\). The remaining \\(N\\) lines lines all contain integers \\(x_1 \\ldots x_N\\) (each in the range \\(0 \\ldots 1,000,000,000\\)).  출력 Please output the minimum power \\(R\\) with which each cow must be launched in order to detonate all the hay bales.     문제 풀이   R을 결정하는 문제다.    파라매트릭 서치를 활용했다.  반지름임에 주의.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, K, arr[], res; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tN = Integer.parseInt(st.nextToken()); \t\tK = Integer.parseInt(st.nextToken()); \t\tarr = new int[N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(br.readLine()); \t\t} \t\tArrays.sort(arr);  \t\tint left = 0; \t\tint right = (arr[N-1] - arr[0]);  \t\t \t\twhile(left &lt;= right) { \t\t\tint mid = left + (right - left)/2; \t\t\tif(count(2 * mid)) { \t\t\t\tres = mid; \t\t\t\tright = mid - 1; \t\t\t}else { \t\t\t\tleft = mid + 1; \t\t\t} \t\t} \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t \tprivate boolean count(int mid) { \t\tint cnt = 1; \t\tint start = 0; \t\tfor(int i=1; i&lt;N; i++) { \t\t\tif(arr[i] - arr[start] &gt; mid) { \t\t\t\tcnt++; \t\t\t\tstart = i; \t\t\t} \t\t\tif(cnt &gt; K) return false; \t\t} \t\treturn cnt &lt;= K; \t} }   혹은 지름으로 계산한다면  /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, K, arr[], res; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tN = Integer.parseInt(st.nextToken()); \t\tK = Integer.parseInt(st.nextToken()); \t\tarr = new int[N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(br.readLine()); \t\t} \t\tArrays.sort(arr);  \t\tint left = 0; \t\tint right = (arr[N-1] - arr[0]);  \t\t \t\twhile(left &lt;= right) { \t\t\tint mid = left + (right - left)/2; \t\t\tif(count(mid)) { \t\t\t\tres = mid; \t\t\t\tright = mid - 1; \t\t\t}else { \t\t\t\tleft = mid + 1; \t\t\t} \t\t} \t\tbw.write(String.valueOf((res+1)/2)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t \tprivate boolean count(int mid) { \t\tint cnt = 1; \t\tint start = 0; \t\tfor(int i=1; i&lt;N; i++) { \t\t\tif(arr[i] - arr[start] &gt; mid) { \t\t\t\tcnt++; \t\t\t\tstart = i; \t\t\t} \t\t\tif(cnt &gt; K) return false; \t\t} \t\treturn cnt &lt;= K; \t} }  "
  },
  
  {
    "title": "BOJ_2961_도영이가 만든 맛있는 음식 (Java)",
    "url": "/posts/BOJ2961%EB%8F%84%EC%98%81%EC%9D%B4%EA%B0%80-%EB%A7%8C%EB%93%A0-%EB%A7%9B%EC%9E%88%EB%8A%94-%EC%9D%8C%EC%8B%9D-Java/",
    "categories": "알고리즘",
    "tags": "",
    "date": "2025-01-14 21:28:02 +0900",
    "content": "[Silver II] 도영이가 만든 맛있는 음식 - 2961 문제 링크 성능 요약 메모리: 14256 KB, 시간: 104 ms 분류 백트래킹, 비트마스킹, 브루트포스 알고리즘 제출 일자 2025년 1월 14일 21:13:23 문제 설명 도영이는 짜파구리 요리사로 명성을 날렸었다. 이번에는 이전에 없었던 새로운 요리에 도전을 해보려고 한다.  지금 도영이의 앞에는 재료가 N개 있다. 도영이는 각 재료의 신맛 S와 쓴맛 B를 알고 있다. 여러 재료를 이용해서 요리할 때, 그 음식의 신맛은 사용한 재료의 신맛의 곱이고, 쓴맛은 합이다.  시거나 쓴 음식을 좋아하는 사람은 많지 않다. 도영이는 재료를 적절히 섞어서 요리의 신맛과 쓴맛의 차이를 작게 만들려고 한다. 또, 물을 요리라고 할 수는 없기 때문에, 재료는 적어도 하나 사용해야 한다.  재료의 신맛과 쓴맛이 주어졌을 때, 신맛과 쓴맛의 차이가 가장 작은 요리를 만드는 프로그램을 작성하시오.  입력  첫째 줄에 재료의 개수 N(1 ≤ N ≤ 10)이 주어진다. 다음 N개 줄에는 그 재료의 신맛과 쓴맛이 공백으로 구분되어 주어진다. 모든 재료를 사용해서 요리를 만들었을 때, 그 요리의 신맛과 쓴맛은 모두 1,000,000,000보다 작은 양의 정수이다.  출력 첫째 줄에 신맛과 쓴맛의 차이가 가장 작은 요리의 차이를 출력한다.      문제 풀이   dfs로 모든 조합을 검사해보며 최소값을 갱신했다. 최소 하나의 재료는 골라야한다는 조건을 비트마스킹 방문조건처리인 visited값이 0보다 큰지 검사로 적용했다. n&lt;=10이란 조건이 있어 가능했다     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*; public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, visited, flavor[][], res=Integer.MAX_VALUE; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t} \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\tvisited = 0; \t\tflavor = new int[N][2]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new  StringTokenizer(br.readLine()); \t\t\tflavor[i][0] = Integer.parseInt(st.nextToken()); \t\t\tflavor[i][1] = Integer.parseInt(st.nextToken()); \t\t} \t\tdfs(0, visited, 1, 0); \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \tprivate void dfs(int depth, int visited, int sour, int bitter) { \t\tif(depth == N) { \t\t\tif(visited &gt; 0) { \t\t\t\tres = Math.min(res, Math.abs(sour - bitter)); \t\t\t} \t\t\treturn;\t \t\t} \t\t \t\tdfs(depth + 1, visited | (1&lt;&lt;depth), sour * flavor[depth][0], bitter + flavor[depth][1]); \t\tdfs(depth + 1, visited, sour, bitter); \t\t \t} }    C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int n, res; vector&lt;pair&lt;int, int&gt;&gt; flavor;  void dfs(int depth, int visited, int sour, int bitter) {     if (depth == n) {         if (visited &gt; 0) {             res = min(res, abs(sour - bitter));         }         return;     }      dfs(depth + 1, visited | (1 &lt;&lt; depth), sour * flavor[depth].first,         bitter + flavor[depth].second);     dfs(depth + 1, visited, sour, bitter); }  void solve() {     cin &gt;&gt; n;     flavor.resize(n);     for (int i = 0; i &lt; n; i++) {         cin &gt;&gt; flavor[i].first &gt;&gt; flavor[i].second;     }     res = INT_MAX;     dfs(0, 0, 1, 0);     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Operating System Concepts - (12)",
    "url": "/posts/Operating-System-Concepts-12/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-14 17:51:31 +0900",
    "content": "   File System (2)   File System Implementations  Allocation of File Data in Disk    Contiguous Allocation   Linked Allocation   Indexed Allocation   Contiguous Allocation      하나의 파일이 디스크 상에서 연속해서 할당되는 방법   단점            External fragmentation 발생 가능                    파일 크기가 균일하지 않아 빈 조각들이 있을것이다. 새로운 파일을 넣을 때 비어있는 블럭의 크기에 따라 들어갈 수 없는 경우 활용될 수 없는 외부 조각이 생기게 된다.                       File grow가 어려움                    file 생성 시 얼마나 큰 hole을 배당할 것인가? (미리 빈공간을 할당하는 방법)           grow 가능 vs 낭비 (Internal fragmentation)                           장점            Fast I/O                    한번의 seek/rotation으로 많은 바이트 transfer           Realtime file용으로, 또는 이미 run 중이던 process의 swapping용                       Direct access(=random access)가능           Linked Allocation      빈 자리가 있으면 아무 곳이나 할당함.   블록의 마지막 부분에 다음 블록이 어디에 위치해 있는지 저장해 두는 것 (연결해 두는 것)   파일의 시작 위치만을 디렉토리가 가지고 있게 되는 것.   장점            External Fragmentation이 발생되지 않음.           단점            Direct Access (Random Access) 불가능. 첫번째 위치만 저장해 두기 때문에 순차 접근만 가능하게 됨.       Reliability 문제                    한 Sector가 고장나 pointer가 유실되면 많은 부분을 잃을 위험이 있음.                       Pointer를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어뜨림.                    512 bytes/sector, 4bytes/pointer                       변형                    File-allocation table(FAT) 파일 시스템                            포인터를 별도의 위치에 보관하여 reliability와 공간 효율성 문제 해결                                                   Indexed Allocation      장점            External Fragmentation이 발생하지 않음       Direct Access (= Random Access) 가능           단점            Small file의 경우 공간 낭비 (실제로 많은 file들이 small)       Too Large File의 경우 하나의 block으로 Index를 저장하기에 부족       해결 방안                    linked scheme ( 큰 파일은 링크드 블럭의 마지막 인덱스를 다음 인덱스 블럭의 위치값을넣음 )           multi-level index ( 2단계 페이지 테이블처럼 인덱스가 다른 인덱스를 가리키도록)           공간 낭비는 늘어남                           UNIX File System Structure      유닉스 파일 시스템의 중요 개념            Boot Block                    부팅에 필요한 정보 (bootstrap loader)                       Super Block                    파일 시스템에 관한 총체적인 정보를 담고 있다.                       Inode                    파일 이름을 제외한 파일의 모든 메타 데이터를 저장                       Data Block                    파일의 실제 내용을 보관           Directory file에는 각 file 이름과 inode 번호가 저장되어 있음.           나머지 정보들은 inode에 저장되어 있지만 file name은 directory에 저장됨.                           index allocation을 변형하여 사용하는 파일 시스템 구조   Direct blocks/single indirect/double indirect/triple indirect 로 나누어 inode를 구성함.   FAT file System     file의 metadata 정보를 FAT에 저장함   나머지 정보는 directory가 가지고 있음. 파일의 이름, 접근 권한, 소유주 등등.   FAT 파일 테이블은 여러번 copy되어 저장하고 있기 때문에 reliability 문제는 해결 가능함.   Free-Space Management          Bit map or bit vector       Linked List            모든 free block들을 링크로 연결 (free list)       연속적인 가용 공간을 찾는 것은 쉽지 않다.       공간의 낭비가 없다.       실제로 사용하기는 쉽지 않은 방법           Grouping            Linked list 방법의 변형       첫번째 free block이 n개의 pointer를 가짐       n-1 pointer는 free data block을 가리킴       마지막 pointer가 가리키는 block은 또 다시 n pointer를 가짐           Counting            프로그램들이 종종 여러 개의 연속적인 block을 할당하고 반납한다는 성질에 착안한 방법       빈 블럭 위치와 몇개가 빈 블럭인지       First free block, # of contiguous free blocks를 유지           Directory Implementation         Linear List      &lt;file name, file의 metadata&gt; 의 list   구현이 간단   디렉토리 내에 파일이 있는지 찾기 위해서는 linear search 필요 (time-consuming)   Hash Table            Linear List + hashing       Hash table은 file name을 이 파일의 linear list의 위치로 바꾸어줌.       search time을 없앰       Collision 발생 가능                File의 metadata의 보관 위치            디렉토리 내에 직접 보관       디렉토리에는 포인터를 두고 다른 곳에 보관                    inode, FAT 등                           Long file name의 지원            &lt;file name, file의 metadata&gt;의 list에서 각 entry는 일반적으로 고정 크기       file name이 고정 크기의 entry 길이보다 길어지는 경우 entry의 마지막 부분에 이름의 뒷부분이 위치한 곳의 포인터를 두는 방법       이름의 나머지 부분은 동일한 directory file의 일부에 존재             VFS and NFS     Virtual File System (VFS)            서로 다른 다양한 file system에 대해 동일한 시스템 콜 인터페이스 (API)를 통해 접근할 수 있게 해주는 OS의 Layer           Network File System (NFS)            분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있음       NFS는 분산 환경에서의 대표적인 파일 공유 방법임.           Page cache and Buffer Cache    Page cache            Virtual Memory의 Paging System에서 사용하는 page frame을 caching의 관점에서 설명하는 용어       Memory-Mapped I/O를 쓰는 경우 file의 I/O에서도 page cache 사용           Memory-Mapped I/O            File의 일부를 virtual memory에 mapping 시킴       매핑시킨 영역에 대한 메모리 접근 연산은 파일의 입출력을 수행하게 함.           Buffer Cache            파일 시스템을 통한 I/O 연산은 메모리의 특정 영역인 buffer cache 사용       File 사용의 locality 활용                    한번 읽어온 block에 대한 후속 요청 시 buffer cache에서 즉시 전달                       모든 프로세스가 공용으로 사용       Replacement algorithm 필요 (LRU, LFU 등)           Unified Buffer Cache            최근의 OS에서는 기존의 buffer cache가 page cache에 통합됨.               페이지 프레임에는 당장 사용하는 데이터를 올려놓고, 나머지는 디스크에 저장해두는 것.   디스크에서 읽어온 내용을 자신의 buffer cache에 올려놓고, 그것을 copy해 사용자에게 전달.   보통 4kbyte 단위의 page 사용 / Disk I/O 단위는 512Byte   Unified Buffer Cache 를 사용하게 되면 단위가 통합되어 4Kbyte 단위의 buffer cache, page cache 사용   별도의 공간 구분을 하지 않고 똑같이 page 단위로 사용하면서 필요할 때마다 buffer cache/page cache로 사용하는 것 (필요시마다 할당)    "
  },
  
  {
    "title": "CORS란?",
    "url": "/posts/CORS%EB%9E%80/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-14 02:28:05 +0900",
    "content": "CORS(Cross Origin Resource Sharing)는 출처가 다른 곳의 리소스를 요청할 때 접근 권한을 부여하는 메커니즘이다. 리소스를 주고받는 두 곳의 출처가 다르면 출처가 교차한다고 한다. 이때 출처는 URL뿐만 아니라 프로토콜과 포트까지 포함된다. 만약 클라이언트의 출처가 허용되지 않았다면 CORS 에러가 발생할 수 있다.  CORS는 왜 필요할까? 과거에는 크로스 사이트 요청 위조(CSRF, Cross-Site Request Forgery) 문제가 있었다. 피해자의 브라우저에서 다른 애플리케이션으로 가짜 클라이언트 요청을 전송하는 공격이다.  CSRF를 예방하기 위해 브라우저는 동일 출처 정책(SOP, same-origin policy)을 구현했다. SOP가 구현된 브라우저는 클라이언트와 동일한 출처의 리소스로만 요청을 보낼 수 있다.  하지만, SOP는 한계가 있습니다. 현대의 웹 애플리케이션은 다른 출처의 리소스를 사용하는 경우가 많기 때문이다. 따라서, SOP를 확장한 CORS가 필요하다.  CORS의 작동 원리  브라우저가 요청 메시지에 Origin 헤더와 응답 메시지의 Access-Control-Allow-Origin 헤더를 비교해서 CORS를 위반하는지 확인한다. 이때, Origin에는 현재 요청하는 클라이언트의 출처(프로토콜, 도메인, 포트)가, Access-Control-Allow-Origin은 리소스 요청을 허용하는 출처가 작성된다.  이렇게 단순하게 요청하는 것을 Simple Request라고 한다. Simple Request은 요청 메서드(GET, POST, HEAD), 수동으로 설정한 요청 헤더(Accept, Accept-Language, Content-Language, Content-Type, Range), Content-Type 헤더(application/x-www-form-urlencoded, multipart/form-data, text/plain)인 경우에만 해당한다.  브라우저가 사전 요청을 보내는 경우도 있다. 이때 사전 요청을 Preflight Request라고 한다. 브라우저가 본 요청을 보내기 이전, Preflight Request를 OPTIONS 메서드로 요청을 보내어 실제 요청이 안전한지 확인한다.  Preflight Request는 추가로 Access-Control-Request-Method로 실 요청 메서드와, Access-Control-Request-Headers 헤더에 실 요청의 추가 헤더 목록을 담아서 보내야 한다.  이에 대한 응답은 대응되는 Access-Control-Allow-Methods와 Access-Control-Headers를 보내야 하고, Preflight Request로 인한 추가 요청을 줄이기 위해 캐시 기간을 Access-Control-Max-Age에 담아서 보내야 한다.  또한 인증된 요청을 사용하는 방식도 있는데 이를 Credential Request라고 한다. 쿠키나 토큰과 같은 인증 정보를 포함한 요청은 더욱 안전하게 처리되어야 한다. 이때 Credential Request를 수행한다.  Credential Request를 요청하는 경우에는 서버에서는 Access-Control-Allow-Credentials를 true로 설정해야 하며 Access-Control-Allow-Origin에 와일드카드를 사용하지 못한다.  References     토스페이먼츠 - CORS 대응하기   MDN - 교차 출처 리소스 공유 (CORS)  "
  },
  
  {
    "title": "Operating System Concepts - (11)",
    "url": "/posts/Operating-System-Concepts-11/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-14 02:14:39 +0900",
    "content": "   File System (1)   File and File System         File            ” A named collection of related information “       일반적으로 비휘발성의 보조기억장치(e.g. hard disk) 에 저장       운영체제는 다양한 저장장치를 file이라는 동일한 논리적 단위로 볼 수 있게 해줌.       Operation : create, read, write, reposition(lseek), delete, open, close 등                File Attribute (or File metadata)            파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보들                    파일 이름, 유형, 저장된 위치, 파일 사이즈           접근 권한 (읽기/쓰기/실행), 시간 (생성/변경/사용), 소유자 등                                File System            운영체제에서 파일을 관리하는 부분       파일 및 파일의 메타데이터, 디렉토리 정보 등을 관리       파일의 저장 방법 결정       파일 보호 등           Directory and Logical Disk         Directory            파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 파일       그 디렉토리에 속한 파일 이름 및 파일 attribute들       Operation                    Search for a file, create a file, delete a file           list a directory, rename a file, traverse the file system                                Partition (= Logical disk)            하나의 (물리적) 디스크 안에 여러 파티션을 두는 것이 일반적       여러 개의 물리적인 디스크를 하나의 파티션으로 구성하기도 함       (물리적) 디스크를 파티션으로 구성한 뒤 각각의 파티션에 file system을 깔거나 swapping등 다른 용도로 사용할 수 있음.           open()      open(“/a/b/c”)            디스크로부터 파일 c의 메타데이터를 메모리로 가지고 옴       이를 위하여 directory path를 search                    루트 디렉토리 “/”를 open하고 그 안에서 파일 “a”의 위치 획득           파일 “a”를 open한 후 read하여 그 안에서 파일 “b”의 위치 획득           파일 “b”를 open한 후 read하여 그 안에서 파일 “c”의 위치 획득           파일 “c”를 open한다.                       Directory path의 search에 너무 많은 시간이 소요됨.                    Open을 read/write와 별도로 두는 이유           한번 open한 파일은 read/write시 directory search 불필요                       Open file table                    현재 open된 파일들의 메타데이터 보관소 (in memory)           디스크의 메타데이터보다 몇 가지 정보가 추가                            Open한 프로세스의 수               File offset : 파일 어느 위치 접근 중인지 표시 (별도 테이블 필요)                                               File descriptor (file handle, file control block)                    Open file table에 대한 위치 정보 (프로세스 별)                               사용자 프로그램이 시스템 콜 ( /a/b 파일을 open하겠다 )   CPU 제어권이 OS로 넘어간다.   이미 알고있던 root 디렉토리의 metadata를 메모리로 올린다. ( root를 먼저 open한다 )   root의 metadata에는 파일의 위치정보가 있으므로 이를 열어보면 root 디렉토리의 실제 내용이 어디있는지 위치를 찾을 수 있다.   root라는건 디렉토리 파일이기 때문에 이 디렉토리 하위 데이터의 metadata가 내용으로 들어가있다.   a/b/였으므로 a의 메타데이터도 있으므로 a의 메타데이터도 메모리로 올린다. ( a를 open )   a의 metadata에는 a파일이 disk의 어디에 있는지 정보가 있고 찾아가서 내용을 열어보면 a라는 파일도 디렉토리 파일이다. a안에 b의 metadata도 있을것이다.   b도 반복하면 디스크의 b의 메타데이터도 찾아갈 수 있을것이다.   open이 끝나면 각 프로세스마다 그 프로세스가 open한 파일들에 대한 metadata포인터를 가지고 있는 배열에서 그 위치를 가리키는 포인터를 리턴한다. 이 리턴값을 file descriptor이라고 한다. 이 fd를 return한다.   사용자 프로세스는 fd 값만 가지고 read write 등의 요청을 할 수 있다.   이때 read로 b의 내용을 읽어서 사용자 프로그램에게 전해주기 전에 먼저 운영체제가 자신의 메모리공간 일부분에 올려놓는다. 그 내용을 copy해서 사용자 프로그램에게 전달하는 것이다. 만약 어떤 프로그램이 동일한 파일의 동일한 위치를 요청하면 (Read System Call하면) Disk까지 가지 않고 운영체제가 Buffer Chaching을 통해 바로 전달해준다.  *이전 가상메모리 시스템에서는 페이징 기법에서 이미 메모리에 올라와 있는 페이지에 대해서는 운영체제가 중간에 끼어들지 못하고 하드웨어가 주소변환을 해서 바로 접근을 했다. Page Fault가 일어나면 CPU가 운영체제에게 넘어와서 운영체제가 Swap 영역에서 page를 읽어왔다. 이에 비해 file시스템에서는 이미 버퍼 캐싱 내용이 메모리에 있든 없든 System Call이기 때문에 CPU가 운영체제로 넘어온다. LRU, LFU 알고리즘을 자연스럽게 사용하게 된다. 페이징시스템에서 Clock 알고리즘을 썼던 것과 대조된다.  또한 Open file table에는 offset이라는 정보도 필요하다. 특정 프로세스가 특정 파일의 어디를 읽고있는지를 구분하기 위한 장치다. 그렇기 때문에 프로세스와 무관한 공통 정보인 파일의 metadata와 프로세스마다 개별로 file의 어디를 읽고있는지를 나타내는 offset이 필요하다.  File Protection  💡 File System의 Mounting     마운트를 하게 되면 또 다른 파일 시스템의 root를 연결할 수 있음.   디스크에 또 다른 디스크를 연결하는 것.   Access Methods    시스템이 제공하는 파일 정보의 접근 방식            순차 접근 (sequential access)                    카세트 테이프를 사용하는 방식처럼 접근           읽거나쓰면 offset은 자동적으로 증가                       직접 접근 (direct access, random access)                    LP 레코드 판과 같이 접근하도록 함           파일을 구성하 레코드를 임의의 순서로 접근할 수 있음.                          "
  },
  
  {
    "title": "BOJ_15591_MooTube (Silver) (Java)",
    "url": "/posts/BOJ15591MooTube-Silver-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-14 02:14:21 +0900",
    "content": "[Gold V] MooTube (Silver) - 15591 문제 링크 성능 요약 메모리: 449696 KB, 시간: 2008 ms 분류 너비 우선 탐색, 깊이 우선 탐색, 그래프 이론, 그래프 탐색 제출 일자 2025년 1월 13일 21:57:20 문제 설명 농부 존은 남는 시간에 MooTube라 불리는 동영상 공유 서비스를 만들었다. MooTube에서 농부 존의 소들은 재밌는 동영상들을 서로 공유할 수 있다. 소들은 MooTube에 1부터 N까지 번호가 붙여진 N (1 ≤ N ≤ 5,000)개의 동영상을 이미 올려 놓았다. 하지만, 존은 아직 어떻게 하면 소들이 그들이 좋아할 만한 새 동영상을 찾을 수 있을지 괜찮은 방법을 떠올리지 못했다. 농부 존은 모든 MooTube 동영상에 대해 “연관 동영상” 리스트를 만들기로 했다. 이렇게 하면 소들은 지금 보고 있는 동영상과 연관성이 높은 동영상을 추천 받을 수 있을 것이다. 존은 두 동영상이 서로 얼마나 가까운 지를 측정하는 단위인 “USADO”를 만들었다. 존은 N-1개의 동영상 쌍을 골라서 직접 두 쌍의 USADO를 계산했다. 그 다음에 존은 이 동영상들을 네트워크 구조로 바꿔서, 각 동영상을 정점으로 나타내기로 했다. 또 존은 동영상들의 연결 구조를 서로 연결되어 있는 N-1개의 동영상 쌍으로 나타내었다. 좀 더 쉽게 말해서, 존은 N-1개의 동영상 쌍을 골라서 어떤 동영상에서 다른 동영상으로 가는 경로가 반드시 하나 존재하도록 했다. 존은 임의의 두 쌍 사이의 동영상의 USADO를 그 경로의 모든 연결들의 USADO 중 최솟값으로 하기로 했다. 존은 어떤 주어진 MooTube 동영상에 대해, 값 K를 정해서 그 동영상과 USADO가 K 이상인 모든 동영상이 추천되도록 할 것이다. 하지만 존은 너무 많은 동영상이 추천되면 소들이 일하는 것이 방해될까 봐 걱정하고 있다! 그래서 그는 K를 적절한 값으로 결정하려고 한다. 농부 존은 어떤 K 값에 대한 추천 동영상의 개수를 묻는 질문 여러 개에 당신이 대답해주기를 바란다. 입력 입력의 첫 번째 줄에는 N과 Q가 주어진다. (1 ≤ Q ≤ 5,000) 다음 N-1개의 줄에는 농부 존이 직접 잰 두 동영상 쌍의 USADO가 한 줄에 하나씩 주어진다. 각 줄은 세 정수 pi, qi, ri (1 ≤ pi, qi ≤ N, 1 ≤ ri ≤ 1,000,000,000)를 포함하는데, 이는 동영상 pi와 qi가 USADO ri로 서로 연결되어 있음을 뜻한다. 다음 Q개의 줄에는 농부 존의 Q개의 질문이 주어진다. 각 줄은 두 정수 ki와 vi(1 ≤ ki ≤ 1,000,000,000, 1 ≤ vi ≤ N)을 포함하는데, 이는 존의 i번째 질문이 만약 K = ki라면 동영상 vi를 보고 있는 소들에게 몇 개의 동영상이 추천될 지 묻는 것이라는 것을 뜻한다. 출력 Q개의 줄을 출력한다. i번째 줄에는 농부 존의 i번째 질문에 대한 답변이 출력되어야 한다.     문제 풀이   bfs로 두 정점 사이의 점수를 구한다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*; public class Main { \tclass Node{ \t\tint from, to, v; \t\tpublic Node(int from, int to, int v) { \t\t\tthis.from = from; \t\t\tthis.to = to; \t\t\tthis.v = v; \t\t} \t} \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int N, Q, board[][], p, q, r, k, v; \tstatic ArrayList&lt;Node&gt;[] related; \tstatic boolean visited[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t} \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tQ = Integer.parseInt(st.nextToken()); \t\tboard = new int[N+1][N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t    Arrays.fill(board[i], Integer.MAX_VALUE); \t\t} \t\trelated = new ArrayList[N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\trelated[i] = new ArrayList&lt;Node&gt;(); \t\t} \t\tfor(int i=0; i&lt;N-1; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tp = Integer.parseInt(st.nextToken()); \t\t\tq = Integer.parseInt(st.nextToken()); \t\t\tr = Integer.parseInt(st.nextToken()); \t\t\trelated[p].add(new Node(p, q, r)); \t\t\trelated[q].add(new Node(q, p, r)); \t\t\tboard[p][q] = r; \t\t\tboard[q][p] = r; \t\t} \t\t \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tbfs(i); \t\t} \t\t \t\tint res = 0; \t\tfor(int i=0; i&lt;Q; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tk = Integer.parseInt(st.nextToken()); \t\t\tv = Integer.parseInt(st.nextToken()); \t\t\t \t\t\tres = 0; \t\t\tfor(int j=1; j&lt;=N; j++) { \t\t\t\tif(j != v &amp;&amp; board[v][j] &gt;= k) res++; \t\t\t} \t\t\tsb.append(res).append(\"\\n\"); \t\t} \t\t //\t\tfor(int i=1; i&lt;N; i++) { //\t\t\tfor(int j=1; j&lt;N; j++) { //\t\t\t\tSystem.out.print(board[i][j] + \" \"); //\t\t\t} //\t\t\tSystem.out.println(); //\t\t} \t\t \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \tprivate void bfs(int i) { \t\tQueue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); \t\tvisited = new boolean[N+1]; \t\t \t\tqueue.offer(i); \t\tvisited[i] = true; \t\t \t\twhile(!queue.isEmpty()) { \t\t\tint curr = queue.poll(); \t\t\tfor(Node n : related[curr]) { \t\t\t\tif(!visited[n.to]) { \t\t\t\t\tboard[i][n.to] = Math.min(board[i][curr], n.v); \t\t\t\t\tqueue.offer(n.to); \t\t\t\t\tvisited[n.to] = true; \t\t\t\t} \t\t\t} \t\t} \t} }  "
  },
  
  {
    "title": "BOJ_2805_나무 자르기 (Java)",
    "url": "/posts/BOJ2805%EB%82%98%EB%AC%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-13 20:52:25 +0900",
    "content": "[Silver II] 나무 자르기 - 2805  문제 링크  성능 요약  메모리: 120652 KB, 시간: 920 ms  분류  이분 탐색, 매개 변수 탐색  제출 일자  2025년 1월 13일 20:47:21  문제 설명  상근이는 나무 M미터가 필요하다. 근처에 나무를 구입할 곳이 모두 망해버렸기 때문에, 정부에 벌목 허가를 요청했다. 정부는 상근이네 집 근처의 나무 한 줄에 대한 벌목 허가를 내주었고, 상근이는 새로 구입한 목재절단기를 이용해서 나무를 구할것이다.  목재절단기는 다음과 같이 동작한다. 먼저, 상근이는 절단기에 높이 H를 지정해야 한다. 높이를 지정하면 톱날이 땅으로부터 H미터 위로 올라간다. 그 다음, 한 줄에 연속해있는 나무를 모두 절단해버린다. 따라서, 높이가 H보다 큰 나무는 H 위의 부분이 잘릴 것이고, 낮은 나무는 잘리지 않을 것이다. 예를 들어, 한 줄에 연속해있는 나무의 높이가 20, 15, 10, 17이라고 하자. 상근이가 높이를 15로 지정했다면, 나무를 자른 뒤의 높이는 15, 15, 10, 15가 될 것이고, 상근이는 길이가 5인 나무와 2인 나무를 들고 집에 갈 것이다. (총 7미터를 집에 들고 간다) 절단기에 설정할 수 있는 높이는 양의 정수 또는 0이다.  상근이는 환경에 매우 관심이 많기 때문에, 나무를 필요한 만큼만 집으로 가져가려고 한다. 이때, 적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 나무의 수 N과 상근이가 집으로 가져가려고 하는 나무의 길이 M이 주어진다. (1 ≤ N ≤ 1,000,000, 1 ≤ M ≤ 2,000,000,000)  둘째 줄에는 나무의 높이가 주어진다. 나무의 높이의 합은 항상 M보다 크거나 같기 때문에, 상근이는 집에 필요한 나무를 항상 가져갈 수 있다. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0이다.  출력  적어도 M미터의 나무를 집에 가져가기 위해서 절단기에 설정할 수 있는 높이의 최댓값을 출력한다.     문제 풀이   파라매트릭 서치로 res값을 찾아나갔다. mid값으로 특정 높이를 찾고 그게 최대한 높으면서 M을 만족하도록 찾았다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, arr[]; \tstatic long M; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Long.parseLong(st.nextToken()); \t\tarr = new int[N]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t} \t\tArrays.sort(arr); \t\t \t\tint left = 1; int right = arr[arr.length-1]; \t\tint res = 0; \t\twhile(left &lt;= right) { \t\t\tint mid = left + (right-left)/2; \t\t\tif(lessThanM(mid)) { \t\t\t\tleft = mid + 1; \t\t\t\tres = mid; \t\t\t} \t\t\telse { \t\t\t\tright = mid-1; \t\t\t} \t\t} \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate boolean lessThanM(int mid) { \t\tlong sum = 0; \t\tfor(int i=0; i&lt;arr.length; i++) { \t\t\tif(arr[i] &gt; mid) sum += arr[i] - mid; \t\t} \t\treturn sum &gt;= M; \t} }  "
  },
  
  {
    "title": "갭락(Gap Lock)과 넥스트키 락(Next-Key Lock) 및 Phantom Read",
    "url": "/posts/%EA%B0%AD%EB%9D%BDGap-Lock%EA%B3%BC-%EB%84%A5%EC%8A%A4%ED%8A%B8%ED%82%A4-%EB%9D%BDNext-Key-Lock-%EB%B0%8F-Phantom-Read/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-13 03:20:38 +0900",
    "content": "Phantom Read란 무엇인가요? Phantom Read는 트랜잭션이 동일한 조건의 쿼리를 반복 실행할 때, 나중에 실행된 쿼리에서 처음에는 존재하지 않았던 새로운 행이 나타나는 현상을 말합니다. 이는 주로 읽기 일관성(Read Consistency) 을 유지하는 과정에서 발생할 수 있는 문제로, 데이터의 삽입이나 삭제가 다른 트랜잭션에 의해 이루어질 때 발생합니다.  -- 트랜잭션 A 시작 START TRANSACTION;  -- 트랜잭션 A 첫 번째 조회 SELECT * FROM orders WHERE amount &gt; 150;  -- 트랜잭션 B 시작 START TRANSACTION;  -- 트랜잭션 B 새로운 행 삽입 INSERT INTO orders (customer_id, amount) VALUES (4, 250);  -- 트랜잭션 B 커밋 COMMIT;  -- 동일한 조건으로 트랜잭션 A 두 번째 조회시, 트랜잭션 A의 첫 번째 조회에는 존재하지 않던,  -- 트랜잭션 B에서 삽입된 새로운 행이 함께 조회됨 SELECT * FROM orders WHERE amount &gt; 150;    갭락(Gap Lock)이란?  갭 락은 특정 인덱스 값 사이의 공간을 잠그는 락입니다. 기존 레코드 간의 간격을 보호하여 새로운 레코드의 삽입을 방지합니다. 갭 락은 범위 내에 특정 레코드가 존재하지 않을 때 적용됩니다. 트랜잭션이 특정 범위 내에서 데이터의 삽입을 막아 팬텀 읽기(Phantom Read) 현상을 방지합니다. 예를 들어, 인덱스 값 10과 20 사이의 갭을 잠그면 이 범위 내에 새로운 레코드 15를 추가할 수 없습니다.  -- id 1, 3, 5가 저장된 orders 테이블  -- 트랜잭션 A 시작 START TRANSACTION;  -- 트랜잭션 A 1-3과 3-5 사이의 갭과 3 레코드 락 설정(넥스트키 락) SELECT * FROM orders WHERE orders_id BETWEEN 2 AND 4 FOR UPDATE;  -- 트랜잭션 B 시작 START TRANSACTION;  -- 트랜잭션 B가 id 4에 데이터 삽입 시도 시, 갭락으로 인해 삽입이 차단되어 대기 INSERT INTO orders (orders_id, orders_amount) VALUES (4, 200); ...   넥스트키 락(Next-Key Lock)이란? 넥스트키 락은 레코드 락과 갭락을 결합한 형태로, 특정 인덱스 레코드와 그 주변의 갭을 동시에 잠그는 락입니다. 이를 통해 레코드 자체의 변경과 함께 그 주변 공간의 변경도 동시에 제어할 수 있습니다.  넥스트키 락은 특정 레코드와 그 주변 공간을 잠그기 때문에, 다른 트랜잭션이 새로운 레코드를 삽입하여 팬텀 리드를 발생시키는 것을 방지합니다.  orders_idorders_amount110022003300  -- 트랜잭션 A 시작 START TRANSACTION;  -- 트랜잭션 A amount = 200인 orders_id = 2 레코드에 대한 레코드 락과 1-2, 2-3에 대한 갭락을 동시에 잠금으로써 넥스트키 락을 설정 SELECT * FROM orders WHERE orders_amount = 200 FOR UPDATE;  -- 트랜잭션 B 시작 START TRANSACTION;  -- 트랜잭션 B orders_id = 4, orders_amount = 200인 레코드 삽입 시도 시, 넥스트키 락으로 인해 차단되어 대기 INSERT INTO orders (orders_id, order_amount) VALUES (4, 200); ...   갭락과 넥스트키 락을 통한 팬텀 리드 방지 메커니즘 트랜잭션 A가 특정 범위의 데이터를 조회할 때, 해당 범위에 대해 갭락 또는 넥스트키 락을 설정합니다. 락이 설정된 범위 내에서는 트랜잭션 B가 새로운 레코드를 삽입하거나 기존 레코드를 수정하는 것이 차단됩니다. 따라서, 트랜잭션 A가 다시 동일한 조건으로 조회를 수행하더라도, 트랜잭션 B에 의해 새로운 데이터가 삽입되지 않아 팬텀 리드가 발생하지 않습니다.  References    MySQL - InnoDB Locking   MySQL - Transaction Isolation Levels  "
  },
  
  {
    "title": "Operating System Concepts - (10)",
    "url": "/posts/Operating-System-Concepts-10/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-13 03:09:05 +0900",
    "content": "   Virtual Memory (2)   다양한 캐싱 환경    캐싱 기법            한정된 빠른 공간(캐시)에 요청된 데이터를 저장해 두었다가 또 똑같은 요청이 들어오면 느린 저장장치에 접근하지 않고 빠른 캐시로부터 직접 서비스하는 방식       가상 메모리 페이징 시스템에서는 한정된 빠른공간(= 물리메모리, RAM), 느린 저장장치(= 하드디스크, 백킹 스토어)       paging system 외에도 cache memory, buffer caching(파일 시스템에 대한 read/write 요청을 메모리에서 빠르게 처리하는 방식), web caching(멀리있는 컴퓨터에 요청해서 이미 읽어온 웹페이지를 내 컴퓨터에 저장했다가 또 다시 요청했을 때 빠르게 응답해줄 수 있음)등 다양한 분야에서 사용.           캐시 운영의 시간 제약            교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없음.       Buffer Caching이나 Web Caching의 경우                    O(1)에서 O(log n)정도까지만 허용한다. O(n)은 오버헤드가 크다고 판단함.                       Paging system인 경우                    Page fault인 경우에만 OS가 관여함.           페이지가 이미 메모리에 존재하는 경우 참조시각 등의 정보를 OS가 알 수 없음. (CPU의 제어권은 페이지폴트가 날때만 OS에게 넘어가기 때문)           O(1)인 LRU의 list 조작조차 불가능.                           Paging System 에서 LRU, LFU 가능한가?     프로세스 A가 CPU를 잡고 running 중인 경우, 프로세스 A의 논리 메모리에서 매 순간 instruction을 읽어와서 수행할 것.   이때 논리주소를 페이지 테이블을 통해서 물리메모리 주소로 변환을 해서, 물리메모리에 있는 내용을 CPU로 읽어와야 될 겁니다.   만약, 주소변환을 했는데 해당하는 페이지가 이미 물리메모리에 올라와 있다면 물리 메모리에서 직접 읽어서 가져올 것.   이 과정에서 OS는 관여를 하지 않으며 모든 주소변환 작업은 하드웨어가 담당함.   CPU는 프로세스 A가 가지고 있으면서, 주소 변환해서 값 가져오는것임.   근데 만약, invalid라서 백킹스토어에 있다면(페이지 폴트가 발생했다면) 디스크 접근을 필요로 하게 됨. (즉 I/O를 필요로 해 프로세스 A가 직접 행할 수 없으므로 trap이 발생하여 CPU의 제어권이 프로세스 A 에서 OS 로 넘어감)   OS가 디스크의 페이지 폴트가 났던 페이지를 물리 메모리로 올리고, 그 과정에서 물리 메모리 위에서 하나를 쫓아내는 Replace 작업을 하게 됨.   쫒아낼 때, 과연 LRU 알고리즘을 쓴다면, 가장 오래 전에 썼던 페이지를 찾을 수 있을까?   또한, LFU 알고리즘을 쓴다면 가장 적게 쓴 페이지를 찾을 수 있을까? 답은 알 수 없음.   프로세스가 요청한 페이지가 메모리에 이미 올라와있는 경우엔, CPU가 OS한테 안 넘어가고, 하드웨어적으로 주소 변환해서 그냥 값을 CPU로 읽어옴. 그러면 page 접근 시간을 OS는 모름.   반면, 페이지 폴트가 나면 CPU 제어권이 OS로 넘어가니까 디스크로부터 메모리로 페이지가 넘어오는 시간을 알 수 있다. 그래서 사실, 페이지 폴트가 날때만 페이지에 접근하는 정보를 OS가 알 수 있는것임.   그러므로 Paging System에서는 LRU, LFU를 사용할 수 없으며, 버퍼 캐싱, 웹캐싱에서 사용됨.   Clock Algorithm    페이징 시스템에서 쓸 수 있는 알고리즘   LRU의 근사 알고리즘. 다양한 명칭으로 불림   Clock Algorithm : 시계바늘이 이동하면서 알고리즘이 동작하는 방식이라서 이렇게 부름.            Second chance Algorithm : 기회를 한번 더 준다.       NUR(Not Used Recently) or NRU Algorithm(Not Recently Used) : 최근에 사용되지 않은 페이지를 쫓아낸다.           reference bit 이라는 것을 사용해서 교체 대상 페이지를 선정하며, reference bit가 0인 것을 찾을 때까지 포인터를 하나씩 앞으로 이동하여 1인 bit값을 모두 0으로 변경함. Reference bit가 0인 페이지를 찾으면 페이지를 교체, 이미 메모리에 존재하는 페이지가 참조되면 1로 표시한다. (이건 운영체제가 안하고 하드웨어가 수행함)   그러면 페이지 폴트가 나서 쫓아내야 하는데, reference bit을 봤는데 1이면 적어도 한번은 참조가 됐구나 알고 쫓아내지 않고 비트만 0으로 바꾸고 다음껄 확인한다.   Clock algorithm의 개선            Reference bit(access bit)과 modified bit(dirty bit)을 함께 사용       Reference bit = 1 : 최근에 참조된 페이지다 라는 뜻       Modified bit = 1 : 최근에 변경된 페이지 (I/O를 동반하는 페이지) =&gt; modified bit이 1이면 디스크에 쫓겨나는 페이지의 수정된 내용을 백킹스토어에 적용해야 하기 때문에 성능이 저하되므로 쫓아내지 말자.               각 사각형이 page frame (물리메모리 안에있는 페이지들)   페이지에 대해서 어떤 페이지가 참조되서 CPU가 그 페이지를 사용하게 되면 그 페이지에 reference bit이 붙게 된다.   reference bit은 주소변환을 해주는 하드웨어가 어떤 페이지에 대해 접근해서 valid라 페이지를 읽으면 reference bit를 1로 셋팅해준다. (페이지가 참조됬다는 것을 표시해줌) -&gt; 이건 운영체제가 수행하는 것이 아니라 하드웨어가 수행함.   운영체제는 reference bit이 이미 1이면, 쫓아내지 않고 다시 0으로 셋팅하고 다음꺼를 검사한다. 그래서 1인거는 최근에 참조됬다는것을 나타냄.   reference bit가 0이라는건 시계바늘 한바퀴를 도는 동안에, 참조가 없었다.   reference bit가 1이라는건 시계바늘 한바퀴를 도는 동안에, 적어도 1번의 참조가 있었다.   하드웨어가 reference bit을 1로 해놓는 역할을 하고, 운영체제가 하드웨어가 셋팅한 bit를 보고 어떤걸 쫓아낼까 서큘러링크드리스트를 쭉 돌면서 1인걸 0으로 바꾸고, 0인걸 쫓아내는 알고리즘이다!!!   reference bit가 0인 페이지를 교체하는 것의 의미 한바퀴 도는 동안 오랫동안 참조하지 않은 페이지를 교체함. (어느 정도 LRU와 비슷하게는 구현한 것)   reference bit말고도 modified bit이라는걸 하나 더 사용함. (dirty bit 라고도 함)   modified bit은 어떤 페이지가 쫓겨날 때, 이 페이지의 modified bit이 0이면 백킹스토어에서 물리메모리로 올라온 이후로 수정이 되지 않았다는 의미로, 그냥 지워도 된다.   1이면 적어도 한번은 내용을 수정한 페이지. 그래서 교체될 때 백킹 스토어에 수정된 내용을 반영한 후에 지워야 한다는 의미임.   Page Frame의 Allocation    Allocation problem : 각 프로세스에 얼마 만큼의 페이지 프레임을 할당할 것인가?   Allocation의 필요성            메모리 참조 명령어 수행 시 명령어, 데이터 등 여러 페이지 동시 참조.                    명령어 수행을 위해 최소한 할당되어야 하는 frame 수가 있음.                       Loop를 구성하는 page들은 한꺼번에 allocate되는 것이 유리함.                    최소한의 allocation이 없으면 매 Loop마다 page fault 발생.                       예를 들어, for문을 구성하는 페이지가 3개라면 for 문을 백만번 반복하는 동안 페이지폴트 가 발생하지 않음.                    근데 3개의 페이지로 구성된 for문에게 페이지를 2개만 준다면 페이지 폴트가 계속 발생하게 됨. -&gt; 페이지폴트가 잘 안나는 일련의 페이지 갯수가 정해져 있는 경우가 많음.           프로그램별로 페이지 allocation을 해주지 않으면, 메모리에서 특정 페이지가 장악하는 일이 발생하게 됨. 그래서 각각의 프로그램에게 어느정도의 페이지를 할당해줘야 하는 것.                           Allocation 방법            Equal allocation : 모든 프로세스에게 똑같은 갯수를 할당.       Proportional allocation : 프로세스 크기에 비례하여 할당.       Priority allocation : CPU 우선 순위가 높은 프로세스에게 할당. (프로세스의 priority에 따라 다르게 할당.)           Global vs Local Replacement     Global replacement            Replace시 다른 Process에 할당된 frame을 빼앗아 올 수 있음.       Process별 할당량을 조절하는 또 다른 방법       FIFO, LRU, LFU등의 알고리즘을 Global replacement로 사용 시 해당함.       Working Set, PFF 알고리즘 사용       다른 프로그램의 페이지를 내쫓을 수 있는 방법.           Local replacement            자신한테 할당된 frame 내에서만 페이지를 쫓아내는(Replacement) 방법.       FIFO, LFU, LRU 등의 알고리즘을 process별로 운영 시 사용할 수 있는 방법.           Thrashing (쓰레싱)    페이지 폴트가 지나치게 자주 일어나는 상황.   프로세스의 원활한 수행에 필요한 최소한의 page frame 수를 할당받지 못한 경우 발생   Page fault rate가 매우 높아지고, CPU Utilization이 낮아짐.   이 경우, OS는 MPD (Multiprogramming degree)를 높여야 한다고 판단하기 때문에 또 다른 프로세스가 시스템에 추가됨. (higher MPD)   프로세스 당 할당된 frame의 수가 더욱 감소하고, 프로세스는 page의 swap in/swap out으로 매우 바빠짐.   이렇게 되면 CPU의 비효율성이 매우 높아지게 됨 (low throughput, 처리율이 낮아짐)   해결을 위해서는 동시에 실행되는 프로세스의 수, 즉 MPD를 조절해 각 프로세스의 메모리 사용률을 어느정도 확보해주어야 함.    x축은 지금 메모리에 올라와있는 프로그램의 갯수. / y축은 CPU 사용률.   메모리에 동시에 올라오는 프로그램의 숫자에 따라서 CPU 이용률이 어떤지 볼 수 있는 그래프.   계속 멀티 프로그램의 개수가 높게 되면, Page fault rate 가 매우 높아지고, CPU utilization이 낮아짐. (프로세스의 원활한 수행에 필요한 최소한의 page frame 수를 할당 받지 못한 경우가 빈번해지기 때문에 비효율적)   Working-set Algorithm    Locality of reference            프로세스는 특정 시간, 특정 장소만을 집중적으로 참조한다는 특징 존재.       집중적으로 참조되는 해당 page들의 집합을 locality set이라고 함.           Working-set Model            Locality(지역성)에 기반해서 프로세스가 일정 시간동안 원활하게 수행되기 위해 한꺼번에 메모리에 올라와 있어야 하는 page들의 집합을 _Working Set_이라고 한다.       Working set 모델에서는 process의 working set 전체가 메모리에 올라와 있어야 수행되고 그렇지 않을 경우 모든 frame을 반납한 후 swap out(suspend)됨.                    만약, 워킹셋이 5개인데 페이지 프레임을 3개밖에 줄 수 없다면??? 모든 페이지를 반납해버린다. 5개 받을 때까지 페이지 교체 진행 X           working set model은 한꺼번에 메모리에 올라가는게 보장이 안되면 메모리를 모두 빼앗아 swap out시켜서 쓰레싱을 방지하는 알고리즘.                           Thrashing을 방지함.   Multiprogramming degree를 결정함.   working set window를 과거를 통해 추정한다.            과거 델타 시간동안 참조된 페이지들을 워킹셋으로 간주해서, 메모리에서 쫓아내지 않는다. 델타 시간을 window라고 한다. 그래서 현재 시점부터 과거 window 사이즈 만큼 참조된 페이지는 메모리에 올려놔야 한다. (= 참조된 후 델타 시간동안 page를 메모리에 유지한 후에 버린다. ) working-set의 크기는 그때그때 바뀐다. 어느 시점에서의 window는 5이고, 어느 시점에서의 window는 2고 … 그러면 할당해줘야 하는 frame수가 다르다.             PFF (Page-Fault Frequency) 알고리즘     직접 페이지 폴트 rate를 보고, 페이지 폴트를 많이 일으키는 프로세스는 페이지 프레임을 많이 할당함.   페이지 폴트 rate가 낮으면, 쓸데 없이 메모리를 많이 갖고있을 것이다라고 생각해 할당 frame 수를 줄이기도 함.   결국, Page-fault Rate의 상한값과 하한값을 정하는 것.   Page Size의 결정    페이징 시스템에서는 동일한 크기의 페이지 크기로 자르며, 일반적으로 페이지 사이즈를 4KB를 사용하고 있음.   메모리 주소체계가 32bit -&gt; 64bit로 바뀌고,   메모리 크기도 점점 커지기 때문에 페이지 사이즈가 너무 작으면 페이지 테이블이 커져서 낭비가 심하게 됨.   그래서 메모리 크기가 커지면 거기에 따라서 페이지 크기도 커져야 할 필요가 생긴다. 그래서 최근엔 대용량 페이지 사이즈를 갖는 메모리 시스템이 증가하고 있다.   Page size를 감소시키면            페이지 수가 증가       페이지 엔트리 수가 많아져서 테이블의 크기가 증가 (페이지 테이블 메모리 낭비가 커짐)       Internal fragmentation (내부 단편화)의 감소       Disk transfer의 효율성 감소 (Seek/rotation vs transfer)                    Disk transfer의 효율성은 페이지 크기가 클때 효율적.           seek를 해야하는데, seek하는 시간이 오래걸림. 그래서 가능하면 디스크 헤더가 움직여서 많은 양의 내용을 한번에 읽어오는게 효율적.                       페이지 크기가 작으면 꼭 필요한 정보만 메모리에 올라오기 때문에, 메모리 이용이 효율적이어야함.                    하지만 locality 측면에서는 페이지 크기가 큰게 좋음.           함수를 구성하는 코드가 연달아서 순차적으로 참조가 되기 때문에, 페이지 폴트가 났을때 페이지 하나를 통채로 메모리에 올리면 한번 올린 이후로 페이지 폴트가 발생하지 않기 때문에                           "
  },
  
  {
    "title": "BOJ_5430_AC (Java)",
    "url": "/posts/BOJ5430AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-12 18:11:43 +0900",
    "content": "[Gold V] AC - 5430  문제 링크  성능 요약  메모리: 92696 KB, 시간: 696 ms  분류  덱, 파싱, 구현, 문자열, 자료 구조  제출 일자  2025년 1월 12일 18:00:57  문제 설명  선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.  함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.  함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, \"AB\"는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, \"RDD\"는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.  배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.  각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.  다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)  다음 줄에는 [x1,...,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)  전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.  출력  각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.     문제 풀이     아무것도 없는 경우에 RRRRR만 하면 [] 가 출력된다는 반례를 생각해내야한다!     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int T, N; \tstatic String command, nums; \tstatic Deque&lt;Integer&gt; dq = new ArrayDeque&lt;Integer&gt;(); \tstatic boolean isError, isReversed; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tint T = Integer.parseInt(br.readLine()); \t\twhile(T--&gt;0) { \t\t\tdq.clear(); \t\t\tisError = false; \t\t\tisReversed = false; \t\t\t \t\t\tcommand = br.readLine(); \t\t\tN = Integer.parseInt(br.readLine()); \t\t\tnums = br.readLine(); \t\t\t \t\t\tif(N == 0) { \t\t\t\tfor(int i=0; i&lt;command.length(); i++) { \t\t\t\t\tif(command.charAt(i) == 'R') continue; \t\t\t\t\telse { \t\t\t\t\t\tisError = true; \t\t\t\t\t\tbreak; \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t\telse { \t\t\t\tString[] split = nums.substring(1, nums.length()-1).split(\",\"); \t//\t\t\tSystem.out.println(Arrays.toString(split)); \t\t\t\tfor(String s : split) dq.offer(Integer.parseInt(s)); \t\t\t\t \t\t\t\tfor(int i=0; i&lt;command.length(); i++) { \t\t\t\t\tif(command.charAt(i) == 'R') isReversed = !isReversed; \t\t\t\t\telse { \t\t\t\t\t\tif(dq.isEmpty()) { \t\t\t\t\t\t\tisError = true; \t\t\t\t\t\t\tbreak; \t\t\t\t\t\t} \t\t\t\t\t\t \t\t\t\t\t    if(isReversed) dq.pollLast(); \t\t\t\t\t    else dq.pollFirst(); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t\tif(isError) sb.append(\"error\").append(\"\\n\"); \t\t\telse { \t\t\t/* \t\t\t출력을 간단하게 toArray로 하면 원소마다 , 뒤 \t\t\t*/ //\t\t\t\tif(isReversed) { //\t\t\t\t\tList&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;(); //\t\t\t\t\twhile(!dq.isEmpty()) tmp.add(dq.pollLast()); //\t\t\t\t\tsb.append(Arrays.toString(tmp.toArray())).append(\"\\n\"); //\t\t\t\t} //\t\t\t    else sb.append(Arrays.toString(dq.toArray())).append(\"\\n\"); \t\t\t\tsb.append(\"[\"); \t\t\t    if(isReversed) { \t\t\t        List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); \t\t\t        while(!dq.isEmpty()) tmp.add(dq.pollLast()); \t\t\t        for(int i = 0; i &lt; tmp.size(); i++) { \t\t\t            sb.append(tmp.get(i)); \t\t\t            if(i &lt; tmp.size() - 1) sb.append(\",\"); \t\t\t        } \t\t\t    } else { \t\t\t        int size = dq.size(); \t\t\t        for(int i = 0; i &lt; size; i++) { \t\t\t            sb.append(dq.pollFirst()); \t\t\t            if(i &lt; size - 1) sb.append(\",\"); \t\t\t        } \t\t\t    } \t\t\t    sb.append(\"]\\n\"); \t\t\t} \t\t} \t\t \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "PGMS_5월 식품들의 총매출 조회하기 (SQL)",
    "url": "/posts/PGMS5%EC%9B%94-%EC%8B%9D%ED%92%88%EB%93%A4%EC%9D%98-%EC%B4%9D%EB%A7%A4%EC%B6%9C-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-01-12 16:41:17 +0900",
    "content": "[level 4] 5월 식품들의 총매출 조회하기 - 131117  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; JOIN  채점결과  Empty  제출 일자  2025년 01월 12일 16:38:46  문제 설명  다음은 식품의 정보를 담은 FOOD_PRODUCT 테이블과 식품의 주문 정보를 담은 FOOD_ORDER 테이블입니다. FOOD_PRODUCT 테이블은 다음과 같으며 PRODUCT_ID, PRODUCT_NAME, PRODUCT_CD, CATEGORY, PRICE는 식품 ID, 식품 이름, 식품코드, 식품분류, 식품 가격을 의미합니다.           Column name Type Nullable            PRODUCT_ID VARCHAR(10) FALSE   PRODUCT_NAME VARCHAR(50) FALSE   PRODUCT_CD VARCHAR(10) TRUE   CATEGORY VARCHAR(10) TRUE   PRICE NUMBER TRUE          FOOD_ORDER 테이블은 다음과 같으며 ORDER_ID, PRODUCT_ID, AMOUNT,  PRODUCE_DATE, IN_DATE, OUT_DATE, FACTORY_ID, WAREHOUSE_ID는 각각 주문 ID, 제품 ID, 주문량, 생산일자, 입고일자, 출고일자, 공장 ID, 창고 ID를 의미합니다.           Column name Type Nullable            ORDER_ID VARCHAR(10) FALSE   PRODUCT_ID VARCHAR(5) FALSE   AMOUNT NUMBER FALSE   PRODUCE_DATE DATE TRUE   IN_DATE DATE TRUE   OUT_DATE DATE TRUE   FACTORY_ID VARCHAR(10) FALSE   WAREHOUSE_ID VARCHAR(10) FALSE            문제  FOOD_PRODUCT와 FOOD_ORDER 테이블에서 생산일자가 2022년 5월인 식품들의 식품 ID, 식품 이름, 총매출을 조회하는 SQL문을 작성해주세요. 이때 결과는 총매출을 기준으로 내림차순 정렬해주시고 총매출이 같다면 식품 ID를 기준으로 오름차순 정렬해주세요.    예시  FOOD_PRODUCT 테이블이 다음과 같고           PRODUCT_ID PRODUCT_NAME PRODUCT_CD CATEGORY PRICE            P0011 맛있는콩기름 CD_OL00001 식용유 4880   P0012 맛있는올리브유 CD_OL00002 식용유 7200   P0013 맛있는포도씨유 CD_OL00003 식용유 5950   P0014 맛있는마조유 CD_OL00004 식용유 8950   P0015 맛있는화조유 CD_OL00005 식용유 8800   P0016 맛있는참기름 CD_OL00006 식용유 7100   P0017 맛있는들기름 CD_OL00007 식용유 7900   P0018 맛있는고추기름 CD_OL00008 식용유 6100   P0019 맛있는카놀라유 CD_OL00009 식용유 5100   P0020 맛있는산초유 CD_OL00010 식용유 6500          FOOD_ORDER 테이블이 다음과 같을 때           ORDER_ID PRODUCT_ID AMOUNT PRODUCE_DATE IN_DATE OUT_DATE FACTORY_ID WAREHOUSE_ID            OD00000056 P0012 1000 2022-04-04 2022-04-21 2022-04-25 FT19980002 WH0032   OD00000057 P0014 2500 2022-04-14 2022-04-27 2022-05-01 FT19980002 WH0033   OD00000058 P0017 1200 2022-05-19 2022-05-28 2022-05-28 FT20070002 WH0033   OD00000059 P0017 1000 2022-05-24 2022-05-30 2022-05-30 FT20070002 WH0038   OD00000060 P0019 2000 2022-05-29 2022-06-08 2022-06-08 FT20070002 WH0035          SQL을 실행하면 다음과 같이 출력되어야 합니다.           PRODUCT_ID PRODUCT_NAME TOTAL_SALES            P0017 맛있는들기름 17380000   P0019 맛있는카놀라유 10200000              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   TOTAL_SALES를 구하기 위해서는 FOOD_ORDER 테이블의 PRODUCE_AMOUNT에 FOOD_PRODUCT 테이블의 PRICE 값을 곱하기 위한 JOIN이 필요했다.     코드   SELECT fp.PRODUCT_ID, fp.PRODUCT_NAME, SUM(fo.AMOUNT * fp.PRICE) AS TOTAL_SALES     FROM FOOD_ORDER fo         JOIN FOOD_PRODUCT fp             ON fo.PRODUCT_ID = fp.PRODUCT_ID         WHERE fo.PRODUCE_DATE BETWEEN '2022-05-01' AND '2022-05-31'             GROUP BY fp.PRODUCT_ID, fp.PRODUCT_NAME                 ORDER BY TOTAL_SALES DESC, fp.PRODUCT_ID ASC;  "
  },
  
  {
    "title": "PGMS_KAKAO(2018)_[1차] 프렌즈4블록 (Java)",
    "url": "/posts/PGMSKAKAO20181%EC%B0%A8-%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-12 01:55:17 +0900",
    "content": "[level 2] [1차] 프렌즈4블록 - 17679  문제 링크  성능 요약  메모리: undefined, 시간: .  구분  코딩테스트 연습 &gt; 2018 KAKAO BLIND RECRUITMENT  채점결과  Empty  제출 일자  2025년 01월 12일 01:33:30  문제 설명  프렌즈4블록  블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 \"프렌즈4블록\". 같은 모양의 카카오프렌즈 블록이 2\u0014×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.   만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.    블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.    만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.   위 초기 배치를 문자로 표시하면 아래와 같다. TTTANT RRFACC RRRFCC TRRRAA TTMMMF TMMTTJ  각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다  입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.  입력 형식   입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. 2 ≦ n, m ≦ 30 board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.   출력 형식  입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.  입출력 예제           m n board answer            4 5 [\"CCBDE\", \"AAADE\", \"AAABF\", \"CCBBF\"] 14   6 6 [\"TTTANT\", \"RRFACC\", \"RRRFCC\", \"TRRRAA\", \"TTMMMF\", \"TMMTTJ\"] 15          예제에 대한 설명   입출력 예제 1의 경우, 첫 번째에는 A 블록 6개가 지워지고, 두 번째에는 B 블록 4개와 C 블록 4개가 지워져, 모두 14개의 블록이 지워진다. 입출력 예제 2는 본문 설명에 있는 그림을 옮긴 것이다. 11개와 4개의 블록이 차례로 지워지며, 모두 15개의 블록이 지워진다.   해설 보러가기     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   level 2 치고 어려운 문제가 아닌가 싶다.  2x2 블록 찾기  전체 보드를 순회하면서 2x2 형태의 같은 문자 블록을 찾습니다 찾은 블록들의 위치를 Set에 저장 (중복 제거) 최적화를 위해 startPos를 활용하여 이미 체크한 위치는 건너뜁니다  블록 제거     Set에 저장된 위치의 블록들을 ‘X’로 변경하여 제거 표시, 제거된 블록 개수는 Set의 크기로 계산   중력 적용     각 열마다 아래에서부터 위로 올라가면서 X를 발견하면 그 위치로 위의 블록을 떨어뜨림   이 과정을 각 위치에서 맨 아래까지 반복   주의할 점  1. Set 사용     2x2 블록의 위치를 저장할 때 Set을 사용하여 중복을 제거   위치는 i * M + j 형태로 1차원 정수로 변환하여 저장   각 사이클 후에 반드시 Set을 clear해야 함 (중력으로 인해 새로운 블록이 형성될 수 있기 때문)   2. startPos 최적화     2x2 블록을 발견하면 그 위치를 startPos에 저장   다음 순회때는 그 위치부터 시작하여 불필요한 순회를 줄임   단, 중력 적용 후 새로운 사이클 시작시에는 (0,0)부터 다시 체크해야 함   3. 중력 처리     각 열별로 처리.   아래에서부터 위로 올라가면서 X를 발견하면 현재 위치부터 맨 아래까지 swap을 반복하여 블록을 떨어뜨림   시간 복잡도     보드의 크기가 N x M일 때 각 사이클마다 보드 전체 순회: O(NM)   중력 적용: O(N²M) (각 열마다 각 행을 체크하고 최대 N번 swap 가능)   전체 블록이 모두 제거될 때까지 반복될 수 있으므로 최악의 경우 O(N³M)      코드   import java.util.*;  class Solution {     static int N, M, res=0;     static char[][] map;     // 한 사이클마다 지워야 할 부분을 Set에 넣어서 넣어서 크기로 개수체크함 -&gt; 사이클마다 clear 필수(밑으로 내려오면 중복됨)     static Set&lt;Integer&gt; toBeDeleted = new HashSet&lt;&gt;();     // startPos 쓴 이유 : 체크했을 떄 2x2있다고 찾은 위치부터 시작하고자. 필요없는순회 제거 \t// 주의점 : 중력으로 밑으로 내린 후 isEnd 적용때마다는 (0,0) 부터 해야하고, 2x2제거만 startPos부터     static int[] startPos = {0, 0};     public int solution(int m, int n, String[] board) {         N = board.length;         M = board[0].length();         map = new char[N][M];         for(int i=0; i&lt;N; i++){             map[i] = board[i].toCharArray();         }                  while(!isEnd()){             for(int i=0; i&lt;N-1; i++){                 for(int j=0; j&lt;M-1; j++){                     // startPos 건너뛰는 부분 (순회 최적화)                     if(i &lt; startPos[0]) continue;                     else if(i==startPos[0] &amp;&amp; j &lt; startPos[1]) continue;                     else{                         if(check2by2(i, j)) {                             // 지울 부분을 정수로 구분하고자 i열 j행을 고유의 숫자 0 ~ (N*N-1)로 표시                             toBeDeleted.add(i * M + j);                             toBeDeleted.add(i * M + j+1);                             toBeDeleted.add((i+1) * M + j);                             toBeDeleted.add((i+1) * M + j+1);                         }                     }                 }             }                          for(int pos : toBeDeleted) { // Set에 추가                  int i = pos / M;                 int j = pos % M;                 map[i][j] = 'X';             }                          // 개수 추가 및 Set 비우기             res += toBeDeleted.size();             System.out.println(toBeDeleted);             toBeDeleted.clear();                          // 빈칸만큼 아래로 매꾸기             goDown();                          // 중력체크(출력)             for(int i=0; i&lt;N; i++){                 for(int j=0; j&lt;M; j++){                     System.out.print(map[i][j]);                 }                 System.out.println();             }         }         return res;     }     private boolean check2by2(int r, int c){         if(map[r][c] == 'X') return false;         return map[r][c]==map[r][c+1] &amp;&amp; map[r][c+1]==map[r+1][c] &amp;&amp; map[r+1][c]==map[r+1][c+1];     }          private boolean isEnd(){         for(int i=0; i&lt;N-1; i++){             for(int j=0; j&lt;M-1; j++){                 if(check2by2(i, j)) {                     startPos[0] = i;                     startPos[1] = j;                     return false;                 }             }         }         return true;     }          private void goDown(){ // 아래부터 swap하며 맨 위 행까지 올라가기         for(int j=0; j&lt;M; j++) {             for(int i=N-2; i&gt;=0; i--) {                 for(int k=i; k&lt;N-1; k++) {                     if(map[k][j] != 'X' &amp;&amp; map[k+1][j] == 'X') {                         swap(k, j);                     }                 }             }         }     }          private void swap(int i, int j){         char tmp = map[i][j];         map[i][j] = map[i+1][j];         map[i+1][j] = tmp;     } }  "
  },
  
  {
    "title": "PGMS_야근지수 (Java, C++)",
    "url": "/posts/PGMS%EC%95%BC%EA%B7%BC%EC%A7%80%EC%88%98-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 알고리즘, 프로그래머스",
    "date": "2025-01-12 00:04:58 +0900",
    "content": "[level 3] 야근 지수 - 12927  문제 링크  성능 요약  메모리: 3.82 MB, 시간: 28.26 ms  구분  코딩테스트 연습 &gt; 연습문제  채점결과  정확성: 86.7효율성: 13.3합계: 100.0 / 100.0  제출 일자  2025년 01월 11일 23:58:47  문제 설명  회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때,  퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.  제한 사항   works는 길이 1 이상, 20,000 이하인 배열입니다. works의 원소는 50000 이하인 자연수입니다. n은 1,000,000 이하인 자연수입니다.   입출력 예           works n result            [4, 3, 3] 4 12   [2, 1, 2] 1 6   [1,1] 3 0          입출력 예 설명  입출력 예 #1 n=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 4시간동안 일을 한 결과는 [2, 2, 2]입니다. 이 때 야근 지수는 22 + 22 + 22 = 12 입니다.  입출력 예 #2 n=1일 때, 남은 일의 작업량이 [2,1,2]라면 야근 지수를 최소화하기 위해 1시간동안 일을 한 결과는 [1,1,2]입니다. 야근지수는 12 + 12 + 22 = 6입니다.  입출력 예 #3  남은 작업량이 없으므로 피로도는 0입니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     평탄화를 한다는 건 최대한 높은 높이부터 -1씩 줄여나간다는 의미. 내림차순으로 정렬한 후 제일 큰 원소를 1 줄이고 다시 넣어 정렬을 반복.  하지만 0인 원소를 넣고 꺼내고 -1로 만들고 이건 불가능하므로, 0인건 넣지 않음.     코드   Java 코드 import java.util.*;  class Solution {     public long solution(int n, int[] works) {         /*         우선순위큐로 평탄화하기         평탄화를 한다는 건 최대한 높은 높이부터 -1씩 줄여나간다는 의미.          내림차순으로 정렬한 후 제일 큰 원소를 1 줄이고 다시 넣어 정렬을 반복.          하지만 0인 원소를 넣고 꺼내고 -1로 만들고 이건 불가능하므로, 0인건 넣지 않음.          */         PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder());         for (int w : works) {             pq.offer(w);         }         while(n--&gt;0 &amp;&amp; !pq.isEmpty()){             int tmp = pq.poll();             if(tmp&gt;0) pq.offer(--tmp);         }                  long res=0;         while(!pq.isEmpty()){             res += (long) Math.pow(pq.poll(), 2);         }         return res;     } }   C++ 코드 #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt;  using namespace std;  long long solution(int n, vector&lt;int&gt; works) {     priority_queue&lt;int&gt; pq;     for(int w : works) pq.push(w);          while(n--&gt;0 &amp;&amp; !pq.empty()){         int tmp = pq.top();         pq.pop();         if(tmp&gt;0) pq.push(--tmp);     }          long long res = 0;     while(!pq.empty()){         long long num = pq.top();         res += num * num;         pq.pop();     }     return res; }  "
  },
  
  {
    "title": "BOJ_1393_음하철도 구구팔 (Java, C++)",
    "url": "/posts/BOJ1393%EC%9D%8C%ED%95%98%EC%B2%A0%EB%8F%84-%EA%B5%AC%EA%B5%AC%ED%8C%94-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-11 14:59:20 +0900",
    "content": "[Silver I] 음하철도 구구팔 - 1393  문제 링크  성능 요약  메모리: 2020 KB, 시간: 0 ms  분류  브루트포스 알고리즘, 수학, 정수론  제출 일자  2025년 1월 11일 14:53:00  문제 설명  최백준은 음하철도 구구팔에 탔다.  문제는 구구팔의 기장인 조교 김재홍이 반쯤 미쳐서 열차를 멈추지 않는다는 것이다. 그래서 최백준은 달리고 있는 열차에서 뛰어내려야 한다.  그런데 뛰어내릴 때 정류장 까지 거리가 너무 멀면 마이 아플 수 있다.  그래서 철도가 정류장에 가장 많이 근접했을 때 뛰어내리고자 한다.  어디서 뛰어내려야 하는가?  입력  첫번째 줄에는 xs와 ys가 주어진다. 이는 정류장의 위치가 (xs, ys)임을 의미한다.  두번째 줄에는 xe, ye, dx, dy가 주어진다. 이는 현재 열차 위치가 (xe, ye)이고, 열차가 1초마다 x가 증가하는 방향으로 dx만큼, y가 증가하는 방향으로 dy만큼 이동함을 의미한다  주어지는 모든 수는 -100이상, 100이하의 정수이다.  출력  최백준이 뛰어내릴 위치의 x좌표와 y좌표를 출력한다. 뛰어내릴 위치의 좌표가 항상 정수인 입력만 주어진다.     문제 풀이        기차의 이동 벡터 최적화      기차의 이동 방향 (dx, dy)를 최소 단위로 줄인다   예: (4,6)으로 이동한다면 GCD인 2로 나눠서 (2,3)으로 변환. 이렇게 하면 모든 가능한 정수 좌표를 놓치지 않고 확인할 수 있다      거리 계산과 탐색      각 시점 t마다 기차의 위치: (xe + tdx, ye + tdy)   이 위치에서 정류장까지의 거리를 계산: (xs - 현재x)² + (ys - 현재y)² 거리가 가장 짧은 지점이 답이 된다.   주의할 점들          탐색 범위             모든 입력값이 -100 ~ 100 사이이므로       최대 거리는 200(x축) + 200(y축) = 400       따라서 200번의 반복문이면 충분합니다                오버플로우 처리             거리 계산시 제곱을 하므로 int 범위를 넘을 수 있음       1LL *를 곱해서 long long으로 확실하게 처리                GCD 처리             이동 벡터를 최소화하면 불필요한 계산을 줄일 수 있음       (4,6) → (2,3)으로 바꾸는 것처럼 최적화           예: 기차가 (2,1)에서 시작해서 (2,4) 방향으로 움직일 때 정류장이 (5,2)에 있다면  움직임: (2,1) → (4,5) → (6,9) → ... 이 중에서 (3,3)이 정류장과 가장 가까운 지점이 됩니다.      코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tint x0 = Integer.parseInt(st.nextToken()); \t\tint y0 = Integer.parseInt(st.nextToken()); \t\tst = new StringTokenizer(br.readLine()); \t\tint x1 = Integer.parseInt(st.nextToken()); \t\tint y1 = Integer.parseInt(st.nextToken()); \t\tint dx = Integer.parseInt(st.nextToken()); \t\tint dy = Integer.parseInt(st.nextToken()); \t\t \t\tint gcd = gcd(Math.abs(dx), Math.abs(dy)); \t    if (gcd &gt; 0) { \t        dx /= gcd; \t        dy /= gcd; \t    } \t     \t    long min = Long.MAX_VALUE; \t    int tx = x1, ty = y1; \t     \t    for (int t = 0; t &lt; 200; t++) { \t        int currX = x1 + t * dx; \t        int currY = y1 + t * dy; \t        long dist = (long)(x0 - currX) * (x0 - currX) + (long)(y0 - currY) * (y0 - currY); \t         \t        if (dist &lt; min) { \t            min = dist; \t            tx = currX; \t            ty = currY; \t        } \t    } \t     \t    bw.write(tx + \" \" + ty); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int gcd(int a, int b) { \t\twhile (b != 0) { \t        int tmp = a % b; \t        a = b; \t        b = tmp; \t    } \t    return a; \t} }    C++ /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int x0, y0;     cin &gt;&gt; x0 &gt;&gt; y0;      int x1, y1, dx, dy;     cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; dx &gt;&gt; dy;      int g = gcd(abs(dx), abs(dy));     if (g &gt; 0) {         dx /= g;         dy /= g;     }      long long min_dist = LLONG_MAX;     int tx = x1, ty = y1;      for (int t = 0; t &lt; 200; t++) {         int currX = x1 + t * dx;         int currY = y1 + t * dy;         long long dist = 1LL * (x0 - currX) * (x0 - currX) +                          1LL * (y0 - currY) * (y0 - currY);          if (dist &lt; min_dist) {             min_dist = dist;             tx = currX;             ty = currY;         }     }      cout &lt;&lt; tx &lt;&lt; \" \" &lt;&lt; ty &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_2698_인접한 비트의 수 (Java)",
    "url": "/posts/BOJ2698%EC%9D%B8%EC%A0%91%ED%95%9C-%EB%B9%84%ED%8A%B8%EC%9D%98-%EC%88%98-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-10 18:21:06 +0900",
    "content": "[Gold IV] 인접한 비트의 개수 - 2698  문제 링크  성능 요약  메모리: 16600 KB, 시간: 116 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 1월 10일 16:59:47  문제 설명  0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다. S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.  s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn  위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어, 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.  수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인 수열 S의 개수를 구하는 프로그램을 작성하시오.  예를 들어, n이 5이고, k가 2이면, 수열 S가 될 수 있는 수열은 다음과 같이 6가지가 있다.  11100, 01110, 00111, 10111, 11101, 11011  입력  첫째 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 수 2개가 공백으로 구분되어 이루어져 있다. 첫 번째 수는 n이고, 두 번째 수는 k이다. n과 k는 100을 넘지 않는 자연수이다.  출력  각 테스트 케이스에 대해 인접한 비트의 개수가 k인 수열 S의 개수를 한 줄에 하나씩 출력한다. 이 값은 2,147,483,647보다 작거나 같다.     문제 풀이        코드   package BOJ_2698_인접한비트의개수;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int TC, N, K, dp[][][];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2698_인접한비트의개수/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          TC = Integer.parseInt(br.readLine());         dp = new int[101][101][2];         dp[1][0][0] = 1;         dp[1][0][1] = 1;          for (int i = 2; i &lt;= 100; i++) {             for (int j = 0; j &lt;= i - 1; j++) {                 for (int k = 0; k &lt; 2; k++) {                     dp[i][j][0] = dp[i - 1][j][0] + dp[i - 1][j][1];                      if (j == 0) { // 이거 없으면 -1 인덱스 접근가능 오류                         dp[i][j][1] = dp[i - 1][j][0];                     } else {                         dp[i][j][1] = dp[i - 1][j][0] + dp[i - 1][j - 1][1];                     }                 }             }         }         while (TC-- &gt; 0) {             st = new StringTokenizer(br.readLine());             N = Integer.parseInt(st.nextToken());             K = Integer.parseInt(st.nextToken());             sb.append(dp[N][K][0] + dp[N][K][1]).append('\\n');         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }   더 효율적인 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int TC, N, K, dp[][];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2698_인접한비트의개수/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          TC = Integer.parseInt(br.readLine());         dp = new int[101][101];         dp[0][0] = 1;         dp[1][0] = 2;         for(int i=2;i&lt;=100;i++){             for(int j=i-1;j&gt;0;j--){                 dp[i][j] = dp[i-1][j] + dp[i-2][j] + (dp[i-1][j-1] - dp[i-2][j-1]);             }             dp[i][0] = dp[i-1][0] + dp[i-2][0];         }                  while(TC--&gt;0){             st = new StringTokenizer(br.readLine());             N = Integer.parseInt(st.nextToken());             K = Integer.parseInt(st.nextToken());             sb.append(String.valueOf(dp[N][K])).append('\\n');         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "브라우저는 어떻게 동작하는가?",
    "url": "/posts/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8F%99%EC%9E%91%ED%95%98%EB%8A%94%EA%B0%80/",
    "categories": "공부",
    "tags": "백엔드",
    "date": "2025-01-10 15:31:52 +0900",
    "content": "Introduction 브라우저는 가장 많이 사용하는 소프트웨어일 것이다. 탈리 가르시엘이란 이스라엘 개발자가 게시한 글을 통해 이를 자세히 알아보자.  이 글에서 설명하는 브라우저 최근 인터넷 익스플로러, 파이어폭스, 사파리, 크롬, 오페라 이렇게 5개의 브라우저가 많이 사용되지만 파이어 폭스, 크롬, 사파리와 같은 오픈소스 브라우저를 예로 설명하고자 한다. 사파리는 부분적으로 오픈소스다. StatCounter 브라우저 통계에 따르면 2012년 3월 파이어폭스, 사파리, 크롬의 점유율이 62.57%에 달한다. 2025년 1월 기준 2023~2024 자료로는 크롬, 사파리, 마이크로소프트 엣지, 파이어폭스, 삼성 인터넷, 오페라 순으로 다음과 같은 점유율을 보인다.  오픈 소스 브라우저가 시장의 대부분을 차지하고 있는 모습이다.  브라우저의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.  브라우저는 HTML과 CSS 명세에 따라 HTML 파일을 해석하고 표시하는데 이 명세는 웹 표준화 기구인 W3C(World Wide Web Consortium)에서 정한다. 과거에는 브라우저들이 일부만 이 명세에 따라 구현하고 독자적인 방법으로 확장함으로써 웹 제작자가 심각한 호환성 문제를 겪었지만 최근에는 대부분의 브라우저가 표준 명세를 따른다.  브라우저의 사용자 인터페이스는 서로 닮아있는데 다음과 같은 요소들이 일반적이다.    URI를 입력할 수 있는 주소 표시 줄   이전 버튼과 다음 버튼   북마크   새로고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지버튼   홈버튼   브라우저의 사용자 인터페이스는 표준 명세가 없음에도 불구하고 수 년간 서로의 장점을 모방하면서 현재에 이르게 되었다. HTML 명세는 주소 표시줄, 상태 표시줄, 도구 모음과 같은 일반적인 요소를 제외하고 브라우저의 필수 UI를 정의하지 않았다. 물론 파이어폭스의 다운로드 관리자와 같이 브라우저에 특화된 기능도 있다.  브라우저의 기본 구조 브라우저의 주요 구성 요소는 다음과 같다.     사용자 인터페이스 : 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등이 해당된다. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.   브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.   렌더링 엔진 : 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.   통신 : HTTP 요청과 같은 네트워크 호출에 사용된다. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.   UI 백엔드 : 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.   자바스크립트 해석기 : 자바스크립트 코드를 해석하고 실행한다.   자료 저장소 : 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 웹 데이터 베이스 가 정의되어 있다.   크롬은 대부분의 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지하는 것이 주목할만하다. 각 탭은 독립된 프로세스로 처리된다.  렌더링 엔진 렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일이다. 렌더링 엔진은 HTML 및 XML 문서와 이미지를 표시할 수 있다. 물론 플러그인이나 브라우저 확장 기능을 이용해 PDF와 같은 다른 유형도 표시할 수 있다. 그러나 이 글에서는 HTML과 이미지를 CSS로 표시하는 주된 사용 패턴에 초점을 맞춘다.  렌더링 엔진들 이 글에서 다루는 브라우저인 크롬과 사파리, 파이어폭스는 두 종류의 렌더링 엔진으로 제작되었다. 크롬은 Blink엔진을 사용하고 사파리는 웹킷(Webkit)엔진을 사용하고 파이어폭스는 모질라에서 직접 만든 게코(Gecko)엔진을 사용한다.  웹킷은 최초 리눅스 플랫폼에서 동작하기 위해 제작된 오픈소스 엔진인데 애플이 맥과 윈도우즈에서 사파리 브라우저를 지원하기 위해 수정을 가했다. 더 자세한 내용은 Webkit 을 참조하자.  동작 과정 렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.  다음은 렌더링 엔진의 기본적인 동작과정이다.  렌더링 엔진은 HTML 문서를 파싱하고 “콘텐츠 트리” 내부에서 태그를 DOM 노드로 변환한다. 그 다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 그 다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 스타일 정보와 HTML 표시 규칙은 “렌더 트리”라고 부르는 또 다른 트리를 생성한다.  렌더 트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 있는데 정해진 순서대로 화면에 표시된다.  렌더 트리 생성이 끝나면 배치가 시작되는데 이것은 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어 내는 그리기 과정이다.  일련의 과정들이 점진적으로 진행된다는 것을 아는 것이 중요하다. 렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.  동작 과정 예시    웹킷 동작 과정    모질라의 게코 렌더링 엔진 동작 과정    웹킷과 게코가 용어를 약간 다르게 사용하고 있지만 동작 과정은 기본적으로 동일하다는 것을 위 두 그림을 통해 알 수 있다.  게코는 시각적으로 처리되는 렌더 트리를 “형상 트리(frame tree)”라고 부르고 각 요소를 형상(frame)이라고 하는데 웹킷은 “렌더 객체(render object)”로 구성되어있는 “렌더 트리(render tree)”라는 용어로 사용한다. 웹킷은 요소를 배치하는데 “배치(layout)” 라는 용어를 사용하지만 게코는 “리플로(reflow)”라고 부른다. “어태치먼트(attachment)”는 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 시각 정보를 연결하는 과정이다. 게코는 HTML과 DOM 트리 사이에 “콘텐츠 싱크(content sink)” 라고 부르는 과정을 두는데 이는 DOM요소를 생성하는 공정으로 웹킷과 비교하여 의미있는 차이점이라고는 보지 않는다.  파싱과 DOM 트리 구축 파싱 일반 파싱은 렌더링 엔진에서 매우 중요한 과정이기 때문에 더 자세히 다룰 필요가 있다. 파싱에 대한 간단한 소개로 시작한다.  문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것을 의미한다. 파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리(parse tree) 또는 문법 트리(syntax tree)라고 부른다.  예를 들면 2+3-1 과 같은 표현식은 다음과 같은 트리가 된다.   문법 파싱은 문서에 작성된 언어 또는 형식의 규칙에 따르는데 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다. 이것을 문맥 자유 문법이라고 한다. 인간의 언어는 이런 모습과는 다르기 때문에 기계적으로 파싱이 불가능하다.  파서-어휘 분석기 조합 파싱은 어휘 분석과 구문 분석이라는 두 가지로 구분할 수 있다.  어휘 분석은 자료를 토큰으로 분해하는 과정이다. 토큰은 유효하게 구성된 단위의 집합체로 용어집이라고도 할 수 있는데 인간의 언어로 말하자면 사전에 등장하는 모든 단어에 해당된다.  구문 분석은 언어의 구문 규칙을 적용하는 과정이다.  파서는 보통 두 가지 일을 하는데 자료를 유효한 토큰으로 분해하는 어휘 분석기(토큰 변환기라고도 함)가 있고, 언어 구문 규칙에 따라 문서 구조를 분석함으로써 파싱 트리를 생성하는 파서가 있다. 어휘 분석기는 공백과 줄 바꿈 같은 의미 없는 문자를 제거한다. 파싱 과정은 계속 반복된다. 파서는 보통 어휘 분석기로부터 새 토큰을 받아서 구문 규칙과 일치하는지 확인한다. 규칙에 맞으면 토큰에 해당하는 노드가 파싱 트리에 추가되고 파서는 또 다르토큰을 요청한다.  규칙에 맞지 않으면 파서는 토큰을 내부적으로 저장하고 토큰과 일치하는 규칙이 발견될 때까지 요청한다. 맞는 규칙이 없는 경우 예외로 처리하는데 이것은 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미다.  변환 파서 트리는 최종 결과물이 아니다. 파싱은 보통 문서를 다른 양식으로 변환하는데 컴파일이 하나의 예가 된다. 소스 코드를 기계 코드로 만드는 컴파일러는 파싱 트리 생성 후 이를 기계 코드 문서로 변환한다.   파싱 예시 이전 수학 수식을 파싱 트리로 만든 사진을 기억할 것이다. 응용하여 간단한 수학 언어를 정의하고 파싱 과정을 살펴보자.  어휘 : 수학 언어는 정수, 더하기, 뺴기 기호를 포함한다.  구문 :     언어 구문의 기본적인 요소는 표현식, 항, 연산자이다.   언어에 포함되는 표현식의 수는 제한이 없다.   표현식은 “항” 뒤에 “연산자” 그 뒤에 또 다른 항이 따르는 형태로 정의한다.   연산자는 더하기 토큰 또는 빼기 토큰이다.   정수 토큰 또는 하나의 표현식은 항이다.   입력된 값 2+3-1 을 분석해보자  규칙에 맞는 첫 번째 부분 문자열은 2이다. 규칙 5번에 따르면 이것은 하나의 항이다. 두 번째로 맞는 것은 2+3인데 이것은 항 뒤에 연산자와 또 다른 항이 등장한다는 세 번쨰 규칙과도 일치한다. 입력 값의 마지막 부분까지 진행하면 또 다른 일치를 발견할 수 있다. 2+3은 항과 연산자와 항으로 구성된 하나의 새로운 항이라는 것을 알고 있기 때문에 2+3-1은 하나의 표현식이 된다. 2++은 어떤 규칙과도 맞지 않기 때문에 유효하지 않은 입력이 된다.  어휘와 구문에 대한 공식적인 정의 어휘는 보통 정규 표현식으로 표현한다. 예를 들면 언어는 다음과 같이 정의될 것이다. INTEGER : 0|[1-9][0-9]* PLUS : + MINUS : -   보다시피 정수는 정규표현식으로 정의한다. 구문은 보통 BNF라고 부르는 형식에 따라 정의한다. 언어는 다음과 같이 정의될 것이다.  expression := term operation term   operation := PLUS | MINUS   term := INTEGER | expression    문법이 문맥 자유 문법이라면 언어는 정규 파서로 파싱할 수 있다. 문맥 자유 문법을 쉽게 말하면 완전히 BNF로 표현 가능한 문법이다. 공식적인 정의는 위키백과의 문맥 자유 문법을 참조한다.  파서의 종류 파서는 기본적으로 하향식 파서와 상향식 파서가 있다. 하향식 파서는 구문의 상위 구조로부터 일치하는 부분을 찾기 시작하는데 반해 상향식 파서는 낮은 수준에서 점차 높은 수준으로 찾는다.  두 종류의 파서가 예제를 어떻게 파싱하는지 살펴보자.  하향식 파서는 2+3과 같은 표현식에 해당하는 높은 수준의 규칙을 먼저 찾는다. 그 다음 표현식으로 2+3-1을 찾을 것이다. 표현식을 찾는 과정은 일치하는 다른 규칙을 점진적으로 더 찾아내는 방식인데 어쨌거나 가장 높은 수준의 규칙을 먼저 찾는 것으로부터 시작한다.  상향식 파서는 입력 값이 규칙에 맞을 때까지 찾아서 맞는 입력 값을 규칙으로 바꾸는데 이 과정은 입력 값의 끝까지 진행된다. 부분적으로 일치하는 표현식은 파서 스택에 쌓인다.                 스택       입력값                               2+3-1                 항       +3-1                 항 연산자       3-1                 표현식       -1                 표현식 연산자       1                 표현식                   상향식 파서는 입력 값의 오른쪽으로 이동하면서(입력 값의 처음을 가리키는 포인터가 오른쪽으로 이동하는 것을 상상) 구문 규칙으로 갈수록 남는 것이 점차 감소하기 때문에 이동-감소 파서라고 부른다.  파서 자동 생성 파서를 생성해 줄 수 있는 도구를 파서 생성기라고 한다. 언어에 어휘나 구문 규칙 같은 문법을 부여하면 동작하는 파서를 만들어 준다. 파서를 생성하는 것은 파싱에 대한 깊은 이해를 필요로 하고 수동으로 파서를 최적화하여 생성하는 것은 쉬운 일이 아니기 때문에 파서 생성기는 매우 유용하다.  웹킷은 잘 알려진 두 개의 파서 생성기를 사용한다. 어휘 생성을 위한 플렉스(Flex)와 파서 생성을 위한 바이슨(Bison)이다. 렉스(Lex)와 약(Yacc)이라는 이름과 함께 들어본 적이 있을지도 모르겠다. 플렉스는 토큰의 정규 표현식 정의를 포함하는 파일을 입력 받고 바이슨은 BNF 형식의 언어 구문 규칙을 입력 받는다.  HTML 파서 HTML 파서는 HTML 마크업을 파싱 트리로 변환한다.  HTML 문법 정의 HTML의 어휘와 문법은 W3C에 의해 명세로 작성되어있다.  문맥 자유 문법이 아님 파싱 일반 소개를 통해 알게 된 것처럼 문법은 BNF와 같은 형식을 이용하여 공식적으로 정의할 수 있다.  안타깝게도 모든 전통적인 파서는 HTML에 적용할 수 없다. 그럼에도 불구하여 지금까지 파싱을 설명한 것은 그냥 재미 때문은 아니다. 파싱은 CSS와 자바스크립트를 파싱하는 데 사용된다. HTML은 파서가 요구하는 문맥 자유 문법에 의해 쉽게 정의할 수 없다.  HTML 정의를 위한 공식적인 형식으로 DTD(문서 형식 정의)가 있지만 이것은 문맥 자유 문법이 아니다.  이것은 언뜻 이상하게 보일 수도 있는데 HTML이 XML과 유사하기 때문이다. 사용할 수 있는 XML 파서는 많다. HTML을 XML 형태로 재구성한 XHTML도 있는데 무엇이 큰 차이점일까?  차이점은 HTML이 더 “너그럽다”는 점이다. HTML은 암묵적으로 태그에 대한 생략이 가능하다. 가끔 시작 또는 종료 태그 등을 생략한다. 전반적으로 뻣뻣하고 부담스러운 XML에 반하여 HTML은 “유연한” 문법이다.  이런 작은 차이가 큰 차이를 만들어 낸다. 웹 제작자의 실수를 너그럽게 용서하고 편하게 만들어주는 이것이야 말로 HTML이 인기가 있었던 이유다. 다른 한편으로는 공식적인 문법으로 작성하기 어렵게 만드는 문제가 있다. 정리하자면 HTML은 파싱하기 어렵고 전통적인 구문 분석이 불가능하기 때문에 문맥 자유 문법이 아니라는 것이다. XML 파서로도 파싱하기 쉽지 않다.  HTML DTD HTML의 정의는 DTD 형식 안에 있는데 SGML 계열 언어의 정의를 이용한 것이다. 이 형식은 허용되는 모든 요소와 그들의 속성 그리고 중첩 구조에 대한 정의를 포함한다. 앞서 말 한대로 HTML DTD는 문맥 자유 문법이 아니다.  DTD는 여러 변종이 있다. 엄격한 형식은 명세만을 따르지만 다른 형식은 낡은 브라우저에서 사용된 마크업을 지원한다. 낡은 마크업을 지원하는 이유는 오래된 콘텐츠에 대한 하위 호환성 때문이다. 현재의 엄격한 형식 DTD는 www.w3.org/TR/html4/strict.dtd 에서 확인할 수 있다.  DOM “파싱 트리”는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. DOM은 문서 객체 모델(Document Object Model)의 준말이다. 이것은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점이다. 트리의 최상위 객체는 문서이다. DOM은 마크업과 1:1의 관계를 맺는다. 예를 들면 아래와 같은 마크업이 있다. &lt;html&gt;   &lt;body&gt;    &lt;p&gt;Hello World&lt;/p&gt;    &lt;div&gt;&lt;img src=\"example.png\" /&gt;&lt;/div&gt;   &lt;/body&gt; &lt;/html&gt;    이를 다음과 같은 DOM 트리로 변환 가능하다.   HTML과 마찬가지로 DOM은 W3C에 의해 명세(www.w3.org/DOM/DOMTR)가 정해져 있다. 이것은 문서를 다루기 위한 일반적인 명세인데 부분적으로 HTML 요소를 설명하기도 한다. HTML 정의는 www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html에서 찾을 수 있다.  트리가 DOM 노드를 포함한다고 말하는 것은 DOM 접점의 하나를 실행하는 요소를 구성한다는 의미다. 브라우저는 내부의 다른 속성들을 이용하여 이를 구체적으로 실행한다.  References    How Browsers Work: Behind the scenes of modern web browsers  "
  },
  
  {
    "title": "Operating System Concepts - (9)",
    "url": "/posts/Operating-System-Concepts-9/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-10 09:27:53 +0900",
    "content": "     Virtual Memory (1)   가상 메모리는 운영체제가 관리한다.   Demand Paging (요구 페이징)    실제로 필요할 때 page를 메모리에 올리는 것. (요청이 있으면 페이지를 메모리에 올리겠다는 의미)   실제로 대부분의 시스템들은 Paging 기법 사용 중   요구 페이징의 장점            I/O양의 감소 (프로그램 중에 빈번하게 사용되는 부분은 지극히 제한적이고, 좋은 소프트웨어일수록 프로그램 사용에 있어 굉장히 방어적으로 코드를 작성하기 때문에 잘 사용되지 않는다.)       물리 Memory 사용량 감소       I/O 요청이 있을때만 메모리에 올리기 때문에 한정된 메모리 공간을 효율적으로 사용하고, 메모리에서 직접 서비스하는 비율이 높아지기 때문에 응답 시간이 빨라진다.       멀티프로그래밍 환경에서는 더 많은 사용자 수용 가능. (프로그램 여러개가 동시에 메모리에 올라가는 환경에서는 더 많은 사용자가 동시에 메모리에 올라갈 수 있기 때문에 효과적)           Vaild / Invaild bit의 사용 (페이지 테이블의 엔트리마다 존재)            Invaild의 의미                    사용되지 않는 주소 영역인 경우           페이지가 물리적 메모리에 없는 경우                       처음에는 모든 page entry가 invaild로 초기화       address translation시에 invalid bit이 set 되어 있으면 ==&gt; page Fault 발생!            Page Fault    운영체제의 Page Fault 처리루틴.   invalid page를 접근하면 MMU가 trap을 발생시키게 된다. (page fault trap)   CPU가 자동적으로 OS에게 넘어감. kernel mode로 들어가 OS에 page fault를 처리하는 코드인 page fault handler가 실행된다.        다음과 같은 순서로 page fault를 처리함             잘못된 요청이 아닌지? address가 잘못되있거나(프로세스가 사용하지 않는 주소인지), 접근권한을 잘못 사용했다던가 하면 =&gt; process를 abort시킴.       정상적인 요청이라면 디스크에서 페이지를 메모리로 올려준다.       만약 비어있는 메모리가 없다면(페이지 프레임이 없다면), 하나를 쫓아내야 한다.(replace)       빈 페이지 프레임을 획득하면 해당 페이지를 디스크에서 메모리로 읽어온다. (이 작업은 매우 느린 작업.)   (1) disk I/O 작업이 끝날때까지, 이 프로세스는 CPU를 뺏기고(CPU 낭비이기 때문에) block 상태가 됨. (preempt) (페이지 폴트가 난 프로세스는 CPU를 뺏기고 당장 CPU를 사용할 수 있는 ready 상태의 프로세스 에게 CPU를 넘겨준다. 넘겨주기 전에 디스크 컨트롤러에게 그 페이지를 읽어오라고 부탁한다.)   (2) Disk Read가 끝나면 page tables entry기록, valid/invalid bit = “valid” (그리고 디스크 I/O가 끝나면, 인터럽트가 걸려서 OS가 CPU를 가지고 페이지 폴트 처리가 끝났으므로 테이블에 valid로 표시하고 해당 페이지 프레임 번호를 적어둠.)   (3) ready queue에 process를 insert -&gt; dispatch later (페이지 폴트났던 프로세스가 CPU를 다시 잡고 정상적으로 MMU에의해 주소변환이 되고 running 상태가 됨.)       instruction 수행 재개.           Steps in Handling a Page Fault      주소변환을 하려고 봤더니 invalid로 표시되어 있음.   페이지가 메모리위에 올라와있지 않다는 말이고 trap에 걸려서 CPU가 OS에게 자동으로 넘어간다.   OS는 백킹스토어에 있는 페이지를 물리메모리로 올린다.   빈 페이지 프레임이 없으면 뭔가를 쫓아내고 올린다.   올렸으면, 해당 프레임번호를 엔트리에 적어두고, invalid -&gt; valid로 수정한다.   나중에 CPU를 다시 얻어서, 정상적으로 주소 변환을 하면 물리 메모리에 정상 접근이 가능해진다.   Performance of Demand Paging (요구 페이징 성능)     페이지 폴트가 발생했을 때 디스크 접근하는 것은 매우 오래 걸리는 작업이기 때문에 페이지 폴트가 얼마나 발생하는가에 따라서 메모리 접근하는 시간이 크게 좌우됨.   페이지 폴트의 비율(Page Fault Rate) : (0 &lt;= p &lt;= 1.0)            if p=0 : 페이지폴트 발생 X. 메모리 위에 항상 페이지가 있음       if p=1 : 메모리 참조할때마다 항상 페이지폴트가 발생함.       실제로는 거의 페이지폴트가 발생하지 않음. (0.0xx)           Effective Access Time            = (1-p) * memory access + p ( OS &amp; HW page fault overhead + 공간 없을때 내쫓기[swap page out if needed] + swap page in + (나중에 CPU얻으면 restart) OS &amp; HW restart overhead )       그러므로 페이지가 부재하면 오버헤드가 발생함.           Free page frame이 없는 경우         Page replacement            어떤 frame을 빼앗아올지 결정       곧바로 사용되지 않을 page를 쫒아내는 것이 좋음       동일한 페이지가 여러 번 메모리에서 쫒겨났다가 다시 들어올 수 있음.       OS가 담당하는 업무                Replacement algorithm            가능하면 Page-fault rate를 최소화하는 것이 목표       알고리즘의 평가                    주어진 page reference string에 대해 page fault를 얼마나 내는지 조사           (p(페이지 폴트 발생비율)을 가급적 0으로 만드는게 이 알고리즘의 목표)                       reference string의 예시 1,2,3,4,1,2,5,1,2,3,4,5 (시간순서에 따라 페이지 참조 순서를 나열한 것)           Page Replacement     Page Replacement 라는 것은 어떤것을 쫓아낼 지 결정하고, 그 쫓아낼 victim 이 결정되면 Disk로 쫓아내는 것이다.   어떤걸 쫓아낼 지 결정하고, 만약 쫓아낼 때, victim이 Disk에서 메모리에 올라온 이후에 변경(Write)된 내용이 있다면 변경된 내용을 백킹스토어에 써줘야 한다. 그 상황이 아니라면 그냥 physical memory에서 지워주기만 하면 된다.   쫓아내고 빈 자리에 새로운 page를 올려준다. 쫓겨난 페이지에 대한 테이블 valid-invalid bit를 invalid로 변경하고, 메모리에 올라온 페이지에 대한 페이지 엔트리에는 페이지 테이블에 frame number를 적고, valid로 바꿔준다.   이런 역할을 OS가 맡아 진행하는 것      Replacement Algorithm(교체 알고리즘)   1. 최적 알고리즘 (Optimal Algorithm)     페이지 폴트를 가장 적게하는 알고리즘. 하지만, 미래의 일을 예측할 수 없기 때문에 이론적인 알고리즘임.   Offline Optimal Algorithm 이라고도 부름. (실제 시스템에서 온라인으로 사용하는게 아니기 때문에)   제일 먼 미래에 사용될 page를 쫓아내는 방식.   다른 알고리즘의 성능에 대한 upper bound를 제공. 아무리 좋은 알고리즘을 만들어도 이 최적 알고리즘보다 더 좋은 알고리즘은 만들 수 없기 때문에 참고용으로만 사용 가능함.   빨간색으로 적은 부분이 페이지 폴트가 발생하는 부분. 연보라색은 페이지 폴트가 나지 않고 메모리에서 직접 참조되는 경우.   2. FIFO (Fist In First Out) Algorithm    여기서부터 실사용 가능한 알고리즘 (미래를 모르는 상황에서 사용하는 알고리즘. 미래 예측.)    먼저 들어온 것을 먼저 내쫓음   FIFO Anomaly(Belady’s Anomaly) : 메모리 크기(page frame 갯수)를 늘려줘도 성능이 더 나빠지는 특이한 상황이 발생할 수 있음.   3. LRU (Least Recently Used) Algorithm     실제로 가장 많이 사용하고 있는 알고리즘   가장 오래 전에 참조된 것을 지우고 최근에 쓰인 것은 남기는 것. 최근에 쓰인 페이지가 또 쓰일 것이라고 가정하는 알고리즘.   4. LFU (Least Frequently Used) Algorithm    참조 횟수 (reference count)가 가장 적은 페이지를 지우는 것.            최저 참조 횟수인 page가 여럿 있는 경우                    LFU 알고리즘 자체에서는 여러 page 중 임의로 선정한다.           성능 향상을 위해 가장 오래 전에 참조된 page를 지우게 구현할 수도 있다.                           장점            LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 시간규모를 보기 때문에 page의 인기도를 좀 더 정확하게 반영할 수 있음.           단점            참조시점의 최근성을 반영하지 못함. LRU보다 구현이 복잡함.           5. LRU vs LFU 예제     페이지 프레임은 4개 존재. 1,2,3,4중에 하나를 쫓아내야 함.   LRU : 1번을 쫓아냄 / LFU : 4번을 쫓아냄.   제일 참조횟수가 많은 1번을 쫒아내는 LRU, 제일 최근에 참조된 페이지를 쫒아낸 LFU -&gt; 누가 더 비효율적인지 측정 힘듬.   6. LRU, LFU 알고리즘의 구현   **1. LRU **    LRU는 메모리에 있는 페이지들을 참조 순서에 따라 한줄로 줄세우기를 한다. 맨 위에 페이지는 가장 오래전에 참조된 페이지.   LRU : Linkedlist 형태로 맨 아래로 갈수록 가장 최근에 참조한 페이지.   쫓아낼 때 비교가 필요없다. 제일 위에 있는 페이지를 내쫓으면 됨.   시간복잡도 : O(1)   2. LFU     LFU : 밑으로 갈수록 참조 횟수가 많은 페이지.   하지만 이 알고리즘은 한 줄로 줄세우기가 불가능함. 카운팅 될 때마다 비교를 해서 어디까지 내려올 수 있는지 비교하고 자리 바꿈을 해야 하기 때문.   시간복잡도 : O(n)   힙을 사용(Complete binary tree)하게 되면 시간복잡도 : O(log n)   경로를 따라가면서 자식 2개와만 비교하기 때문에 log n 의 시간복잡도가 발생하게 됨. (이진트리의 장점)  "
  },
  
  {
    "title": "데이터베이스 동시성 제어",
    "url": "/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%A0%9C%EC%96%B4/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 21:18:58 +0900",
    "content": "동시성 제어 방식 중 대표적으로 MVCC(Multi-Version Concurrency Control) 와 Lock-Based Concurrency Control 이 있다.  MVCC(Multi-Version Concurrency Control)  MVCC는 데이터의 여러 버전을 유지하여 트랜잭션이 동시에 데이터를 읽고 쓸 수 있도록 하는 방식이다. 각 트랜잭션은 자신만의 일관된 스냅샷을 기반으로 데이터를 읽어, 다른 트랜잭션의 변경 사항에 영향을 받지 않는다.  데이터의 각 버전을 유지하여 읽기 작업이 쓰기 작업과 독립적으로 이루어질 수 있다. 트랜잭션은 시작 시점의 스냅샷을 기반으로 데이터를 읽어, 다른 트랜잭션의 변경 사항을 보지 못한다.  또한 읽기 작업 시 잠금을 사용하지 않아 높은 동시성을 제공한다. 읽기 작업이 잠금에 의해 지연되지 않아서, 읽기 중심의 애플리케이션에서 높은 성능을 보인다. 읽기 작업시 잠금을 사용하지 않기 떄문에 쓰기 작업과 충돌도 줄어든다. 하지만, 여러 버전의 데이터를 유지해야하기 때문에 저장 공간이 더 많이 필요할 수 있다.  Lock-Based Concurrency Control Lock-Based 방식은 데이터에 접근할 때 잠금(Lock)을 사용해 동시성을 제어한다. 트랜잭션이 데이터를 읽거나 수정할 때 해당 데이터에 잠금을 걸어 다른 트랜잭션의 접근을 제한한다. 즉 잠금을 통해 데이터의 일관성과 무결성을 직접 제어하는 것이다.  데이터에 접근할 때 잠금을 걸어서 다른 트랜잭션의 접근을 제한한다. 읽기 작업은 공유 잠금을, 쓰기 작업은 배타 잠금을 사용해 동시성을 제어한다. 많은 다수의 트랜잭션이 동일한 데이터에 접근할 경우 성능 저하가 발생할 수 있다. 또한 잘못된 잠금 순서나 설계로 인해 교착 상태(Deadlock)이 발생할 위험이 있다.  MVCC와 Lock-Based Concurrency Control 중 어떤것을 선택해야할 까? 실제 데이터베이스 시스템, 특히 MySQL의 InnoDB에서는 MVCC와 Lock-Based 방식의 장점을 결합해 동시성 제어를 최적화한다.  읽기 트랜잭션은 MVCC를 사용하여 일관된 스냅샷을 기반으로 데이터를 읽으므로, 잠금을 최소화하고 높은 동시성을 유지할 수 있다.  쓰기 트랜잭션은 잠금을 사용해서 데이터의 일관성과 무결성을 유지하고, 동시에 데이터 충돌을 방지한다.  References    MVCC(Multi Version Concurrency Control) 알아보기   Lock Based Concurrency Control Protocol in DBMS   What is MVCC? How does multiversion concurrency control work?  "
  },
  
  {
    "title": "HTTP 메서드의 멱등성",
    "url": "/posts/HTTP-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 20:43:58 +0900",
    "content": "멱등성이란? 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 멱등성이라고 한다. HTTP 메서드의 멱등성은 동일한 요청을 한 번 보내는 것과 여러번 보내는 것이 서로 동일한 효과를 지니며, 서버의 상태도 동일하게 남을 경우에 멱등하다고 말할 수 있다. 대표적으로 멱등한 메서드는 GET , HEAD , PUT , DELETE , TRACE , OPTIONS 가 있다.  멱등성은 어떻게 사용되는가?  전송 커넥션이 끊어졌을 때, 멱등성은 클라이언트가 다시 같은 요청을 해도 되는가에 대한 판단 근거가 될 수 있다. 멱등하다면 요청을 재시도할 때 같은 서버의 상태를 보장하기 때문에 문제가 없다. 하지만, 멱등하지 않다면 재시도 요청시 중복 요청을 보내 문제를 발생 시킬 수 있다.  예를 들어, 사용자가 결제하는 시점에 타임아웃으로 인해 정상 응답을 못받는 상황을 생각해 볼 수 있다. 해당 경우에서 멱등하지 않은 결제 API 경우에는 결제가 성공했는지 수동으로 확인하고 요청해야한다. 하지만, 멱등한 결제 API의 경우에는 안심하고 여러 번 요청할 수 있으며 중복 요청으로 발생하는 문제 (중복 문제)를 방지할 수 있다.  References    토스페이먼츠 - 멱등성이 뭔가요?   멱등성  "
  },
  
  {
    "title": "BOJ_2503_숫자 야구 (Java)",
    "url": "/posts/BOJ2503%EC%88%AB%EC%9E%90-%EC%95%BC%EA%B5%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-09 16:38:36 +0900",
    "content": "[Silver III] 숫자 야구 - 2503  문제 링크  성능 요약  메모리: 16248 KB, 시간: 120 ms  분류  브루트포스 알고리즘, 구현  제출 일자  2025년 1월 9일 16:33:20  문제 설명  정보문화진흥원 정보 영재 동아리에서 동아리 활동을 하던 영수와 민혁이는 쉬는 시간을 틈타 숫자야구 게임을 하기로 했다.   \t영수는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 마음속으로 생각한다. (예: 324) \t민혁이는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 영수에게 묻는다. (예: 123) \t민혁이가 말한 세 자리 수에 있는 숫자들 중 하나가 영수의 세 자리 수의 동일한 자리에 위치하면 스트라이크 한 번으로 센다. 숫자가 영수의 세 자리 수에 있긴 하나 다른 자리에 위치하면 볼 한 번으로 센다.   예) 영수가 324를 갖고 있으면    \t429는 1 스트라이크 1 볼이다. \t241은 0 스트라이크 2 볼이다. \t924는 2 스트라이크 0 볼이다. \t영수는 민혁이가 말한 수가 몇 스트라이크 몇 볼인지를 답해준다. \t민혁이가 영수의 세 자리 수를 정확하게 맞추어 3 스트라이크가 되면 게임이 끝난다. 아니라면 민혁이는 새로운 수를 생각해 다시 영수에게 묻는다.   현재 민혁이와 영수는 게임을 하고 있는 도중에 있다. 민혁이가 영수에게 어떤 수들을 물어보았는지, 그리고 각각의 물음에 영수가 어떤 대답을 했는지가 입력으로 주어진다. 이 입력을 바탕으로 여러분은 영수가 생각하고 있을 가능성이 있는 수가 총 몇 개인지를 알아맞혀야 한다.  아래와 같은 경우를 생각해보자.     \t민혁: 123 \t영수: 1 스트라이크 1 볼. \t민혁: 356 \t영수: 1 스트라이크 0 볼. \t민혁: 327 \t영수: 2 스트라이크 0 볼. \t민혁: 489 \t영수: 0 스트라이크 1 볼.   이때 가능한 답은 324와 328, 이렇게 두 가지이다.  영수는 동아리의 규율을 잘 따르는 착한 아이라 민혁이의 물음에 곧이곧대로 정직하게 답한다. 그러므로 영수의 답들에는 모순이 없다.  민혁이의 물음들과 각각의 물음에 대한 영수의 답이 입력으로 주어질 때 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력하는 프로그램을 작성하시오.  입력  첫째 줄에는 민혁이가 영수에게 몇 번이나 질문을 했는지를 나타내는 1 이상 100 이하의 자연수 N이 주어진다. 이어지는 N개의 줄에는 각 줄마다 민혁이가 질문한 세 자리 수와 영수가 답한 스트라이크 개수를 나타내는 정수와 볼의 개수를 나타내는 정수, 이렇게 총 세 개의 정수가 빈칸을 사이에 두고 주어진다.  출력  첫 줄에 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력한다.     문제 풀이   가능한 모든 3자리 숫자를 생성한다. 이때 문제의 조건에 맞는 숫자만을 리스트에 추가한다.  추가 조건     세 자리의 숫자가 모두 달라야 함   0이 포함되지 않아야 함   스트라이크와 볼 계산    같은 위치에 같은 숫자가 있으면 스트라이크 증가   다른 위치에 같은 숫자가 있으면 볼 증가   시간 복잡도 분석  초기 숫자 생성: O(900) 각 질문에 대한 검사: O(N * L * 9), N은 질문의 수, L은 현재 리스트의 크기     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint N = Integer.parseInt(br.readLine()); \t\tint res = 0; \t\tList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); \t\tfor(int i=123; i&lt;=987; i++) { \t\t\tString str = String.valueOf(i); \t\t\tif(str.charAt(0) == str.charAt(1) || str.charAt(1) == str.charAt(2) || str.charAt(2) == str.charAt(0)) continue; \t\t\tif(str.charAt(0) == '0' || str.charAt(1)== '0' || str.charAt(2) == '0') continue; \t\t\tlist.add(i); \t\t} \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint input = Integer.parseInt(st.nextToken()); \t\t\tint strike = Integer.parseInt(st.nextToken()); \t\t\tint ball = Integer.parseInt(st.nextToken()); \t\t    List&lt;Integer&gt; newList = new ArrayList&lt;&gt;();  \t\t\tfor(int num : list) { \t\t\t\tint s = 0, b = 0; \t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\tchar c1 = String.valueOf(input).charAt(j); \t\t\t\t\tfor(int k=0; k&lt;3; k++) { \t\t\t\t\t\tchar c2 = String.valueOf(num).charAt(k); \t\t\t\t\t\tif(c1 == c2 &amp;&amp; j == k) s++; \t\t\t\t\t\telse if(c1 == c2 &amp;&amp; j != k) b++; \t\t\t\t\t} \t\t\t\t} \t\t\t\t \t\t\t\tif(s == strike &amp;&amp; b == ball) newList.add(num); \t\t\t} \t\t\tlist = newList; \t\t} //\t\tSystem.out.println(\"Possible numbers: \" + list); \t\tres = list.size(); \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   "
  },
  
  {
    "title": "클라이언트가 웹사이트에 처음 접근했을 때 발생하는 일",
    "url": "/posts/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EA%B0%80-%EC%9B%B9%EC%82%AC%EC%9D%B4%ED%8A%B8%EC%97%90-%EC%B2%98%EC%9D%8C-%EC%A0%91%EA%B7%BC%ED%96%88%EC%9D%84-%EB%95%8C-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%BC/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 02:53:07 +0900",
    "content": "사용자가 https://www.google.com/ 를 입력하면, 브라우저는 HTTP 프로토콜을 사용해 구글 웹 서버와 통신하려고 한다. HTTP는 OSI 7계층 중 애플리케이션 계층에서 동작하는 프로토콜이다.  이때 브라우저는 요청한 도메인 이름 (www.google.com)에 대한 IP 주소를 알아야 하기 때문에 DNS(Domain Name System) 서버에 질의합니다. 이 질의 과정 또한 애플리케이션 계층에서 이루어지며, DNS 서버는 해당 도메인에 대한 IP 주소 ( 예를 들어 142.250.190.78 ) 를 응답한다.  IP 주소를 얻은 후, 브라우저는 구글 서버와 통신을 시작한다. HTTP는 TCP/IP를 기반으로 작동하므로, 데이터를 주고받기 전에 TCP 3-Way Handshake 과정이 필요하다. 이 단계는 전송 계층(4계층) 에서 이루어진다.  TCP 연결이 성립된 후, 브라우저는 HTTP Request 메시지를 생성하여 구글 서버에 보낸다. 예를 들어, 브라우저는 \"GET / HTTP / 1.1\" 이라는 요청을 TCP 포로토콜을 통해 80번 포트로 전송한다. 이때 데이터는 패킷(Packet) 형태로 네트워크를 통해 전달된다. 네트워크를 통해 데이터를 전송하기 위해서는 네트워크 계층(3계층) 에서 IP 주소를 사용하고, 데이터 링크 계층(2계층) 에서 MAC 주소를 사용해 패킷이 전송된다.  구글 서버는 클라이언트의 요청을 수신하고 이를 처리한 후, HTTP Response 메시지를 생성하여 응답한다. 서버는 요청이 성공했음을 알리는 200 OK 상태 코드와 함께 웹 페이지 데이터를 전송한다. 브라우저는 이 응답을 받아 HTML, CSS, JS 등의 데이터를 해석하여 화면에 페이지를 렌더링한다.  모든 데이터 전송이 완료되면 클라이언트와 서버는 4-Way Handshake 과정을 거쳐 TCP 연결을 종료한다.  References    웹의 동작 방식   웹페이지를 표시한다는 것: 브라우저는 어떻게 동작하는가   웹 브라우저에 URL 입력하면 일어나는 일 - 인프라 위주  "
  },
  
  {
    "title": "데이터베이스 커넥션 풀(Connection Pool)",
    "url": "/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%BB%A4%EB%84%A5%EC%85%98-%ED%92%80Connection-Pool/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 02:32:38 +0900",
    "content": "애플리케이션과 데이터베이스가 통신을 하기 위해서는 데이터베이스 커넥션이 필요하다.  데이터베이스 커넥션의 생애주기     데이터베이스 드라이버를 사용하여 데이터베이스에 연결   데이터 읽기/쓰기를 위한 TCP 소켓 열기   소켓을 통한 데이터 읽기/쓰기   연결 종료   소켓 닫기   커넥션 풀이 없다면 애플리케이션에서 데이터베이스에 접근해야하는 요청을 처리할 때마다 커넥션을 새로 생성하여 연결하고 해제하는 과정을 반복해야 한다. 이 과정은 비용이 상당히 많이 들기 때문에 요청의 응답시간이 길어진니다.  또 동시에 많은 요청이 들어올 경우 매번 새로운 커넥션을 생성하게 되는데, 데이터베이스의 최대 연결 수를 초과할 수 있다. 데이터베이스는 일반적으로 동시에 처리할 수 있는 요청 개수에 제한이 있는데, 이 제한을 초과하면 요청이 거부되어 사라지거나, 데이터베이스 자체가 비정상 종료될 수 있다.  데이터베이스 커넥션 풀의 장점 커넥션 풀(Connection Pool)은 애플리케이션과 데이터베이스 간의 데이터베이스 연결(Connection)을 미리 생성해두고, 이를 재사용하는 기법이다. 데이터베이스에 접근할 때마다 새로운 연결을 생성하고 종료하는 대신, 미리 준비된 연결을 재사용함으로써 성능을 향상시키고 자원 사용을 최적화할 수 있다.  커넥션 풀의 주요 구성 요소는 초기 풀 크기(Initial Pool Size), 최소 풀 크기(Minimum Pool Size), 최대 풀 크기(Maximum Pool Size), 연결 대기 시간(Connection Timeout) 등이 있고, 이를 통해 커넥션을 효율적으로 관리하고 사용할 수 있다.  커넥션 풀 사이즈는 클수록 좋을까?  커넥션을 사용하는 주체는 스레드(Thread)이기 때문에, 커넥션과 스레드를 연결지어 생각해야 한다. 만약 커넥션 풀 사이즈가 스레드 풀 사이즈보다 크면, 스레드가 모두 사용하지 못해서 리소스가 낭비된다. 반대로 커넥션 풀 사이즈가 스레드 풀 사이즈보다 작으면, 스레드가 커넥션이 반환되기를 기다려야 하기 때문에 작업이 지연된다.  커넥션 풀 사이즈와 스레드 풀 사이즈의 균형이 맞더라도, 너무 큰 사이즈로 설정하면, 데이터베이스 서버, 애플리케이션 서버의 메모리와 CPU를 과도하게 사용하게 되므로 성능이 저하된다.  References    A Simple Guide to Connection Pooling in Java   HikariCP   데이터베이스 커넥션 풀의 이해와 최적화 전략   데이터베이스 커넥션 풀 (Connection Pool)과 HikariCP   DBCP (DB connection pool)의 개념부터 설정 방법까지! hikariCP와 MySQL을 예제로 설명합니다!   "
  },
  
  {
    "title": "Thread, Process, Core의 수는 다다익선일까?",
    "url": "/posts/Thread-Process-Core%EC%9D%98-%EC%88%98%EB%8A%94-%EB%8B%A4%EB%8B%A4%EC%9D%B5%EC%84%A0%EC%9D%BC%EA%B9%8C/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 01:51:02 +0900",
    "content": "스레드, 프로세스, 코어의 수가 많을수록 시스템 성능이 향상된다고 생각할 수 있지만, 실제로 그렇지 않을 확률이 크다.  Thread 쓰레드가 지나치게 많아지면 운영체제가 쓰레드 간 컨텍스트 스위칭을 자주 수행해야 하여 CPU 자원이 쓰레드 관리에 소모된다. 이로 인해 실제 작업 수행 효율이 떨어질 수 있으며, 많은 쓰레드가 동시에 실행될 경우 메모리나 캐시, 락 등의 자원을 경쟁하게 되어 성능 저하나 Dead Lock이 발생할 가능성이 높아진다. 또한, 쓰레드가 많아지면 동기화와 상태 관리가 복잡해져 버그 발생 가능성도 커진다.  Process 각 프로세스는 독립된 메모리 공간을 가진다. 그래서 많은 프로세스가 동시에 실행되면 메모리 사용량이 급격히 증가할 수 있다. 또한, 프로세스를 생성하고 관리하는 데는 상당한 시스템 자원이 소모되며, 프로세스 간 통신(IPC)이 필요할 경우 성능 저하가 발생할 수 있다. 프로세스 간 컨텍스트 스위칭은 쓰레드 간 컨텍스트 스위칭보다 더 많은 오버헤드를 수반하기 때문에, 프로세스 수가 많아지면 시스템 성능이 저하될 수 있다. 운영체제는 동시에 실행할 수 있는 프로세스 수에 제한이 있으며, 이를 초과하면 새로운 프로세스 생성이 불가능하거나 시스템이 불안정해질 수 있다.  Core  많은 코어를 가진 CPU는 병렬 처리 성능을 향상시킬 수 있지만, 이를 최대한 활용하기 위해서는 소프트웨어가 멀티코어 환경에 최적화되어 있어야 한다. 단일 쓰레드 작업이 주를 이루는 경우, 추가 코어의 이점을 제대로 활용하지 못할 수 있다. 또한, 코어수가 많아질수록 CPU의 비용과 전력 소비가 증가할 수 있으며, 발열 관리도 더 복잡해진다.  References     CPU가 멀티태스킹을 하는 방법: 프로세스 VS 스레드   완전히 정복하는 프로세스 vs 스레드 개념   [10분 테코톡] 🌷 코다의 Process vs Thread  "
  },
  
  {
    "title": "단위테스트 VS 통합테스트",
    "url": "/posts/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-VS-%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 01:07:05 +0900",
    "content": "단위 테스트는 소프트웨어으 가장 작은 단위, 즉 개별 메서드나 함수의 기능을 검증하는 테스트다. 특정 기능이 올바르게 동작하는지 확인하기 위함이며 독립적이고 빠르게 실행된다. 반면 통합 테스트는 개별 모듈들이 결합되어 전체 시스템이 올바르게 동작하는지 검증하는 테스트다. 모듈 간의 상호작용이 올바르게 동작하는지 확인하기 위함이며 실제 데이터베이스, 네트워크 등의 외부 시스템과의 통합을 테스트한다.  슬라이스 테스트란? 슬라이스 테스트는 특정 레이어 (ex. controller, service, repository)에 대한 테스트다. 애플리케이션의 특정 슬라이스가 올바르게 동작하는지 확인하기 위해 작성된다. 스프링의 특정 컴포넌트만 로드하여 테스트하므로 상대적으로 빠르게 실행된다. 관련된 어노테이션으로는 @WebMvcTest, DataJpaTest 등이 있다.  테스트코드를 작성해야 하는 이유 테스트 코드를 작성하면 버그를 초기에 발견할 수 있으며 리팩터링을 수행할 경우 유용하다. 또한 개발 속도를 향상시킬 수 있으며, 코드에 대한 문서로서 역할을 수행할 수 있다.  References     Spring Boot 슬라이스 테스트   스프링캠프 2019 [Track 2 Session 3] : 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?   스프링캠프 2023 [Session 5] 실무에서 적용하는 테스트 코드 작성 방법과 노하우  "
  },
  
  {
    "title": "공유 락(Shared Lock) 과 배타 락(Exclusive Lock)",
    "url": "/posts/%EA%B3%B5%EC%9C%A0-%EB%9D%BDShared-Lock-%EA%B3%BC-%EB%B0%B0%ED%83%80-%EB%9D%BDExclusive-Lock/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-09 00:24:40 +0900",
    "content": "공유 락과 배타 락은 비관적 락(Pessimistic Lock)의 데이터 일관성과 무결성을 위해 사용하는 락 유형이다.  공유 락(Shared Lock) 공유 락은 읽기 락(Read Lock)이라고 부르며, 공유 락이 걸린 데이터는 읽기(SELECT)연산만 가능하며, 쓰기(UPDATE, DELETE)는 불가능하다. 공유 락이 걸린 데이터에 대해서 다른 트랜잭션에서도 공유 락을 획득할 수 있지만, 배타락은 획득할 수 없다. 즉, 공유 락을 사용하면 트랜잭션 내에서 조회한 데이터가 변경되지 않는다는 것을 보장한다. SELECT * FROM table_name WHERE id = 1 FOR SHARE;   배타 락(Exclusive Lock) 배타 락은 쓰기 락(Write Lock)이라고 부르며, 배타 락을 획득한 트랜잭션은 읽기, 쓰기 연산 모두 가능하다. 하지만 다른 트랜잭션에서는 읽기, 쓰기 모두 불가능하다. 즉, 배타 락을 획득한 트랜잭션은 데이터에 대한 독점권을 가진다. SELECT * FROM table_name WHERE id = 1 FOR UPDATE;   정리하자면, 공유 락이 걸린 데이터는 다른 트랜잭션에서 공유락을 획득 할 수 있고, 배타 락이 걸린 데이터는 다른 트랜잭션에서 어떤 종류의 락도 획득할 수 없어서 대기하게 된다.  배타 락 사용시 어떤 상황에 데드락이 발생할까?  데드 락(Dead Lock)이란 교착 상태로, 두 개 이상의 트랜잭션이 서로 필요로 하는 데이터의 락을 점유하고 있어서 무한히 대기하는 상황을 말한다. 트랜잭션은 락을 획득하지 못하는 경우, 다른 트랜잭션이 점유하고 있는 락이 해제될 때 까지 대기한다.  트랜잭션 A, B가 있고 id가 1, 2 인 데이터가 있는 상황에서 두 트랜잭션이 시작한다. 트랜잭션 A는 id 1번을 읽고, 2번을 변경하는 트랜잭션이다. 트랜잭션 B는 id 2번을 읽고 1번을 변경하는 트랜잭션이다.  데드락 상황     A는 1번, B는 2번 데이터에 대해 공유 락을 획득한다.   A는 2번 데이터의 공유 락을 가지고 있는 B 트랜잭션이 락을 해제할 때 까지 대기한다.   B는 1번 데이터의 공유 락을 가지고 있는 A 트랜잭션이 락을 해제할 때 까지 대기한다.   데드락을 해결하는 방법     트랜잭션에서 락 획득 순서를 일관되게 만들기. 모든 트랜잭션에서 1번 데이터, 2번 데이터 순으로 락을 획득할 시 데드락이 발생하지 않는다.   락 타임아웃을 설정한다.   References    MySQL 8.0의 공유 락(Shared Lock)과 배타 락(Exclusive Lock)   JPA의 비관적 락, MySQL 8.0 공유락과 베타락을 통한 동시성 제어   Shared and Exclusive Locks   [10분 테코톡] ⛲️ 오즈의 데이터베이스 Lock  "
  },
  
  {
    "title": "Operating System Concepts - (8)",
    "url": "/posts/Operating-System-Concepts-8/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-09 00:07:19 +0900",
    "content": "     Memory Management - (3)        맨 왼쪽 테이블이 Logical memory, Logical Memory의 개수만큼 가운데 있는 페이지 테이블에 엔트리가 존재한다.   논리적인 메모리가 최종적으로 물리적인 페이지 어디에 적재되어 있는지에 대해서도 페이지 테이블에 저장해둔다.   주소 변환 정보 뿐만 아니라 valid-invalid bit이 같이 들어있다.   Logical Memory의 최대 개수만큼 페이지 테이블 엔트리가 존재하기 때문에, 현재 사용하고 있지 않는 영역이더라도 엔트리가 존재한다. 사진속 6, 7 페이지가 없지만 페이지 테이블은 존재하는 것과 같다. 이로 인해 valid-invalid bit을 통해 이미 물리적으로 적재된 페이지인지 판별이 가능하다.   항상 메모리에 올라와있지 않거나, 물리적으로 적재되어있지 않은 경우 invalid bit을 표기하여 파악 가능하다.   Memory Protection    page table의 각 entry마다 아래의 bit를 둔다.     Protection bit      page에 대한 접근 권한 (read/write/read-only)   Valid-Invaild bit    “valid”는 해당 주소의 frame에 그 프로세스를 구성하는 유효한 내용이 있음을 뜻함 (접근 허용)   “invalid”는 해당 주소의 frame에 유효한 내용이 없음을 뜻함. (접근 불허) 이 때, 유효한 내용이 없다는 의미는 프로세스가 그 주소 부분을 사용하지 않고 있거나, 해당 페이지가 메모리에 올라와 있지 않고 swap area(backing store)에 임시 저장되어 있는 경우를 뜻함.   Inverted Page Table (역방향 페이지 테이블)    page table이 매우 큰 이유            모든 process 별로 그 logical address에 대응하는 모든 page에 대해 page table entry가 존재.       대응하는 page가 메모리에 있든 아니든 간에 page table에는 entry로 존재       공간 오버헤드가 큰 편.           Inverted page table            page frame 하나 당 page table에 하나의 entry를 둔 것 (system-wide)       각 page table entry는 각각의 물리적 메모리의 page frame이 담고 있는 내용 표시 (process-id, process의 logical address)       단점 : 테이블 전체를 탐색해야 함 (시간적인 오버헤드 존재)       해결 방법 : associative register 사용 (expensive) -&gt; 별도의 하드웨어를 사용하여 시간적인 오버헤드를 줄이는 방법               실제 물리적 메모리의 프레임 개수만큼 테이블에 엔트리가 존재한다.   페이지 테이블의 첫번째 엔트리에는 물리적 메모리의 첫번째 프레임에 들어가는 논리적 메모리의 첫번째 프레임의 주소가 있고, 페이지 테이블의 두번째 엔트리에는 물리적 메모리의 두번째 프레임에 들어가는 논리적 메모리의 두번째 프레임 주소가 있다.   페이지 주소 변환이란, 논리적 메모리의 주소를 참조해서 물리적 메모리를 찾아가는 과정이지만, Inverted Page Table은 정반대 방향이다.   논리적 페이지의 페이지번호 p가 물리적 메모리의 몇번째 프레임에 위치했는지를 찾기위해서는, 페이지테이블은 모두 뒤져서 p가 위치한 엔트리를 찾은 뒤, 물리적 메모리의 어디에 위치했는지를 알 수 있다. 목적과는 맞지 않지만 페이지 테이블이 메모리에서 차지하는 공간을 줄이고자 이를 사용한다. 하지만 시간적인 오버헤드가 존재하고 p가 어느 프로세스의 p인지 파악하기 위해 프로세스를 구분하는 pid도 저장해야한다.      CPU가 logical address를 준다.   1번에서 받은 논리적 주소를 가지고 page entry를 뒤져서 p가 위치하는 물리적 메모리의 frame 위치를 파악한다.   p가 여러개 존재할 수 있기 때문에 현재 CPU를 점유하고 있는 프로세스의 PID를 동시에 줘서 그 PID를 가진 P가 물리적 메모리의 어떤 위치에 존재하는지 찾는다.   찾은 위치가 page table에서 몇번째 떨어진 위치인지(여기서는 f만큼 떨어진 엔트리) 파악해서 물리적 메모리에 가서 f번째 떨어진 엔트리를 찾음으로써 주소 변환을 완료한다.   Shared Page      Shared code (Re-entrant Code, 재진입 가능 코드, Pure code)            read-only로 하여 프로세스 간에 하나의 code만 메모리에 올림 (코드 공유). e.g. text editors, compilers, window systems       shared code는 모든 프로세스의 logical address space에서 동일한 위치에 있어야 함.       공유할 수 있는 코드를 하나만 올려서 여러 프로세스와 매핑. Read-only로만 세팅해서 물리적 메모리에 하나의 code만 올림.           Private code and data            각 프로세스들은 독자적으로 메모리에 올림       Private data는 logical address space의 아무 곳에 와도 무방       만약 하나의 워드 프로그램을 3개 사용한다고 하면, 같은 프로그램을 사용하기 때문에 프로그램 코드는 share가 가능함. 이렇게 share가 가능한 코드들에 대해서는 물리적 메모리에 하나의 코드만 올려서 이걸 공유함. 각각의 프로세스마다 다른 데이터 코드만 메모리에 별도로 올려서 사용.              2. Segmentaion   Segmentation (세그먼테이션 기법)     의미 있는 크기, 공간별로 자름. 크기가 균일하지 않음.            작게는 프로세스를 구성하는 주소 공간(함수) 하나하나를 의미 단위로 잘라 세그먼트로 정의       크게는 프로그램 전체를 하나의 세그먼트로 정의 가능.           코드 세그먼트 / 데이터 세그먼트 / 스택 세그먼트 등으로 자름. 함수 별로도 자를 수 있음.   logical unit 예제            main(), function, global variables, stack, symbol table, arrays           Segmentation Architecture    Logical address는 다음의 두 가지로 구성됨.  &lt; Segment-number, offset &gt;   Segment table (주소변환이 필요하므로 테이블 존재)            each table entry has                    base (starting physical address of segment, 물리 주소),           limit (length of the segment, 세그먼트의 개수)                           STBR (Segment-table base register)            물리적 메모리에서의 segment table의 위치       table이 어느 위치에 저장되어 있는지           STLR (Segent-table length register)            프로그램이 사용하는 segment의 수 segment number s가 STLR보다 작으면 오류 발생 !!               프레임의 크기가 일괄적인 페이징 기법과 달리, 세그먼트 기법은 unit별로 크기가 다르기 때문에 물리적 메모리에서 세그먼트가 시작하는 위치인 base와 함께 세그먼트의 크기인 limit 값도 가지고 있음.   페이징에서는 프레임 크기가 모두 동일하기 때문에 프레임 번호만으로도 주소를 찾아갈 수 있음   주소 변환 시 확인해야할 것은 세그먼트 번호가 STLR보다 작아야 하고, 세그먼트의 크기 limit보다, 세그먼트가 위치하는 곳을 나타내는 offset의 크기 d의 값이 더 크면 역시 scope error이기 때문에 오류 발생.   이러한 오류가 발생하지 않을 때 비로소 세그먼트가 시작하는 위치 base에서 offset의 크기 d를 더한 주소로 이동해 주소 변환을 진행함.      Protection            각 세그먼트 별로 protection bit가 있음       Each entry                    Vaild bit = 0 =&gt; illegal segment           Read/Write/Execution 권한 bit                           Sharing            shared segment (같은 논리 주소 보유)       same segment number       장점 : segment는 의미 단위이기 때문에 공유와 보안에 있어서 paging보다 훨씬 효과적이다.           Allocation            first fit / best fit       external fragmentation 발생       단점 : segment의 길이가 동일하지 않으므로 가변 분할 방식에서와 동일한 문제점들이 발생함.              정리      단점 : segmentation의 크기가 동일하지 않기 때문에 hole 문제가 발생 가능   장점 : 의미단위로 일을 처리할 때에는 매우 효과적, 의미 단위로 세그먼트를 나누기 때문에 Read/ Write 등등 구분하는 게 자연스러움       페이지는 개수가 정말 많지만, 세그먼트는 운영해보면 개수가 몇개 안됨. (이론적인 비교는 앞쪽, 실질적인 비교는 이러함)   그러므로 테이블에 의한 메모리 낭비는 페이징이 더 심함. 세그먼트는 좀 더 적음.   사진은 5개의 세그먼트로 형성된 경우, 0번 세그먼트의 시작 위치 (base)와 크기(limit)가 표로 형성되어 있음.   세그먼트 별로 물리 메모리에 적재되어 있을 수도 있고, 아닐 수도 있음.   Sharing of Segments     같은 역할을 하기 때문에 공유를 하는 것   세그먼트 번호가 같고, 물리적인 세그먼트 위치가 같아야 함.   주소 변환 시 같은 주소로 변환됨. private segment의 경우 다른 위치에 적재되어 있음.   Segmentation with paging     segment 하나가 여러 개의 page로 구성. 때문에 메모리에 올라갈 때 page 단위로 잘려서 올라감. segment table entry가 물리적 메모리에서 segment가 어디서 시작하는지 나타내는 base address가 아니라 segment를 구성하는 page의 위치를 나타내는 page table의 base address를 가지고 있음. =&gt; 이를 통해 segment의 크기가 각각 달라 hole이 발생하는 문제를 해결.   어떤 segment를 read-only로 설정할 것인지 등등의 의미단위 작업은 segment table에서 미리 설정.      logical address에서 s를 통해 setment table 내의 몇 번째 segment entry를 나타내는지 확인   그렇게 알게 된 segment table의 s에서 segment 내부의 page의 시작 위치인 page-table base를 확인   한편, 물리적 메모리에서 해당 segment가 어디에서 시작하는지 나타내는 offset값 d와 s를 비교하여 error를 검출   3번에서 이상이 없다면 offset값 d를 나눠서 page의 page-table에서 몇 번째 page entry인지 나타내는 p값과 page의 어디에서 시작되는지 나타내는 offset 값 d’를 확인   1~4번에서 얻은 값을 통해 최종적으로 논리적 주소를 물리적 메모리 주소로 변환      이 모든 작업은 MMU라는 하드웨어와 CPU가 해줘야 하는 일. 여기서 운영체제가 하는 일은 없음. 운영체제는 IO Device에 접근할 때. 하지만 메모리 접근 시에는 하드웨어가 작업.   "
  },
  
  {
    "title": "BOJ_1937_욕심쟁이 판다 (Java)",
    "url": "/posts/BOJ1937%EC%9A%95%EC%8B%AC%EC%9F%81%EC%9D%B4-%ED%8C%90%EB%8B%A4-Java/",
    "categories": "알고리즘",
    "tags": "",
    "date": "2025-01-08 14:50:32 +0900",
    "content": "[Gold III] 욕심쟁이 판다 - 1937  문제 링크  성능 요약  메모리: 37428 KB, 시간: 456 ms  분류  깊이 우선 탐색, 다이나믹 프로그래밍, 그래프 이론, 그래프 탐색  제출 일자  2025년 1월 8일 14:42:05  문제 설명  n × n의 크기의 대나무 숲이 있다. 욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다. 그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다. 그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다. 이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다.  이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데, 어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 판다가 최대한 많은 칸을 방문할 수 있는지 고민에 빠져 있다. 우리의 임무는 이 사육사를 도와주는 것이다. n × n 크기의 대나무 숲이 주어져 있을 때, 이 판다가 최대한 많은 칸을 이동하려면 어떤 경로를 통하여 움직여야 하는지 구하여라.  입력  첫째 줄에 대나무 숲의 크기 n(1 ≤ n ≤ 500)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 대나무 숲의 정보가 주어진다. 대나무 숲의 정보는 공백을 사이로 두고 각 지역의 대나무의 양이 정수 값으로 주어진다. 대나무의 양은 1,000,000보다 작거나 같은 자연수이다.  출력  첫째 줄에는 판다가 이동할 수 있는 칸의 수의 최댓값을 출력한다.     문제 풀이     간단한 dfs, 메모이제이션(백트래킹) 문제.  문제 접근 DFS와 DP(동적 계획법)를 결합하여 해결하는 대표적인 문제다. 판다가 현재 위치에서 이동할 수 있는 최대 칸 수를 구하기 위해, 각 위치에서 시작했을 때의 최대 이동 가능 거리를 메모이제이션하는 방식을 사용한다.  핵심 로직     DP 배열의 의미            dp[r][c]: (r,c) 위치에서 시작했을 때 이동할 수 있는 최대 칸 수 초기값 0은 아직 계산하지 않은 상태를 의미           DFS 탐색 과정            현재 위치에서 상,하,좌,우 네 방향을 탐색       다음 위치의 대나무가 현재 위치보다 많은 경우에만 이동       이동할 때마다 이전 위치의 최대 이동 칸 수 + 1을 계산                메모이제이션             이미 계산된 위치(dp[r][c] ≠ 0)는 재계산하지 않고 저장된 값 사용       이를 통해 중복 계산을 방지하고 시간 복잡도를 크게 줄임                시간 복잡도             O(N²): 모든 위치에 대해 한 번씩만 계산           구현 시 주의사항          초기값 설정             각 위치에서 최소 1칸은 이동 가능하므로 dp[r][c] = 1로 초기화                경계 조건 처리             배열 범위를 벗어나지 않도록 체크                최댓값 갱신             모든 시작점에 대해 DFS를 수행하며 전체 최댓값 갱신              코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, board[][], dp[][], dr[] = {-1, 1, 0, 0}, dc[] = {0, 0, -1, 1}; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\tboard = new int[N][N]; \t\tdp = new int[N][N]; \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j=0; j&lt;N; j++) { \t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken()); \t\t\t} \t\t} \t\t \t\tint res = 1; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfor(int j=0; j&lt;N; j++) { \t\t\t\tres = Math.max(res, dfs(i, j)); \t\t\t} \t\t} \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int dfs(int r, int c) { \t\tif(dp[r][c] != 0) return dp[r][c]; \t\t \t\tdp[r][c] = 1; \t\t \t\tfor(int k=0; k&lt;4; k++) { \t\t\tint nr = r + dr[k]; \t\t\tint nc = c + dc[k]; \t\t\t \t\t\tif(nr &gt;= 0 &amp;&amp; nr &lt; N &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; N) { \t\t\t\tif(board[nr][nc] &gt; board[r][c]) dp[r][c] = Math.max(dp[r][c], dfs(nr, nc) + 1); \t\t\t} \t\t} \t\treturn dp[r][c]; \t} }  "
  },
  
  {
    "title": "동기 방식으로 외부 서비스를 호출할 때 외부 서비스 장애시 어떻게 조치해야 할까?",
    "url": "/posts/%EB%8F%99%EA%B8%B0-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EC%99%B8%EB%B6%80-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%ED%98%B8%EC%B6%9C%ED%95%A0-%EB%95%8C-%EC%99%B8%EB%B6%80-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%9E%A5%EC%95%A0%EC%8B%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A1%B0%EC%B9%98%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-07 20:42:52 +0900",
    "content": "외부 서비스 장애로 인해 응답이 오래 걸린다고 했을 때 외부 API 응답으로 대기하는 자원들이 운영 서버 내부에 쌓이면서 성능에 악영향을 줄 수 있다. 이를 해결하기 위한 가장 기본적인 방법은 타임아웃을 설정하는 것이다. 크게 타임아웃에는 커넥션 타임아웃과 리드 타임아웃, HTTP 커넥션 풀 타임아웃을 설정해 볼 수 있다.  다음과 같은 특정 서비스 장애가 전체 서비스에 영향을 주는 경우는 어떻게 해결해야 할까?  1. A 서비스, B 서비스, C 서비스 연동 코드가 HTTP 커넥션 풀을 공유한다. 2. A 서비스의 장애로 응답 시간 지연이 발생하는 경우 \t2-1. 풀에 남은 커넥션이 점점 줄어든다     2-2. 풀에서 커넥션을 구하는 대기 시간이 증가한다.     2-3. B, C 서비스에 대한 연동도 함께 대기한다.   이 경우에는 벌크헤드 패턴을 적용해 볼 수 있다. 벌크헤드 패턴은 기능의 종류마다 자원 사용을 분리하는 것을 의미한다. 자원을 격리하여 서비스 일부에 장애가 발생해도 전체로 전파되지 않도록 보장해준다. 위 예시에서는 외부 서비스마다 다른 HTTP 커넥션 풀을 사용하도록 벌크헤드 패턴을 적용해볼 수 있다. 서로 다른 커넥션 풀을 사용하기 때문에 A 서비스에 문제가 발생해도 B, C의 영향을 최소화할 수 있다.  외부 서비스 장애가 계속 발생하면 어떻게 될까?  지속되는 외부 서비스 장애로 타임아웃에 의한 서비스 에러가 발생할 수 있다. 외부 서비스가 장애가 발생했음에도 불구하고 운영 서버는 계속 요청을 보내기 때문에, 불필요하게 응답 시간이 저해되고, 처리량도 감소하게 된다. 이 문제를 해결하기 위해서는 서킷 브레이커를 적용할 수 있다. 서킷 브레이커는 오류가 지속되는 경우 일정 시간동안 기능 실행을 차단할 수 있다. 서킷 브레이커가 빠른 실패를 도와주기 때문에 외부 서비스 장애에 의한 응답 시간 증가를 예방할 수 있다.  References     외부 API 장애에 영향 덜 받는 3가지 방법   Bulkhead 패턴을 사용한 장애 격리   Connection Timeout과 Read Timeout 살펴보기  "
  },
  
  {
    "title": "BOJ_17352_여러분의 다리가 되어 드리겠습니다! (Java)",
    "url": "/posts/BOJ17352%EC%97%AC%EB%9F%AC%EB%B6%84%EC%9D%98-%EB%8B%A4%EB%A6%AC%EA%B0%80-%EB%90%98%EC%96%B4-%EB%93%9C%EB%A6%AC%EA%B2%A0%EC%8A%B5%EB%8B%88%EB%8B%A4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-07 20:28:44 +0900",
    "content": "[Gold V] 여러분의 다리가 되어 드리겠습니다! - 17352  문제 링크  성능 요약  메모리: 83392 KB, 시간: 548 ms  분류  자료 구조, 분리 집합, 그래프 이론, 그래프 탐색  제출 일자  2025년 1월 7일 20:22:41  문제 설명  선린월드에는 N개의 섬이 있다. 섬에는 1, 2, ..., N의 번호가 하나씩 붙어 있다. 그 섬들을 N - 1개의 다리가 잇고 있으며, 어떤 두 섬 사이든 다리로 왕복할 수 있다.  어제까지는 그랬다.  \"왜 다리가 N - 1개밖에 없냐, 통행하기 불편하다\"며 선린월드에 불만을 갖던 욱제가 다리 하나를 무너뜨렸다! 안 그래도 불편한 통행이 더 불편해졌다. 서로 왕복할 수 없는 섬들이 생겼기 때문이다. 일단 급한 대로 정부는 선린월드의 건축가를 고용해, 서로 다른 두 섬을 다리로 이어서 다시 어떤 두 섬 사이든 왕복할 수 있게 하라는 지시를 내렸다.  그런데 그 건축가가 당신이다! 안 그래도 천하제일 코딩대회에 참가하느라 바쁜데...  입력  첫 줄에 정수 N이 주어진다. (2 ≤ N ≤ 300,000)  그 다음 N - 2개의 줄에는 욱제가 무너뜨리지 않은 다리들이 잇는 두 섬의 번호가 주어진다.  출력  다리로 이을 두 섬의 번호를 출력한다. 여러 가지 방법이 있을 경우 그 중 아무거나 한 방법만 출력한다.     문제 풀이   보자마자 Union-find 문제라고 생각했다. 모든 점들을 묶으면 2개의 그룹이 생긴다고 생각했다. 그래서 집합으로 묶자고 결정했다. 예제 2를 보면 2라는 숫자만 주어지고 1 2 를 출력해줘야하기 때문에 예외처리해주었고 이를 생각하다보니 5 2 3 3 4 4 5  이면 1 이랑 다른점중 하나 2 이런식으로 출력해야하므로 난 입력받은 수 중 처음을 group1으로 하려했는데 이 때문에 틀렸음을 생각해냈고 무조건 1을 group1, 다른 그룹을 만나면 그 수를 group2로 선정했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, p[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\t \t\tif (N==2) { \t\t\tSystem.out.print(\"1 2\"); \t\t\treturn; \t\t} \t\tp = new int[N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tp[i] = i; \t\t}  \t\tint group1=1, group2=0; \t\t \t\tfor(int i=0; i&lt;N-2; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint a = Integer.parseInt(st.nextToken()); \t\t\tint b = Integer.parseInt(st.nextToken());\t\t\t \t\t\tunion(a, b); \t\t} \t\t \t\tfor(int i=2; i&lt;=N; i++) { \t        if(find(i) != find(group1)) { \t            group2 = i; \t            break; \t        } \t    } \t\t \t\tbw.write(String.valueOf(group1) + \" \" + String.valueOf(group2)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void union(int x, int y) { \t\tint px = find(x); \t\tint py = find(y); \t\tif(px != py) { \t\t\tif(px &lt; py) p[py] = px; \t\t\telse p[px] = py; \t\t} \t} \t \tprivate int find(int x) { \t\tif(p[x] != x) return p[x] = find(p[x]); \t\treturn p[x]; \t} }  "
  },
  
  {
    "title": "BOJ_2493_탑 (Java, C++)",
    "url": "/posts/BOJ2493%ED%83%91-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-07 17:36:04 +0900",
    "content": "[Gold V] 탑 - 2493  문제 링크  성능 요약  메모리: 87888 KB, 시간: 816 ms  분류  자료 구조, 스택  제출 일자  2025년 1월 7일 17:20:49  문제 설명  KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.   예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.  탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.   입력  첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.  출력  첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.     문제 풀이     스택이 비었는지 체크하지 않기 위에 맨 앞에 더미데이터로 높이가 무한대이며 순서가 0인 탑을 넣었다.     스택에는 이전에 확인한 탑들 중에서 현재 탑보다 높은 탑들만 유지.   새로운 탑을 확인할 때마다, 스택의 top에 있는 탑이 수신 가능한지 확인.   스택의 top에 있는 탑이 현재 탑보다 낮다면, 그 탑은 이후의 신호도 수신할 수 없으므로 제거.      코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tclass Tower{ \t\tint n; \t\tint h; \t\tpublic Tower(int number, int height) { \t\t\tthis.n = number; \t\t\tthis.h = height; \t\t} \t} \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint N = Integer.parseInt(br.readLine()); \t\tStack&lt;Tower&gt; stack = new Stack&lt;Tower&gt;(); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tint H; \t\tstack.add(new Tower(0, Integer.MAX_VALUE)); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tH = Integer.parseInt(st.nextToken()); \t\t\tTower t = new Tower(i, H); \t\t\twhile(!stack.isEmpty() &amp;&amp; stack.peek().h &lt; H) { \t\t\t\tstack.pop(); \t\t\t} \t\t\tsb.append(stack.peek().n).append(\" \"); \t\t\tstack.push(t); \t\t} \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;      stack&lt;pair&lt;int, int&gt;&gt; stack;     stack.push({0, INT_MAX});      for (int i = 1; i &lt;= N; i++) {         int height;         cin &gt;&gt; height;          while (stack.top().second &lt; height) {             stack.pop();         }          cout &lt;&lt; stack.top().first &lt;&lt; \" \";         stack.push({i, height});     } }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Spring 어노테이션들의 차이 @Component, @Controller, @Service, @Repository",
    "url": "/posts/Spring-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EB%93%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4-Component-Controller-Service-Repository/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-07 03:14:54 +0900",
    "content": "@Component, @Service, @Controller, @Repository는 각각의 클래스를 특정 역할을 수행하는 Spring Bean으로 등록할 때 사용된다.  각 어노테이션은 클래스가 어떤 역할을 하는지를 명시적으로 나타내며, Spring의 @ComponentScan 기능을 통해 자동으로 Bean으로 등록된다. @Service, @Controller, @Repository 어노테이션은 내부적으로 @Component 어노테이션을 사용하고 있다.  @Component  가장 일반적인 형태의 어노테이션으로, 특정 역할에 종속되지 않는 일반적인 Spring Bean을 나타낸다. 공통 기능을 제공하는 유틸리티 클래스나, 특정 계층에 속하지 않는 일반적인 컴포넌트를 정의할 때 사용된다  @Service  비즈니스 로직을 수행하는 클래스에 사용되며 서비스 레이어의 Bean을 나타낸다.  @Controller  Spring MVC에서 웹 요청을 처리하는 컨트롤러 클래스에 사용되며 프레젠테이션 레이어의 Bean을 나타낸다.  @Repository  데이터베이스와의 상호작용을 수행하는 클래스에 사용되며, 데이터 엑세스 레이어의 Bean을 나타낸다.  Controller, @Repository 대신 @Component 사용가능할까?  Spring 6(Spring Boot 3) 이전 버전에서는 @Component + @RequestMapping으로도 Bean 및 핸들러 등록이 가능했다. 하지만 Spring 6 이후부터 @Controller 이외에는 핸들러로 등록하지 않아 웹 요청을 정상적으로 수행할 수 없다. public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMapping \t\timplements MatchableHandlerMapping, EmbeddedValueResolverAware {     ...     @Override     protected boolean isHandler(Class&lt;?&gt; beanType) {         return AnnotatedElementUtils.hasAnnotation(beanType, Controller.class); // 컨트롤러 애너테이션인지 확인     }     ... }   @Repository를 @Component로 대체할 경우, PersistenceExceptionTranslationPostProcessor에 의해 예외가 DataAccessException으로 변환되지 않는다. 이 경우 데이터 엑세스 계층에서 발생하는 예외 처리에 영향을 미칠 수 있다.  또 @Service, @Controller, @Repository는 각각 특정 계층을 나타내므로, AOP의 포인트컷을 정의할 때 유용하게 사용될 수 있다. @Component를 사용하려면 이러한 계층 구분이 불분명해져 AOP적용이 어려울 수 있다.  References    Spring Bean Annotations   General ORM Integration Considerations  "
  },
  
  {
    "title": "동일성 vs 동등성",
    "url": "/posts/%EB%8F%99%EC%9D%BC%EC%84%B1-vs-%EB%8F%99%EB%93%B1%EC%84%B1/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-07 02:30:05 +0900",
    "content": "동일성과 동등성은 객체를 비교할 때 중요한 개념이다. 자바에서는 이 두 개념을 equals() 메서드와 == 연산자를 통해 구분할 수 있다.  equals 와 == 의 차이 equals()는 객체의 내용을 비교하는 반면, ==는 객체의 참조(레퍼런스)를 비교한다. 따라서 두 객체의 내용이 같더라도 서로 다른 객체라면 equals()는 true를 반환할 수 있지만, ==는 false를 반환한다.  동등성(Equality)이란? 동등성은 논리적으로 객체의 내용이 같은지를 비교하는 개념이다. 자바에서는 equals() 메서드를 사용해 객체의 동등성을 비교한다. Apple 클래스를 예시로 보면, Object.equals 메서드를 오버라이딩하여 객체의 실제 데이터를 비교하도록 했다. 그래서 apple과 anotherApple 은 다른 객체지만, 무게가 같기 때문에 동등성 비교 결과 true가 반환된다.  public class Apple {      private final int weight;      public Apple(int weight) {         this.weight = weight;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         Apple apple = (Apple) o;         return weight == apple.weight;     }      @Override     public int hashCode() {         return Objects.hashCode(weight);     }      public static void main(String[] args) {         Apple apple = new Apple(100);         Apple anotherApple = new Apple(100);          System.out.println(apple.equals(anotherApple)); // true     } }    왜 equals() 메서드를 오버라이딩 하는가? public class Object {     ...     public boolean equals(Object obj) {         return (this == obj);     }     ... }    Object 클래스의 equals() 메서드는 == 연산자를 사용해 동일성을 비교한다. 그리고 모든 클래스는 Object 클래스를 상속하여 동일성 비교를 기본으로 동작하기 때문에, 동등성 비교가 필요한 클래스에서 필요에 맞게 equals &amp; hashCode 메서드를 오버라이딩 해야한다.  동일성(Identity)이란? 동일성은 두 객체가 메모리 상에서 같은 객체인지 비교하는 개념이다. 자바에서는 == 연산자를 사용해 객체의 동일성을 비교한다. ==연산자는 객체의 레퍼런스(참조)를 비교하므로, 두 변수가 동일한 객체를 가리키고 있는지 확인한다.  public static void main(String[] args) {     Apple apple1 = new Apple(100);     Apple apple2 = new Apple(100);     Apple apple3 = apple1;      System.out.println(apple1 == apple2); // false     System.out.println(apple1 == apple3); // true }    apple1과 apple2는 참조가 다르기 때문에 == 연산 결과가 false지만, apple1의 참조를 가지는 apple3은 == 연산 결과 true가 반환된다.  String은 객체인데 == 비교가 가능한 이유 문자열 리터럴은 문자열 상수풀(String Constant Pool) 에 저장되기 때문에, 동일한 문자열 리터럴을 참조하면 == 연산자가 true를 반환할 수 있다. 하지만 new 키워드를 사용하여 문자열을 생성하면 새로운 객체가 생성되므로 == 연산자가 false를 반환할 수 있다. 따라서 문자열 비교시 항상 equals() 메서드를 사용한 동등성 비교를 하는것이 좋다.  public class StringComparison {     public static void main(String[] args) {         String str1 = \"안녕하세요\";         String str2 = \"안녕하세요\";         String str3 = new String(\"안녕하세요\");                  // 동일성 비교         System.out.println(str1 == str2); // true         System.out.println(str1 == str3); // false                  // 동등성 비교         System.out.println(str1.equals(str2)); // true         System.out.println(str1.equals(str3)); // true     } }  // String.class equals 오버라이딩 되어있음. public boolean equals(Object anObject) {     if (this == anObject) {         return true;     }     return (anObject instanceof String aString)             &amp;&amp; (!COMPACT_STRINGS || this.coder == aString.coder)             &amp;&amp; StringLatin1.equals(value, aString.value); }    ### Integer과 같은 Wrapper 클래스의 비교는?  래퍼 클래스도 객체이기 때문에 == 연산자는 참조를 비교한다. 값 비교를 원할 경우 equals() 메서드를 사용해야한다. 하지만, Java는 특정 범위의 래퍼 객체를 캐싱하므로 같은 값의 Integer 객체가 같은 참조를 가질 수 있다 (-128 ~ 127). 하지만 일반적으로 equals()를 사용하는 것이 안전하다.  ### References    자바의 동등성과 동일성 이해하기   how-do-you-implement-equals-hashcode-methods   what-is-the-difference-between-identity-and-equality-in-oop   equals와 hashCode는 왜 함께 재정의해야 할까요?  "
  },
  
  {
    "title": "equals 와 hashCode를 함께 재정의하는 이유",
    "url": "/posts/equals-%EC%99%80-hashCode%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-07 01:02:08 +0900",
    "content": "equals와 hashCode 메서드는 객체의 동등성 비교와 해시값 생성을 위해서 사용할 수 있다. 하지만, 함께 재정의하지 않는다면 예상치 못한 결과를 만들 수 있다. 가령, 해시값을 사용하는 자료구조(HashSet, HashMap, …) 을 사용할 때 문제가 발생할 수 있다.  class EqualsHashCodeTest {  \t@Test     @DisplayName(\"equals만 정의하면 HashSet이 제대로 동작하지 않는다.\") \tvoid test() {         // 아래 2개는 같은 구독자         Subscribe subscribe1 = new Subscribe(\"team.maeilmail@gmail.com\", \"backend\");         Subscribe subscribe2 = new Subscribe(\"team.maeilmail@gmail.com\", \"backend\");         HashSet&lt;Subscribe&gt; subscribes = new HashSet&lt;&gt;(List.of(subscribe1, subscribe2));          // 결과는 1개가 나와야하는데 2개가 나온다.         System.out.println(subscribes.size());     }          class Subscribe {          private final String email;         private final String category;          public Subscribe(String email, String category) {             this.email = email;             this.category = category;         }          @Override         public boolean equals(Object o) {             if (this == o) return true;             if (o == null || getClass() != o.getClass()) return false;             Subscribe subscribe = (Subscribe) o;             return Objects.equals(email, subscribe.email) &amp;&amp; Objects.equals(category, subscribe.category);         }     } }   이러한 결과가 나오는 이유  해시값을 사용하는 자료구조는 hashCode 메서드의 반환값을 사용한다. hashCode 메서드의 반환값이 일치한 이후 equals 메서드의 반환값 참일 때만 논리적으로 같은 객체라 판단한다. 위 예제에서 Subscribe 클래스는 hashCode 메서드를 재정의하지 않았기 때문에 Object 클래스의 기본 hashCode 메서드를 사용한다. Object 클래스의 기본 hashCode 메서드는 객체의 고유한 주소를 사용하기 때문에 객체마다 다른 값을 반환한다. 따라서 2개의 Subscribe 객체는 다른 객체로 판단되었고 HashSet에서 중복처리가 되지 않았다. "
  },
  
  {
    "title": "JPA에서의 ID 생성 전략",
    "url": "/posts/JPA%EC%97%90%EC%84%9C%EC%9D%98-ID-%EC%83%9D%EC%84%B1-%EC%A0%84%EB%9E%B5/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-07 00:38:56 +0900",
    "content": "JPA에서 ID를 생성하기 위해서는 직접할당 과 자동할당 을 사용할 수 있다. 직접 할당은 @Id 어노테이션만을 사용해 Id 값을 직접 할당하는 방식이다. 반면, 자동 할당은 @Id 와 @GeneratedValue 를 함께 사용해서 원하는 키 생성 전략을 선택하는 방식이다. @GeneratedValue 의 strategy 옵션을 통해 생성 전략을 설정할 수 있는데, 여기에 올 수 있는 값인 GenerationType은 다음과 같다.  @Target({ElementType.METHOD, ElementType.FIELD})   @Retention(RetentionPolicy.RUNTIME)   public @interface GeneratedValue {       GenerationType strategy() default GenerationType.AUTO;          String generator() default \"\";   }  public enum GenerationType {  \tAUTO, \tIDENTITY, \tSEQUENCE,  \tTABLE }   자동 생성 방식을 사용할 때 각 전략  IDENTITY 전략은 기본 키 생성을 DB에 위임하는 전략이다. 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용된다. 해당 전략을 사용하며 엔티티를 생성할 때 쓰기 지연이 적용되지 않는다. 왜냐하면 JPA에서 엔티티를 영속하기위해 식별자가 필요한데, IDENTITY 전략에서는 이 식별자가 DB에 저장되어야 할당되기 때문이다. 따라서 엔티티를 생성할 때 즉시  INSERT 쿼리가 실행되어야 한다. 이때 하이버네이트를 사용하는 경우에는 INSERT 쿼리의 결과를 다시 조회하지 않기 위해서 내부적으로 Statement.getGeneratedKeys를 사용한다. 추가로 IDENTITY 전략을 사용하면 배치 인서트가 불가능하다는 점을 주의해야한다.  SEQUENCE 전략은 시퀀스 키 생성 전략을 지원하는 DB에서 사용할 수 있다. 데이터베이스 시퀀스란, 유일한 값을 자동으로 생성하게 하는 객체다. auto_increment와 달리 초기값과 한번에 증가할 크기를 설정할 수 있다. 해당 시퀀스를 키 생성 전략으로 갖는 DB에 대해 SEQUENCE전략을 사용할 수 있다. 어떤 시퀀스를 사용할 것인지를 @SequenceGenerator 로 설정할 수 있다. SEQUENCE 전략은 em.persist() 를 호출하는 경우 먼저 데이터베이스 시퀀스를 이용해 식별자를 조회한다. 이후 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다. 트랜잭션을 커밋하여 플러시가 일어나면 엔티티를 저장한다는 점에서 IDENTITY 전략과 차이가 있다.  TABLE 전략은 키 생성 전용 테이블을 만들어 시퀀스를 흉내내는 전략이다. 어떤 테이블을 사용할 것인지를 @TableGenerator 로 설정할 수 있다. TABLE 전략은 값을 조회하면서 SELECT 쿼리를 사용하며 증가를 위해 UPDATE 쿼리를 사용한다. SEQUENCE 전략보다 DB와 한번 더 통신한다는 점에서 성능이 안좋다는 단점이 있지만, 모든 DB에 적용할 수 있다는 장점이 있다.  AUTO 전략은 데이터베이스 방언에 따라서 IDENTITY, SEQUENCE, TABLE 중 하나를 자동으로 선택한다. 데이터베이스를 변경해도 코드를 수정할 필요가 없다는 장점이 있다.  References    [JPA] 기본 키(Primary Key)매핑 - @Id, @GeneratedValue   [JPA] 기본 키 매핑 - SEQUENCE, TABLE 전략의 최적화   Identity 전략으로는 Batch Insert가 불가능한 이유   최범균님 JPA - JPA 기초 05 엔티티 식별자 생성 방식  "
  },
  
  {
    "title": "BOJ_2873_롤러코스터 (Java)",
    "url": "/posts/BOJ2873%EB%A1%A4%EB%9F%AC%EC%BD%94%EC%8A%A4%ED%84%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-06 20:42:07 +0900",
    "content": "[Platinum III] 롤러코스터 - 2873  문제 링크  성능 요약  메모리: 73500 KB, 시간: 696 ms  분류  해 구성하기, 그리디 알고리즘, 구현  제출 일자  2025년 1월 6일 20:36:02  문제 설명  상근이는 우리나라에서 가장 유명한 놀이 공원을 운영하고 있다. 이 놀이 공원은 야외에 있고, 다양한 롤러코스터가 많이 있다.  어느 날 벤치에 앉아있던 상근이는 커다란 황금을 발견한 기분이 들었다. 자신의 눈 앞에 보이는 이 부지를 구매해서 롤러코스터를 만든다면, 세상에서 가장 재미있는 롤러코스터를 만들 수 있다고 생각했다.  이 부지는 직사각형 모양이고, 상근이는 R행 C열의 표 모양으로 나누었다. 롤러코스터는 가장 왼쪽 위 칸에서 시작할 것이고, 가장 오른쪽 아래 칸에서 도착할 것이다. 롤러코스터는 현재 있는 칸과 위, 아래, 왼쪽, 오른쪽으로 인접한 칸으로 이동할 수 있다. 각 칸은 한 번 방문할 수 있고, 방문하지 않은 칸이 있어도 된다.  각 칸에는 그 칸을 지나갈 때, 탑승자가 얻을 수 있는 기쁨을 나타낸 숫자가 적혀있다. 롤러코스터를 탄 사람이 얻을 수 있는 기쁨은 지나간 칸의 기쁨의 합이다. 가장 큰 기쁨을 주는 롤러코스터는 어떻게 움직여야 하는지를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 R과 C가 주어진다. (2 ≤ R, C ≤ 1000) 둘째 줄부터 R개 줄에는 각 칸을 지나갈 때 얻을 수 있는 기쁨이 주어진다. 이 값은 1000보다 작은 양의 정수이다.  출력  첫째 줄에 가장 가장 큰 기쁨을 주는 롤러코스터는 가장 왼쪽 위 칸부터 가장 오른쪽 아래 칸으로 어떻게 움직이면 되는지를 출력한다. 위는 U, 오른쪽은 R, 왼쪽은 L, 아래는 D로 출력한다. 정답은 여러 가지 일 수도 있다.     문제 풀이     처음엔 짝수x짝수부분을 dfs로 풀었는데 시간초과가 났다. 이에 내가 생각하는 최적의 패턴이 존재했기에 이대로 출력해야겠다고 생각했고, 효율적인 계산을 위해 2묶음(행단위)으로 나눠 처리해줬다.  2차원배열을 마음대로 다루는 연습이 되었다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int R, C, board[][], res; \tstatic int[] dr = {0, 1, 0, -1}, dc = {1, 0, -1, 0}; \tstatic String[] dir = {\"R\", \"D\", \"L\", \"U\"}; \tstatic boolean[][] visited; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tR = Integer.parseInt(st.nextToken()); \t\tC = Integer.parseInt(st.nextToken()); \t\tboard = new int[R][C]; \t\tvisited = new boolean[R][C]; \t\tfor(int i=0; i&lt;R; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j=0; j&lt;C; j++) { \t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken()); \t\t\t} \t\t} \t\t \t\tboolean flag = false; // 모두 순회해도 되면 true, 안되면(짝수 x 짝수) false \t\t \t\tflag = !(R%2==0 &amp;&amp; C%2==0); \t\tif(flag) findAll(); \t\telse findExceptMin();  \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void findExceptMin() { \t\tint min = Integer.MAX_VALUE; \t\tint minR = -1, minC = -1; \t\t \t\tfor(int i=0; i&lt;R; i++) { \t\t\tfor(int j=0; j&lt;C; j++) { \t\t\t\tif((i+j)%2 == 1 &amp;&amp; board[i][j] &lt; min) { \t\t\t\t\tmin = board[i][j]; \t\t\t\t\tminR = i; \t\t\t\t\tminC = j; \t\t\t\t} \t\t\t} \t\t} \t\t \t\tfor(int i=0; i&lt;minR/2; i++) { \t        // 첫 행은 오른쪽으로 \t        for(int j=0; j&lt;C-1; j++) { \t            sb.append(\"R\"); \t        } \t        sb.append(\"D\"); \t        // 두번째 행은 왼쪽으로 \t        for(int j=0; j&lt;C-1; j++) { \t            sb.append(\"L\"); \t        } \t        sb.append(\"D\"); \t    } \t\t \t\tint c = 0; \t\tint r = 2 * (minR/2); // 최솟값 존재 묶음 중 윗줄  \t\tint nextR = r+1; // 최솟값 존재 묶음 중 아랫줄 \t\t \t\twhile(r != nextR || c != C-1) { \t\t\tif(r &lt; nextR &amp;&amp; (c != minC || nextR != minR)) { \t\t\t\tr++; \t\t\t\tsb.append(\"D\"); \t\t\t} \t\t\telse if(r == nextR &amp;&amp; (c != minC || nextR-1 != minR)) { \t\t\t\tr--; \t\t\t\tsb.append(\"U\"); \t\t\t} \t\t\t \t\t\tif(c != C-1) { \t            c++; \t            sb.append(\"R\"); \t        } \t\t} \t\t \t\t// 남은 묶음들 \t    for(int i=minR/2+1; i&lt;R/2; i++) { \t        sb.append(\"D\"); \t        for(int j=0; j&lt;C-1; j++) { \t            sb.append(\"L\"); \t        } \t        sb.append(\"D\"); \t        for(int j=0; j&lt;C-1; j++) { \t            sb.append(\"R\"); \t        } \t    } \t\t //\t\tvisited[minR][minC] = true; //\t\tdfs(0, 0, 1); \t}  //\tprivate boolean dfs(int r, int c, int cnt) { // 시간초과 //\t\tif(r == R-1 &amp;&amp; c == C-1) return cnt == R * C - 1; //\t\t //\t\tvisited[r][c] = true; //\t\t //\t\tfor(int k=0; k&lt;4; k++) { //\t\t\tint nr = r + dr[k]; //\t\t\tint nc = c + dc[k]; //\t\t\t //\t\t\tif(nr &gt;= 0 &amp;&amp; nr &lt; R &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; C &amp;&amp; !visited[nr][nc]) { //\t\t\t\tsb.append(dir[k]); //\t\t\t\tif(dfs(nr, nc, cnt + 1)) return true; //\t\t\t\tsb.setLength(sb.length()-1); //\t\t\t} //\t\t} //\t\t //\t\tvisited[r][c] = false; //\t\treturn false; //\t}  \tprivate void findAll() { \t\tif(R % 2 == 1) { \t\t\tfor(int i=1; i&lt;=R; i++) { \t\t\t\tif(i%2 == 1) { \t\t\t\t\tfor(int j=0; j&lt;C-1; j++) { \t\t\t\t\t\tsb.append(\"R\"); \t\t\t\t\t} \t\t\t\t} \t\t\t\telse { \t\t\t\t\tfor(int j=0; j&lt;C-1; j++) { \t\t\t\t\t\tsb.append(\"L\"); \t\t\t\t\t} \t\t\t\t} \t\t\t\tif(i != R) sb.append(\"D\"); \t\t\t} \t\t} \t\telse { \t\t\tfor(int j=1; j&lt;=C; j++) { \t\t\t\tif(j%2 == 1) { \t\t\t\t\tfor(int i=0; i&lt;R-1; i++\t) { \t\t\t\t\t\tsb.append(\"D\"); \t\t\t\t\t} \t\t\t\t} \t\t\t\telse { \t\t\t\t\tfor(int i=0; i&lt;R-1; i++\t) { \t\t\t\t\t\tsb.append(\"U\"); \t\t\t\t\t} \t\t\t\t} \t\t\t\tif(j!=C) sb.append(\"R\"); \t\t\t} \t\t} \t} }  "
  },
  
  {
    "title": "SWEA_1798_범준이의 제주도 여행 계획 (Java)",
    "url": "/posts/SWEA1798%EB%B2%94%EC%A4%80%EC%9D%B4%EC%9D%98-%EC%A0%9C%EC%A3%BC%EB%8F%84-%EC%97%AC%ED%96%89-%EA%B3%84%ED%9A%8D-Java/",
    "categories": "알고리즘",
    "tags": "Java, SWEA, 알고리즘",
    "date": "2025-01-06 04:26:47 +0900",
    "content": "[D5] 범준이의 제주도 여행 계획 - 1798   문제 링크  성능 요약  메모리: 24,960 KB, 시간: 3,595 ms, 코드길이: 4,573 Bytes  제출 일자  2025-01-06 04:19     출처: SW Expert Academy, https://swexpertacademy.com/main/code/problem/problemList.do      문제 풀이   기본 구조    Node 클래스: 각 장소의 정보를 저장 c : 장소 타입 (A: 공항, H: 호텔, P: 관광지) t : 관광지에서의 소요 시간 s : 관광지에서의 만족도   DFS를 통한 경로 탐색    DFS 파라미터 start : 현재 위치 day : 현재 일차 ( 1일차부터 시작임!! 0넣었다가 틀림 ) time : 현재까지의 누적 시간 sat : 현재까지의 누적 만족도   주요 제약 조건 처리          시간 제약 하루 최대 540분(9시간) 이내 이동 이동시간 + 관광시간 포함하여 계산           경로 유효성 검사 canGoHotel() : 호텔 도착 가능 여부 확인 canGoAirport() : 공항 도착 가능 여부 확인           1일 여행과 다일 여행 구분 1일 여행: 공항 출발 → 관광지 → 공항 복귀 다일 여행: 공항 출발 → 관광지 → 호텔 → … → 공항 복귀      핵심 로직          방문 처리 관광지는 한 번만 방문 가능 호텔은 중복 방문 가능           경로 저장 myPlan : 현재 탐색 중인 경로 bestPlan : 최대 만족도를 얻은 경로           종료 조건 마지막 날 공항 도착 시간 초과 일수 초과           특별 케이스 처리 1일차 여행 시작: M == 1 &amp;&amp; time == 0 조건으로 처리 마지막 날 공항 도착: 누적 만족도 비교 후 최적 경로 갱신         코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Solution { \t \tclass Node{ \t\tchar c; \t\tint t; \t\tint s; \t\tpublic Node(char c, int time, int satisfication) { \t\t\tthis.c = c; \t\t\tthis.t = time; \t\t\tthis.s = satisfication; \t\t} \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int N, M, map[][]; \tstatic int v, time, satisfication, maxS, airport; \tstatic Node[] place; \tboolean[] visited; \tstatic List&lt;Integer&gt; hotels; \tstatic List&lt;Integer&gt; bestPlan, myPlan; \t \tpublic static void main(String[] args) throws Exception { \t\tnew Solution().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint T = Integer.parseInt(br.readLine()); \t\tfor(int tc=1; tc&lt;=T; tc++) { \t\t\tsb.append(\"#\").append(tc).append(\" \"); \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tN = Integer.parseInt(st.nextToken()); \t\t\tM = Integer.parseInt(st.nextToken()); \t\t\tmap = new int[N][N]; \t\t\tplace = new Node[N]; \t\t\tfor(int i=0; i&lt;N-1; i++) { \t\t\t\tst = new StringTokenizer(br.readLine()); \t\t\t\tfor(int j=i+1; j&lt;N; j++) { \t\t\t\t\tv = Integer.parseInt(st.nextToken()); \t\t\t\t\tmap[i][j] = v; \t\t\t\t\tmap[j][i] = map[i][j]; \t\t\t\t} \t\t\t} \t\t\t \t\t\tairport=0; \t\t\thotels = new ArrayList&lt;Integer&gt;(); \t\t\tchar p; \t\t\tfor(int i=0; i&lt;N; i++) { \t\t\t\tst = new StringTokenizer(br.readLine()); \t\t\t\tp = st.nextToken().charAt(0); \t\t\t\tif(p == 'A') { \t\t\t\t\tplace[i] = new Node('A', -1, -1); \t\t\t\t\tairport = i; \t\t\t\t} \t\t\t\telse if(p == 'H') { \t\t\t\t\tplace[i] = new Node('H', -1, -1); \t\t\t\t\thotels.add(i); \t\t\t\t} \t\t\t\telse { \t\t\t\t\ttime = Integer.parseInt(st.nextToken()); \t\t\t\t\tsatisfication = Integer.parseInt(st.nextToken()); \t\t\t\t\tplace[i] = new Node('P', time, satisfication); \t\t\t\t} \t\t\t} \t\t\t \t\t\tvisited = new boolean[N]; \t\t\tmaxS = 0; \t\t\t \t\t\tbestPlan = new ArrayList&lt;&gt;(); \t\t\tmyPlan = new ArrayList&lt;&gt;(); \t\t\t \t\t\tdfs(airport, 1, 0, 0); // 시작위치, 일차, 누적시간, 누적만족도 \t\t\tif(maxS == 0) sb.append(0); \t\t\telse {\t\t\t \t\t\t\tsb.append(maxS).append(\" \"); \t\t\t\tfor(int i : bestPlan) { \t\t\t\t\tsb.append(i + 1).append(\" \"); \t\t\t\t} \t\t\t} \t\t\tsb.append(\"\\n\"); \t\t} \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void dfs(int start, int day, int time, int sat) { \t\tif(day &gt; M) return; \t\tif(time &gt; 540) return; \t\t \t\t// M일차 공항 도착, M=1일때 첫 시작은 그냥 넘어가기 \t\tif(day == M &amp;&amp; start == airport &amp;&amp; !(M == 1 &amp;&amp; time == 0)) { \t\t\tif(sat &gt; maxS) { \t\t\t\tmaxS = sat; \t\t\t\tbestPlan = new ArrayList&lt;Integer&gt;(myPlan); \t\t\t} \t\t\treturn; \t\t} \t\t \t\t// 1일차 ~ M-1일차 \t\tfor(int next = 0; next &lt; N; next++) { \t\t\tif(!visited[next] || place[next].c == 'H') { \t\t\t\t// 마지막날 아니면 공항은 가지말고 \t\t\t\tif(place[next].c == 'A') { \t\t\t\t\tif(M == 1) { \t                    // 하루여행에서는 공항가능 \t                    if(sat &gt; 0 &amp;&amp; sat &gt; maxS) { \t                        maxS = sat; \t                        bestPlan = new ArrayList&lt;Integer&gt;(myPlan); \t                    } \t                    continue; \t                } \t                if(day != M) continue;  // 마지막 날이 아니면 공항 방문 불가 \t            } \t\t\t\t \t\t\t\tint nextTime = time + map[start][next]; \t\t\t\t// 놀러간거면 노는 시간도 더하기 \t\t\t\tif(place[next].c == 'P') nextTime += place[next].t; \t\t\t\t \t\t\t\t// 9시간규칙 먼저 검사 \t\t\t\tif(nextTime &gt; 9 * 60) continue; \t\t\t\t \t\t\t\tif(day &lt; M) { \t\t\t\t\tif(!canGoHotel(day, next, nextTime)) continue; \t\t\t\t} \t\t\t\telse { // 마지막날은 호텔이 아니라 공항으로체크 \t\t\t\t\tif(!canGoAirport(next, nextTime)) continue; \t\t\t\t} \t\t\t\t \t\t\t\tif(place[next].c == 'P') { \t\t\t\t\tvisited[next] = true; \t\t\t\t\tmyPlan.add(next); \t\t\t\t\tdfs(next, day, nextTime, sat + place[next].s); \t\t\t\t\t \t\t\t\t\tmyPlan.remove(myPlan.size()-1); \t\t\t\t\tvisited[next] = false; \t\t\t\t} \t\t\t\telse if (place[next].c == 'H' &amp;&amp; day &lt; M) { // 호텔돌아옴 -&gt; 다음날 시작부분 \t\t\t\t\tmyPlan.add(next); \t\t\t\t\tdfs(next, day+1, 0, sat); \t\t\t\t\tmyPlan.remove(myPlan.size()-1); \t\t\t\t} \t\t\t\telse if(next == airport &amp;&amp; day == M){ \t\t\t\t\tmyPlan.add(next); \t\t\t\t\tdfs(next, day, nextTime, sat); \t\t\t\t\tmyPlan.remove(myPlan.size()-1); \t\t\t\t} \t\t\t} \t\t} \t} \t \tprivate boolean canGoHotel(int day, int next, int nextTime) {\t\t \t\tfor(int h : hotels) { \t\t\tint toHotelTime = map[next][h]; \t\t\tif(nextTime + toHotelTime &lt;= 540) return true; \t\t} \t\treturn false; \t} \t \tprivate boolean canGoAirport(int start, int time) { \t\tint toAirportTime = time + map[start][airport]; \t\treturn toAirportTime &lt;= 540;  \t} }  "
  },
  
  {
    "title": "PGMS_즐겨찾기가 가장 많은 식당 정보 출력하기 (SQL)",
    "url": "/posts/PGMS%EC%A6%90%EA%B2%A8%EC%B0%BE%EA%B8%B0%EA%B0%80-%EA%B0%80%EC%9E%A5-%EB%A7%8E%EC%9D%80-%EC%8B%9D%EB%8B%B9-%EC%A0%95%EB%B3%B4-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2025-01-05 23:21:01 +0900",
    "content": "[level 3] 즐겨찾기가 가장 많은 식당 정보 출력하기 - 131123  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  Empty  제출 일자  2025년 01월 05일 23:20:10  문제 설명  다음은 식당의 정보를 담은 REST_INFO 테이블입니다. REST_INFO 테이블은 다음과 같으며 REST_ID, REST_NAME, FOOD_TYPE, VIEWS, FAVORITES, PARKING_LOT, ADDRESS, TEL은 식당 ID, 식당 이름, 음식 종류, 조회수, 즐겨찾기수, 주차장 유무, 주소, 전화번호를 의미합니다.           Column name Type Nullable            REST_ID VARCHAR(5) FALSE   REST_NAME VARCHAR(50) FALSE   FOOD_TYPE VARCHAR(20) TRUE   VIEWS NUMBER TRUE   FAVORITES NUMBER TRUE   PARKING_LOT VARCHAR(1) TRUE   ADDRESS VARCHAR(100) TRUE   TEL VARCHAR(100) TRUE            문제  REST_INFO 테이블에서 음식종류별로 즐겨찾기수가 가장 많은 식당의 음식 종류, ID, 식당 이름, 즐겨찾기수를 조회하는 SQL문을 작성해주세요. 이때 결과는 음식 종류를 기준으로 내림차순 정렬해주세요.    예시  REST_INFO 테이블이 다음과 같을 때           REST_ID REST_NAME FOOD_TYPE VIEWS FAVORITES PARKING_LOT ADDRESS TEL            00001 은돼지식당 한식 1150345 734 N 서울특별시 중구 다산로 149 010-4484-8751   00002 하이가쯔네 일식 120034 112 N 서울시 중구 신당동 375-21 NULL   00003 따띠따띠뜨 양식 1234023 102 N 서울시 강남구 신사동 627-3 1F 02-6397-1023   00004 스시사카우스 일식 1522074 230 N 서울시 서울시 강남구 신사동 627-27 010-9394-2554   00005 코슌스 일식 15301 123 N 서울특별시 강남구 언주로153길 010-1315-8729          SQL을 실행하면 다음과 같이 출력되어야 합니다.           FOOD_TYPE REST_ID REST_NAME FAVORITES            한식 00001 은돼지식당 734   일식 00004 스시사카우스 230   양식 00003 따띠따띠뜨 102              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   문제 분석     GROUP BY로 음식종류를 묶으면서   각 그룹에서 즐겨찾기 최댓값을 가진 식당 정보를 가져와야 함   단순 GROUP BY로는 개별 식당 정보를 가져올 수 없음   해결 방안     서브쿼리 활용: (FOOD_TYPE, MAX(FAVORITES)) 조합을 찾아 매칭 (내 방법 ✔)   또는 윈도우 함수(RANK)로 음식종류별 순위를 매겨 1등만 선택하는 방법도 있다   고려사항     GROUP BY 사용시 SELECT절의 컬럼 제약 주의   정렬 순서 (FOOD_TYPE DESC) 잊지 않기   같은 즐겨찾기 수를 가진 식당이 있을 경우 모두 출력      코드   SELECT r1.FOOD_TYPE, r1.REST_ID, r1.REST_NAME, r1.FAVORITES     FROM REST_INFO AS r1         WHERE (r1.FOOD_TYPE, r1.FAVORITES) IN         (SELECT r2.FOOD_TYPE, MAX(r2.FAVORITES)             FROM REST_INFO AS r2                 GROUP BY r2.FOOD_TYPE)             ORDER BY r1.FOOD_TYPE DESC;  "
  },
  
  {
    "title": "BOJ_9251_LCS (Java, C++)",
    "url": "/posts/BOJ9251LCS-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-05 23:00:09 +0900",
    "content": "[Gold V] LCS - 9251  문제 링크  성능 요약  메모리: 6004 KB, 시간: 4 ms  분류  다이나믹 프로그래밍, 문자열  제출 일자  2025년 1월 5일 22:52:41  문제 설명  LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.  예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.  입력  첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.  출력  첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.     문제 풀이     상세 로직 설명     문자가 같은 경우 (str1[i-1] == str2[j-1])      현재 문자를 LCS에 포함   이전 상태(dp[i-1][j-1])에 1을 더함   예: “AB”와 “AC”에서 ‘A’ 매칭 시 dp[1][1] = dp[0][0] + 1      문자가 다른 경우      이전 상태들 중 최대값 선택   위쪽(dp[i-1][j])과 왼쪽(dp[i][j-1]) 중 큰 값   현재 문자를 포함하지 않는 최적해 유지   예시로 보는 알고리즘 진행 과정 str1 = \"ABCD\" str2 = \"AEBD\"  단계별 DP 테이블 변화     초기 상태     '' A  E  B  D '' 0  0  0  0  0 A  0  0  0  0  0 B  0  0  0  0  0 C  0  0  0  0  0 D  0  0  0  0  0           첫 번째 행 처리 (A)     '' A  E  B  D '' 0  0  0  0  0 A  0  1  1  1  1 B  0  0  0  0  0 C  0  0  0  0  0 D  0  0  0  0  0           최종 DP 테이블     '' A  E  B  D '' 0  0  0  0  0 A  0  1  1  1  1 B  0  1  1  2  2 C  0  1  1  2  2 D  0  1  1  2  3           시간 복잡도 분석          시간 복잡도: O(N × M)             N: 첫 번째 문자열의 길이       M: 두 번째 문자열의 길이                공간 복잡도: O(N × M)             2차원 DP 테이블 사용              코드   Java 코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tString str1 = br.readLine(); \t\tString str2 = br.readLine(); \t\t \t\tint[][] dp = new int[str1.length() + 1][str2.length() + 1]; \t\tfor(int i=1; i&lt;=str1.length(); i++) { \t\t\tfor(int j=1; j&lt;=str2.length(); j++) { \t\t\t\tif(str1.charAt(i-1)==str2.charAt(j-1)) dp[i][j] = Math.max(dp[i-1][j-1] + 1, dp[i][j]); \t\t\t\telse dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); \t\t\t} \t\t} //\t\tfor(int i=0; i&lt;=str1.length(); i++) { //\t\t\tfor(int j=0; j&lt;=str2.length(); j++) { //\t\t\t\tSystem.out.print(dp[i][j] + \" \"); //\t\t\t} //\t\t\tSystem.out.println(); //\t\t} \t\tbw.write(String.valueOf(dp[str1.length()][str2.length()])); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   C++ 코드  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     string str1, str2;     cin &gt;&gt; str1 &gt;&gt; str2;      vector&lt;vector&lt;int&gt;&gt; dp(str1.length() + 1,                            vector&lt;int&gt;(str2.length() + 1, 0));      for (int i = 1; i &lt;= str1.length(); i++) {         for (int j = 1; j &lt;= str2.length(); j++) {             if (str1[i - 1] == str2[j - 1])                 dp[i][j] = dp[i - 1][j - 1] + 1;             else                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);         }     }     cout &lt;&lt; dp[str1.length()][str2.length()] &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_15971_두 로봇 (Java, C++)",
    "url": "/posts/BOJ15971%EB%91%90-%EB%A1%9C%EB%B4%87-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-05 22:27:31 +0900",
    "content": "[Gold IV] 두 로봇 - 15971  문제 링크  성능 요약  메모리: 81880 KB, 시간: 444 ms  분류  너비 우선 탐색, 깊이 우선 탐색, 그래프 이론, 그래프 탐색  제출 일자  2025년 1월 5일 22:05:56  문제 설명  2018년 강원도에서 새로운 동굴이 발견되었다. 이 동굴에는 총 N개의 넓은 방이 존재하며 좁은 통로로 서로 연결되어 있는 것으로 밝혀졌다. N개의 방은 1번부터 N번까지의 번호를 붙여 1번 방, 2번 방, …, N번 방으로 부른다. 통로는 정확히 N-1개가 발견되었는데, 각각 서로 다른 두 방 사이를 연결시켜 주며 중간에 다른 통로와 이어지는 경우는 없다고 한다. 또한 이 통로들을 이용하여 임의의 두 방 사이를 이동하는 것이 가능하며, 임의의 두 방 사이를 이동할 때 같은 통로를 두 번 이상 지나지 않는 경로는 유일한 것으로 밝혀졌다.  새로 발견된 동굴을 조사하기 위해 동굴 탐사 로봇 두 대를 이용하기로 하였다. 두 로봇은 어떤 시점이 되면 각자가 획득한 정보를 공유하기 위해 통신을 해야 한다. 두 로봇이 서로 통신을 하기 위해서는 동굴 내의 같은 통로 위에 위치해야만 한다. 참고로 임의의 통로의 양 끝에 위치한 두 방들도 그 통로 위에 위치해 있다고 간주한다.   &lt;그림 1&gt; 동굴 내부를 간략히 표현한 그림  &lt;그림 1&gt;은 방이 9개인 동굴 내부를 간략하게 나타낸 예이다. &lt;그림 1&gt;에서 방은 원으로 표현되어 있으며 원 안의 수는 방 번호이다. 8개의 통로는 두 원 사이의 선분으로 표시되어 있으며 그 위의 정수 값이 통로의 길이이다. 예를 들어, 5번 방과 9번 방 사이에 길이가 6 인 통로가 있음을 알 수 있다. 만약 두 로봇이 1번 방과 9번 방에 위치해 있다면, 각각 2번 방과 5번 방으로 이동한 후 통신할 수 있으며 이때 이동한 거리의 합은 14로 최소이다.  동굴 내의 통로에 대한 정보와 두 로봇의 현재 위치가 입력으로 주어질 때, 서로 통신하기 위해 이동해야 하는 거리의 합의 최솟값을 계산하는 프로그램을 작성하시오.  동굴의 각 통로는 양 끝에 위치한 두 방의 번호와 그 길이로 주어진다. 두 로봇의 위치는 방 번호로 주어진다.  입력  표준 입력으로 동굴의 방의 개수 N과 두 로봇이 위치한 방의 번호가 세 개의 양의 정수로 공백으로 분리되어 첫 줄에 주어진다. 이후 동굴의 통로 N-1개가 한 줄에 하나씩 주어진다. 각 통로는 세 개의 양의 정수로 공백으로 분리되어 한 줄에 주어지며, 앞 두 정수는 통로의 양 끝에 위치한 방의 번호를, 세 번째 정수는 그 통로의 길이를 의미한다.  출력  표준 출력으로 두 로봇이 서로 통신하기 위해 현재 위치에서 이동해야 하는 거리의 합의 최솟값을 정수로 출력한다.     문제 풀이     전체 거리에서 최대 간선 값을 빼주었다. 주의할 점은 서브태스크에서 시작점이 같거나 정점이 1개밖에 없으면 0을 출력해줘야하고 이미 한 칸 건너 로봇이 있으면 움직일 필요 없으므로 이때도 0이다.  C++코드에서 배운 점          const - 반복하면서 요소를 변경하지 않겠다는 의미, 실수로 데이터를 수정하는 것을 방지           Node&amp; - 참조자(reference)를 사용(직접참조). &amp;가 없으면 매번 복사가 일어나 성능이 저하된다. &amp;를 사용하면 원본 데이터를 직접 참조하여 성능이 향상된다         코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tclass Node{ \t\tint to; \t\tint W; \t\tpublic Node(int to, int W){ \t\t\tthis.to = to; \t\t\tthis.W = W; \t\t} \t} \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, robot1, robot2, first, second, w, totalD, maxW; \tstatic ArrayList&lt;Node&gt;[] map; \tstatic boolean[] visited; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tN = Integer.parseInt(st.nextToken()); \t\trobot1 = Integer.parseInt(st.nextToken()); \t\trobot2 = Integer.parseInt(st.nextToken());  \t\tif(N == 1 || robot1 == robot2) { \t        bw.write(\"0\"); \t        bw.flush(); \t        bw.close(); \t        br.close(); \t        return; \t    } \t\t \t\tmap = new ArrayList[N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tmap[i] = new ArrayList&lt;Node&gt;(); \t\t} \t\t \t\tfor(int i=0; i&lt;N-1; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfirst = Integer.parseInt(st.nextToken()); \t\t\tsecond = Integer.parseInt(st.nextToken()); \t\t\tw = Integer.parseInt(st.nextToken()); \t\t\t \t\t\tmap[first].add(new Node(second, w)); \t\t\tmap[second].add(new Node(first, w)); \t\t} \t\t \t\tvisited = new boolean[N+1]; \t\ttotalD = 0; \t\tmaxW = 0; \t\t \t\tdfs(robot1, robot2); \t\tbw.write(String.valueOf(totalD - maxW)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate boolean dfs(int start, int end) { \t\tif(start == end) { \t\t\treturn true; \t\t} \t\t \t\tvisited[start] = true; \t\t \t\tfor(Node n : map[start]) { \t\t\tif(!visited[n.to]) { \t\t\t\tint prevMax = maxW; \t\t\t\tmaxW = Math.max(maxW, n.W); \t\t\t\ttotalD += n.W; \t\t\t\t \t\t\t\tif(dfs(n.to, end)) return true; \t\t\t\t \t\t\t\t// 백트래킹 \t\t\t\ttotalD -= n.W; \t\t\t\tmaxW = prevMax;\t\t\t\t \t\t\t} \t\t} \t\t \t    // 경로를 못 찾았을 때 백트래킹 및 초기화 \t\tvisited[start] = false; \t\tmaxW = 0; \t\treturn false; \t} }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  struct Node {     int to;     int W;     Node(int to, int W) : to(to), W(W) {} };  vector&lt;vector&lt;Node&gt;&gt; board; vector&lt;bool&gt; visited; int N, robot1, robot2, totalD, maxW;  bool dfs(int start, int end) {     if (start == end) return true;      visited[start] = true;      for (const Node&amp; n : board[start]) {         if (!visited[n.to]) {             int prevMaxW = maxW;             maxW = max(maxW, n.W);             totalD += n.W;              if (dfs(n.to, end)) return true;              maxW = prevMaxW;             totalD -= n.W;         }     }      visited[start] = false;     maxW = 0;     return false; }  void solve() {     cin &gt;&gt; N &gt;&gt; robot1 &gt;&gt; robot2;     if (N == 1 || robot1 == robot2) {         cout &lt;&lt; 0 &lt;&lt; \"\\n\";         return;     }      board.resize(N + 1);     visited.resize(N + 1, false);      for (int i = 0; i &lt; N - 1; i++) {         int first, second, w;         cin &gt;&gt; first &gt;&gt; second &gt;&gt; w;         board[first].push_back(Node(second, w));         board[second].push_back(Node(first, w));     }      totalD = 0;     maxW = 0;      dfs(robot1, robot2);     cout &lt;&lt; totalD - maxW &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   "
  },
  
  {
    "title": "Operating System Concepts - (7)",
    "url": "/posts/Operating-System-Concepts-7/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2025-01-05 04:12:59 +0900",
    "content": "     Memory Management - (2)   Noncontiguous Allocation     주소 변환을 페이징 별로 해야하기 때문에 바인딩이 어려워짐.      Paging (페이징 기법)            Process의 Virtual Memory를 동일한 사이즈의 Page 단위로 나눔       Virtual Memory의 내용이 page 단위로 noncontiguous하게 저장됨.       일부는 backing storage에, 일부는 physical memory에 저장됨.       Basic Method                    Physical memory를 동일한 크기의 frame으로 나눔.           Logical memory를 동일 크기의 page로 나눔 (frame과 같은 크기)           모든 가용 frame들을 관리           page table(각각의 페이지의 주소공간을 관리하는 배열)을 사용하여 logical address를 physical address로 변환           External fragmentation 발생 안함 (같은 크기로 분할하기 때문)           Internal Fragmentation 발생 가능 (마지막에 페이지 하나보다 남는 공간이 생길 수 있음. memory 공간이 페이지 개수만큼 할당되지는 않기 때문에.)                       주소변환을 위해 paging table(배열)이 사용됨.       page가 들어갈 수 있는 공간을 paging frame이라고 함.       앞부분이 논리적인 페이지 번호(p) / 뒤부분은 논리적인 주소(d)           Implementation of Page Table     Page table은 main memory에 상주   Page-table base register(PTBR)가 page table을 가리킴   Page-table length register(PTLR)가 테이블 크기를 보관   모든 메모리 접근 연산에는 2번의 memory access 필요   page table 접근 1번, 실제 data/instruction 접근 1번   속도 향상을 위해 associative register or translation look-aside buffer (TLB) 라 불리는 고속의 lookup hardware cache 사용 (별도의 하드웨어를 사용하여 속도 향상을 도모함)       메모리 주소 변환을 위해 별도의 cache memory를 두는 것을 TLB라고 보면 됨.   페이지 테이블에 대한 일부 데이터를 caching함.   TLB를 주소 변환 전에 먼저 검색하여 데이터를 체크하고, 존재한다면 바로 주소변환이 발생함.   정보 전체를 담고 있는 것이 아니라 빈번이 참고되는 일부 데이터만을 담고 있기 때문에 물리적/논리적 페이지의 쌍을 가지고 있음.   TLB는 전체를 search해야 하기 때문에 Associative registers를 추가로 사용하여 병행 검색(parallel search)이 가능하도록 구현함.   Address Translation (주소 변환)            page table 중 일부가 associative register에 보관되어 있음.       만약 해당 page #(number)가 associative register에 있는 경우 곧바로 frame #를 얻음.       그렇지 않은 경우 main memory에 있는 page table로부터 frame #를 얻음       TLB는 context switch 때 flush (remove old entries)           Effective Access Time     TLB로부터 주소변환이 되는 비율이 굉장히 높기 때문에 입실론(e)의 비율은 굉장이 적다.   Two-Level Page Table      Outer-page table / Inner-page table(page of page table) 이렇게 두가지 테이블 사용   속도는 줄어들지 않지만, 메모리 사용량이 줄어들기 때문에 사용함.   현대의 컴퓨터는 address space가 매우 큰 프로그램을 지원함.            32bit address 사용 시 : 2^32 Byte (4GB)의 주소 공간                    page size가 4K일 시 1M(백만)개의 Page table entry 필요.           각 page entry가 4Byte일 시 프로세스 당 4M의 page table 필요.           그러나, 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만을 사용하므로 page table 공간이 심하게 낭비됨.                           -&gt; 따라서 page table 자체를 page로 구성하면 사용되지 않는 주소 공간에 대한 outer page table의 엔트리 값은 null (대응하는 inner page table이 없음, 그러므로 메모리 공간을 아낄 수 있음.)      페이지 테이블도 영역을 나누어 관리하는 것   Logical address (on 32-bit machine with 4K page size)의 구성            20 bit의 page number       12 bit의 page offset           page table 자체가 page로 구성되기 때문에 page number는 다음과 같이 나뉘게 된다.            10-bit page number       10-bit page offset                따라서, logical address는 page number (p1 - 10bit, p2 - 10bit)와 page offset (d - 12bit)로 구성되어 있게 된다.            여기서 p1은 outer page table의 index이고, p2는 outer page table의 page에서의 변위 (displacement)가 된다.     d : 페이지 하나의 크기가 4KB고, 4KB안에서 몇번째 byte냐를 나타내기 때문에 4K의 위치 부분이 필요. 4K는 2^12이므로 12Bit. p1, p2 : 각각 페이지테이블이 페이지화 되어 들어가기 때문에 4KB가 되고, 각각의 엔트리가 4Byte기 때문에 1K개(1024개)가 있다. 그렇기 때문에 이를 표현하기 위해 2^10인 10Bit.  Multilevel Paging and Performance    Address space가 더 커지면 다단계 페이지 테이블 필요   각 단계의 페이지 테이블이 메모리에 존재하므로 logical address의 physical address 변환에 더 많은 메모리 접근 필요   TLB를 통해 메모리 접근 시간을 줄일 수 있음   4단계 페이지 테이블을 사용하는 경우            메모리 접근 시간이 100ns, TLB 접근 시간이 20ns이고       TLB hit ratio가 98%인 경우 effective memory access time = 0.98 x 120 + 0.02 x 520 = 128ns           결과적으로 주소변환을 위해 28ns만 소요     "
  },
  
  {
    "title": "얕은 복사와 깊은 복사",
    "url": "/posts/%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC/",
    "categories": "공부",
    "tags": "Java, 백엔드",
    "date": "2025-01-04 22:13:51 +0900",
    "content": "자바에서 객체를 복사할 때 얕은 복사와 깊은 복사라는 두 가지 방식이 있다. 먼저 Book과 Author라는 두 클래스를 사용해서 예제를 알아보자. Book은 책의 이름(name)과 저자(author) 정보를 가지고 있고, Author는 저자의 이름을 가지고 있다.  class Book {      private String name;\t// 책 이름     private Author author;\t// 저자      public Book(String name, Author author) {         this.name = name;         this.author = author;     }      public Book shallowCopy() { // 얕은 복사         return new Book(this.name, this.author);     }      public Book deepCopy() { \t// 깊은 복사         Author copiedAuthor = new Author(this.author.getName());         return new Book(this.name, copiedAuthor);     }      public void changeAuthor(String name) { // 저자 이름 변경         author.setName(name);     }      @Override     public String toString() {         return \"Book name : \" + name + \", \" + author;     }      static class Author {          private String name; // 저자 이름          public Author(String name) {             this.name = name;         }          public String getName() { \t\t\t// 저자 이름 반환             return name;         }          public void setName(String name) {  // 저자 이름 변경             this.name = name;         }          @Override         public String toString() {             return \"Author : \" + name;         }     }      public static void main(String[] args) {         Author author1 = new Author(\"조슈아 블로크\");         Book book1 = new Book(\"이펙티브 자바\", author1);          // 얕은 복사 후 변경         Book shallowCopyBook = book1.shallowCopy();         shallowCopyBook.changeAuthor(\"현재\");          // 얕은 복사 결과 출력         System.out.println(\"얕은 복사 및 변경:\");         System.out.println(\"원본 book1: \" + book1);         System.out.println(\"얕은 복사 후 book: \" + shallowCopyBook);          Author author2 = new Author(\"마틴 파울러\");         Book book2 = new Book(\"리팩터링\", author2);          // 깊은 복사 후 변경         Book deepCopyBook = book2.deepCopy();         deepCopyBook.changeAuthor(\"현재\");          // 깊은 복사 결과 출력         System.out.println(\"깊은 복사 및 변경:\");         System.out.println(\"원본 book2: \" + book2);         System.out.println(\"깊은 복사 후 book: \" + deepCopyBook);     } }    shallowCopy() 메서드는 새로운 Book 객체를 만들지만, 내부의 Author 객체는 원본과 동일한 객체를 참조합니다. 즉, Book 객체는 새로 만들었지만, Author 객체는 새로 만들지 않고 기존의 것을 그대로 사용합니다. 예를 들어, book1에서 shallowCopyBook을 만든 후, shallowCopyBook의 저자 이름을 “현재”로 바꾸면 book1의 저자 이름도 “현재”로 바뀝니다. 둘이 같은 Author 객체를 공유하고 있기 때문에 두 Book 객체의 Author가 동시에 변경되는 것입니다.  반면 deepCopy()메서드는 Book 객체와 Author 객체 모두 새로운 객체로 만들어줍니다. 그래서 book2에서 deepCopyBook을 만들고 deepCopyBook의 저자 이름을 “현재”로 바꾸어도, book2의 저자 이름은 여전히 “마틴 파울러”로 남아있다. deepCopyBook과 book2가 서로 다른 Author 객체를 참조하고 있기 때문이다.  출력 결과를 살펴보자. 얕은 복사 및 변경: 원본 book1: Book name : 이펙티브 자바, Author : 현재 얕은 복사 후 book: Book name : 이펙티브 자바, Author : 현재  얕은 복사에서 shallowCopyBook 과 book1이 같은 Author를 공유하므로, shallowCopyBook의 저자 이름을 바꾸면 book1의 저자 이름도 바뀐다.  깊은 복사 및 변경: 원본 book2: Book name : 리팩터링, Author : 마틴 파울러 깊은 복사 후 book: Book name : 리팩터링, Author : 현재  깊은 복사한 deepCopyBook 과 book2는 서로 다른 Author 객체를 참조하므로, deepCopyBook의 저자 이름을 바꿔도 book2는 영향을 받지 않는다.  References    얕은 복사   깊은 복사  "
  },
  
  {
    "title": "트랜잭션의 격리 수준",
    "url": "/posts/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-04 21:47:33 +0900",
    "content": "트랜잭션의 격리 수준은 동시에 여러 트랜잭션이 실행될 때 한 트랜잭션이 다른 트랜잭션의 연산에 영향을 받지 않도록 하는 정도를 말한다. 낮은 격리 수준은 동시 처리 능력을 높이지만, 데이터의 일관성 문제를 발생시킬 수 있다. 반대로, 높은 격리 수준은 데이터의 일관성을 보장하지만, 동시 처리 능력이 떨어질 수 있다. 즉, 데이터 정합성과 성능은 반비례한다. 트랜잭션 격리 수준은 개발자가 트랜잭션 격리 수준을 설정할 수 있는 기능을 제공하는 기능이다.  트랜잭션 격리 수준의 종류와 특징 트랜잭션 격리 수준에는 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ가 존재한다. READ UNCOMMITTED 는 커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용한다. 또한 해당 격리 수준에서는 Dirty Read, Phantom Read, Non-Repeatable Read 문제가 발생할 수 있다.  READ COMMITTED 는 커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용한다. 특정 트랜잭션이 이루어지는 동안, 다른 트랜잭션은 해당 데이터에 접근할 수 없다. Dirty Read는 발생하지 않지만, Phantom Read, Non-Repeatable Read 문제가 발생할 수 있다.  REPEATABLE READ 는 한 트랜잭션에서 특정 레코드를 조회할 때 항상 같은 데이터를 응답하는 것을 보장한다. 하지만, SEREALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다. Non-Repeatable Read 문제가 발생하지 않지만, Phantom Read 문제가 발생할 수 있다.  SERIALIZABLE 은 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다. 가장 높은 데이터 정합성을 가지지만 성능이 가장 낮다. MySQL의 경우 단순한 SELECT 쿼리가 실행되더라도 데이터베이스 잠금이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없다.  각 문제에 대한 설명 Dirty Read 는 한 트랜잭션에서 다른 트랜잭션이 변경 중인 데이터를 읽는 경우 발생한다. 다른 트랜잭션이 아직 커밋되지 않은 (즉, 롤백할 가능성이 있는) 데이터를 읽어서, 그 데이터가 나중에 롤백될 경우 트랜잭션의 결과가 변경될 수 있다. 이는 데이터의 일관성을 깨뜨릴 수 있다.  Phantom Read 는 한 트랜잭션이 동일한 쿼리를 두 번 실행했을 때, 두 번의 쿼리 사이에 다른 트랜잭션이 INSERT, UPDATE, DELETE 등의 작업을 수행하여 결과 집합이 달라지는 경우를 말한다. 이로 인해 한 트랜잭션 내에서 일관성 없는 결과를 가져올 수 있다.  Non-Repeatable Read 는 같은 트랜잭션 안에서 동일한 쿼리를 실행했을 때, 다른 결과를 얻는 경우를 의미한다. 예를 들어, 한 트랜잭션이 같은 데이터를 두 번 읽을 때, 첫 번째 읽기와 두 번째 읽기 사이에 다른 트랜잭션이 해당 데이터를 변경했을 경우 발생할 수 있다.  References    [MySQL] 트랜잭션의 격리 수준(Isolation Level)에 대해 쉽고 완벽하게 이해하기   wiki - Isolation (database systems)   MySQL의 팬텀 리드를 재연하기   [10분 테코톡] 러쉬의 MySQL 트랜잭션 격리 수준  "
  },
  
  {
    "title": "BOJ_20952_게임 개발자 승희 (Java)",
    "url": "/posts/BOJ20952%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%8A%B9%ED%9D%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-04 14:55:06 +0900",
    "content": "[Gold IV] 게임 개발자 승희 - 20952  문제 링크  성능 요약  메모리: 56632 KB, 시간: 696 ms  분류  구현, 수학  제출 일자  2025년 1월 4일 14:40:17  문제 설명  승희는 최근 369 게임에 푹 빠졌다. 369 게임을 하던 승희는 놀라 자빠질 수밖에 없었다. 369 게임을 잘하는 자기 자신이 너무 대견하였기 때문이다. 369 게임이 식상해진 승희는 369 게임을 변형한 71421 게임을 개발하였다. 369 게임에서는 3, 6, 9가 들어가는 수에 손뼉을 치지만, 71421 게임에서는 7의 배수에 손뼉을 친다. 승희는 71421 게임을 널리 퍼트리기로 결심하였다.  71421 게임은 최근 대학생들 사이에서 큰 인기를 끌고 있다. 369 게임에 이어 71421 게임도 식상해진 승희는 수열을 이용한 새로운 게임을 개발하였다.  승희의 수열 게임은 혼자서 즐길 수 있는 재미난 게임이다. 시작하기에 앞서 길이가 N인 수열 A와 길이가 M인 수열 B를 준비한다. 이후 수열 A에 대하여 M번의 연산을 수행한다. i(1 ≤ i ≤ M)번째 연산은 수열 A의 모든 원소에 Bi를 더한 후 7의 배수인 원소들을 제거하는 연산이다. 단, 연산을 수행한 결과 수열 A의 모든 원소가 제거된다면 해당 연산은 수행하지 않는다.  수열 A와 B가 주어졌을 때, M번의 연산을 수행한 결과를 구하는 프로그램을 작성하시오.  입력  첫 번째 줄에 수열 A의 길이 N과 수열 B의 길이 M이 주어진다.  두 번째 줄에 N개의 정수 A1, A2, ..., AN이 주어진다.  세 번째 줄에 M개의 정수 B1, B2, ..., BM이 주어진다.  모든 입력은 공백으로 구분되어 주어진다.  출력  첫 번째 줄에 M번의 연산을 수행한 후 수열 A의 길이 K를 출력한다.  두 번째 줄에 K개의 정수 A1, A2, ..., AK를 공백으로 구분하여 출력한다. 답이 매우 커질 수 있으므로 109 + 7로 나눈 나머지를 출력한다.     문제 풀이    재밌는 문제! 매번 모든 수에 대해 연산을 수행하고 7로 나누어 확인하는 것은 비효율적이므로, 다음과 같은 전략을 사용했다.  나머지 기반 그룹화    수열 A의 각 원소를 7로 나눈 나머지를 기준으로 그룹화   0부터 6까지 총 7개의 그룹이 생성됨   각 그룹에는 해당 나머지를 가진 원소들이 저장   누적 합 효율적으로 관리     나머지의 합(sumMod)            지금까지 더해진 모든 수를 7로 나눈 나머지       다음 연산에서 어떤 그룹이 7의 배수가 될지 예측하는데 사용           실제 누적 합(actualSum)            MOD(10^9 + 7)로 나눈 나머지를 유지       최종 결과 계산에 사용           제거될 그룹 계산   (r + x) % 7 = 0     원본 순서 유지            각 수의 원래 위치(originalIndex) 저장       최종 출력 시 원래 순서대로 정렬하기 위해 사용              코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \t \tclass Number { \t    long value; \t    int originalIndex; \t    Number(long value, int originalIndex) { \t        this.value = value; \t        this.originalIndex = originalIndex; \t    } \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int N, M; \tstatic ArrayList&lt;Number&gt;[] num; \tstatic final long MOD = 1000000007; \tstatic long size; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tsize = N; \t\tnum = new ArrayList[7]; \t\tfor(int i=0; i&lt;7; i++) { \t\t\tnum[i] = new ArrayList&lt;Number&gt;(); \t\t} \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tlong n = Long.parseLong(st.nextToken()); \t\t\tint m = (int) n % 7; \t\t    num[m].add(new Number(n % MOD, i)); \t\t} \t\t \t\tlong sumMod = 0; // 7로 나눈 나머지 ( 계속 추가됨 ) \t\tlong actualSum = 0;  // 실제 더할 값  \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;M; i++) { \t\t\tlong l = Long.parseLong(st.nextToken()); \t\t\t \t\t\tlong nextSumMod = ((sumMod + (l % 7)) % 7); \t\t\t \t\t\t//제거될 인덱스 \t\t\tint idx = (7 - (int) (nextSumMod))%7; \t\t\tint l_size = num[idx].size(); \t\t\tif(size - l_size == 0) { \t\t\t\tcontinue; \t\t\t} \t\t\telse { \t\t\t\tsize -= l_size; \t\t\t\tnum[idx].clear(); \t\t\t\tactualSum = ((actualSum % MOD) + (l % MOD)) % MOD; \t\t        sumMod = nextSumMod; \t\t\t} \t\t} \t\t \t\tsb.append(size + \"\\n\"); \t\t \t\tArrayList&lt;Number&gt; result = new ArrayList&lt;&gt;(); \t\tfor(int i = 0; i &lt; 7; i++) { \t\t    for(Number n : num[i]) { \t\t        result.add(new Number( \t\t            ((n.value % MOD) + (actualSum % MOD)) % MOD,  \t\t            n.originalIndex \t\t        )); \t\t    } \t\t}  \t\t// originalIndex 기준으로 정렬 \t\tCollections.sort(result, (a, b) -&gt; a.originalIndex - b.originalIndex);   \t\tfor(Number n : result) { \t\t    sb.append(n.value + \" \"); \t\t} \t\t \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "Checked Exception과 Unchecked Exception",
    "url": "/posts/Checked-Exception%EA%B3%BC-Unchecked-Exception/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-04 02:06:08 +0900",
    "content": "Checked Exception 은 컴파일 시점에 확인되며, 반드시 처리해야하는 예외다. Java에서는 IOException , SQLException 등이 이에 속한다. Check Exception을 유발하는 메서드를 호출하는 경우, 메서드 시그니처에 throw 를 사용하여 호출자에게 예외를 위임하거나 메서드 내에서 try-catch를 사용하여 해당 예외를 반드시 처리해야한다.  Unchecked Exception 은 런타임 시점에 발생하는 예외로, 컴파일러가 처리 여부를 강제하지 않는다. Java에서는 RuntimeException 을 상속한 예외들이 해당된다. 일반적으로 프로그래머의 실수나 코드 오유로 인해 발생한다.  언제 사용해야할까? Checked Exception은 외부 환경과의 상호작용에서 발생할 가능성이 높은 예외에 적합하다. 예를들어, 파일 입출력, 네트워크 통신 등에서 발생할 수 있는 예외는 Checked Exception으로 처리하는것이 좋다. 이러한 예외는 예측 가능하며, 호출하는 쪽에서 적절히 처리할 수 있는 여지가 있다.  Unchecked Exception은 코드 오류, 논리적 결함 등 프로그래머의 실수로 인해 발생할 수 있는 예외에 적합하다. 예를 들어, null 참조 또는 잘못된 인덱스 접근 등은 호출자가 미리 예측하거나 처리할 수 없기 때문에 Unchecked Exception으로 두는것이 좋다.  Error과 Exception의 차이 Error는 주로 JVM에서 발생하는 심각한 문제로, OutOfMemoryError, StackOverflowError 등 시스템 레벨에서 발생하는 오류입니다. 이는 일반적으로 프로그램에서 처리하지 않으며, 회복이 어려운 오류에 속하며, 애플리케이션 코드에서 복구할 수 없는 심각한 문제를 나타냅니다.  반면, Exception은 프로그램 실행 중 발생할 수 있는 오류 상황을 나타냅니다. 대부분의 경우 회복 가능성이 있으며, 프로그램 내에서 예외 처리를 통해 오류 상황을 제어할 수 있습니다. Exception은 다시 hecked Exception과 Unchecked Exception으로 나눌 수 있습니다.  References    [10분 테코톡] 케로의 예외처리   기억보단 기록을 - 좋은 예외(Exception) 처리   custom exception을 언제 써야 할까?  "
  },
  
  {
    "title": "N+1문제 (Spring JPA)",
    "url": "/posts/N1%EB%AC%B8%EC%A0%9C-Spring-JPA/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-04 01:35:43 +0900",
    "content": "JPA N+1 문제는 연관 관계가 설정된 엔티티를 조회할 경우에, 조회된 데이터 개수 N개 만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상이다. 예를들어, 블로그 게시글과 댓글이 있는 경우, 게시글을 조회한 후 각 게시글마다 댓글을 조회하기 위해 추가 쿼리가 발생한다면 N+1 문제가 발생한 것이다. 댓글 10개가 달린 게시글 1개를 조회하는데 총 11개의 쿼리 (게시글 1개 조회 + 각 게시글의 댓글 조회 10개)가 실행된다.  findAll 메서드의 글로벌 패치 전략 별 N+1 문제 상황    Spring Data JAP에서 제공하는 findAll 메서드의 경우다.   글로벌 패치 전략을 즉시 로딩으로 설정하고 findAll() 메서드를 실행하면 N+1 문제가 발생한다. 이는 fineAll()에서는 select u from User u 라는 JPQL 구문을 생성해 실행하기 때문이다. JPQL은 글로벌 패치 전략을 고려하지 않고 쿼리를 실행한다. 모든 User을 조회하는 쿼리 실행 후, 즉시로딩 설정을 보고 연관관계에 있는 모든 엔티티를 조회하는 쿼리를 실행한다.  글로벌 패치 전략을 지연 로딩으로 설정하고 findAll()을 실행하면 N+1 문제가 발생하지 않는다. 이는 연관관계에 있는 엔티티를 실제 객체 대신에 프록시 객체로 생성하여 주입하기 때문이다. 하지만 프록시 객체를 사용할 경우에 식제 데이터가 필요해서 조회하는 쿼리가 발생하고 N+1 문제가 발생할 수 있다.  N+1 문제 해결방법 N+1 문제를 해결하기 위해서는 fetch join , @EntityGraph 를 사용해 볼 수 있다. fetch join 은 연관관계에 있는 엔티티를 한번에 즉시 로딩하는 구문이다. @EntityGraph 도 비슷한 효과를 만들어내며, 쿼리 메서드에 해당 어노테이션을 추가해 사용할 수 있다.  SELECT DISTINCT u \tFROM User u     \tLEFT JOIN FETCH u.posts   @EntityGraph(attributePaths = {\"posts\"}, type = EntityGraphType.FETCH) List&lt;User&gt; findAll();   References    JPA 모든 N+1 발생 케이스과 해결책    JPA Pagination, 그리고 N + 1 문제   "
  },
  
  {
    "title": "엔티티 매니저란?",
    "url": "/posts/%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%EB%8B%88%EC%A0%80%EB%9E%80/",
    "categories": "알고리즘",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-04 01:19:28 +0900",
    "content": "  엔티티 매니저에 대해 알기 위해선 영속성 컨텍스트에 대해 알아야 한다. 영속성 컨텍스트는 엔티티를 영구 저장하는 환경으로 1차 캐싱, 쓰기 지연, 변경 감지를 통해 영속 로직을 효율적으로 할 수 있게 해준다. 이러한 효율적인 영속 로직 수행을 위해서 엔티티는 영속성 컨텍스트에 관리되어야 한다. 이런 작업을 도와주는 것이 바로 엔티티 매니저다. 엔티티 매니저는 상태를 변경하고, 영속성 컨텍스트와 상호작용 함으로써 영속 로직을 수행하는 역할을 가지고 있다.  구체적인 엔티티 매니저의 역할  엔티티는 영속성 컨텍스트와 관련해 4가지 상태(비영속, 영속, 준영속, 삭제)를 가질 수 있다. 엔티티 매니저는 persis , merge , remove , close 메서드를 이용해 엔티티의 상태를 변경할 수 있다. 또한 엔티티 매니저는 영속성 컨텍스트의 1차 캐시로부터 엔티티를 조회할 수 있으며, 쓰기 지연 저장소에 있는 쿼리들을 flush하여 DB와 동기화시킬 수 있다. 또한 JPQL이나 Native Query를 이용해 직접 DB로부터 데이터를 불러올 수도 있다.  엔티티의 각 상태 Member member = new Member(\"현재\");  비영속 상태 는 엔티티 객체가 새로 생성되었지만, 아직 영속성 컨텍스트와 연관되지 않은 상태다. 이 상태에서는 데이터베이스와 전혀 관련이 없으며, 엔티티 객체는 메모리 상에만 존재한다.   em.persist(member); em.merge(detagedMember); em.find(Member.class, 1L);  영속 상태 는 엔티티 객체가 영속성 컨텍스트에 관리되고 있는 상태다. 이 상태에서는 엔티티의 변경사항이 자동으로 데이터베이스에 반영된다.   em.detach(member); em.clear(); em.close();  준영속 상태 는 엔티티 객체가 한 번 영속성 컨텍스트에 의해 관리되었지만, 현재는 영속성 컨텍스트와 분리된 상태다. 이 상태에서 엔티티 객체의 변경 사항이 더이상 데이터베이스에 반영되지 않는다. 영속성 컨텍스트 종료, 트랜잭션 종료 등으로 준영속 상태로 전환된다.   em.remove(member);  삭제 상태는 엔티티 객체가 영속성 컨텍스트에서 제거된 상태다. 이 상태에서는 엔티티 객체가 데이터베이스에서 삭제된다.  References    [10분 테코톡] 산초의 영속성 컨텍스트와 EntityManager   [10분 테코톡] 잉, 페퍼의Spring Data JPA 삽질일지  "
  },
  
  {
    "title": "JPA의 ddl-auto 옵션은 각각 어떤 동작을 하고 어떤 상황에서 사용해야 할까?",
    "url": "/posts/JPA%EC%9D%98-ddl-auto-%EC%98%B5%EC%85%98%EC%9D%80-%EA%B0%81%EA%B0%81-%EC%96%B4%EB%96%A4-%EB%8F%99%EC%9E%91%EC%9D%84-%ED%95%98%EA%B3%A0-%EC%96%B4%EB%96%A4-%EC%83%81%ED%99%A9%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-04 01:02:44 +0900",
    "content": "ddl-auto 옵션은 스프링 부트 애플리케이션에서 Hibernate와 같은 JPA 구현체를 사용할 때 데이터베이스 스키마 관리를 제어하는 설정이다. 이 옵션은 application.properties 또는 application.yml 파일에서 설정할 수 있으며, 다양한 값에 따라 데이터베이스 스키마에 대해 다른 동작을 수행한다. ddl-auto 옵션에는 none, validate, update, create, create-drop 등이 존재한다.  각 옵션에 대한 설명  none 으로 설정하면 데이터베이스 스키마와 관련된 어떠한 작업도 수행하지 않느다. 데이터베이스 스키마를 수동으로 관리하고 싶을 때 유용하며, 프로덕션 환경에서 주로 사용된다.  validate 는 애플리케이션이 시작될 때, 엔티티 매핑이 데이터베이스 스키마와 일치하는지 검증하며 스키마 변경은 따로 수행하지 않는다. 프로덕션 환경에서 엔티티와 데이터베이스 스키마가 일치하는지 확인하고 싶을 때 사용한다.  update 는 엔티티 매핑과 데이터베이스 스키마를 비교하여 필요한 경우 스키마를 업데이트합니다. 기존 데이터는 유지되지만, 새로운 엔티티나 변경된 엔티티 필드는 스키마에 반영됩니다. 해당 옵션은 엔티티에 변경이 발생할 때 자동으로 스키마를 업데이트하고 싶을 때 유용합니다. 프로덕션 환경에서는 예기치 않은 스키마 변경을 방지하기 위해 주의가 필요합니다.  create 는 애플리케이션이 시작될 때 기존 스키마를 삭제하고 새로 생성한다. 데이터가 모두 삭제되며 엔티티 매핑을 기반으로 새로운 스키마가 생성된다. 개발 초기에 빈 데이터베이스 스키마를 반복적으로 생성해야 할 때 유용하다. 기존 데이터가 모두 삭제되므로 프로덕션 환경에서는 사용하지 않는다.  create-drop 은 create 와 유사하지만, 애플리케이션이 종료될 때 스키마를 삭제한다는 점이 다르다. 해당 옵션은 테스트 환경에서 일시적인 데이터베이스 스키마가 필요한 경우 유용하며, 매 테스트 실행시마다 깨끗한 데이터베이스 상태를 유지하고자 할 때 사용된다. 프로덕션 환경에서는 사용되지 않는다.  프로덕션 환경에서 스키마 변경은 어떻게 해야할까? 스키마 변경이 필요할 때는 적절한 데이터베이스 마이그레이션 도구(Flyway, Liquibase 등)를 사용해 제어된 방식으로 스키마를 관리하거나, 사용자가 없는 새벽에 스키마 변경 작업을 수동으로 진행하는 것이 안전할 수 있다. "
  },
  
  {
    "title": "Spring Data JPA에서 새로운 Entity인지 판단하는 방법",
    "url": "/posts/Spring-Data-JPA%EC%97%90%EC%84%9C-%EC%83%88%EB%A1%9C%EC%9A%B4-Entity%EC%9D%B8%EC%A7%80-%ED%8C%90%EB%8B%A8%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-03 16:51:28 +0900",
    "content": "@Override public boolean isNew(T entity) {      if(versionAttribute.isEmpty())            || versionAttribute.map(Attribute::getJavaType).map(Class::isPrimitive).orElse(false)) {         return super.isNew(entity);     }      BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);      return versionAttribute.map(it -&gt; wrapper.getPropertyValue(it.getName()) == null).orElse(true); }   새로운 엔티티인지 여부는 JpaEntityInformation의 isNew(T entity) 에 의해 판단된다. 다른 설정이 없다면 JpaMetaModelEntityInformation 클래스가 동작한다. @Version 이 사용된 필드가 없거나 Version 이 사용된 필드가 primitive타입이면 AbstractEntityInformation의 isNew() 를 호출한다. @Version 이 사용된 필드가 wrapper class면 null 여부를 확인한다.  public boolean isNew(T entity) {      Id id = getId(entity);     Class&lt;ID&gt; idType = getIdType();      if (!idType.isPrimitive()) {         return id == null;     }      if (id instanceof Number) {         return ((Number) id).longValue() == 0L;     }      throw new IllegalArgumentException(String.format(\"Unsupported primitive id type %s\", idType)); }  @Version 이 사용된 필드가 없어서 AbstractEntityInformation 클래스가 동작하면 @Id 어노테이션을 사용한 필드를 확인해서 primitive 타입이 아니라면 null 여부, Number의 하위 타입이면 0인지 여부를 확인한다. @GenerateValue 어노테이션으로 키 생성 전략을 사용하면 데이터베이스에 저장될 때 id가 할당된다. 따라서 데이터베이스에 저장되기 전에 메모리에서 생성된 객체는 id가 비어있기 때문에 isNew() 는 true가 되어 새로운 entity로 판단한다.  직접 ID를 할당하는 경우에는? 키 생성 전략을 사용하지 않고 직접 ID를 할당하는 경우 새로운 entity로 간주되지 않는다. 이 때는 entity에서 Persistable&lt;T&gt; 인터페이스를 구현해서 JpaMetamodelEntityInformation 클래스가 아닌 JpaPersistableEntityInformation의 isNew() 가 동작하도록 해야한다.  public class JpaPersistableEntityInformation&lt;T extends Persistable&lt;ID, ID&gt;          extends JpaMetamodelEntityInformation&lt;T, ID&gt; {      public JpaPersistableEntityInformation(Class&lt;T&gt; domainClass, Metamodel metamodel,              PersistenceUnitUtil persistenceUnitUtil) {         super(domainClass, metamodel, persistenceUnitUtil);     }      @Override     public boolean isNew(T entity) {         return entity.isNew();     }      @Nullable     @Override     public ID getId(T entity) {         return entity.getId();     } }   새로운 Entity인지 판단하는것이 왜 중요할까? @Override @Transactional public &lt;S extends T&gt; S save(S entity) {      Assert.notNull(entity, \"Entity must not be null\");  \tif (entityInformation.isNew(entity)) { \t\tentityManager.persist(entity); \t\treturn entity; \t} else { \t\treturn entityManager.merge(entity); \t} }   SimpleJpaRepository 의 save 메서드에서 isNew() 를 사용하여 persist를 수행할지 merge를 수행할지 결정하기 때문이다. 만약 ID를 직접 지정해주는 경우에는 신규 entity라고 판단하지 않기 때문에 merge를 수행한다. 이때 해당 entity는 새로운 entity임에도 불구하고 DB를 조회하기 때문에 비효율적이다. 그렇기 때문에 새 entity인지 판단하는것이 중요하다.  References    save()시 식별자가 존재하는 경우 어떻게 동작할까?   Persistable - 새로운 엔티티 판별 여부 설정  "
  },
  
  {
    "title": "BOJ_17611_직각다각형 (Java)",
    "url": "/posts/BOJ17611%EC%A7%81%EA%B0%81%EB%8B%A4%EA%B0%81%ED%98%95-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-03 12:33:48 +0900",
    "content": "[Gold II] 직각다각형 - 17611  문제 링크  성능 요약  메모리: 46140 KB, 시간: 276 ms  분류  누적 합, 정렬, 스위핑  제출 일자  2025년 1월 3일 12:25:29  문제 설명  다각형의 두 선분이 연속하는 선분의 꼭짓점을 제외하고는 만나지 않는 다각형을 단순다각형이라고 부른다. 다각형의 각 변이 x축과 y축에 평행한 다각형을 직각다각형이라 부른다. 단순다각형이면서 직각다각형을 단순직각다각형이라 부른다. 아래 두 그림은 단순직각다각형의 예를 보여준다.     단순직각다각형이 주어질 때, 수평선 H가 다각형의 수직선분과 몇 번 교차하는지 또는 수직선 V가 다각형의 수평선분과 몇 번 교차하는지 알고자 한다. 첫 번째 그림에서 수평선 H는 4개의 수직선분과 교차하고 수직선 V는 2개의 수평선분과 교차한다. 두 번째 그림은 첫 번째 그림에서 수평선 H의 위치를 조금 위로 옮긴 것으로 8개의 수직선분과 교차하게 된다.   이때, 단순직각다각형과 가장 많이 교차하는 수평선 H와 수직선 V의 위치를 찾아 그때의 교차 횟수를 구하고자 한다. 단, 수평선 H는 다각형의 어떤 수평선분과도 겹처 놓여서는 안 되고, 유사하게 수직선 V는 다각형의 어떤 수직선분과도 겹쳐 놓여서는 안 된다.  수평선 H의 위치를 잘 정해서 주어진 단순직각다각형의 수직선분과 가장 많이 교차하는 지점을 찾을 때, 그 때의 교차 횟수를 h라 하고, 유사하게 수직선 V와 주어진 단순직각다각형의 수평선분과 가장 많이 교차하는 횟수를 v라 할 때, max(h, v)를 출력하는 프로그램을 작성하시오.  입력  입력의 첫 줄에는 단순직각다각형의 꼭지점의 개수를 나타내는 정수 n(4 ≤ n ≤ 100,000)이 주어지고, 이어지는 n개 줄 각각에 단순직각다각형 꼭지점의 좌표 (xi, yi)가 차례대로 주어진다. 주어지는 꼭지점들의 순서는 시계방향이다. 다각형의 꼭지점을 나타내는 각 좌표값은 정수이며, -500,000 ≤ xi, yi ≤ 500,000이다.  출력  max(h, v)를 출력한다.     문제 풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, point[][], startX, startY, initialX, initialY, currX, currY, res=-1; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tN = Integer.parseInt(br.readLine()); \t\tpoint = new int[1000001][2]; // 0 : 세로, 1 : 가로 \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tstartX = Integer.parseInt(st.nextToken()) + 500000; \t\tstartY = Integer.parseInt(st.nextToken()) + 500000; \t\t \t\tinitialX = startX; \t\tinitialY = startY; \t\t \t\tfor(int i=1; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tcurrX = Integer.parseInt(st.nextToken()) + 500000; \t\t\tcurrY = Integer.parseInt(st.nextToken()) + 500000; \t\t\t \t\t\tif(startY == currY) { // 세로검사 \t\t\t\tcheckV(startX, currX); \t\t\t} \t\t\telse { // 가로검사 \t\t\t\tcheckH(startY, currY); \t\t\t} \t\t\t \t\t\tstartX = currX; \t\t\tstartY = currY; \t\t} \t\t \t\tif(startY == initialY) { \t\t\tcheckV(startX, initialX); \t\t} \t\telse { \t\t\tcheckH(startY, initialY); \t\t} \t\t \t\tfor(int i=0; i&lt;point.length; i++) { \t\t\tres = Math.max(res, Math.max(point[i][0], point[i][1])); \t\t} \t\t \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate static void checkV(int r1, int r2) { \t\tint left = Math.min(r1, r2); \t\tint right = Math.max(r1, r2); \t\tfor(int i=left; i&lt;right; i++) { \t\t\tpoint[i][0]++; //\t        System.out.println(\"V : \" + (i-500000) + \", value: \" + point[i][0]);  \t\t} \t}  \tprivate static void checkH(int c1, int c2) { \t\tint up = Math.max(c1, c2); \t\tint down = Math.min(c1, c2); \t\tfor(int i=down; i&lt;up; i++) { \t\t\tpoint[i][1]++; //\t        System.out.println(\"H : \" + (i-500000) + \", value: \" + point[i][1]);  \t\t} \t} }  "
  },
  
  {
    "title": "Spring @Transactional 어노테이션은 private 메서드에서 동작할까?",
    "url": "/posts/Spring-Transactional-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%80-private-%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90%EC%84%9C-%EB%8F%99%EC%9E%91%ED%95%A0%EA%B9%8C/",
    "categories": "공부",
    "tags": "Java, Spring, 백엔드",
    "date": "2025-01-03 03:23:13 +0900",
    "content": "Spring AOP 기반 런타임에 동작하는 어노테이션으로 @Transactional , @Cacheable , @Async 등이 있습니다. Spring AOP (어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것)가 제공하는 JDK Dynamic Proxy, CGLIB 방식 모두 타겟이 구현하는 인터페이스나 구체 클래스를 대상으로 프록시를 만들어서 타겟 클래스의 메서드 수행 전후에 횡단 관심사에 대한 처리를 할 수 있다.  Spring은 빈 생성시, 해당 빈에 AOP 어노테이션이 있는지 검사하고, 있다면 프록시 객체를 생성해서 빈을 대체한다. AOP 적용 대상인 클래스의 경우 (@Transactional 과 같은 AOP 어노테이션이 하나라도 선언된 클래스) 는 프록시로 감싸진다.  JDK Dynamic Proxy의 경우 타겟 클래스가 구현하는 인터페이스를 기준으로 프록시를 생성해서 public 메서드만 AOP 적용 가능. CGLIB (코드 생성 라이브러리로서 런타임에 동적으로 자바 클래스의 프록시를 생성해주는 기능을 제공) 방식의 경우 인터페이스를 구현하지 않는 클래스를 상속해 프록시를 생성하고, private 을 제외한 public, protected, package-private 메서드에 AOP 적용 가능하다.  @Slf4j   @RequiredArgsConstructor   @Service   public class SelfInvocation {          private final MemberRepository memberRepository;          public void outerSaveWithPublic(Member member) {           saveWithPublic(member);       }          @Transactional       public void saveWithPublic(Member member) {           log.info(\"call saveWithPublic\");           memberRepository.save(member);           throw new RuntimeException(\"rollback test\");       }          public void outerSaveWithPrivate(Member member) {           saveWithPrivate(member);       }          @Transactional       private void saveWithPrivate(Member member) {           log.info(\"call saveWithPrivate\");           memberRepository.save(member);           throw new RuntimeException(\"rollback test\");       }   }  public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; {   }   @SpringBootTest   class SelfInvocationTest {          private static final Logger log = LoggerFactory.getLogger(SelfInvocationTest.class);          @Autowired       private SelfInvocation selfInvocation;          @Autowired       private MemberRepository memberRepository;          @AfterEach       void tearDown() {           memberRepository.deleteAllInBatch();       }          @Test       void aopProxyTest() {           // @Transactional 애너테이션을 가지고 있으므로, 빈이 Proxy 객체로 대체되어 주입된다.           assertThat(AopUtils.isAopProxy(selfInvocation)).isTrue();           // interface를 구현하지 않은 클래스이므로 CGLIB Proxy가 생성된다.           assertThat(AopUtils.isCglibProxy(selfInvocation)).isTrue();       }          @Test       void outerSaveWithPublic() {           Member member = new Member(\"test\");              try {               selfInvocation.outerSaveWithPublic(member);           } catch (RuntimeException e) {               log.info(\"catch exception\");           }              List&lt;Member&gt; members = memberRepository.findAll();           // self invocation 문제로 인해 트랜잭션이 정상 동작하지 않음.           // 예외 발생으로 인한 롤백이 동작하지 않고 남아있음.            assertThat(members).hasSize(1);       }          @Test       void outerSaveWithPrivate() {           try {               selfInvocation.outerSaveWithPrivate(new Member(\"test\"));           } catch (RuntimeException e) {               log.info(\"catch exception\");           }              List&lt;Member&gt; members = memberRepository.findAll();              // self invocation 문제로 인해 트랜잭션이 정상 동작하지 않음.           // 예외 발생으로 인한 롤백이 동작하지 않고 남아있음.         assertThat(members).hasSize(1);       }          @Test       void saveWithPublic() {           Member member = new Member(\"test\");              try {               selfInvocation.saveWithPublic(member);           } catch (RuntimeException e) {               log.info(\"catch exception\");           }              List&lt;Member&gt; members = memberRepository.findAll();              // 외부에서 프록시 객체를 통해 메서드가 호출되었기 때문에 트랜잭션 정상 동작, 롤백 성공.           assertThat(members).hasSize(0);       }   }   Spring AOP는 외부에서 프록시 객체를 통해 메서드가 호출될 때만 AOP 어드바이스(트랜잭션 관리)를 적용한다. 같은 클래스 내에서 메서드를 호출하면 프록시를 거치지 않고 직접 호출되므로 트랜잭션 어드바이스가 적용되지 않는다.  이를 해결하기 위해 자기 자신을 프록시로 주입 받아 프록시를 통해 메서드를 호출하거나, 별도의 클래스로 분리하거나, AspectJ를 이용하는 방법이 있다. AspectJ를 사용하면 동일 클래스 내에서의 메서드 호출에도 AOP 어드바이스를 적용할 수 있다.  자기 자신을 프록시로 주입받는 방법 @Slf4j   @RequiredArgsConstructor   @Service   public class SelfInvocation {          private final MemberRepository memberRepository;       private final SelfInvocation selfInvocation;          public void outerSaveWithPublic(Member member) {           selfInvocation.saveWithPublic(member);       }          @Transactional       public void saveWithPublic(Member member) {           log.info(\"call saveWithPublic\");           memberRepository.save(member);           throw new RuntimeException(\"rollback test\");       }     ... }  이 방법은 순환 의존성 문제를 일으킬 수 있어 권장되지 않습니다.  별도의 클래스로 분리하는 방법 @Slf4j   @RequiredArgsConstructor   @Service   public class TransactionService {          @Transactional       public void outer() {           log.info(\"call outer\");           logCurrentTransactionName();           logActualTransactionActive();           inner();       }          @Transactional(propagation = Propagation.REQUIRES_NEW)       public void inner() {           log.info(\"call inner\");           logCurrentTransactionName();           logActualTransactionActive();       }          private void logActualTransactionActive() {           boolean actualTransactionActive = TransactionSynchronizationManager.isActualTransactionActive();           log.info(\"actualTransactionActive = {}\", actualTransactionActive);       }          private void logCurrentTransactionName() {           String currentTransactionName = TransactionSynchronizationManager.getCurrentTransactionName();           log.info(\"currentTransactionName = {}\", currentTransactionName);       }   }  // 로그 // call outer   // currentTransactionName = server.transaction.TransactionService.outer   // actualTransactionActive = true   // call inner   // currentTransactionName = server.transaction.TransactionService.outer   // actualTransactionActive = true  outer가 inner 메서드를 호출하는데, outer의 propagation 속성은 REQUIRED, inner는 REQUIRES_NEW로 서로 다른 트랜잭션으로 분리되어야 한다. 하지만, 로그를 보면 동일한 outer의 트랜잭션에 속해있다. 이처럼 트랜잭션 전파 속성이 다른 두 메서드가 동일한 클래스 내부에서 self invocation 호출하면 의도대로 동작하지 않는다. 이 때 outer와 inner 메서드를 각각 다른 클래스로 분리하여 호출하면 해결할 수 있다.  // OuterTransactionService @Slf4j   @RequiredArgsConstructor   @Service   public class OuterTransactionService {          private final InnerTransactionService innerTransactionService;          @Transactional       public void outer() {           log.info(\"call outer\");           logCurrentTransactionName();           logActualTransactionActive();           innerTransactionService.inner();       }          private void logActualTransactionActive() {           boolean actualTransactionActive = TransactionSynchronizationManager.isActualTransactionActive();           log.info(\"actualTransactionActive = {}\", actualTransactionActive);       }          private void logCurrentTransactionName() {           String currentTransactionName = TransactionSynchronizationManager.getCurrentTransactionName();           log.info(\"currentTransactionName = {}\", currentTransactionName);       }   }   // InnerTransactionService @Slf4j   @RequiredArgsConstructor   @Service   public class InnerTransactionService {          @Transactional(propagation = Propagation.REQUIRES_NEW)       public void inner() {           log.info(\"call inner\");           logCurrentTransactionName();           logActualTransactionActive();       }          private void logActualTransactionActive() {           boolean actualTransactionActive = TransactionSynchronizationManager.isActualTransactionActive();           log.info(\"actualTransactionActive = {}\", actualTransactionActive);       }          private void logCurrentTransactionName() {           String currentTransactionName = TransactionSynchronizationManager.getCurrentTransactionName();           log.info(\"currentTransactionName = {}\", currentTransactionName);       }   }  // 로그 // call outer   // currentTransactionName = server.transaction.OuterTransactionService.outer   // actualTransactionActive = true   // call inner   // currentTransactionName = server.transaction.InnerTransactionService.inner   // actualTransactionActive = true  이처럼 각각 프록시를 생성할 수 있게 두 클래스로 분리하면 AOP 어드바이스가 적용되어 의도한 대로 독립적인 트랜잭션을 시작할 수 있다.  References  Spring - Proxying Mechanisms Spring - Programmatic Transaction Management 테코블 - AOP에 대한 사실과 오해 그런데 트랜잭션을 사알짝 곁들인..  참고 공부 할 자료  Spring Redisson - 어노테이션 기반으로 분산락을 사용하는 방법 "
  },
  
  {
    "title": "BOJ_2629_양팔 저울 (Java)",
    "url": "/posts/BOJ2629%EC%96%91%ED%8C%94-%EC%A0%80%EC%9A%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-02 17:41:12 +0900",
    "content": "[Gold III] 양팔저울 - 2629  문제 링크  성능 요약  메모리: 15584 KB, 시간: 112 ms  분류  다이나믹 프로그래밍, 배낭 문제  제출 일자  2025년 1월 2일 17:15:20  문제 설명  양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.  무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.  구슬이 3g인 경우 아래 &lt;그림 1&gt;과 같이 구슬과 추를 올려놓으면 양팔 저울이 수평을 이루게 된다. 따라서 각각 1g과 4g인 추가 하나씩 있을 경우 주어진 구슬이 3g인지도 확인해 볼 수 있다.    &lt;그림 1&gt; 구슬이 3g인지 확인하는 방법 ($\\boxed{1}$은 1g인 추, $\\boxed{4}$는 4g인 추, ●은 무게를 확인할 구슬)    &lt;그림 2&gt;와 같은 방법을 사용하면 구슬이 5g인지도 확인할 수 있다. 구슬이 2g이면 주어진 추를 가지고는 확인할 수 없다.  추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.  &lt;그림 2&gt; 구슬이 5g인지 확인하는 방법  입력  첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.  출력  주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.     문제 풀이    dp배열에 dp[i][j]의 값은 i번째까지 골랐을 때 j란 값을 만들 수 있는지 없는지를 뜻한다. 고로 j란 값을 만들 수 있는지를 체크하기 위해선 1~N 개를 골랐을 때 num라는 값을 만들 수 있는지를 체크해야 하는 것이다. 따라서 dp[1][num] ~ dp[N][num]가지 검사해서 true가 있으면 만들 수 있다는 것!     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, weight[], arr[];     static boolean[][] dp;     static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2629_양팔저울/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         weight = new int[N];         dp = new boolean[31][500 * 30 + 1]; // 추 30개 , 각 500g이하 -&gt; 무게 1~15000         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             weight[i] = Integer.parseInt(st.nextToken());         }          dfs(0, 0);          M = Integer.parseInt(br.readLine());         arr = new int[M];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; M; i++) {             arr[i] = Integer.parseInt(st.nextToken());             if (arr[i] &gt; 15000) sb.append(\"N\").append(\" \");             else {                 boolean flag = false;                 for (int j = 0; j &lt;= N; j++) {                     if (dp[j][arr[i]]) {                         flag = true;                         break;                     }                 }                 sb.append(dp[N][arr[i]] ? \"Y\" : \"N\").append(\" \");             }         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      private void dfs(int idx, int sum) {          if (idx &gt; N || sum &gt; 15000 || dp[idx][sum]) return;          dp[idx][sum] = true;          if (idx == N) return;          dfs(idx + 1, Math.abs(sum - weight[idx]));         dfs(idx + 1, sum);         if (sum + weight[idx] &lt;= 15000) dfs(idx + 1, sum + weight[idx]);      } }  "
  },
  
  {
    "title": "BOJ_14497_주난의 난(難) (Java)",
    "url": "/posts/BOJ14497%EC%A3%BC%EB%82%9C%EC%9D%98-%EB%82%9C%E9%9B%A3-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2025-01-02 14:59:13 +0900",
    "content": "[Gold IV] 주난의 난(難) - 14497  문제 링크  성능 요약  메모리: 23860 KB, 시간: 232 ms  분류  0-1 너비 우선 탐색, 너비 우선 탐색, 데이크스트라, 그래프 이론, 그래프 탐색, 최단 경로  제출 일자  2025년 1월 2일 14:02:32  문제 설명  주난이는 크게 화가 났다. 책상 서랍 안에 몰래 먹으려고 숨겨둔 초코바가 사라졌기 때문이다. 주난이는 미쳐 날뛰기 시작했다. 사실, 진짜로 뛰기 시작했다.  ‘쿵... 쿵...’  주난이는 점프의 파동으로 주변의 모든 친구들을 쓰러뜨리고(?) 누군가 훔쳐간 초코바를 찾으려고 한다. 주난이는 N×M크기의 학교 교실 어딘가에서 뛰기 시작했다. 주난이의 파동은 상하좌우 4방향으로 친구들을 쓰러뜨릴(?) 때 까지 계속해서 퍼져나간다. 다르게 표현해서, 한 번의 점프는 한 겹의 친구들을 쓰러뜨린다. 다음의 예를 보자.  1 # 1 0 1 1 1 1 1 0 1 0 0 1 0 0 1 * 1 1 1 1 1 0 1 1 1 1 0 0 1 1 0 0 1  주난이를 뜻하는 *은 (3, 4)에 있고, 초코바를 가진 학생 #는 (1, 2)에 있다. 0은 장애물이 없는 빈 공간임을 뜻하고, 1은 친구들이 서있음을 의미한다. 다음은 주난이의 점프에 따른 생존(?) 학생들의 변화이다.  1 # 1 0 1 1 1 1 1 0 0 0 0 1 0 0 0 * 0 1 1 1 1 0 0 1 1 1 0 0 1 1 0 0 1     1 # 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 * 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 1     0 X 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 * 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0  위의 예시에서 주난이는 3번의 점프 만에 초코바를 훔쳐간 범인을 찾아낼 수 있다!  주난이를 빨리 멈춰야 교실의 안녕을 도모할 수 있다. 주난이에게 최소 점프 횟수를 알려줘서 교실을 지키자.  입력  첫째 줄에 주난이가 위치한 교실의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 300)  둘째 줄에 주난이의 위치 x1, y1과 범인의 위치 x2, y2가 주어진다. (1 ≤ x1, x2 ≤ N, 1 ≤ y1, y2 ≤ M)  이후 N×M 크기의 교실 정보가 주어진다. 0은 빈 공간, 1은 친구, *는 주난, #는 범인을 뜻한다.  출력  주난이가 범인을 잡기 위해 최소 몇 번의 점프를 해야 하는지 출력한다.     문제 풀이   간단한 BFS 문제다. time을 우선순위큐에 넣어 진행했다. 생각해보니 다익스트라 같기도 하다.     코드   package BOJ_14497_주난의난; /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {      class Node implements Comparable&lt;Node&gt; {         int r;         int c;         int jump;          public Node(int r, int c, int jump) {             this.r = r;             this.c = c;             this.jump = jump;         }          @Override         public int compareTo(Node o) {             return this.jump - o.jump;         }     }      static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, M, startR, startC, endR, endC, res;     static int[] dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};     static char[][] board;     static boolean[][] visited;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14497_주난의난/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          st = new StringTokenizer(br.readLine());         startR = Integer.parseInt(st.nextToken());         startC = Integer.parseInt(st.nextToken());         endR = Integer.parseInt(st.nextToken());         endC = Integer.parseInt(st.nextToken());          board = new char[N + 1][M + 1];         for (int i = 1; i &lt;= N; i++) {             String str = br.readLine();             for (int j = 1; j &lt;= M; j++) {                 board[i][j] = str.charAt(j - 1);             }         }          bfs();          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     }      private void bfs() {         PriorityQueue&lt;Node&gt; queue = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1.jump - o2.jump);         visited = new boolean[N + 1][M + 1];         queue.add(new Node(startR, startC, 0));         visited[startR][startC] = true;          while (!queue.isEmpty()) {             Node curr = queue.poll();             int currJump = curr.jump;             for (int k = 0; k &lt; 4; k++) {                 int nr = curr.r + dr[k];                 int nc = curr.c + dc[k];                 if (nr &lt; 1 || nc &lt; 1 || nr &gt; N || nc &gt; M || visited[nr][nc]) continue;                  if (board[nr][nc] == '#') {                     res = currJump + 1;                     return;                 } else if (board[nr][nc] == '0') {                     queue.add(new Node(nr, nc, currJump));                     visited[nr][nc] = true;                 } else if (board[nr][nc] == '1') {                     queue.add(new Node(nr, nc, currJump + 1));                     visited[nr][nc] = true;                 }             }          }     } }  "
  },
  
  {
    "title": "PGMS_2020 카카오 인턴_보석 쇼핑 (Java)",
    "url": "/posts/PGMS2020-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EC%9D%B8%ED%84%B4%EB%B3%B4%EC%84%9D-%EC%87%BC%ED%95%91-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2025-01-02 00:00:58 +0900",
    "content": "[level 3] [카카오 인턴] 보석 쇼핑 - 67258  문제 링크  성능 요약  메모리: 83.2 MB, 시간: 51.36 ms  구분  코딩테스트 연습 &gt; 2020 카카오 인턴십  채점결과  정확성: 33.3효율성: 66.7합계: 100.0 / 100.0  제출 일자  2025년 01월 01일 21:57:58  문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다. 어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다. 어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다. 진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매  예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.           진열대 번호 1 2 3 4 5 6 7 8            보석 이름 DIA RUBY RUBY DIA DIA EMERALD SAPPHIRE DIA          진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.    진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.  진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요. 가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.  [제한사항]   gems 배열의 크기는 1 이상 100,000 이하입니다.   gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다. gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다. gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.      입출력 예           gems result            [\"DIA\", \"RUBY\", \"RUBY\", \"DIA\", \"DIA\", \"EMERALD\", \"SAPPHIRE\", \"DIA\"] [3, 7]   [\"AA\", \"AB\", \"AC\", \"AA\", \"AC\"] [1, 3]   [\"XYZ\", \"XYZ\", \"XYZ\"] [1, 1]   [\"ZZZ\", \"YYY\", \"NNNN\", \"YYY\", \"BBB\"] [1, 5]          입출력 예에 대한 설명  입출력 예 #1 문제 예시와 같습니다.  입출력 예 #2 3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다.  시작 진열대 번호가 더 작은 [1, 3]을 return 해주어야 합니다.  입출력 예 #3 1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다.  시작 진열대 번호가 가장 작은 [1, 1]을 return 해주어야 합니다.  입출력 예 #4 4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다. 그러므로 [1, 5]를 return 해주어야 합니다.  ※ 공지 - 2020년 7월 21일 테스트케이스가 추가되었습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이        코드   import java.util.*;  class Solution {     public int[] solution(String[] gems) {         Set&lt;String&gt; gemSet = new HashSet&lt;&gt;();         for(String s : gems){             gemSet.add(s);                     }         int gemKinds = gemSet.size();                  Map&lt;String, Integer&gt; gemMap = new HashMap&lt;&gt;();         int left = 0;         int right = left;         int resLeft = 0;         int resRight = gems.length;         gemMap.put(gems[0], 1);                  while(left &lt;= right &amp;&amp; right &lt; gems.length){             if(gemMap.size() == gemKinds){                 // left 증가                 if((resRight - resLeft) &gt; (right - left)){                     resRight = right + 1;                     resLeft = left + 1;                 }                 boolean isLeftCntOne = (gemMap.get(gems[left]) == 1);                 if(isLeftCntOne) gemMap.remove(gems[left]);                 else {                     int cnt = gemMap.get(gems[left])-1;                     gemMap.put(gems[left], cnt);                 }                 left++;             }             else{                 // right 증가                 right++;                 if(right &gt;= gems.length) break;                                  gemMap.put(gems[right], gemMap.getOrDefault(gems[right],0) + 1);             }         }                  int[] ans = {resLeft, resRight};         return ans;     } }  "
  },
  
  {
    "title": "LeetCode_11_Container With Most Water (Java, C++)",
    "url": "/posts/LeetCode11Container-With-Most-Water-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, leetcode, 알고리즘",
    "date": "2025-01-01 13:42:15 +0900",
    "content": "11. Container With Most Water Medium  You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).  Find two lines that together with the x-axis form a container, such that the container contains the most water.  Return the maximum amount of water a container can store.  Notice that you may not slant the container.  &nbsp; Example 1:   Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.   Example 2:   Input: height = [1,1] Output: 1   &nbsp; Constraints:   \tn == height.length \t2 &lt;= n &lt;= 105 \t0 &lt;= height[i] &lt;= 104      문제 풀이   범위를 좁혀나가면서 최대 넓이 갱신, 투포인터 문제인 것 같다고 생각했다.     코드   Java 코드 import java.util.*; import java.io.*;  class Solution {     public int maxArea(int[] height) {         int n = height.length;         int left = 0;         int right = n-1;         int width = right-left;         int res = 0;         while(left &lt; right){             int leftH = height[left];             int rightH = height[right];             int minH = Math.min(leftH, rightH);             int S = width * minH;             res = Math.max(res, S);              if(leftH &lt; rightH) left++;              else right--;             width--;         }         System.out.println(res);         return res;     } }      C++ 코드  class Solution { public:     int maxArea(vector&lt;int&gt;&amp; height) {         int n, left, right, width, res;         n = height.size();         left = 0;         right = n-1;         width = right-left;         res =0;         while(left&lt;right){             int leftH = height[left];             int rightH = height[right];             int minH = min(leftH, rightH);             int S = width * minH;             res = max(res, S);              if(leftH &lt; rightH) left++;              else right--;             width--;         }         return res;     } };   "
  },
  
  {
    "title": "Leet_146_LRUCache (Java)",
    "url": "/posts/Leet146LRUCache-Java/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-01-01 13:34:41 +0900",
    "content": "146. LRU Cache Medium  Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  Implement the LRUCache class:   \tLRUCache(int capacity) Initialize the LRU cache with positive size capacity. \tint get(int key) Return the value of the key if the key exists, otherwise return -1. \tvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.   The functions get and put must each run in O(1) average time complexity.  &nbsp; Example 1:   Input [&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4]  Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1);    // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2);    // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1);    // return -1 (not found) lRUCache.get(3);    // return 3 lRUCache.get(4);    // return 4   &nbsp; Constraints:   \t1 &lt;= capacity &lt;= 3000 \t0 &lt;= key &lt;= 104 \t0 &lt;= value &lt;= 105 \tAt most 2 * 105 calls will be made to get and put.      문제풀이   자료구조를 완전구현하듯 진행했다. 노드클래스로 key, value, 이 노드들의 배열과 링크드리스트를 뜻하는 prev, next배열, 노드인덱스 해시맵과 용량이 꽉 찼는지 체크하는 bool까지 사용했다.     코드   class LRUCache {     class Node{         int key;         int value;         Node(int key, int value){             this.key = key;             this.value = value;         }     }     int capacity;     Node[] node;     int[] prev; int[] next;     int head; int tail;     Map&lt;Integer, Integer&gt; nodeIdx;     boolean isFull;      public LRUCache(int c) {         this.capacity = c;         this.node = new Node[c];         this.prev = new int[c];         this.next = new int[c];         this.head = -1;         this.tail = -1;         this.nodeIdx = new HashMap&lt;&gt;();         this.isFull = false;     }          /*     * key 존재여부 따지기     * key 있으면 찾은 key를 head로 옮기기 (최신화) - 메서드화     * key에 해당하는 value를 node배열에서 찾아 리턴     */     public int get(int k) {         if(!nodeIdx.containsKey(k)) return -1;          int idx = nodeIdx.get(k);         setHead(idx);          return node[idx].value;     }          /*     * key 존재여부 따지기     * key **있으면** 찾은 key로 idx찾고 그 idx의 값을 node에서 찾기 - (a)     * 찾은 value를 변경후 head로 만들기 (최신화)     * key **없으면** 먼저 사용중인 개수가 capacity만큼 꽉 찼는지 확인, - (b)     * capacity가 꽉 차지 않았으면 새로운 node추가 후 isFull 갱신     * capacity가 꽉 찼으면 LRU키(tail) 찾아서 제거, 관계도 제거     * 이후 맨 앞에 추가, 관계 추가 - 메서드화     * key에 해당하는 value를 node배열에서 찾아 리턴     */     public void put(int k, int v) {         // (a)         if(nodeIdx.containsKey(k)){             int idx = nodeIdx.get(k);             node[idx].value = v;             setHead(idx);             return;         }          // (b)         if(!isFull){             putNewNode(k, v, nodeIdx.size()); // 이 부분 새로운 인덱스 써야함             if(nodeIdx.size() == capacity) isFull = true;         }         else{             int LRUkey = node[tail].key;             nodeIdx.remove(LRUkey);              int idxToPut = tail;             if(prev[tail]!=-1) {                 tail = prev[tail];                 next[tail] = -1;              }             else{ // 용량 1이면 head/tail 없으므로 초기화;                 head = -1;                 tail = head;             }              putNewNode(k, v, idxToPut);         }     }      /*     * 맨 앞으로 옮기는 메서드     * 원래 위치에서의 관계 끊고 맨 앞으로 옮기기     * 맨 앞의 관계는 prev가 없고 맨 앞(head)가 next.     */     private void setHead(int idx){         if(idx == head) return;                  if(idx != tail){             prev[next[idx]] = prev[idx];             next[prev[idx]] = next[idx];         }         else{             tail = prev[idx];             next[tail] = -1;         }          prev[head] = idx;         prev[idx] = -1;         next[idx] = head;                  head = idx;     }      /*     * 새로 추가할 노드를 배열에 추가 후     * 맨 앞에 관계도 추가, head설정     */     private void putNewNode(int k, int v, int idxToPut){         node[idxToPut] = new Node(k, v);         nodeIdx.put(k, idxToPut);          prev[idxToPut] = -1;         next[idxToPut] = head;         if(head!=-1) prev[head] = idxToPut; // 용량 1 고려한 조건문         head = idxToPut;          if(tail==-1) tail = idxToPut; // 첫원소넣는경우 고려      } }  /**  * Your LRUCache object will be instantiated and called as such:  * LRUCache obj = new LRUCache(capacity);  * int param_1 = obj.get(key);  * obj.put(key,value);  */   "
  },
  
  {
    "title": "LeetCode_71_Simplify Path (Java)",
    "url": "/posts/LeetCode71Simplify-Path/",
    "categories": "알고리즘",
    "tags": "Java, leetcode, 알고리즘",
    "date": "2025-01-01 13:31:26 +0900",
    "content": "71. Simplify Path Medium  You are given an absolute path for a Unix-style file system, which always begins with a slash &#39;/&#39;. Your task is to transform this absolute path into its simplified canonical path.  The rules of a Unix-style file system are as follows:   \tA single period &#39;.&#39; represents the current directory. \tA double period &#39;..&#39; represents the previous/parent directory. \tMultiple consecutive slashes such as &#39;//&#39; and &#39;///&#39; are treated as a single slash &#39;/&#39;. \tAny sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, &#39;...&#39; and &#39;....&#39; are valid directory or file names.   The simplified canonical path should follow these rules:   \tThe path must start with a single slash &#39;/&#39;. \tDirectories within the path must be separated by exactly one slash &#39;/&#39;. \tThe path must not end with a slash &#39;/&#39;, unless it is the root directory. \tThe path must not have any single or double periods (&#39;.&#39; and &#39;..&#39;) used to denote current or parent directories.   Return the simplified canonical path.  &nbsp; Example 1:   Input: path = &quot;/home/&quot;  Output: &quot;/home&quot;  Explanation:  The trailing slash should be removed.   Example 2:   Input: path = &quot;/home//foo/&quot;  Output: &quot;/home/foo&quot;  Explanation:  Multiple consecutive slashes are replaced by a single one.   Example 3:   Input: path = &quot;/home/user/Documents/../Pictures&quot;  Output: &quot;/home/user/Pictures&quot;  Explanation:  A double period &quot;..&quot; refers to the directory up a level (the parent directory).   Example 4:   Input: path = &quot;/../&quot;  Output: &quot;/&quot;  Explanation:  Going one level up from the root directory is not possible.   Example 5:   Input: path = &quot;/.../a/../b/c/../d/./&quot;  Output: &quot;/.../b/d&quot;  Explanation:  &quot;...&quot; is a valid name for a directory in this problem.   &nbsp; Constraints:   \t1 &lt;= path.length &lt;= 3000 \tpath consists of English letters, digits, period &#39;.&#39;, slash &#39;/&#39; or &#39;_&#39;. \tpath is a valid absolute Unix path.      문제 풀이   /로 split 한 뒤 ..에 대한 경우의수를 나누었고 아무것도 없는 조건에서 바로 리턴하는 조건문도 추가했다.     코드   class Solution {     public String simplifyPath(String path) {         String[] dirArr = path.split(\"/\");         Deque&lt;String&gt; dq = new ArrayDeque&lt;&gt;();          for(int i=0; i&lt;dirArr.length; i++){             if(!dirArr[i].equals(\".\") &amp;&amp; !dirArr[i].isEmpty()){                 if(dirArr[i].equals(\"..\")){                     if(!dq.isEmpty()) dq.pollLast();                 }                 else{                     dq.addLast(dirArr[i]);                 }             }         }         StringBuilder sb = new StringBuilder();          // case4 위한 조건문         if(dq.isEmpty()) return \"/\";          while(!dq.isEmpty()){             sb.append(\"/\").append(dq.poll());         }         return sb.toString();     } }    "
  },
  
  {
    "title": "BOJ_17073_나무 위의 빗물 (Java, C++)",
    "url": "/posts/BOJ17073%EB%82%98%EB%AC%B4-%EC%9C%84%EC%9D%98-%EB%B9%97%EB%AC%BC-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2025-01-01 00:59:57 +0900",
    "content": "[Gold V] 나무 위의 빗물 - 17073  문제 링크  성능 요약  메모리: 118868 KB, 시간: 460 ms  분류  그래프 이론, 그래프 탐색, 수학, 트리  제출 일자  2025년 1월 1일 00:54:45  문제 설명      트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 1번 정점을 루트로 하는 어떤 트리를 나타낸 모습이다.  사실 이 트리는 영훈이가 뒷마당에서 기르고 있는 나무이다. 어제는 비가 왔기 때문에, 트리의 1번 정점에는 W만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.  이제 매초마다 모든 정점은 아래의 작업을 순서대로 반복한다.   \t물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다. \t만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.   이때, 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 즉시 자식 정점에게 줄 수는 없다.  영훈이는 나무를 바라보면서 더 이상 물이 움직이지 않는 상태가 되었을 때 각 정점에 어느 정도의 물이 있게 될지 궁금해졌다. 더 이상 물이 움직이지 않을 때, i번 정점에 쌓인 물의 양의 기댓값을 Pi라 하자. 이때, Pi가 0보다 큰 정점들에 대해서 Pi들의 평균은 어느 정도가 될까?  입력  첫째 줄에 트리의 노드의 수 N과 1번 노드에 고인 물의 양을 의미하는 정수 W가 주어진다. (2 ≤ N ≤ 500,000, 1 ≤ W ≤ 109)  다음 N-1줄에 걸쳐, 트리에 존재하는 간선의 정보가 U V의 형태로 주어진다. (1 ≤ U, V ≤ N​​​​, U ≠ V)  이는 양 끝 정점이 각각 U와 V인 간선이 트리에 존재한다는 의미이다.  입력으로 주어지는 트리는 항상 올바른 연결 트리임이 보장되며, 주어지는 트리의 루트는 항상 1번 정점이다.  출력  문제의 정답을 출력한다. 정답과의 차이가 10-3 이하인 값은 모두 정답으로 인정된다.     문제 풀이   문제 이해가 꽤 난해했다. 나무가 있고 빗물이 떨어지는데 결국 노드마다 무한대의 물을 저장할 수 있으므로 맨 아래 즉 리프 노드에 모두 저장된다. 그리고 물의 양도 정해져있기 때문에 매우 쉬운 문제다.     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;     static int N, W, tree[];     double leaf, res; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tW = Integer.parseInt(st.nextToken()); \t\ttree = new int[500010]; \t\tleaf = 0; \t\t \t\tfor(int i=0; i&lt;N-1; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint U = Integer.parseInt(st.nextToken()); \t\t\tint V = Integer.parseInt(st.nextToken()); \t\t\ttree[U]++; \t\t\ttree[V]++; \t\t} \t\t \t\tfor(int i=2; i&lt;=500000; i++) { \t\t\tif(tree[i] == 1) leaf++; \t\t} \t\t \t\tres = W / leaf; \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }    C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, W;     cin &gt;&gt; N &gt;&gt; W;     long long leaf = 0;     double res = 0;     vector&lt;int&gt; tree(500010, 0);      for (int i = 0; i &lt; N - 1; i++) {         int U, V;         cin &gt;&gt; U &gt;&gt; V;         tree[U]++;         tree[V]++;     }      for (int i = 2; i &lt;= 500000; i++) {         if (tree[i] == 1) leaf++;     }      res = 1.0 * W / leaf;     cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_18428_감시 피하기 (Java)",
    "url": "/posts/BOJ18428%EA%B0%90%EC%8B%9C-%ED%94%BC%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-31 23:52:45 +0900",
    "content": "[Gold V] 감시 피하기 - 18428  문제 링크  성능 요약  메모리: 15848 KB, 시간: 124 ms  분류  백트래킹, 브루트포스 알고리즘  제출 일자  2024년 12월 31일 23:49:03  문제 설명  NxN 크기의 복도가 있다. 복도는 1x1 크기의 칸으로 나누어지며, 특정한 위치에는 선생님, 학생, 혹은 장애물이 위치할 수 있다. 현재 몇 명의 학생들은 수업시간에 몰래 복도로 빠져나왔는데, 복도로 빠져나온 학생들은 선생님의 감시에 들키지 않는 것이 목표이다.  각 선생님들은 자신의 위치에서 상, 하, 좌, 우 4가지 방향으로 감시를 진행한다. 단, 복도에 장애물이 위치한 경우, 선생님은 장애물 뒤편에 숨어 있는 학생들은 볼 수 없다. 또한 선생님은 상, 하, 좌, 우 4가지 방향에 대하여, 아무리 멀리 있더라도 장애물로 막히기 전까지의 학생들은 모두 볼 수 있다고 가정하자.  다음과 같이 3x3 크기의 복도의 정보가 주어진 상황을 확인해보자. 본 문제에서 위치 값을 나타낼 때는 (행,열)의 형태로 표현한다. 선생님이 존재하는 칸은 T, 학생이 존재하는 칸은 S, 장애물이 존재하는 칸은 O로 표시하였다. 아래 그림과 같이 (3,1)의 위치에는 선생님이 존재하며 (1,1), (2,1), (3,3)의 위치에는 학생이 존재한다. 그리고 (1,2), (2,2), (3,2)의 위치에는 장애물이 존재한다.     이 때 (3,3)의 위치에 존재하는 학생은 장애물 뒤편에 숨어 있기 때문에 감시를 피할 수 있다. 하지만 (1,1)과 (2,1)의 위치에 존재하는 학생은 선생님에게 들키게 된다.  학생들은 복도의 빈 칸 중에서 장애물을 설치할 위치를 골라, 정확히 3개의 장애물을 설치해야 한다. 결과적으로 3개의 장애물을 설치하여 모든 학생들을 감시로부터 피하도록 할 수 있는지 계산하고자 한다. NxN 크기의 복도에서 학생 및 선생님의 위치 정보가 주어졌을 때, 장애물을 정확히 3개 설치하여 모든 학생들이 선생님들의 감시를 피하도록 할 수 있는지 출력하는 프로그램을 작성하시오.  예를 들어 N=5일 때, 다음과 같이 선생님 및 학생의 위치 정보가 주어졌다고 가정하자.    이 때 다음과 같이 3개의 장애물을 설치하면, 모든 학생들을 선생님의 감시로부터 피하도록 만들 수 있다.    입력  첫째 줄에 자연수 N이 주어진다. (3 ≤ N ≤ 6) 둘째 줄에 N개의 줄에 걸쳐서 복도의 정보가 주어진다. 각 행에서는 N개의 원소가 공백을 기준으로 구분되어 주어진다. 해당 위치에 학생이 있다면 S, 선생님이 있다면 T, 아무것도 존재하지 않는다면 X가 주어진다.  단, 전체 선생님의 수는 5이하의 자연수, 전체 학생의 수는 30이하의 자연수이며 항상 빈 칸의 개수는 3개 이상으로 주어진다.  출력  첫째 줄에 정확히 3개의 장애물을 설치하여 모든 학생들을 감시로부터 피하도록 할 수 있는지의 여부를 출력한다. 모든 학생들을 감시로부터 피하도록 할 수 있다면 \"YES\", 그렇지 않다면 \"NO\"를 출력한다.     문제 풀이   보자마자 dfs 문제라고 생각했다. 모든 조합에 대한 완탐이 필요하다고 생각했기 때문이다. trap을 매개변수로 하나씩 늘려가는것이 함정개수다. 실수만 없다면 쉽게 풀 수 있다고 생각한다. 이런 문제를 빠르게 풀어내는게 PS, CP에 도움에 될 것 같다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N; \tstatic int[] dr = {1, 0, -1, 0}, dc = {0, -1, 0, 1}; \tstatic char[][] board; \tstatic boolean[][] visited; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\tboard = new char[N][N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j=0; j&lt;N; j++) { \t\t\t\tboard[i][j] = st.nextToken().charAt(0); \t\t\t} \t\t} \t\t \t\tString res = dfs(0) ? \"YES\" : \"NO\"; \t\tbw.write(res); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t \tprivate boolean dfs(int trap) { \t\tif(trap == 3) { \t\t\tfor(int i=0; i&lt;N; i++) { \t\t\t\tfor(int j=0; j&lt;N; j++) { \t\t\t\t\tif(board[i][j] == 'T' &amp;&amp; checkS(i, j)) return false; \t\t\t\t} \t\t\t} \t\t\treturn true; \t\t} \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfor(int j=0; j&lt;N; j++) { \t\t\t\tif(board[i][j] == 'X') { \t\t\t\t\tboard[i][j] = 'O'; \t\t\t\t\tif(dfs(trap + 1)) return true; \t\t\t\t\tboard[i][j] = 'X'; \t\t\t\t} \t\t\t} \t\t} \t\treturn false; \t}  \tprivate static boolean checkS(int r, int c) { \t\tfor(int k=0; k&lt;4; k++) { \t\t\tint nr = r; \t\t\tint nc = c; \t\t\twhile(true) { \t\t\t\tnr += dr[k]; \t\t\t\tnc += dc[k]; \t\t\t\tif(nr &lt; 0 || nr &gt;= N || nc &lt; 0 || nc &gt;= N) break; \t\t\t\tif(board[nr][nc] == 'O') break; \t\t\t\tif(board[nr][nc] == 'S') return true; \t\t\t} \t\t} \t\treturn false; \t} }  "
  },
  
  {
    "title": "PGMS_자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기 (SQL)",
    "url": "/posts/PGMS%EC%9E%90%EB%8F%99%EC%B0%A8-%EB%8C%80%EC%97%AC-%EA%B8%B0%EB%A1%9D%EC%97%90%EC%84%9C-%EB%8C%80%EC%97%AC%EC%A4%91-%EB%8C%80%EC%97%AC-%EA%B0%80%EB%8A%A5-%EC%97%AC%EB%B6%80-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-12-31 21:50:21 +0900",
    "content": "[level 3] 자동차 대여 기록에서 대여중 / 대여 가능 여부 구분하기 - 157340  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; GROUP BY  채점결과  Empty  제출 일자  2024년 12월 31일 21:49:59  문제 설명  다음은 어느 자동차 대여 회사의 자동차 대여 기록 정보를 담은 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블입니다. CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블은 아래와 같은 구조로 되어있으며, HISTORY_ID, CAR_ID, START_DATE, END_DATE 는 각각 자동차 대여 기록 ID, 자동차 ID, 대여 시작일, 대여 종료일을 나타냅니다.           Column name Type Nullable            HISTORY_ID INTEGER FALSE   CAR_ID INTEGER FALSE   START_DATE DATE FALSE   END_DATE DATE FALSE            문제  CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블에서 2022년 10월 16일에 대여 중인 자동차인 경우 '대여중' 이라고 표시하고, 대여 중이지 않은 자동차인 경우 '대여 가능'을 표시하는 컬럼(컬럼명: AVAILABILITY)을 추가하여 자동차 ID와 AVAILABILITY 리스트를 출력하는 SQL문을 작성해주세요. 이때 반납 날짜가 2022년 10월 16일인 경우에도 '대여중'으로 표시해주시고 결과는 자동차 ID를 기준으로 내림차순 정렬해주세요.    예시  예를 들어 CAR_RENTAL_COMPANY_RENTAL_HISTORY 테이블이 다음과 같다면           HISTORY_ID CAR_ID START_DATE END_DATE            1 4 2022-09-27 2022-09-27   2 3 2022-10-03 2022-10-04   3 2 2022-10-05 2022-10-05   4 1 2022-10-11 2022-10-16   5 3 2022-10-13 2022-10-15   6 2 2022-10-15 2022-10-17          2022년 10월 16일에 대여 중인 자동차는 자동차 ID가 1, 2인 자동차이고, 대여 가능한 자동차는 자동차 ID가 3, 4이므로, '대여중' 또는 '대여 가능' 을 표시하는 컬럼을 추가하고, 자동차 ID를 기준으로 내림차순 정렬하면 다음과 같이 나와야 합니다.           CAR_ID AVAILABILITY            4 대여 가능   3 대여 가능   2 대여중   1 대여중              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   case문으로 조건에 맞는 경우를 각각 출력하고자 했다. 이때 집계함수 사용전에는 그냥 groupby한 후 이를 case문으로 작성했는데 틀렸다. 이에 집계함수 MAX로 조건에 맞으면 1, 맞지 않으면 0을 만들었고 이렇게 하니까 정답처리가 되었다.  전체 과정은    CAR_ID로 GROUP_BY해서 중복제거   특정 날짜를 MAX() 집계함수로 조건문 통해 1, 0 반환   CASE문으로 출력문 조정   별칭 지정 후 내림차순정렬      코드   SELECT DISTINCT CAR_ID,      CASE         WHEN MAX('2022-10-16' BETWEEN START_DATE AND END_DATE) = 1 THEN '대여중'         ELSE '대여 가능'     END AS AVAILABILITY         FROM CAR_RENTAL_COMPANY_RENTAL_HISTORY             GROUP BY CAR_ID                 ORDER BY CAR_ID DESC  "
  },
  
  {
    "title": "BOJ_7983_내일 할거야 (Java)",
    "url": "/posts/BOJ7983%EB%82%B4%EC%9D%BC-%ED%95%A0%EA%B1%B0%EC%95%BC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-31 20:34:03 +0900",
    "content": "[Gold V] 내일 할거야 - 7983  문제 링크  성능 요약  메모리: 276848 KB, 시간: 2068 ms  분류  그리디 알고리즘, 정렬  제출 일자  2024년 12월 31일 20:30:18  문제 설명  아 과제 하기 싫다. 아무 것도 안 하고 싶다. 더 적극적이고 격렬하게 아무 것도 안 하고 싶다.  있잖아. 내가 아까 책상에다가 n개의 과제 목록을 적어놨어. 각각의 과제 i는 di 일이 걸리고, 오늘로부터 ti 일 안에 끝내야 해. 그러니까 오늘이 0일이면, ti일이 끝나기 전에 제출이야. 과제는 한번 시작하면 쉬지 않고 계속해야 해. 안 그러면 머리 아파 지거든.  근데 있잖아. 내가 지금 너무, 너무 아무 것도 안 하고 싶어. 그래서 오늘은 아무 것도 안 할 거야. 더 중요한 게 뭔지 알아? 사실 나 내일도, 모레도, 아무 것도 안 하고 싶어. 한 며칠 동안은 계속 아무 것도 안하려고. 아. 과제가 있을 때 내가 내일부터 연속으로 최대 며칠동안 놀 수 있는지 궁금하다. 궁금하긴 한데, 난 아무 것도 안 하고 싶어.  좋은 생각이 났다. 너희가 이걸 대신 구해주면, 내가 너희의 맞은 문제 수를 하나 올려줄게.  입력  첫째 줄에는 과제의 개수인 정수 n (1 ≤ n ≤ 106)이 주어진다.  이후 n개의 줄에 각각의 과제를 나타내는 두 정수 di, ti (1 ≤ di, ti ≤ 109)가 순서대로 주어진다. 오늘은 0일이다.  모든 입력에 대해, 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다.  출력  내일(1일)부터 연속으로 최대 며칠 동안 놀 수 있는지를 출력한다. 가령, 답이 0이면, 내일 과제를 해야 하며, 1 이면, 모레에 과제를 해야 한다.     문제 풀이    그리디하게 시작일을 설정하면된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tclass Work implements Comparable&lt;Work&gt;{ \t\tint time, end; \t\tpublic Work(int time, int end) { \t\t\tthis.time = time; \t\t\tthis.end = end; \t\t} \t\t \t\t@Override \t\tpublic int compareTo(Work o) { \t\t\treturn o.end - this.end; \t\t} \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint n = Integer.parseInt(br.readLine()); \t\tWork[] work = new Work[n]; \t\tfor(int i=0; i&lt;n; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\twork[i] = new Work(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())); \t\t} \t\t \t\tArrays.sort(work); // 내림차순 \t\t \t\tint finalDay = work[0].end; \t\tfor(int i=0; i&lt;n; i++) { \t\t\t \t\t\t// 그리디한 시작날짜 선택 \t\t\tif(work[i].end &lt;= finalDay) finalDay = work[i].end - work[i].time;\t \t\t\telse finalDay -= work[i].time; \t\t}  \t\tbw.write(String.valueOf(finalDay)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_23829_인문예술탐사주간 (Java)",
    "url": "/posts/BOJ23829%EC%9D%B8%EB%AC%B8%EC%98%88%EC%88%A0%ED%83%90%EC%82%AC%EC%A3%BC%EA%B0%84/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-31 14:58:57 +0900",
    "content": "[Gold IV] 인문예술탐사주간 - 23829  문제 링크  성능 요약  메모리: 45380 KB, 시간: 684 ms  분류  이분 탐색, 누적 합  제출 일자  2024년 12월 31일 14:48:28  문제 설명  태영이는 SASA의 축제라고 불리는 “인문예술탐사주간”을 보내게 되었다. “인문예술탐사주간”을 맞이하여 세종호수공원에 가게 된 태영이는 아름다운 경치에 놀라움을 금치 못했다.  세종호수공원은 일직선으로 뻗어있는 모습이다. 이 공원에는 나무가 총 $N$ 그루 있으며, $i$ 번째 나무의 위치는 $P_i$이다.  태영이는 카메라를 들고 파노라마 사진을 $Q$ 번 찍어, 이 아름다운 풍경을 담으려고 한다. 태영이는 이 사진에 점수를 매기려고 하는데, 사진의 점수는 사진을 찍은 위치로부터 각 나무까지의 거리 합이다. 이 때, 두 위치의 거리는 두 위치의 차의 절댓값으로 정의된다.  태영이가 찍은 사진에 대해서, 각 사진의 점수를 매겨주자.  입력  첫째 줄에는 나무의 개수 $N$과 태영이가 찍은 사진의 개수 $Q$가 공백으로 구분되어 주어진다.  둘째 줄에는 나무의 위치 $P_1, P_2, \\cdots, P_N$이 주어진다.  셋째 줄부터 $Q$개의 줄의 $i$ 번째 줄에는 태영이가 $i$ 번째로 사진을 찍은 위치 $X_i$가 주어진다.  출력   $i$ 번째 줄에는 태영이가 $i$ 번째 찍은 사진의 점수를 한 줄에 하나씩 차례대로 출력한다.     문제 풀이     문제를 처음 풀 때 누적합을 사용해 특정 위치에서 모든 나무까지의 거리를 한번에 계산하고자 했다. 이렇게도 답은 나오지만 문제는 맨 왼쪽 나무보다 작은곳에서 찍으면 값이 제대로 계산되지 않았다. 이를 해결하려면 왼쪽 나무 오른쪽 나무를 나눠서 계산해야했다.  원래 아이디어 : 그림 바뀐 아이디어 : leftSum으로 왼쪽거리 합 + rightSum으로 오른쪽거리합, 왼쪽오른쪽개수는 파라매트릭서치로 찾고, 만약 첫 해결법과 같이 문제가 생기는 경우를 위해 맨 왼쪽보다 작으면 개수 0 반환하게 했다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int N, Q, tree[]; \tstatic long prefixSum[]; \tstatic long sum; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tN = Integer.parseInt(st.nextToken()); \t\tQ = Integer.parseInt(st.nextToken()); \t\ttree = new int [N]; \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\ttree[i] = Integer.parseInt(st.nextToken()); \t\t} \t\tArrays.sort(tree);\t\t \t\t \t\tprefixSum = new long[N+1]; \t\t/* \t\t * 처음아이디어 : 맨 왼쪽부터 진행해 나무 한그루씩 지나칠때마다 -2씩 되므로 이를 반영하여 누적합 -&gt; 첫 O(N) 이후 쿼리마다 O(1) \t\t * \t\t\t   -&gt; 절댓값 계산 문제 발생 \t\t * 다음아이디어 : 왼쪽 오른쪽을 따로 해서 절댓값 오류까지 해결 -&gt;  O(NlogN) \t\t */ \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tprefixSum[i] = prefixSum[i-1] + tree[i-1]; \t\t} \t\t \t\tfor(int i=0; i&lt;Q; i++) { \t\t\tint pos = Integer.parseInt(br.readLine()); \t\t\tint left = findIdx(pos); \t\t\tlong leftSum = (long) left * pos - prefixSum[left]; \t\t\tlong rightSum = (long) (prefixSum[N] - prefixSum[left]) - (long) pos * (N-left); \t\t\t \t\t\tsb.append(leftSum + rightSum).append(\"\\n\"); \t\t} \t\t\t\t\t\t \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int findIdx(int pos) { \t\tint res = 0; \t\tint left = 0, right = tree.length-1;          if(pos &lt; tree[0]) return 0;  \t\twhile(left &lt;= right) { \t\t\tint mid = left + (right-left) / 2; \t\t\tif(tree[mid] &lt;= pos) { \t\t\t\tleft = mid + 1; \t\t\t\tres = mid; \t\t\t} \t\t\telse { \t\t\t\tright = mid-1; \t\t\t} \t\t} \t\treturn res+1; // 인덱스 0부턴데 개수반환해야하므로 \t} }  "
  },
  
  {
    "title": "BOJ_10974_모든 순열 (Java, C++)",
    "url": "/posts/BOJ10974%EB%AA%A8%EB%93%A0-%EC%88%9C%EC%97%B4-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-29 19:04:21 +0900",
    "content": "[Silver III] 모든 순열 - 10974  문제 링크  성능 요약  메모리: 3896 KB, 시간: 16 ms  분류  백트래킹, 브루트포스 알고리즘  제출 일자  2024년 12월 29일 18:55:08  문제 설명  N이 주어졌을 때, 1부터 N까지의 수로 이루어진 순열을 사전순으로 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 N(1 ≤ N ≤ 8)이 주어진다.   출력  첫째 줄부터 N!개의 줄에 걸쳐서 모든 순열을 사전순으로 출력한다.     문제 풀이   순열은 재귀로 방문처리와 함께 작성할 수 있었다. 메모리 사용을 좋게 하고자 길이 8 제한을 보고 비트마스킹으로 방문처리를 했다.  C++에서 숫자를 문자로 만들기 위해 to_string 말고 stringstream을 사용해보았다. stringstream res에 « 하듯 입력했고 마지막에 cout « res.str()로 출력했다.     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int N, number[];  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tnumber = new int[N]; \t\tpermutation(0, 0);  \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void permutation(int depth, int visited) { \t\tif (depth == N) { \t\t\tfor (int i = 0; i &lt; N; i++) { \t\t\t\tsb.append(number[i]).append(\" \"); \t\t\t} \t\t\tsb.append(\"\\n\"); \t\t\treturn; \t\t}  \t\tfor (int i = 1; i &lt;= N; i++) { \t\t\tif ((visited &amp; (1 &lt;&lt; (i - 1))) == 0) { \t\t\t\tnumber[depth] = i; \t\t\t\tpermutation(depth+1, visited | (1 &lt;&lt; (i-1))); \t\t\t} \t\t} \t} }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int N; vector&lt;int&gt; number; stringstream res;  void permutation(int depth, int visited) {     if (depth == N) {         for (int i = 0; i &lt; N; i++) {             res &lt;&lt; number[i] &lt;&lt; \" \";         }         res &lt;&lt; \"\\n\";         return;     }      for (int i = 1; i &lt;= N; i++) {         if ((visited &amp; (1 &lt;&lt; (i - 1))) == 0) {             number[depth] = i;             permutation(depth + 1, visited | (1 &lt;&lt; (i - 1)));         }     } }  void solve() {     cin &gt;&gt; N;     number.resize(N);     permutation(0, 0);     cout &lt;&lt; res.str(); }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_2374_같은 수로 만들기 (Java)",
    "url": "/posts/BOJ2374%EA%B0%99%EC%9D%80-%EC%88%98%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-26 18:24:09 +0900",
    "content": "[Gold IV] 같은 수로 만들기 - 2374  문제 링크  성능 요약  메모리: 14348 KB, 시간: 108 ms  분류  자료 구조, 그리디 알고리즘, 스택  제출 일자  2024년 12월 26일 18:19:39  문제 설명  n(1 ≤ n ≤ 1,000)개의 자연수 A[1], A[2], A[3], …, A[n]이 있다. 이 자연수에 Add(i)라는 연산을 하면, A[i]가 1만큼 증가한다. 이때, A[i]만 증가하는 것이 아니고, A[i]의 좌우로 인접한 같은 수의 그룹이 한번에 1씩 증가한다. A[1]과 A[n]은 인접해 있지 않다.  예를 들어 수가 {1, 1, 1, 1, 3, 3, 1} 이었다고 해 보자. Add(2)를 하면 A[2]의 좌우로 인접한 같은 수가 1씩 증가하니까 {2, 2, 2, 2, 3, 3, 1}이 된다. 여기서 Add(4)를 하면 {3, 3, 3, 3, 3, 3, 1}이 되고, 여기서 Add(1)을 하면 {4, 4, 4, 4, 4, 4, 1}이 된다.  이와 같이 Add라는 연산을 사용하여 A[1] = A[2] = A[3] = … = A[n]이 되도록 하려 한다. 이때, 최소 회수로 Add연산을 사용하는 방법을 찾는 것이 문제이다.  입력  첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 차례로 A[1], A[2], …, A[n]이 주어진다. 모든 입력은 1,000,000,000을 넘지 않는다.  출력  첫째 줄에 최소의 Add연산 사용 회수를 출력한다. 이 값은 1025을 넘지 않는다.     문제 풀이        코드   package BOJ_2374_같은수로만들기;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2374_같은수로만들기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int N = Integer.parseInt(br.readLine());         Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();         long res = 0;         int max = 0;         for (int i = 0; i &lt; N; i++) {             int num = Integer.parseInt(br.readLine());             if (max &lt; num) max = num;             if (!stack.isEmpty()) {                 int p = stack.pop();                 if (p &lt;= num) res += num - p;             }             stack.push(num);         }          // 마지막에 1 5 2 이렇게 끝나면 2의 경우 최댓값까지 올려주는 계산이 추가로 필요         res += max - stack.pop();         bw.write(String.valueOf(res));          bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1519_부분 문자열 뽑기 게임 (Java)",
    "url": "/posts/BOJ1519%EB%B6%80%EB%B6%84-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-25 04:30:05 +0900",
    "content": "[Gold II] 부분 문자열 뽑기 게임 - 1519  문제 링크  성능 요약  메모리: 323276 KB, 시간: 2424 ms  분류  다이나믹 프로그래밍, 게임 이론, 문자열  제출 일자  2024년 12월 25일 04:21:35  문제 설명  게임 판에 어떤 자연수 N이 쓰여 있을 때, 두 명의 플레이어가 턴을 번갈아가면서 이 게임을 하려고 한다.  매 턴이 돌아올때마다, 플레이어는 현재 게임 판에 쓰여 있는 수의 진 부분 문자열인 양의 정수 M을 고를 수 있다. 그리고 나서 원래 수에서 M을 뺀다. 진 부분 문자열이란 자기 자신을 제외한 모든 연속된 부분 문자열을 말한다.  예를 들어, 현재 게임 판에 2309가 써있을 때, 플레이어는 2, 3, 9, 23, 30, 230, 309를 고를 수 있다. 2를 고르면, 현재 게임 판에 쓰여 있는 수는 2307이 되고, 3은 2306, ..............., 309는 2000이 된다.  만약에 플레이어가 부분 문자열을 고를 수 없게되면, 게임에서 지게된다.  입력으로 현재 게임 판에 쓰여 있는 수 N이 주어졌을 때, 플레이어 1(첫 턴을 가지는 플레이어)이 이기기 위해서 골라야 하는 수를 출력하는 프로그램을 작성하시오. 만약 여러 가지 경우가 있다면, 가장 작은 것을 출력하고, 이길 수 없다면 -1을 출력한다.  입력  첫째 줄에 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수이다.  출력  정답을 출력한다.     문제 풀이   이미 계산된 값이면 바로 반환 (메모이제이션) num이 9 이하면 -1 반환    현재 숫자의 모든 가능한 부분 문자열 생성:            앞자리가 0이 아닌 모든 부분 문자열을 만듦       HashSet을 사용해 중복 제거           각 부분 문자열에 대해:    원래 숫자보다 작은 경우에만 처리            (원래 숫자 - 현재 부분 문자열)을 재귀적으로 확인       결과가 -1이면 항상 이전은 이기므로 이 부분 문자열을 후보값으로 저장 가능한 후보값 최소값 갱신           시간복잡도 : O(N * L²) (N: 입력값, L: 자릿수)     코드    /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, dp[];  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine());  \t\tif (N &lt; 10) \t\t\tbw.write(\"-1\"); \t\telse { \t\t\tdp = new int [N+1]; \t\t\tint res = getMinNum(N); \t\t\tbw.write(String.valueOf(res)); \t\t}  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int getMinNum(int num) { \t\tif(dp[num] != 0) return dp[num]; \t\t \t\tif(num &lt;= 9) { \t\t\tdp[num] = -1; \t\t\treturn dp[num]; \t\t}  \t\tString s = String.valueOf(num); \t\tSet&lt;Integer&gt; subset = new HashSet&lt;&gt;(); \t\t \t\tfor(int i=0; i&lt;s.length(); i++) { \t\t\tif(s.charAt(i) == '0') continue; \t\t\tStringBuilder sb = new StringBuilder(); \t\t\t \t\t\tfor(int j=i; j&lt;s.length(); j++) { \t\t\t\tsb.append(s.charAt(j)); \t\t\t\tif(!sb.toString().equals(s)) subset.add(Integer.parseInt(sb.toString())); \t\t\t} \t\t} \t\t \t\tint min = Integer.MAX_VALUE; \t\tfor(int curr : subset) { \t\t\tif(curr &lt; num) { \t\t\t\tint nextNum = num - curr; \t\t\t\tint nextVal = getMinNum(nextNum); \t\t\t\t \t\t\t\tif(nextVal == -1) min = Math.min(min, curr); \t\t\t} \t\t} \t\t \t\tdp[num] = (min == Integer.MAX_VALUE) ? -1 : min; \t\treturn dp[num]; \t} }  "
  },
  
  {
    "title": "BOJ_3711_학번 (C++)",
    "url": "/posts/BOJ3711%ED%95%99%EB%B2%88-C/",
    "categories": "알고리즘",
    "tags": "C++, 백준, 알고리즘",
    "date": "2024-12-23 22:42:34 +0900",
    "content": "[Silver V] 학번 - 3711  문제 링크  성능 요약  메모리: 2020 KB, 시간: 196 ms  분류  브루트포스 알고리즘, 수학, 정수론  제출 일자  2024년 12월 23일 22:34:45  문제 설명  Z 대학교 학생은 입학할 때 학번을 받게 된다. 학번은 0보다 크거나 같고, 106-1보다 작거나 같은 정수이다. Z 대학의 김상근 교수는 학번으로 학생들을 구분한다. 상근이는 학생들을 조금 더 쉽게 기억하기 위해서 자신이 가르치는 학생들의 학번을 m으로 나누었을 때, 나머지가 모두 다른 가장 작은 양의 정수를 찾으려고 한다.  입력  첫째 줄에 테스트 케이스의 개수 N이 주어진다. 각 테스트 케이스의 첫째 줄에는 상근이가 가르치는 학생의 수 G가 (1 ≤ G ≤ 300) 주어진다. 다음 G개 줄에는 학생의 학번이 한 줄에 하나씩 주어진다. 학번이 같은 경우는 없다.  출력  각 테스트 케이스마다, 학번을 m으로 나눈 나머지가 모두 다른 가장 작은 정수 m을 출력한다.     문제 풀이   간단하게 m을 1부터 나누어보며 나머지를 저장시키고 모든 학생수만큼 진행했을 떄 겹치는게 없으면 그때가 최소 m이므로 출력.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int G;     cin &gt;&gt; G;     vector&lt;int&gt; students(G);      for (int i = 0; i &lt; G; i++) {         cin &gt;&gt; students[i];     }      for (int m = 1;; m++) {         vector&lt;int&gt; remainers;         bool flag = true;          for (int s : students) {             int remainer = s % m;             if (find(ALL(remainers), remainer) != remainers.end()) {                 flag = false;                 break;             }             remainers.push_back(remainer);         }         if (flag) {             cout &lt;&lt; m &lt;&lt; \"\\n\";             break;         }     } }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_25707_팔찌 만들기 (C++)",
    "url": "/posts/BOJ25707%ED%8C%94%EC%B0%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0-C/",
    "categories": "알고리즘",
    "tags": "C++, 백준, 알고리즘",
    "date": "2024-12-23 22:40:55 +0900",
    "content": "[Silver V] 팔찌 만들기 - 25707  문제 링크  성능 요약  메모리: 2020 KB, 시간: 0 ms  분류  애드 혹, 그리디 알고리즘, 수학, 정렬  제출 일자  2024년 12월 22일 12:37:38  문제 설명  용모는 유치원에서 아이들을 위해 자원봉사를 하고 있다.  오늘의 활동은 구슬 N개를 줄로 이어 팔찌를 만드는 것이다. 각 구슬에는 서로 다른 수가 하나씩 적혀 있는데, 두 구슬 사이를 잇는 줄의 길이는 두 구슬에 적힌 수들의 차의 절댓값이 되어야 한다. 선생님은 이 활동을 통해 아이들이 뺄셈을 즐겁게 배우길 기대하고 있다.    용모는 아이들에게 완성된 팔찌의 견본을 보여주는 역할을 맡았다. 선생님은 똑똑한 용모에게 N개의 구슬을 건네주며, N개의 구슬로 팔찌를 만들되 줄을 가능한 적게 사용할 것을 부탁하였다. 하지만 자원봉사를 너무 열심히 하느라 지친 용모는 필요한 줄의 최소 길이를 구할 방법이 생각나질 않았다. 여러분이 용모 대신 N개의 구슬로 팔찌를 만드는데 필요한 줄의 최소 길이를 구해주자.  입력  첫 번째 줄에 구슬의 개수 N이 주어진다.  두 번째 줄에 각 구슬에 적힌 수 N개가 공백으로 구분되어 차례로 주어진다.  출력  N개의 구슬을 모두 사용하여 조건에 맞게 팔찌를 만들 때 사용하는 줄의 길이의 최솟값을 출력한다.     문제 풀이   반드시 한바퀴를 돌며 처음부터 끝까지 검사해야하는데 반드시 최소값과 최대값은 지나쳐야하며 최대값 - 최솟값의 절댓값이 있으면 양쪽으로 그 이상은 들쭉날쭉하지 않으므로 이걸 두배하면 된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;     vector&lt;int&gt; arr(N);     int minNum = INT_MAX, maxNum = INT_MIN;     for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; arr[i];         minNum = min(minNum, arr[i]);         maxNum = max(maxNum, arr[i]);     }     /*     반드시 한바퀴 돌 때 min-&gt;max 할 때 그리고 max-&gt;min할 때 각각 |max-min|     이상의 길이가 필요하므로 최소값은 2 x |maxNum - minNum|     */     cout &lt;&lt; 2 * abs(maxNum - minNum) &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_2720_세탁소 사장 동혁 (Java)",
    "url": "/posts/BOJ2720%EC%84%B8%ED%83%81%EC%86%8C-%EC%82%AC%EC%9E%A5-%EB%8F%99%ED%98%81-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-23 22:38:27 +0900",
    "content": "[Bronze III] 세탁소 사장 동혁 - 2720  문제 링크  성능 요약  메모리: 14300 KB, 시간: 104 ms  분류  사칙연산, 그리디 알고리즘, 수학  제출 일자  2024년 12월 21일 23:22:43  문제 설명  미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.  동혁이는 리암에게 실망했다.  리암은 거스름돈을 주는 것을 자꾸 실수한다.  심지어 $0.5달러를 줘야하는 경우에 거스름돈으로 $5달러를 주는것이다!  어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.  거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.  입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500)  출력  각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.     문제 풀이   간단한 수학 계산이다. 몫을 저장하고 나머지로 갱신하며 답을 찾았다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int[] divide = {25, 10, 5, 1}; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint tt = Integer.parseInt(br.readLine()); \t\twhile(tt--&gt;0) { \t\t\tint price = Integer.parseInt(br.readLine()); \t\t\tsb.append(price / divide[0]).append(\" \"); \t\t\tprice %= divide[0]; \t\t\tsb.append(price / divide[1]).append(\" \"); \t\t\tprice %= divide[1]; \t\t\tsb.append(price / divide[2]).append(\" \"); \t\t\tprice %= divide[2]; \t\t\tsb.append(price / divide[3]).append(\" \").append(\"\\n\"); \t\t} \t\t \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "클라이언트와 서버의 통신, 그리고 WebSocket과 WebRTC",
    "url": "/posts/%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%99%80-%EC%84%9C%EB%B2%84%EC%9D%98-%ED%86%B5%EC%8B%A0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-WebSocket%EA%B3%BC-WebRTC/",
    "categories": "공부",
    "tags": "JPA, Java, Spring, websocket, 백엔드",
    "date": "2024-12-20 17:16:37 +0900",
    "content": "프로젝트를 진행하며 공부한 내용을 기록하고자 한다.     Client-to-server communication   Http 클라이언트와 서버는 통신을 할 때 여러 방식을 채택할 수 있다. 이때 가장 대표적인 것으로 Http / Https 통신을 생각할 수 있을것이다.  Http란 하이퍼 텍트스 전송 프로토콜로, 하이퍼 텍스트 링크를 사용해 웹 페이지를 로드한다.   Http는 네트워크 장치간에 정보를 전송하도록 설계된 애플리케이션 계층 프로토콜이며 네트워크 프로토콜 스텍의 다른 계층 위에서 실행된다. 일반적인 흐름에서 클라이언트 시스템에서 서버에 요청한 다음 서버에서 응답 메시지를 보내는 작업이 이루어진다.  Http 요청 Http 요청은 웹 브라우저와 같은 인터넷 통신 플랫폼에서 웹 사이트를 로드하는데 필요한 정보를 요청하는 방법이다. 인터넷을 통해 이루어진 각 Http요청은 서로 다른 유형의 정보를 전달하는 일련의 인코딩된 데이터를 전달한다.  일반적인 Http요청의 구성요소     Http 버전 유형   URL   Http 메서드            Http 동사라고도 불리는 Http메서드는 Http 요청이 쿼리된 서버에서 기대하는 작업을 나타낸다.       일반적인 Http 메서드로 GET, POST 메서드가 있다. Get 요청은 응답으로 정보를 기대 (일반적으로 웹 사이트 형식으로) 하는 반면 POST요청은 일반적으로 클라이언트가 웹 서버에 정보를 제출 (양식 정보 등; ex-사용자 이름 및 비밀번호) 하고 있음을 나타낸다.           Http 요청 헤더            헤더에는 키값 쌍에 저장된 텍스트 정보가 포함되어 있으며 헤더는 모든 Http 요청 및 응답에 포함된다. 헤더는 클라이언트가 사용하는 브라우저 및 요청되는 데이터와 같은 핵심 정보를 전달한다.       Google Chrome 네트워크 탭에 있는 Http Request Header 예시\t             [Http 본문] - (선택사항)            요청의 본문에는 요청에서 전송되는 정보의 “본문”을 포함한다. 사용자 이름 및 비밀번호 or 양식에 입력된 기타 데이터와 같이 웹 서버에 제출되는 모든 정보가 포함된다.           Http 응답 Http 응답은 웹 클라이언트(브라우저 등)에서 요청에 대한 응답으로 인터넷 서버로부터 수신하는 응댭이다. 이러한 응답은 Http 요청에서 요청된 내용을 기반으로 중요한 정보를 전달한다.  일반적인 Http 응답 구성요소     Http 상태 코드            Http 요청 결과 여부를 나타내는데 사용되는 코드. 다음과 같은 5개 블록으로 나뉜다.                    100 - 199 : Informational responses           200 - 299 : Success Successful responses           300 - 399 : Redirection messages           400 - 499 : Client error responses           500 - 599 : Server error responses                                Http 응답 헤더 - Google Chrome 의 경우 개발자 도구의 Network에서 해당 파일에 대한 Response, Request 헤더를 확인할 수 있다.       [Http 본문] - (선택사항) ‘GET’ 요청에 대한 성공적인 HTTP 응답에는 일반적으로 요청된 정보가 포함된 본문이 있다. 대부분의 웹 요청의 경우 이는 웹 브라우저에서 웹 페이지로 변환되는 HTML 데이터다.   References     Http response status codes   A Comparison of WebSocket VS WebRTC  "
  },
  
  {
    "title": "BOJ_16756_Pismo (Java, C++)",
    "url": "/posts/BOJ16756Pismo-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-20 17:15:28 +0900",
    "content": "[Bronze I] Pismo - 16756  문제 링크  성능 요약  메모리: 2376 KB, 시간: 12 ms  분류  그리디 알고리즘, 구현  제출 일자  2024년 12월 20일 17:07:06  문제 설명  In a small village besides Đakovo lives Kasap. While agriculture is his branch, love and destiny, in his free time Kasap solves tasks in competitive programming and is doing very well. Particularly interesting are the tasks involving data structures.  On a sunny summer day, Kasap's friend Mirko sent him a letter we carry forward entirely:   “My dear Kasap, I hope you tolerate well these hot summer days. I'm writing this letter because I have a problem. One friend gave me a hard task the other day that I have not managed to solve yet. Since I know that you love this sort of tasks, I would ask you for help because I do not want to embarass myself in front of my friend. In the task there is an array A consisting of N integers. You should find an interval of the minimum value. The value of the interval [L, R] is defined as the difference between the maximum and minimum value of the numbers in that interval: max(A[L], A[L+1], …, A[R]) - min(A[L], A[L+1], …, A[R]). I will remind you that we observe only the intervals in which L is strictly less than R. Thank you, Mirko”   After a week of solving, Kasap has not yet managed to solve the task and asks you to help him.  입력  In the first line of input there is a positive integer N (2 ≤ N ≤ 100 000).  In the second line of input there are N integers, which absolute value is less than 109.  출력  Print the minimum value of an interval.     문제 풀이   생각보다 문제 이해가 잘 안됐다가 아이디어가 번뜩였다. 최대값 - 최소값의 차이가 최소인 구간을 찾는 것 이므로 가장 최대값 - 최소값의 차이가 적은 구간은 구간이 가장 짧을때이다. 예를들어 6 100 70 50 49 30 1   이런 테스트케이스의 경우 최대값 - 최소값이 구간이 증가함에 따라 최댓값은 증가하고, 최솟값은 감소하기 때문에 최댓값 - 최솟값의 값 자체는 항상 구간이 증가함에 따라 커진다. 따라서 길이 2짜리에서 판별하는것이 가장 이득이다. 그리디 알고리즘이라고 생각했는데 실제로 문제 유형도 그리디였다.     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tint N = Integer.parseInt(br.readLine()); \t\tint arr[] = new int[N]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t} \t\t \t\tint res = Integer.MAX_VALUE; \t\tfor(int i = 1; i &lt; N; i++) {             res=Math.min(res, Math.abs(arr[i] - arr[i-1]));         }  \t\tbw.write(String.valueOf(res));  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }     C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;     vector&lt;int&gt; arr(N);      for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; arr[i];     }      int res = INT_MAX;     for (int i = 1; i &lt; N; i++) {         res = min(res, abs(arr[i] - arr[i - 1]));     }      cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_11728_배열 합치기 (Java, C++)",
    "url": "/posts/BOJ11728%EB%B0%B0%EC%97%B4-%ED%95%A9%EC%B9%98%EA%B8%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-20 17:03:41 +0900",
    "content": "[Silver V] 배열 합치기 - 11728 문제 링크 성능 요약 메모리: 353940 KB, 시간: 1464 ms 분류 정렬, 두 포인터 제출 일자 2024년 12월 19일 21:22:18 문제 설명 정렬되어있는 두 배열 A와 B가 주어진다. 두 배열을 합친 다음 정렬해서 출력하는 프로그램을 작성하시오.  입력 첫째 줄에 배열 A의 크기 N, 배열 B의 크기 M이 주어진다. (1 ≤ N, M ≤ 1,000,000) 둘째 줄에는 배열 A의 내용이, 셋째 줄에는 배열 B의 내용이 주어진다. 배열에 들어있는 수는 절댓값이 109보다 작거나 같은 정수이다.  출력 첫째 줄에 두 배열을 합친 후 정렬한 결과를 출력한다.     문제 풀이   리스트에 추가 후 오름차순 정렬하여 출력했다.     코드   Java코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tint N = Integer.parseInt(st.nextToken()); \t\tint M = Integer.parseInt(st.nextToken()); \t\tList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tlist.add(Integer.parseInt(st.nextToken())); \t\t} \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;M; i++){ \t\t\tlist.add(Integer.parseInt(st.nextToken())); \t\t}  \t\tCollections.sort(list); \t\t \t\tStringBuilder sb = new StringBuilder(); \t\tfor(int num : list){ \t\t\tsb.append(num).append(\" \"); \t\t} \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }     C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, M;     cin &gt;&gt; N &gt;&gt; M;      vector&lt;int&gt; list;     for (int i = 0; i &lt; N; i++) {         int num;         cin &gt;&gt; num;         list.push_back(num);     }      for (int i = 0; i &lt; M; i++) {         int num;         cin &gt;&gt; num;         list.push_back(num);     }      sort(ALL(list));      for (int num : list) {         cout &lt;&lt; num &lt;&lt; \" \";     }     cout &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_23563_벽 타기 (Java)",
    "url": "/posts/BOJ23563%EB%B2%BD-%ED%83%80%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-18 16:43:52 +0900",
    "content": "[Gold III] 벽 타기 - 23563  문제 링크  성능 요약  메모리: 33392 KB, 시간: 628 ms  분류  0-1 너비 우선 탐색, 데이크스트라, 그래프 이론, 최단 경로  제출 일자  2024년 12월 18일 16:11:27  문제 설명  루시우는 높이가 $H$이고 너비가 $W$인 맵의 시작점에서 끝점까지 이동하려고 한다.     맵은 $H$개의 행과 $W$개의 열로 이루어진 격자판 모양이다. 각 칸은 벽 또는 빈칸이다.   루시우는 상, 하, 좌, 우 방향 인접한 칸으로 한 칸씩 이동할 수 있다. 벽으로는 이동할 수 없다.   루시우가 한 칸을 이동하는 데에는 1초가 걸린다.   하지만 루시우가 벽을 타고 이동하면 순식간에 (0초의 시간에) 상, 하, 좌, 우 방향 인접한 칸으로 이동할 수 있다.   어떤 빈칸의 상하좌우 중 하나가 벽이면 이 칸은 벽에 인접한 칸이라고 한다.   벽에 인접한 칸에서 벽에 인접한 칸으로 이동하면 벽을 타고 이동한다고 말한다. 루시우가 맵의 시작점에서 끝점까지 이동하는 데 걸리는 최소 시간을 구하여라.   입력  첫째 줄에는 $H$와 $W$가 공백을 사이에 두고 주어진다. 맵은 $H$개의 행과 $W$개의 열로 이루어진 격자판 모양이다.  둘째 줄부터, $H$개의 줄에 걸쳐서 맵의 모습을 나타내는 $W$개의 문자가 주어진다.     #는 벽을 뜻한다.   .는 빈칸을 뜻한다.   S는 맵의 시작점을 뜻한다. 시작점은 빈칸이다.   E는 맵의 끝점을 뜻한다. 끝점은 빈칸이다.   출력  루시우가 맵의 시작점에서 끝점까지 이동하는 데 걸리는 최소 시간을 출력하라.     문제 풀이   union find와 bfs를 사용했다.     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int[] dr = {0, -1, 0, 1};     static int[] dc = {-1, 0, 1, 0};     static int H, W, visited[][], start[], end[];     static int[] p;     static char board[][];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_23563_벽타기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         H = Integer.parseInt(st.nextToken());         W = Integer.parseInt(st.nextToken());          board = new char[H][W];         visited = new int[H][W];         p = new int[H * W];          for (int i = 0; i &lt; H; i++) {             String str = br.readLine();             for (int j = 0; j &lt; W; j++) {                 board[i][j] = str.charAt(j);                 visited[i][j] = Integer.MAX_VALUE;                 p[i * W + j] = i * W + j;                 if (board[i][j] == 'S') {                     start = new int[]{i, j};                     visited[i][j] = 0;                 }                 if (board[i][j] == 'E') {                     end = new int[]{i, j};                 }             }         }          for (int i = 1; i &lt; H - 1; i++) {             for (int j = 1; j &lt; W - 1; j++) {                 if (board[i][j] != '#' &amp;&amp; isNextToWall(i, j)) {                     for (int k = 0; k &lt; 4; k++) {                         int nr = i + dr[k];                         int nc = j + dc[k];                         if (nr &gt;= 1 &amp;&amp; nr &lt; H - 1 &amp;&amp; nc &gt;= 1 &amp;&amp; nc &lt; W - 1 &amp;&amp; board[nr][nc] != '#' &amp;&amp; isNextToWall(nr, nc)) {                             union(i * W + j, nr * W + nc);                         }                     }                 }             }         }          bfs(start);         System.out.println(visited[end[0]][end[1]]);          bw.flush();         bw.close();         br.close();     }      private boolean isNextToWall(int i, int j) {         for (int k = 0; k &lt; 4; k++) {             int nr = i + dr[k];             int nc = j + dc[k];             if (nr &gt;= 0 &amp;&amp; nr &lt; H &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; W &amp;&amp; board[nr][nc] == '#') return true;         }         return false;     }      private void union(int x, int y) {         p[find(y)] = find(x);     }      private int find(int x) {         if (p[x] != x) return p[x] = find(p[x]);         return x;     }      private void bfs(int[] start) {         PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; a[2] - b[2]);         pq.offer(new int[]{start[0], start[1], 0});         visited[start[0]][start[1]] = 0;          while (!pq.isEmpty()) {             int[] curr = pq.poll();             int currTime = curr[2];              if (currTime &gt; visited[curr[0]][curr[1]]) continue;              for (int k = 0; k &lt; 4; k++) {                 int nr = curr[0] + dr[k];                 int nc = curr[1] + dc[k];                  if (nr &lt;= 0 || nr &gt;= H - 1 || nc &lt;= 0 || nc &gt;= W - 1 || board[nr][nc] == '#') continue;                  int time = currTime + 1;                  if (isNextToWall(curr[0], curr[1]) &amp;&amp; isNextToWall(nr, nc) &amp;&amp; find(curr[0] * W + curr[1]) == find(nr * W + nc)) {                     time = currTime;                 }                  if (visited[nr][nc] &gt; time) {                     visited[nr][nc] = time;                     pq.offer(new int[]{nr, nc, time});                 }             }         }     } }   C++ 코드   "
  },
  
  {
    "title": "BOJ_17304_변호사들 (Java)",
    "url": "/posts/BOJ17304%EB%B3%80%ED%98%B8%EC%82%AC%EB%93%A4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-17 05:42:34 +0900",
    "content": "[Platinum II] 변호사들 - 17304  문제 링크  성능 요약  메모리: 94808 KB, 시간: 668 ms  분류  깊이 우선 탐색, 그래프 이론, 그래프 탐색, 강한 연결 요소  제출 일자  2024년 12월 17일 05:34:02  문제 설명  N명의 변호사가 사기 범죄를 저지른 혐의로 기소되었다. N명의 변호사는 서로를 변호하여 전원 무사히 무죄로 처리되려고 한다.  변호사들은 자신이 신뢰하는 변호사에게만 변호를 받을 수 있다. 이 신뢰관계란 M개의 (A, B)쌍으로 표현되는데, 이는 변호사 B가 변호사 A를 신뢰한다는 의미로 이 경우에만 변호사 A가 변호사 B를 변호할 수 있다.  각각의 변호사들의 실력은 매우 뛰어나기 때문에, 1명 이상의 변호를 받은 사람은 무조건 무죄가 된다. 단, 두 변호사 A, B에 대해 A가 B를 변호하고, B가 A를 변호하는 경우는 매우 수상하기 때문에 둘 모두 유죄가 된다.  각 (A, B) 쌍에 대해 변호사 A가 변호사 B를 변호할지 말지를 선택하여 모든 변호사가 무죄가 되는 것이 가능한지 판정하라.  입력  첫 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 200,000)  두 번째 줄부터 M 줄에 걸쳐 i번째 줄에는 서로 다른 두 정수 Ai, Bi가 주어진다. 이는 변호사 Ai가 변호사 Bi를 변호할 수 있다는 뜻이다.  주어지는 입력에서 순서쌍 (A, B)가 중복하여 나타나는 경우는 없다.  출력  모든 변호사가 1명 이상의 변호를 받고, 서로를 변호하는 변호사 쌍이 없도록 할 수 있는 경우 첫 줄에 YES을 출력한다.  불가능한 경우 첫 줄에 NO를 출력한다.     문제 풀이     처음 틀린 풀이(14%) 부터 리뷰하겠다.  // 틀린풀이(14%) /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M;     static ArrayList&lt;Integer&gt;[] lawyer;     // a-&gt;b 변호 관계     static ArrayList&lt;Integer&gt;[] canDefendMe; // 나를 변호할 수 있는 변호사 리스트     static boolean[] isDefended;              // 변호받았는지 여부     static int[] defenderOf;                // 각 변호사의 변호자 번호      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_17304_변호사들/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          lawyer = new ArrayList[N + 1];         canDefendMe = new ArrayList[N + 1];         for (int i = 1; i &lt;= N; i++) {             lawyer[i] = new ArrayList&lt;&gt;();             canDefendMe[i] = new ArrayList&lt;&gt;();         }          for (int i = 0; i &lt; M; i++) {             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             lawyer[a].add(b);             canDefendMe[b].add(a);         }          isDefended = new boolean[N + 1];         defenderOf = new int[N + 1]; // 변호관계저장         Arrays.fill(defenderOf, -1);                  for (int i = 1; i &lt;= N; i++) {             if (!isDefended[i]) {                 if (!dfs(i)) {                     System.out.println(\"NO\");                     return;                 }             }         }          System.out.println(\"YES\");         bw.flush();         bw.close();         br.close();     }      static boolean dfs(int curr) {         if (isDefended[curr]) return true;          for (int defender : canDefendMe[curr]) {             if (lawyer[curr].contains(defender) &amp;&amp; defenderOf[defender] == curr) continue;              // 아직 변호 못받은사람             if (defenderOf[defender] == -1 || dfs(defenderOf[defender])) {                 isDefended[curr] = true;      // curr이 변호받음                 defenderOf[curr] = defender;  // defender -&gt; curr 변호                 return true;             }          }          return false;     } }   변호관계를 다 저장한 뒤 dfs로 그래프 탐색을 한다. 이때 양방향이거나 이미 변호 받았으면 넘어가고, 아직 변호 못 받은 사람(변호인이 변호한 사람 없거나 변호인이 변호한 사람 있으면 그 사람에서 진행 할 수 없을 때) 변호하고 true반환, 변호 못하면 false반환하도록 했다.  뭔가 부실한 로직임을 인정하지만 어떻게 고치면 가능할 것 같다는 생각이 아직도 든다.  이에 가장 처음 생각했던 한붓그리기 -&gt; union-find방법을 사용했다. 어떤 사이클이든 완전 길이 2짜리 양방향선분이 아니면 가능하고, 그래야만한다. 어떻게든 한붓그리기로 돌아와야 모든 사람들이 무죄다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, M;     static ArrayList&lt;Integer&gt;[] lawyer; // a-&gt;b 변호 관계     static ArrayList&lt;Integer&gt;[] doubleRelationship; // 양방향관계     static boolean[] isDefended; \t\t// 변호받았는지 여부     static boolean flag;     static int[] p;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         M = Integer.parseInt(st.nextToken());          lawyer = new ArrayList[N + 1];         doubleRelationship = new ArrayList[N+1];         for (int i = 1; i &lt;= N; i++) {             lawyer[i] = new ArrayList&lt;&gt;();             doubleRelationship[i] = new ArrayList&lt;&gt;();         }          for (int i = 0; i &lt; M; i++) {             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             lawyer[a].add(b);         }          isDefended = new boolean[N + 1];                  p = new int[N+1];         for(int i=1; i&lt;=N; i++) {         \tp[i] = i;         }                  for(int i=1; i&lt;=N; i++) { // 나         \tfor(int l : lawyer[i]) { // 변호사         \t\tif(lawyer[l].contains(i)) {         \t\t\t// 서로 포함하므로          \t\t\tdoubleRelationship[i].add(l);         \t\t}         \t\telse {         \t\t\tisDefended[l] =true;         \t\t}         \t}         }                  for(int i=1; i&lt;=N; i++) {         \tif(isDefended[i] || p[i] != i) continue;         \tflag = false;         \tdfs(i, i);         \tif(!flag) {         \t\tSystem.out.println(\"NO\");         \t\treturn;         \t}         }                   System.out.println(\"YES\");         bw.flush();         bw.close();         br.close();     }  \tprivate void dfs(int prev, int curr) { \t\tfor(int next : doubleRelationship[curr]) { \t\t\tif(next == prev) continue; \t\t\tif(isDefended[next]) { \t\t\t\tflag = true; \t\t\t} \t\t\tif(!union(curr, next)) { \t\t\t\tflag = true; \t\t\t\tcontinue; \t\t\t} \t\t\tdfs(curr, next); \t\t} \t} \t \tprivate boolean union(int x, int y) { \t\tif(find(y) == find(x)) return false; \t\tp[find(y)] = find(x); \t\treturn true; \t} \t \tprivate int find(int x) { \t\tif(p[x] != x) return p[x] = find(p[x]); \t\treturn x; \t} }  "
  },
  
  {
    "title": "BOJ_2096_내려가기 (Java, C++)",
    "url": "/posts/BOJ2096%EB%82%B4%EB%A0%A4%EA%B0%80%EA%B8%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-16 17:08:12 +0900",
    "content": "[Gold V] 내려가기 - 2096  문제 링크  성능 요약  메모리: 2020 KB, 시간: 20 ms  분류  다이나믹 프로그래밍, 슬라이딩 윈도우  제출 일자  2024년 12월 16일 17:03:41  문제 설명  N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.  먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.    별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.  입력  첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.  출력  첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다.     문제 풀이   간단한 dp 문제다. 자바로 풀 땐 dp배열과 board배열을 사용해 전체에 저장하며 풀었다. 이를 c++로 그대로 구현하니 메모리 초과가 발생했다. 이를 위해 전체적인 메모리 사용량을 줄여야했고 맨 처음 생각한 1차원dp (2차원에서 필요없는 이전 사용된값을 버리는) 방법을 채택했고 이에 그때그때 cin 값이 필요하므로 입력받고 dp계산하는식으로 반복했다.     코드   Java코드 package BOJ_2096_내려가기;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, board[][], maxdp[][], mindp[][];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2096_내려가기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         board = new int[N][3];         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             for (int j = 0; j &lt; 3; j++) {                 board[i][j] = Integer.parseInt(st.nextToken());             }         }         maxdp = new int[N + 1][3];         mindp = new int[N + 1][3];         maxdp[1][0] = mindp[1][0] = board[0][0];         maxdp[1][1] = mindp[1][1] = board[0][1];         maxdp[1][2] = mindp[1][2] = board[0][2];          for (int i = 2; i &lt;= N; i++) {             maxdp[i][0] = board[i - 1][0] + Math.max(maxdp[i - 1][0], maxdp[i - 1][1]);             mindp[i][0] = board[i - 1][0] + Math.min(mindp[i - 1][0], mindp[i - 1][1]);             maxdp[i][1] = board[i - 1][1] + Math.max(maxdp[i - 1][0], Math.max(maxdp[i - 1][1], maxdp[i - 1][2]));             mindp[i][1] = board[i - 1][1] + Math.min(mindp[i - 1][0], Math.min(mindp[i - 1][1], mindp[i - 1][2]));             maxdp[i][2] = board[i - 1][2] + Math.max(maxdp[i - 1][1], maxdp[i - 1][2]);             mindp[i][2] = board[i - 1][2] + Math.min(mindp[i - 1][1], mindp[i - 1][2]);         }          int maxRes = Math.max(maxdp[N][0], Math.max(maxdp[N][1], maxdp[N][2]));         int minRes = Math.min(mindp[N][0], Math.min(mindp[N][1], mindp[N][2]));         StringBuilder sb = new StringBuilder();         sb.append(maxRes).append(\" \").append(minRes);         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     } }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;      vector&lt;int&gt; maxdp(3), mindp(3);     vector&lt;int&gt; nextmaxdp(3), nextmindp(3);      for (int i = 0; i &lt; 3; i++) {         int num;         cin &gt;&gt; num;         maxdp[i] = mindp[i] = num;     }      for (int i = 1; i &lt; N; i++) {         vector&lt;int&gt; tmp(3);         for (int j = 0; j &lt; 3; j++) {             cin &gt;&gt; tmp[j];         }          nextmaxdp[0] = tmp[0] + max(maxdp[0], maxdp[1]);         nextmindp[0] = tmp[0] + min(mindp[0], mindp[1]);         nextmaxdp[1] = tmp[1] + max(maxdp[0], max(maxdp[1], maxdp[2]));         nextmindp[1] = tmp[1] + min(mindp[0], min(mindp[1], mindp[2]));         nextmaxdp[2] = tmp[2] + max(maxdp[1], maxdp[2]);         nextmindp[2] = tmp[2] + min(mindp[1], mindp[2]);          maxdp = nextmaxdp;         mindp = nextmindp;     }      int maxres = max(maxdp[0], max(maxdp[1], maxdp[2]));     int minres = min(mindp[0], min(mindp[1], mindp[2]));      cout &lt;&lt; maxres &lt;&lt; \" \" &lt;&lt; minres &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "[Java] List.contains() 와 Set.contains() 비교",
    "url": "/posts/Java-List.contains-%EC%99%80-Set.contains-%EB%B9%84%EA%B5%90/",
    "categories": "공부",
    "tags": "Java",
    "date": "2024-12-16 16:06:34 +0900",
    "content": "   LeetCode에서 PS를 진행 도중 Submit완료 한 뒤 코드 성능 개선을 위해 여러 시도를 하던 중 List의 contains() 와 set의 contains()메서드 시간복잡도가 다르다는것을 알게 되었다. 이를 여러 자료 및 블로그를 참고해 간단히 정리하고자 남기게되었다.   contains()의 시간복잡도  먼저 요약하자면 set에서 사용시 시간복잡도는 O(1)이고, list에서 사용시 O(N)의 시간복잡도를 가진다. 왜 이런 결과를 보이는지 알아보자.    직접 구현된 코드를 찾아가보니 Collection을 상속받고있고, 둘 다 Struct로 구현되어있다.    더 깊게 찾아가보니 hashSet은 hashMap을 기반으로 구현된다는 것도 알았다!  이에 반해  ArrayList에서는 indexOf()를 통해 결정하기에 모든 항목을 체크해야 하는 것이다.  Set set은 내부적으로 해시테이블로 구현이 되어있다고 한다. 해시테이블은 빠른 검색 속도를 자랑한다. key-value 구조로 이루어져있고 key를 해시 함수에 넣어 고유한 인덱스를 만들어 버킷의 해당 인덱스에 값을 넣는다.  이를 통해 key-value로 바로 O(1)만에 찾아낼 수 있는것임을 공부했다! "
  },
  
  {
    "title": "LeetCode_433_Minimum Genetic Mutation (Java, C++)",
    "url": "/posts/LeetCode433Minimum-Genetic-Mutation-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, leetcode, 알고리즘",
    "date": "2024-12-16 15:43:59 +0900",
    "content": "433. Minimum Genetic Mutation Medium  A gene string can be represented by an 8-character long string, with choices from &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.  Suppose we need to investigate a mutation from a gene string startGene to a gene string endGene where one mutation is defined as one single character changed in the gene string.   \tFor example, &quot;AACCGGTT&quot; --&gt; &quot;AACCGGTA&quot; is one mutation.   There is also a gene bank bank that records all the valid gene mutations. A gene must be in bank to make it a valid gene string.  Given the two gene strings startGene and endGene and the gene bank bank, return the minimum number of mutations needed to mutate from startGene to endGene. If there is no such a mutation, return -1.  Note that the starting point is assumed to be valid, so it might not be included in the bank.  &nbsp; Example 1:   Input: startGene = &quot;AACCGGTT&quot;, endGene = &quot;AACCGGTA&quot;, bank = [&quot;AACCGGTA&quot;] Output: 1   Example 2:   Input: startGene = &quot;AACCGGTT&quot;, endGene = &quot;AAACGGTA&quot;, bank = [&quot;AACCGGTA&quot;,&quot;AACCGCTA&quot;,&quot;AAACGGTA&quot;] Output: 2   &nbsp; Constraints:   \t0 &lt;= bank.length &lt;= 10 \tstartGene.length == endGene.length == bank[i].length == 8 \tstartGene, endGene, and bank[i] consist of only the characters [&#39;A&#39;, &#39;C&#39;, &#39;G&#39;, &#39;T&#39;].      문제 풀이   완전 탐색을 생각했다. 이후 어떻게 찾은 문자에 대해서만 진행하지를 생각했을 때 queue에 넣고 그 사이즈만큼 반복해서 돌리면 될 것 같았다. BFS알고리즘과 비슷한 것 같다.  이후 어떻게 이 gene들을 비교할 지 생각 중 문자열이기 때문에 contains를 사용시 O(8)만큼 걸리는데 이를 사칙연산인 ==을 사용한다면 O(1)이 걸릴것이기 때문에 A, C, G, T 를 각각 1, 2, 3, 4로 해싱한 뒤 10진수로 바꿔 고유의 유전자 패턴을 만들어줬다.  개선점은 List의 contains메서드는 list의 길이만큼 순회해야 하기 때문에 O(N)의 시간복잡도를 가지는데 HashSet의 경우 hashTable로 구현되어있기 때문에 key-value형태를 가지고 있고 이를 hashMap.contains() 메서드를 사용하기 때문에 O(1)의 시간복잡도를 가진다고 한다. 이에 visited의 자료구조를 List에서 hashSet으로 변경하였다.  c++의 경우 알고리즘 라이브러리의 find함수를 통해 vector이나 list에서 값을 찾는데 이때 찾으면 그 찾은 iterator을 반환하고, 못찾으면 해당 자료구조의 .end()를 반환한다고 한다.그리고  unordered_set과 set에서 contains함수를 c++20부터 쓸 수 있다고 한다.     코드   Java 코드 class Solution {     public int minMutation(String startGene, String endGene, String[] bank) {         int start = hashing(startGene);         int end = hashing(endGene);         List&lt;Integer&gt; geneBank = new ArrayList&lt;&gt;();         for(String s : bank){             geneBank.add(hashing(s));         }          if(!geneBank.contains(end)) return -1;                  Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();         Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();          queue.offer(start);         visited.add(start);          int cnt = 0;         while(!queue.isEmpty()){             int size = queue.size();             for(int s = 0; s &lt; size; s++){                 int curr = queue.poll();                 if(curr == end) return cnt;                  for(int idx = 0; idx &lt; 8; idx++){                     int idxNum = curr/ (int) Math.pow(10, idx) % 10;                     for(int newNum= 1; newNum &lt;= 4; newNum++){                          if(idxNum != newNum) {                             int next = curr + (newNum - idxNum) * (int) Math.pow(10, idx);                             if(geneBank.contains(next) &amp;&amp; !visited.contains(next)){                                 queue.offer(next);                                 visited.add(next);                             }                          }                     }                 }             }             cnt++;         }         return -1;     }          private int hashing(String str){ // 10진수 해싱          int num = 0;         for(int i=0; i&lt;8; i++){             num *= 10;             char c = str.charAt(i);             if(c=='A') num += 1;             else if(c=='C') num += 2;             else if(c=='G') num += 3;             else num += 4;         }         return num;     } }      C++ 코드 #define ALL(v) v.begin(), v.end()  class Solution { public:     int minMutation(string startGene, string endGene, vector&lt;string&gt;&amp; bank) {         int start = hashing(startGene);         int end = hashing(endGene);          vector&lt;int&gt; geneBank;         for(string s : bank){             geneBank.push_back(hashing(s));         }          if(find(ALL(geneBank), end) == geneBank.end()) return -1;          queue&lt;int&gt; queue;         unordered_set&lt;int&gt; visited;          queue.push(start);         visited.insert(start);          int cnt = 0;         while(!queue.empty()){             int size = queue.size();             for(int s=0; s&lt;size; s++){                 int curr = queue.front();                 queue.pop();                 if(curr == end) return cnt;                  for(int idx = 0; idx&lt;8; idx++){                     int idxNum = curr / (int) pow(10, idx) % 10;                     for(int newNum=1; newNum &lt;= 4; newNum++){                         if(idxNum != newNum) {                             int next = curr + (newNum - idxNum) * (int)pow(10, idx);                             if(find(ALL(geneBank), next) != geneBank.end() &amp;&amp; !visited.contains(next)){                                 queue.push(next);                                 visited.insert(next);                             }                         }                     }                 }             }             cnt++;         }         return -1;     }  private:     int hashing(string str){         int num = 0;         for(int i=0; i&lt;8; i++){             num *= 10;             char c = str[i];             if(c=='A') num += 1;             else if(c=='C') num += 2;             else if(c=='G') num += 3;             else num += 4;         }         return num;     } };   "
  },
  
  {
    "title": "BOJ_23353_승부 조작 (Java)",
    "url": "/posts/BOJ23353%EC%8A%B9%EB%B6%80-%EC%A1%B0%EC%9E%91-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-16 02:09:59 +0900",
    "content": "[Gold III] 승부 조작 - 23353  문제 링크  성능 요약  메모리: 243664 KB, 시간: 996 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 12월 16일 01:56:03  문제 설명  고양이 랑이와 메리는 오목 게임의 변형인 냥목 게임을 하고 있다. 냥목 게임의 규칙은 복잡하니 점수 계산 방법만 보자.    냥목 게임은 위 그림과 같은 $N \\times N$ 크기의 바둑판에서 흑돌과 백돌을 이용해 진행된다.  랑이는 흑돌을, 메리는 백돌을 사용한다.  냥목 게임에서 랑이의 점수는 가로, 세로, 대각선 중 하나의 방향으로 연속하여 존재하는 가장 긴 흑돌의 길이가 된다.  잠시 집사가 돌아와서 메리가 반기러 간 사이 랑이는 메리의 돌 하나를 자신의 돌로 바꿔치기 하려고 한다. 즉, 랑이는 백돌 하나를 흑돌로 바꿀 수 있다.  랑이가 백돌 하나를 흑돌로 바꿀 때 얻을 수 있는 최대 점수를 구하는 프로그램을 작성하시오.  랑이는 흑돌을, 메리는 백돌을 사용한다.  냥목 게임에서 랑이의 점수는 가로, 세로, 대각선 중 하나의 방향으로 연속하여 존재하는 가장 긴 흑돌의 길이가 된다.  잠시 집사가 돌아와서 메리가 반기러 간 사이 랑이는 메리의 돌 하나를 자신의 돌로 바꿔치기 하려고 한다. 즉, 랑이는 백돌 하나를 흑돌로 바꿀 수 있다.  랑이가 백돌 하나를 흑돌로 바꿀 때 얻을 수 있는 최대 점수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 자연수 $N$이 주어진다. ($2 \\le N \\le 1,000$)  둘째 줄부터 $N$개 줄에는 줄마다 $N$개의 숫자가 공백으로 구분되어 주어진다. 이는 랑이가 돌을 바꿔치기하기 전 바둑판의 상태를 나타낸다. 각 수는 0, 1, 2 중 하나로 주어지고, 0은 비어 있는 위치를, 1은 흑돌을, 2는 백돌을 의미한다.  흑돌과 백돌은 각각 하나 이상 존재한다.  출력  랑이가 얻을 수 있는 최대 점수를 출력한다.     문제 풀이     접근 방식       4차원 DP 배열 :  r, c: 현재 위치 direction: 탐색 방향 (0:가로, 1:세로, 2:대각선, 3:대각선/) changed: 백돌을 바꾼 여부 (0:안바꿈, 1:바꿈)     static int[][][][] dp; // [r][c][direction][changed]           탐색방향배열     static int[] dr = {0, 1, 1, 1}; // 가로, 세로, 대각선\\, 대각선/ static int[] dc = {1, 0, 1, -1};                 4가지 방향을 탐색: 가로: (0,1) 세로: (1,0) 대각선: (1,1) 대각선/: (1,-1)           DP 계산 로직      흑돌인 경우: 다음 위치의 DP값에 1을 더합니다 범위를 벗어나면 현재 위치만 계산 (1)   if(board[i][j] == 1) {  // 흑돌인 경우     for(int k = 0; k &lt; 4; k++) {         int nr = i + dr[k];         int nc = j + dc[k];         if(nr &gt;= 1 &amp;&amp; nr &lt;= N &amp;&amp; nc &gt;= 1 &amp;&amp; nc &lt;= N) {             dp[i][j][k][0] = dp[nr][nc][k][0] + 1;             dp[i][j][k][1] = dp[nr][nc][k][1] + 1;         } else {             dp[i][j][k][0] = 1;             dp[i][j][k][1] = 1;         }     } }      백돌인 경우:            한쪽에만 흑돌이 있는 경우: 해당 방향의 연속된 길이 + 1       양쪽에 흑돌이 있는 경우: 양쪽 방향의 연속된 길이 합 + 1 (현재 위치)              주요 포인트 아래에서 위로(N에서 1로) 탐색하며 DP를 계산! 백돌을 바꾸는 경우, 주변 흑돌과의 연결을 고려해야함. 경계 체크 해야함. 최댓값 갱신.   이 문제의 핵심은 백돌을 바꿨을 때 양쪽의 흑돌 연결을 어떻게 처리하느냐임. 모든 경우(한쪽만 있는 경우, 양쪽 다 있는 경우)를 고려하여 최적의 해를 찾았다.  나중에 다시 풀어보자! 까다로운 dp문제였다  else if(board[i][j] == 2) {  // 백돌인 경우     for(int k = 0; k &lt; 4; k++) {         int prevR = i - dr[k];         int prevC = j - dc[k];         int nextR = i + dr[k];         int nextC = j + dc[k];                  // 이전 방향에 흑돌이 있는 경우         if(prevR &gt;= 1 &amp;&amp; prevR &lt;= N &amp;&amp; prevC &gt;= 1 &amp;&amp; prevC &lt;= N) {             if(board[prevR][prevC] == 1) {                 dp[i][j][k][1] = Math.max(dp[i][j][k][1], dp[prevR][prevC][k][0] + 1);             }         }                  // 다음 방향에 흑돌이 있는 경우도 동일하게 처리                  // 양쪽 모두 흑돌이 있는 경우         if(prevR &gt;= 1 &amp;&amp; ... &amp;&amp; board[prevR][prevC] == 1 &amp;&amp; board[nextR][nextC] == 1) {             dp[i][j][k][1] = dp[prevR][prevC][k][0] + dp[nextR][nextC][k][0] + 1;         }     } }      코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, res=0; \tstatic int[] dr = {0, 1, 1, 1}; // 가로, 세로, 대각선\\, 대각선/ \tstatic int[] dc = {1, 0, 1, -1};  \tstatic int[][] board; \tstatic int[][][][] dp; // [r][c][direction][changed] \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\t \t\tboard = new int[N+2][N+2]; \t\t// (r, c) 위치에서 k방향으로 연속된 흑돌의 최대 길이         dp = new int[N+2][N+2][4][2]; // direction: 0-가로, 1-세로, 2-대각선\\, 3-대각선/, changed: 0-안바꿈, 1-바꿈 \t\tList&lt;int[]&gt; whiteList = new ArrayList&lt;&gt;();  \t\tfor(int i = 1; i &lt;= N; i++) {             st = new StringTokenizer(br.readLine());             for(int j = 1; j &lt;= N; j++) {                 board[i][j] = Integer.parseInt(st.nextToken()); \t\t\t\tif(board[i][j] == 2) whiteList.add(new int[] {i, j});             }         } \t\t \t\t// dp 계산         for(int i = N; i &gt;= 1; i--) {             for(int j = N; j &gt;= 1; j--) {                 if(board[i][j] == 1) {                     for(int k = 0; k &lt; 4; k++) {                     \tint nr = i + dr[k];                         int nc = j + dc[k];                         if(nr &gt;= 1 &amp;&amp; nr &lt;= N &amp;&amp; nc &gt;= 1 &amp;&amp; nc &lt;= N) {                             dp[i][j][k][0] = dp[nr][nc][k][0] + 1;                             dp[i][j][k][1] = dp[nr][nc][k][1] + 1;                         } else {                             dp[i][j][k][0] = 1;                             dp[i][j][k][1] = 1;                         }                     }                 }                 else if(board[i][j] == 2) {                     for(int k = 0; k &lt; 4; k++) {                     \tint prevR = i - dr[k];                         int prevC = j - dc[k];                         int nextR = i + dr[k];                         int nextC = j + dc[k];                         if(prevR &gt;= 1 &amp;&amp; prevR &lt;= N &amp;&amp; prevC &gt;= 1 &amp;&amp; prevC &lt;= N) {                             if(board[prevR][prevC] == 1) {                                 // 이전 방향에 흑돌이 있는 경우                                 dp[i][j][k][1] = Math.max(dp[i][j][k][1], dp[prevR][prevC][k][0] + 1);                             }                         }                                                  if(nextR &gt;= 1 &amp;&amp; nextR &lt;= N &amp;&amp; nextC &gt;= 1 &amp;&amp; nextC &lt;= N) {                             if(board[nextR][nextC] == 1) {                                 // 다음 방향에 흑돌이 있는 경우                                 dp[i][j][k][1] = Math.max(dp[i][j][k][1], dp[nextR][nextC][k][0] + 1);                             }                         }                                                  // 양쪽 모두 흑돌이 있는 경우                         if(prevR &gt;= 1 &amp;&amp; prevR &lt;= N &amp;&amp; prevC &gt;= 1 &amp;&amp; prevC &lt;= N &amp;&amp;                            nextR &gt;= 1 &amp;&amp; nextR &lt;= N &amp;&amp; nextC &gt;= 1 &amp;&amp; nextC &lt;= N &amp;&amp;                            board[prevR][prevC] == 1 &amp;&amp; board[nextR][nextC] == 1) {                             dp[i][j][k][1] = dp[prevR][prevC][k][0] + dp[nextR][nextC][k][0] + 1;                         }                     }                 }             }         }                           // 최대값 찾기         int res = 0;         for(int i = 1; i &lt;= N; i++) {             for(int j = 1; j &lt;= N; j++) {                 for(int k = 0; k &lt; 4; k++) {                     res = Math.max(res, Math.max(dp[i][j][k][0], dp[i][j][k][1]));                 }             }         }                  System.out.println(res); \t\t \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_25629_홀짝 수열 (C++)",
    "url": "/posts/BOJ25629%ED%99%80%EC%A7%9D-%EC%88%98%EC%97%B4-C/",
    "categories": "알고리즘",
    "tags": "C++, 백준, 알고리즘",
    "date": "2024-12-16 00:00:11 +0900",
    "content": "[Bronze III] 홀짝 수열 - 25629  문제 링크  성능 요약  메모리: 2020 KB, 시간: 0 ms  분류  애드 혹, 수학  제출 일자  2024년 12월 15일 23:54:58  문제 설명 길이가 $N$인 수열의 $i(1 \\le i \\le N)$번째 원소를 정수 $a_i(1\\le a_i \\le 100)$라고 하자. 동훈이는 이 수열을 잘 정렬해서 홀짝 수열로 만들고 싶다. 어떤 수열이 홀짝 수열이 되려면 다음 조건을 만족해야 한다.     수열의 홀수번째 원소는 모두 홀수여야 하고, 순서대로 나열했을 때 감소하지 않아야 한다. \\(a_1 \\le a_3 \\le a_5 \\le a_7 \\le ...\\)    수열의 짝수번째 원소는 모두 짝수여야 하고, 순서대로 나열했을 때 감소하지 않아야 한다. \\(a_2 \\le a_4 \\le a_6 \\le a_8 \\le ...\\)    다음과 같은 수열은 홀짝 수열이다. $[1, 2, 1], [3], [5, 4]$ 그러나 다음과 같은 수열은 홀짝 수열이 아니다. $[3, 2, 1], [2, 2], [5, 4, 7, 2]$     $[3, 2, 1]$의 홀수번째 원소들을 순서대로 나열하면 $[3, 1]$인데, 감소하기 때문에 홀짝 수열이 아니다.  $[2, 2]$는 첫 번째 원소가 홀수가 아니므로 홀짝 수열이 아니다.   $[5,4,7,2]$의 짝수번째 원소들을 순서대로 나열하면 $[4, 2]$인데, 감소하기 때문에 홀짝 수열이 아니다.  길이 $N$의 수열 $a_1,a_2,…a_N$이 주어졌을 때, 이 수열을 잘 정렬한다면 홀짝 수열로 만드는 것이 가능할까?  입력 첫째 줄에 수열의 길이 $N(1\\le N \\le 100)$이 주어진다.  둘째 줄에 $a_1, a_2, …, a_N$이 주어진다. 수열의 $i$번째 원소는 정수 $a_i(1\\le a_i \\le 100)$이다.  출력 주어진 수열을 잘 정렬해서 홀짝 수열로 만들 수 있다면 1을, 어떻게 정렬하더라도 홀짝 수열로 만들 수 없다면 0을 출력한다.     문제 풀이   그냥 수열 개수로 정할 수 있다. 시작이 1이므로 홀수가 같거나 1커야하고 이를 전체 길이 홀짝 나눠서 생각해보자. 길이가 짝수면 홀짝 딱 맞게 진행되므로 odd-even이 0이고, 길이가 홀수면 홀수가 1개 많으므로 odd-even==1이다!     코드   /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, odd = 0, even = 0;     cin &gt;&gt; N;     for (int i = 0; i &lt; N; i++) {         int num;         cin &gt;&gt; num;         if (num % 2 == 0)             even++;         else             odd++;     }     int res = 0;     if (N % 2 == 0) {         res = odd == even ? 1 : 0;     } else {         res = odd - even == 1 ? 1 : 0;     }     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "PGMS_보물 지도 (Java)",
    "url": "/posts/PGMS%EB%B3%B4%EB%AC%BC-%EC%A7%80%EB%8F%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2024-12-15 20:35:16 +0900",
    "content": "[PCCP 모의고사 #2] 4번 - 보물 지도  문제 링크  성능 요약  메모리: undefined, 시간:  구분  프로그래밍 강의 &gt; PCCP 모의고사 2회 &gt; [PCCP 모의고사 2] 4번  채점결과  채점 결과 정확성: 100.0 합계: 100.0 / 100.0  제출 일자  2024년 12월 15일 11:22:45  문제 설명          진수는 보물이 묻힌 장소와 함정이 표시된 보물 지도를 이용해 보물을 찾으려 합니다. 보물지도는 가로 길이가 n, 세로 길이가 m인 직사각형 모양입니다.  맨 왼쪽 아래 칸의 좌표를 (1, 1)으로, 맨 오른쪽 위 칸의 좌표를 (n, m)으로 나타냈을 때, 보물은 (n, m) 좌표에 묻혀있습니다. 또한, 일부 칸에는 함정이 있으며, 해당 칸으로는 지나갈 수 없습니다.  진수는 처음에 (1, 1) 좌표에서 출발해 보물이 있는 칸으로 이동하려 합니다. 이동할 때는 [상,하,좌,우]로 인접한 네 칸 중 한 칸으로 걸어서 이동합니다. 한 칸을 걸어서 이동하는 데 걸리는 시간은 1입니다.  진수는 보물이 위치한 칸으로 수월하게 이동하기 위해 신비로운 신발을 하나 준비했습니다. 이 신발을 신고 뛰면 한 번에 두 칸을 이동할 수 있으며, 함정이 있는 칸도 넘을 수 있습니다. 하지만, 이 신발은 한 번밖에 사용할 수 없습니다. 신비로운 신발을 사용하여 뛰어서 두 칸을 이동하는 시간도 1입니다.  이때 진수가 출발점에서 보물이 위치한 칸으로 이동하는데 필요한 최소 시간을 구해야 합니다.  예를 들어, 진수의 보물지도가 아래 그림과 같을 때, 진수가 걸어서 오른쪽으로 3칸, 걸어서 위쪽으로 3칸 이동하면 6의 시간에 보물이 위치한 칸으로 이동할 수 있습니다. 만약, 오른쪽으로 걸어서 1칸, 위쪽으로 걸어서 1칸, 신비로운 신발을 사용하여 위로 뛰어 2칸, 오른쪽으로 걸어서 2칸 이동한다면 총 5의 시간에 보물이 위치한 칸으로 이동할 수 있으며, 이보다 빠른 시간 내에 보물이 있는 위치에 도착할 수 없습니다.    진수의 보물지도가 표현하는 지역의 가로 길이를 나타내는 정수 n, 세로 길이를 나타내는 정수 m, 함정의 위치를 나타내는 2차원 정수 배열 hole이 주어졌을 때, 진수가 보물이 있는 칸으로 이동하는데 필요한 최소 시간을 return 하는 solution 함수를 완성해주세요. 단, 보물이 있는 칸으로 이동할 수 없다면, -1을 return 해야 합니다.    제한사항   1 ≤ n, m ≤ 1,000   단, n * m이 3 이상인 경우만 입력으로 주어집니다.  1 ≤ hole의 길이 ≤ n * m - 2   hole[i]는 [a, b]의 형태이며, (a, b) 칸에 함정이 존재한다는 의미이며, 1 ≤ a ≤ n, 1 ≤ b ≤ m을 만족합니다. 같은 함정에 대한 정보가 중복해서 들어있지 않습니다.  (1, 1) 칸과 (n, m) 칸은 항상 함정이 없습니다.     입출력 예           n m hole result            4 4 [[2, 3], [3, 3]] 5   5 4 [[1, 4], [2, 1], [2, 2], [2, 3], [2, 4], [3, 3], [4, 1], [4, 3], [5, 3]] -1            입출력 예 설명  입출력 예 #1   본문의 예시와 같습니다.   입출력 예 #2   보물지도를 그림으로 나타내면 아래와 같으며, 보물이 위치한 칸으로 이동할 수 없습니다. 따라서, -1을 return 해야 합니다.                문제 풀이   벽 부수고 이동하기 처럼 3차원 visited로 간단하게 풀었다. bfs는 코딩테스트 단골문제기 때문에 빠른시간안에 정확히 풀어내는게 중요한데 나만의 템플릿이 갖춰졌기 때문에 응용만 제대로 한다면 쉽게 풀 수 있을 것 같다. 속도를 내는게 중요할 것 같다.     코드   /*  1-based index 문제이므로 좌표 실수를 주의해야함 */  import java.util.*;  class Solution {     class Pos{         int r, c;         int time;         int jumped;         Pos(int r, int c, int time, int jumped){             this.r = r;             this.c = c;             this.time = time;             this.jumped = jumped;         }     }     static int[] dr = {0, -1, 0, 1};     static int[] dc = {-1, 0, 1, 0};     static boolean[][] isHole;     static boolean[][][] visited;     public int solution(int n, int m, int[][] hole) {         visited = new boolean[n+1][m+1][2]; // 1-based index, 아니면 위치는 1, 1, 이고 visited는 0,0해줘서귀찮음         isHole = new boolean[n+1][m+1]; // 1-based index -&gt; 작성하다가 매번 hole길이만큼 순회하는게 별로라서 만듬         for(int[] h : hole){             isHole[h[0]][h[1]] = true;         }         int res = 0;         res = bfs(n, m);                          return res;     }     private int bfs(int n, int m){         Queue&lt;Pos&gt; queue = new LinkedList&lt;&gt;();         queue.offer(new Pos(1, 1, 0, 0));         visited[1][1][0] = true;                  while(!queue.isEmpty()){             Pos curr = queue.poll();              if(curr.r == n &amp;&amp; curr.c == m) return curr.time;                          for(int k=0; k&lt;4; k++){                 int nextr = curr.r + dr[k];                 int nextc = curr.c + dc[k];                 int jumped = curr.jumped==1 ? 1 : 0;                 if(nextr &gt;= 1 &amp;&amp; nextr &lt;= n &amp;&amp; nextc &gt;= 1 &amp;&amp; nextc &lt;= m &amp;&amp; !visited[nextr][nextc][jumped]){                     if(!isHole[nextr][nextc]){                         queue.offer(new Pos(nextr, nextc, curr.time + 1, curr.jumped));                         visited[nextr][nextc][curr.jumped] = true;                     }                 }             }                          // 사방탐색 뿐만아니라 추가 행동은 점프까지 고려하는것.             if(curr.jumped == 0){                 for(int k =0; k&lt;4; k++){                     int nextr = curr.r + dr[k] * 2;                     int nextc = curr.c + dc[k] * 2;                                          if(nextr &gt;= 1 &amp;&amp; nextr &lt;= n &amp;&amp; nextc &gt;= 1 &amp;&amp; nextc &lt;= m &amp;&amp; !visited[nextr][nextc][1]){                         if(!isHole[nextr][nextc]){                             queue.offer(new Pos(nextr, nextc, curr.time + 1, 1));                             visited[nextr][nextc][1] = true;                         }                     }                    }             }         }                  return -1;     } }   "
  },
  
  {
    "title": "PGMS_대장균들의 자식의 수 구하기 (SQL)",
    "url": "/posts/PGMS%EB%8C%80%EC%9E%A5%EA%B7%A0%EB%93%A4%EC%9D%98-%EC%9E%90%EC%8B%9D%EC%9D%98-%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-12-15 20:29:37 +0900",
    "content": "[level 3] 대장균들의 자식의 수 구하기 - 299305  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SELECT  채점결과  합계: 100.0 / 100.0  제출 일자  2024년 12월 15일 11:22:45  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  대장균 개체의 ID(ID)와 자식의 수(CHILD_COUNT)를 출력하는 SQL 문을 작성해주세요. 자식이 없다면 자식의 수는 0으로 출력해주세요. 이때 결과는 개체의 ID 에 대해 오름차순 정렬해주세요.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 10 2019/01/01 5   2 NULL 2 2019/01/01 3   3 1 100 2020/01/01 4   4 2 17 2020/01/01 4   5 2 10 2020/01/01 6   6 4 101 2021/01/01 22          ID 1인 개체의 자식은 ID 3으로 1개 ID 2인 개체의 자식은 ID 4,5 로 2개 ID 4인 개체의 자식은 ID 6으로 1개이며 나머지 개체들은 자식이 없으므로 ID 에 대해 오름차순 정렬하면 결과는 다음과 같아야 합니다.            ID CHILD_COUNT            1 1   2 2   3 0   4 1   5 0   6 0              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   섭쿼리를 사용해 문제를 풀었다! 조인도 사용할 수 있을 것 같지만 이게 더 간단한 방법같다. 섭쿼리에 조건을 준 뒤 그 개수를 셋다     코드   SELECT ID, (SELECT COUNT(*)                 FROM ECOLI_DATA AS d1                     WHERE d1.PARENT_ID = d2.ID) AS CHILD_COUNT     FROM ECOLI_DATA AS d2         ORDER BY d2.ID;  "
  },
  
  {
    "title": "BOJ_1094_막대기 (Java, C++)",
    "url": "/posts/BOJ1094%EB%A7%89%EB%8C%80%EA%B8%B0-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-14 19:40:40 +0900",
    "content": "[Silver V] 막대기 - 1094  문제 링크  성능 요약  메모리: 15880 KB, 시간: 124 ms  분류  비트마스킹, 수학  제출 일자  2024년 12월 14일 19:32:48  문제 설명  지민이는 길이가 64cm인 막대를 가지고 있다. 어느 날, 그는 길이가 Xcm인 막대가 가지고 싶어졌다. 지민이는 원래 가지고 있던 막대를 더 작은 막대로 자른다음에, 풀로 붙여서 길이가 Xcm인 막대를 만들려고 한다.  막대를 자르는 가장 쉬운 방법은 절반으로 자르는 것이다. 지민이는 아래와 같은 과정을 거쳐서 막대를 자르려고 한다.   \t지민이가 가지고 있는 막대의 길이를 모두 더한다. 처음에는 64cm 막대 하나만 가지고 있다. 이때, 합이 X보다 크다면, 아래와 같은 과정을 반복한다. \t \t\t가지고 있는 막대 중 길이가 가장 짧은 것을 절반으로 자른다. \t\t만약, 위에서 자른 막대의 절반 중 하나를 버리고 남아있는 막대의 길이의 합이 X보다 크거나 같다면, 위에서 자른 막대의 절반 중 하나를 버린다. \t \t \t이제, 남아있는 모든 막대를 풀로 붙여서 Xcm를 만든다.   X가 주어졌을 때, 위의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지 구하는 프로그램을 작성하시오.   입력  첫째 줄에 X가 주어진다. X는 64보다 작거나 같은 자연수이다.  출력  문제의 과정을 거친다면, 몇 개의 막대를 풀로 붙여서 Xcm를 만들 수 있는지 출력한다.     문제 풀이   숫자를 2진수로 표현 후 1의 개수를 세면된다.     코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1094_막대기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int X = Integer.parseInt(br.readLine());          int res = Integer.bitCount(X);         // int count = 0;         // while (X &gt; 0) {         //     if ((X &amp; 1) == 1) count++;         //     X &gt;&gt;= 1;         // }          bw.write(res + \"\\n\");         bw.flush();         bw.close();         br.close();     } }    /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int x;     cin &gt;&gt; x;      int res = 0;     while (x &gt; 0) {         res += x &amp; 1;         x &gt;&gt;= 1;     }     cout &lt;&lt; res &lt;&lt; \"\\n\";     // cout &lt;&lt; __builtin_popcount(x) &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_5550_헌책방 (Java, C++)",
    "url": "/posts/BOJ5550%ED%97%8C%EC%B1%85%EB%B0%A9-Java-C/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-13 23:55:03 +0900",
    "content": "[Gold II] 헌책방 - 5550  문제 링크  성능 요약  메모리: 23536 KB, 시간: 300 ms  분류  다이나믹 프로그래밍, 누적 합, 정렬  제출 일자  2024년 12월 13일 23:43:43  문제 설명   \t상근이가 살고있는 도시에는 헌책방이 있다. 데이트 비용을 점점 감당할 수 없게된 상근이는 집에 있는 책을 헌책방에 팔려고 한다. 각 책에는 기준 가격이 정해져있고, 헌책방은 이 가격으로 매입한다.   \t헌책방은 책을 소설, 만화, 잡지등 10개의 장르로 분류한다. 장르는 1부터 10까지 번호가 매겨져 있다. 이 가게는 같은 장르의 책을 한 번에 매입할 때, 고가로 매입해 준다.   \t같은 장르의 책을 T권 매입할 때, 책 한 권 당 매입 가격이 기준 가격보다 T-1원 높아진다. 예를 들어, 같은 장르에서 기준 가격이 100원, 120원, 150원인 책을 한 번에 헌책방에 판다면, 매입 가격은 102원, 122원, 152원이 된다.   \t상근이는 내일 데이트를 가기 위해서 가지고 있는 책 N권 중 K권을 팔려고 한다.   \t책 N권의 기준 가격과 장르 번호가 주어졌을 때, 총 매입 가격의 최댓값을 구하는 프로그램을 작성하시오.  입력   \t첫째 줄에 상근이가 가지고 있는 책의 개수 N과 파려고 하는 책의 수 K가 주어진다. (2 ≤ N ≤ 2000, 1 ≤ K &lt; N)   \t둘째 줄부터 N개 줄에는 상근이가 가지고 있는 책의 기준 가격 Ci와 장르 Gi가 공백으로 구분되어 주어진다. (1 ≤ Ci ≤ 105, 1 ≤ Gi ≤ 10)  출력   \t첫째 줄에 총 매입 가격의 최댓값을 출력한다.     문제 풀이     상당히 어려웠다… 아이디어가 매우 중요한데    선택하는 책 카테고리를 늘려가기   선택하는 책 수를 늘려가기   최대값을 dp에 저장 ( dp[i][j]는 i종류 j개일 때 최대가격을 의미)      코드   Java 코드  /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, K, bookCnt, categorySize;     static long dp[][];     static ArrayList&lt;Integer&gt;[] books;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_5550_헌책방/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());          dp = new long[11][K + 1];          books = new ArrayList[11];         for (int i = 0; i &lt; 11; i++) {             books[i] = new ArrayList&lt;&gt;();         }          int price, category;         for (int i = 0; i &lt; N; i++) {             st = new StringTokenizer(br.readLine());             price = Integer.parseInt(st.nextToken());             category = Integer.parseInt(st.nextToken());             books[category].add(price);         }          for (int i = 1; i &lt;= 10; i++) {             Collections.sort(books[i], Collections.reverseOrder());              ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(books[i]);              for (int j = 1; j &lt; books[i].size(); j++) {                 books[i].set(j, books[i].get(j) + books[i].get(j - 1));             }              for (int j = 1; j &lt; books[i].size(); j++) {                 books[i].set(j, books[i].get(j) + j * (j + 1));             }         }                  int res = 0;         bookCnt = 0;         for (int i = 1; i &lt;= 10; i++) {             categorySize = books[i].size();             /* 헷갈린부분              * 똑같은 개수로 진행되어야하므로 이전에 골랐든 안골랐든 cnt만큼 추가              * 예를 들면 앞 종류에서 2개 뒷종류에서 3개랑 같은 선상에서 뒷종류만 5개를 고른경우가 비교되어야하므로 min(K, size)하면안됨! 놓치는 경우생김              */             int leftAmount = Math.min(K, bookCnt + categorySize);             for (int j = 0; j &lt;= leftAmount; j++) {                 dp[i][j] = dp[i - 1][j];                 for (int k = 1; k &lt;= categorySize; k++) {                     if (j &gt;= k) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - k] + books[i].get(k - 1));                 }             }             bookCnt = Math.min(bookCnt + categorySize, K);         }          bw.write(String.valueOf(dp[10][K]));         bw.flush();         bw.close();         br.close();     } }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, K;     cin &gt;&gt; N &gt;&gt; K;     vector&lt;vector&lt;int&gt;&gt; books(11);     vector&lt;vector&lt;long long&gt;&gt; dp(11, vector&lt;long long&gt;(K + 1));      for (int i = 0; i &lt; N; i++) {         int price, category;         cin &gt;&gt; price &gt;&gt; category;         books[category].push_back(price);     }      for (int i = 1; i &lt;= 10; i++) {         sort(books[i].rbegin(), books[i].rend());         // sort(books[i].begin(), books[i].end(), greater&lt;int&gt;());         // sort(books[i].begin(), books[i].end(),         //      [](int a, int b) { return a &gt; b; });          vector&lt;int&gt; tmp = books[i];         for (int j = 1; j &lt; books[i].size(); j++) {             books[i][j] = books[i][j] + books[i][j - 1];         }         for (int j = 1; j &lt; books[i].size(); j++) {             books[i][j] = books[i][j] + j * (j + 1);         }     }      int bookCnt = 0;     for (int i = 1; i &lt;= 10; i++) {         int categorySize = books[i].size();         int leftAmount =             min(K, bookCnt + categorySize);  // 고를 수 있는 최대 수          for (int j = 0; j &lt;= leftAmount; j++) {             dp[i][j] = dp[i - 1][j];             for (int k = 1; k &lt;= categorySize; k++) {                 if (j &gt;= k) {                     dp[i][j] =                         max(dp[i][j], dp[i - 1][j - k] + books[i][k - 1]);                 }             }         }         bookCnt = min(bookCnt + categorySize, K);     }     cout &lt;&lt; dp[10][K] &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "백준허브(BaekjoonHub)와 LeetHub 커스텀하여 사용하기",
    "url": "/posts/%EB%B0%B1%EC%A4%80%ED%97%88%EB%B8%8CBaekjoonHub%EC%99%80-LeetHub-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/",
    "categories": "사이드_프로젝트",
    "tags": "leetcode, 백준",
    "date": "2024-12-13 16:52:42 +0900",
    "content": "   PS을 위해 여러 사이트에서 알고리즘 문제들을 푼 사람이라면 코드들을 정리해본 적이 있을것이다. 이에 백준 허브 or LeetHub를 사용하는 사람이 많다. 하지만 두 확장프로그램에는 차이점이 있어 좀 더 깔끔한 백준허브 스타일에 LeetHub를 커스텀해보고자 한다.   이미 존재하는, 사용중인 레포지토리로 진행한다.  현재 백준허브만 사용하는 상태라 백준허브 템플릿으로 만들어진 것을 볼 수 있다. 여기 LeetHub도 적용해보자.  1. LeetHub. v2 Chrome 확장프로그램 설치   구글링을 해 본 결과 v2가 가장 정상작동한다고 하여 설치했다.  2. LeetHub-2.0 Repository Fork하기   3. Local 로 클론받기  git clone https://github.com/{사용자명}/LeetHub-2.0.git   이제 커스텀 할 준비를 마쳤다. 로컬에서 파일을 커스텀 할 것이다. 빠르게 진행하고 싶다면 이 레포지토리를 클론해 사용해보자!! 4. 로컬에서 커스텀 할 파일 - leetcode.js   5. const URL 의 contents/ 뒤에 LeetCode/를 추가         변경점 1           ▼              변경점 2           ▼              변경점 3           ▼       return `[${difficulty}] Title: ${qid}.${title}, Time: ${time} (${timePercentile}%), Space: ${space} (${spacePercentile}%) - LeetHub`;           변경점 4 - version.js           ▼        ▼   6. (선택사항) 문제 요약 리드미 삭제 - leetcode.js  이 부분 주석처리하면 문제 풀이 코드만 올라간다!  7. chrome://extensions/으로 가서 개발자모드 ON 하기   8. 압축해제된 확장 프로그램을 로드하고 clone 받은 repository 선택   9. 적용되었는지 확인!     빠르게 사용해보고싶다면? 이 레포지토리 에서 클론한 뒤 확장프로그램에서 적용해 사용가능하다! "
  },
  
  {
    "title": "iCloud 동기화 해제 및 iCloud에서 폴더로 다운받기 오류 (Mac) (데스크탑, 문서 옮기기)",
    "url": "/posts/iCloud-%EC%97%90%EC%84%9C-%ED%8F%B4%EB%8D%94%EB%A1%9C-%EB%8B%A4%EC%9A%B4%EB%B0%9B%EA%B8%B0-%EC%98%A4%EB%A5%98-Mac/",
    "categories": "오류, 해결",
    "tags": "iCloud, mac",
    "date": "2024-12-13 15:40:09 +0900",
    "content": "   맥북 사용 중 iCloud 용량때문에 동기화를 해제할 일이 생겼고, 이에 로컬에 있는 데스크톱 파일들과 로컬 파일들이 전부 사라지는 현상을 겪었다. 이를 많은 구글링을 해보아도 마땅한 해결책이 없어 나름 대안을 혼자 하루종일 시간을 갈아넣으며 찾았다.   문제 상황    iCloud와 맥북 동기화를 해제   동기화 해제 시 Desktop과 Document 폴더가 다 날아감. 그냥 싹 지워짐   iCloud 웹으로 확인해보니 클라우드 저장소에는 다 남아있음   시도 1 - 웹에서 다운받기 ( 실패 )    iCloud에 남아있는 파일들을 로컬로 다운받기. -&gt; 가능은 하다. 문제는 폴더 다운로드가 안된다는 것. 진짜 치명적인 단점이다. 개발자들의 경우 프로젝트 파일에만 수십개의 폴더가 있고 파일은 수백개이며 assets등을 포함하면 용량도 작지 않다. 이런 작업물들을 어떻게 파일 단위로 하나하나 다운받고 다시 정리하겠는가?   시도 2 - 복사 붙여넣기 ( 실패 )    mac에서 Finder을 통해 열어보면 폴더로 iCloud가 따로 있는데 이게 보기완 달리 그냥 웹 스토리지를 폴더 형태로 보여주는것이다.  로컬에 있는 파일이 아니다! 그래서 복사 붙여넣기 하면 무한 로딩이 걸린다. 아마 시간 측정중 혹은 복사 준비중이라 뜨며 몇시간을 걸려도 실패할것이다.(경험담)   시도 3 - 압축 ( 실패 )    복사 붙여넣기가 안되길래 압축도 해보고 복제도 해봤다. 압축도 무한 프로그레스바가 보이고 닫히지도 않아서 활성상태보기로 강제 종료해서 껐다… 복제는 그냥 웹 스토리지에서 복제본이 생기는 것이기 때문에 해결방안이 아니다.   시도 4 - 가상본 만들기 ( 성공 )    그냥 이것저것 해보다가 가상본을 만들어봤고 이를 로컬로 자유롭게 가공할 수 있다는 것을 찾았다. 이에 가상본을 전부 만든 후 압축하고, 이를 자유롭게 로컬에 옮긴 뒤 동기화를 해제했다. 내용도 전부 잘 남아있고 잘 옮겨졌다!    후기 이런 고민이나 오류를 만난 사람들이 글로벌하게 많다는것을 하루종일 시간을 녹이며 알아보았고, iOS가 진짜 폐쇄적인 OS구나를 한번 더 체감했다.   글로벌한 많은 고민의 흔적들이 구글에 있으니 읽어봐도 재미있다! "
  },
  
  {
    "title": "BOJ_5052_전화번호 목록 (Java)",
    "url": "/posts/BOJ5052%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-11 05:04:43 +0900",
    "content": "[Gold IV] 전화번호 목록 - 5052  문제 링크  성능 요약  메모리: 107912 KB, 시간: 328 ms  분류  자료 구조, 정렬, 문자열, 트리, 트라이  제출 일자  2024년 12월 11일 04:53:18  문제 설명  전화번호 목록이 주어진다. 이때, 이 목록이 일관성이 있는지 없는지를 구하는 프로그램을 작성하시오.  전화번호 목록이 일관성을 유지하려면, 한 번호가 다른 번호의 접두어인 경우가 없어야 한다.  예를 들어, 전화번호 목록이 아래와 같은 경우를 생각해보자   \t긴급전화: 911 \t상근: 97 625 999 \t선영: 91 12 54 26   이 경우에 선영이에게 전화를 걸 수 있는 방법이 없다. 전화기를 들고 선영이 번호의 처음 세 자리를 누르는 순간 바로 긴급전화가 걸리기 때문이다. 따라서, 이 목록은 일관성이 없는 목록이다.   입력  첫째 줄에 테스트 케이스의 개수 t가 주어진다. (1 ≤ t ≤ 50) 각 테스트 케이스의 첫째 줄에는 전화번호의 수 n이 주어진다. (1 ≤ n ≤ 10000) 다음 n개의 줄에는 목록에 포함되어 있는 전화번호가 하나씩 주어진다. 전화번호의 길이는 길어야 10자리이며, 목록에 있는 두 전화번호가 같은 경우는 없다.  출력  각 테스트 케이스에 대해서, 일관성 있는 목록인 경우에는 YES, 아닌 경우에는 NO를 출력한다.     문제 풀이   두가지 방법으로 풀었다. 첫번째는 startsWith매서드, 두번째는 트라이다.     코드      startsWith() 사용 코드   /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.Arrays; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_5052_전화번호목록/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          int T = Integer.parseInt(br.readLine());         while (T-- &gt; 0) {             int n = Integer.parseInt(br.readLine());             String[] s = new String[n];             for (int i = 0; i &lt; n; i++) {                 String num = br.readLine();                 s[i] = num;             }              Arrays.sort(s);              boolean flag = true;             for (int i = 0; i &lt; s.length - 1; i++) {                 if (s[i + 1].startsWith(s[i])) {                     flag = false;                     sb.append(\"NO\").append(\"\\n\");                     break;                 }             }             if (flag) {                 sb.append(\"YES\").append(\"\\n\");             }         }         bw.write(sb.toString());         bw.flush();         bw.close();         br.close();     }      }      Trie 구현 코드   /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tclass Trie{ \t\tTrie[] children = new Trie[10]; \t\tboolean isEnd; \t\tTrie(){ \t\t\tfor(int i=0; i&lt;10; i++) { \t\t\t\tchildren[i] = null; \t\t\t} \t\t\tisEnd = false; \t\t} \t} \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic Trie root; \tstatic boolean flag; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint T = Integer.parseInt(br.readLine()); \t\twhile(T--&gt;0) { \t\t\troot = new Trie(); \t\t\tint n = Integer.parseInt(br.readLine()); \t\t\t \t\t\tflag = true; \t\t\tfor(int i=0; i&lt;n; i++) { \t\t\t\tString num = br.readLine(); \t\t\t\tinsertNum(num); \t\t\t} \t\t\t \t\t\tsb.append(flag ? \"YES\" : \"NO\").append(\"\\n\"); \t\t}  \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \tprivate void insertNum(String num) { \t\tTrie trie = root; \t\t \t\tfor(int i=0; i&lt;num.length(); i++) { \t\t\tint number = num.charAt(i) - '0'; \t\t\t \t\t\tif(trie.isEnd) { \t\t\t\tflag = false; \t\t\t\treturn; \t\t\t} \t\t\t \t\t\tif(trie.children[number]==null) { \t\t\t\ttrie.children[number] = new Trie(); \t\t\t} \t\t\t \t\t\ttrie = trie.children[number]; \t\t} \t\t \t\tif(trie.isEnd) { \t\t\tflag = false; \t\t\treturn; \t\t} \t\t \t\tfor(int i=0; i&lt;10; i++) { \t\t\tif(trie.children[i] != null) { \t\t\t\tflag = false; \t\t\t\treturn; \t\t\t} \t\t} \t\ttrie.isEnd = true; \t} }  "
  },
  
  {
    "title": "BOJ_14369_전화번호 수수께끼(Small) (Java)",
    "url": "/posts/BOJ14369%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EC%88%98%EC%88%98%EA%BB%98%EB%81%BCSmall-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-12-09 22:47:09 +0900",
    "content": "[Gold V] 전화번호 수수께끼 (Small) - 14369  문제 링크  성능 요약  메모리: 14948 KB, 시간: 124 ms  분류  애드 혹, 브루트포스 알고리즘, 문자열  제출 일자  2024년 12월 9일 22:43:52  문제 설명  \"전화번호가 뭐에요?\"  \"제 전화번호의 각 자리를 영어단어로 바꾸고, 철자를 잘 섞으면 OZONE TOWER가 나와요.\"  \"예?\"  \"그리고 제 전화번호는 오름차순으로 정렬되어 있어요.\"  \"...\"  입력  첫 줄에 테스트케이스의 개수 T가 주어진다. 각 테스트케이스에는 상대방이 제시한 스트링 S가 주어진다. S는 영어 대문자로만 이루어져 있다.  1≤ T ≤ 100이고, S의 길이는 3 이상 20 이하이다. 모든 테스트케이스에는 유일한 해답이 있다.  출력  각 줄에 테스트케이스 번호 x와 전화번호 y를 Case #x: y의 형태로 출력한다.     문제 풀이   각 숫자를 어떤 순서로 처리해야 편한지 고민했다!  자세한 풀이는 코드 속 주석 참조     코드    /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tclass Number { \t\tString s; \t\tchar c; \t\tint n;  \t\tpublic Number(String s, char c, int n) { \t\t\tthis.s = s; \t\t\tthis.c = c; \t\t\tthis.n = n; \t\t} \t}  \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tNumber[] number = { new Number(\"ZERO\", \t'Z', 0), \t\t\t\t\t\tnew Number(\"SIX\", \t'X', 6),  \t\t\t\t\t\tnew Number(\"EIGHT\", 'G', 8),  \t\t\t\t\t\tnew Number(\"TWO\", \t'W', 2), \t\t\t\t\t\tnew Number(\"THREE\", 'T', 3),  \t\t\t\t\t\tnew Number(\"SEVEN\", 'S', 7),  \t\t\t\t\t\tnew Number(\"FIVE\", \t'V', 5),  \t\t\t\t\t\tnew Number(\"FOUR\", \t'F', 4), \t\t\t\t\t\tnew Number(\"NINE\", \t'I', 9),  \t\t\t\t\t\tnew Number(\"ONE\", \t'N', 1) };  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint T = Integer.parseInt(br.readLine());  \t\tfor (int tc = 1; tc &lt;=T; tc++) { \t\t\t/* \t\t\t * 1. 0 : Z 개수로 찾기 - 25 \t\t\t * 2, 6 : X 개수로 찾기 - 23 \t\t\t * 3. 8 : G 개수로 찾기 - 6 \t\t\t * 4. 2 : W개수로 찾기 - 22 \t\t\t * 5. 3 : TWO, EIGHT 찾은 후 T로 찾기 - 19 \t\t\t * 6. 7 : SIX 찾은 후 S로 찾기 - 18 \t\t\t * 7. 5 : SEVEN 다 찾은 후 V로 찾기 - 21 \t\t\t * 8. 4 : FIVE 다 찾은 후 F로 찾기 - 5 \t\t\t * 9. 9 : I 개수로 찾기 - 8 \t\t\t * 10 0 : 나머지 N개수로 찾기 - 13 \t\t\t */  \t\t\tint[] arr = new int[26]; // A~Z; \t\t\tString str = br.readLine(); \t\t\tfor (int i = 0; i &lt; str.length(); i++) { \t\t\t\tarr[str.charAt(i) - 'A']++; \t\t\t}  \t\t\tint[] numCnt = new int[10]; \t\t\tfor (int i = 0; i &lt; 10; i++) { \t\t\t\tint tmpCnt = 0; \t\t\t\tif (arr[number[i].c-'A'] &gt; 0) { \t\t\t\t\ttmpCnt = arr[number[i].c-'A']; \t\t\t\t\tnumCnt[number[i].n] += tmpCnt; \t\t\t\t\tfor (int j = 0; j &lt; number[i].s.length(); j++) { \t\t\t\t\t\tarr[number[i].s.charAt(j)-'A'] -= tmpCnt; \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t\tStringBuilder sb = new StringBuilder(); \t\t\tfor(int i=0; i&lt;10; i++) { \t\t\t\tfor(int j=0; j&lt;numCnt[i]; j++) { \t\t\t\t\tsb.append(i);\t\t\t\t\t \t\t\t\t} \t\t\t} \t\t\tbw.write(\"Case #\" + tc + \": \" + sb.toString() + \"\\n\"); \t\t}   \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_11444_피보나치 수 6 (C++)",
    "url": "/posts/BOJ11444%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98-6-C/",
    "categories": "알고리즘",
    "tags": "C++, 백준, 알고리즘",
    "date": "2024-12-08 01:57:23 +0900",
    "content": "[Gold II] 피보나치 수 6 - 11444  문제 링크  성능 요약  메모리: 2160 KB, 시간: 0 ms  분류  분할 정복을 이용한 거듭제곱, 수학  제출 일자  2024년 12월 8일 00:42:23  문제 설명  피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.  이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.  n=17일때 까지 피보나치 수를 써보면 다음과 같다.  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597  n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 n번째 피보나치 수를 1,000,000,007으로 나눈 나머지를 출력한다.     문제 풀이        코드   /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  map&lt;int, int&gt; fibo;  int getFibo(int n) {     if (fibo.contains(n)) return fibo[n];     int num;     if (n % 2 == 0)         num =             (getFibo(n / 2) * (getFibo(n / 2 - 1) + getFibo(n / 2 + 1)) % MOD) %             MOD;     else         num = ((getFibo((n - 1) / 2)) * (getFibo((n - 1) / 2)) % MOD) % MOD +               ((getFibo((n + 1) / 2)) * (getFibo((n + 1) / 2)) % MOD) % MOD;      return fibo[n] = num % MOD; }  void solve() {     int n;     cin &gt;&gt; n;     fibo[0] = 0;     fibo[1] = 1;     fibo[2] = fibo[0] + fibo[1];     int res = 0;     res = getFibo(n);     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  signed main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "vscode CPH Judge C++20 컴파일 오류",
    "url": "/posts/vscode-CPH-Judge-C20-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%98%A4%EB%A5%98/",
    "categories": "오류, 해결",
    "tags": "C++, CPH, vscode",
    "date": "2024-12-08 01:54:42 +0900",
    "content": "   vscode에서 Competitive Companion과 CPH Judge를 사용해 알고리즘을 푸는데 C++의 map 문법 중 C++20버전부터 사용 가능한 contains를 사용했는데 컴파일이 안되었다. 기존 C++17로 설정되어있었다. 이를 고치기 위한 여러 트러블슈팅   .vscode에서 c+cpp_properies.json수정 {     \"configurations\": [         {             \"name\": \"Win32\",             \"includePath\": [                 \"${workspaceFolder}/**\"             ],             \"defines\": [                 \"_DEBUG\",                 \"UNICODE\",                 \"_UNICODE\"             ],             \"compilerPath\": \"C:/msys64/ucrt64/bin/g++.exe\",             \"cStandard\": \"c17\",             \"cppStandard\": \"c++20\",             \"intelliSenseMode\": \"windows-gcc-x64\",             \"compilerArgs\": [\"-std=c++20\"]         }     ],     \"version\": 4 }   이후 settings.json도 수정 {     \"cph.general.saveLocation\": \"\",     \"cph.language.cpp.Command\": \"g++\",     \"cph.language.cpp.SubmissionCompiler\": \"GNU G++20 13.2 (64 bit, winlibs)\",     \"C_Cpp.default.cppStandard\": \"c++20\",     \"C_Cpp.default.compilerPath\": \"C:/msys64/ucrt64/bin/g++.exe\",     \"files.associations\": {         \"iostream\": \"cpp\"     } // Windows용 }   tasks.json도 수정 {     \"cph.general.saveLocation\": \"\",     \"cph.language.cpp.Command\": \"g++\",     \"cph.language.cpp.SubmissionCompiler\": \"GNU G++20 13.2 (64 bit, winlibs)\",     \"C_Cpp.default.cppStandard\": \"c++20\",     \"C_Cpp.default.compilerPath\": \"C:/msys64/ucrt64/bin/g++.exe\",     \"files.associations\": {         \"iostream\": \"cpp\"     } // Windows용 }   근데 여전히 해결이 안되었고  Exit code: 1 Errors while compiling: c:\\Users\\nowal\\Desktop\\cppalgorithm\\BOJ\\피보나치수_6.cpp: In function 'long long int getFibo(long long int)': c:\\Users\\nowal\\Desktop\\cppalgorithm\\BOJ\\피보나치수_6.cpp:21:14: error: 'class std::map&lt;long long int, long long int&gt;' has no member named 'contains'    21 |     if (fibo.contains(n)) return fibo[n];       |              ^~~~~~~~  이런 에러가 발생했는데 이는 컴파일이 여전히 C++20으로 안되는것이었다.  이에 extension에서 설정을 확인해봤다.  문제는 이 부분이었다. 여기서 Language &gt; Cpp : Args에서 아무것도 없어서 계속 디폴트가 반영되었던 것 같다. 그래서   다음과 같이 직접 C++20으로 작성해주니 반영되었다.   PS 번외로 vscode 계정을 Settings sync해뒀더니 macOS에서 다른 부분이 있어서 sync를 꺼두었다.  macOS에서는 Cph &gt; Language &lt; Cpp: Command를  /opt/homebrew/bin/g++-14 로 바꾸어야한다!  참고자료  Integrating CF-Tools with Visual Studio Code CPH Judge extension, making submission more convenient. "
  },
  
  {
    "title": "BOJ_18186_라면 사기 (Large) (Java, C++)",
    "url": "/posts/BOJ18186%EB%9D%BC%EB%A9%B4-%EC%82%AC%EA%B8%B0-Large-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-07 16:58:28 +0900",
    "content": "[Diamond IV] 라면 사기 (Large) - 18186  문제 링크  성능 요약  메모리: 9836 KB, 시간: 100 ms  분류  그리디 알고리즘  제출 일자  2024년 12월 7일 16:50:43  문제 설명  라면매니아 교준이네 집 주변에는 N개의 라면 공장이 있다. 각 공장은 1번부터 N번까지 차례대로 번호가 부여되어 있다. 교준이는 i번 공장에서 정확하게 Ai개의 라면을 구매하고자 한다(1 ≤ i ≤ N).  교준이는 아래의 세 가지 방법으로 라면을 구매할 수 있다.   \ti번 공장에서 라면을 하나 구매한다(1 ≤ i ≤ N). 이 경우 비용은 B원이 든다. \ti번 공장과 (i+1)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ i ≤ N-1). 이 경우 비용은 (B+C)원이 든다. \ti번 공장과 (i+1)번 공장, (i+2)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ i ≤ N-2). 이 경우 비용은 (B+2C)원이 든다.   최소의 비용으로 라면을 구매하고자 할 때, 교준이가 필요한 금액을 출력하는 프로그램을 작성하시오.  입력  첫 번째 줄에 라면 공장의 개수를 의미하는 자연수 N과 두 자연수 B, C가 사이에 공백을 두고 주어진다.  두번째 줄에 N개의 정수 A1, ···, AN가 사이에 공백을 두고 주어진다.  출력  첫 번째 줄에 교준이가 필요한 최소 금액을 출력한다.     문제 풀이     C++에서 int 대신 long long리턴 시 unsigned main으로 바꾸었다! (++새로운 지식)    코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tlong N = Long.parseLong(st.nextToken()); \t\tlong B = Long.parseLong(st.nextToken()); \t\tlong C = Long.parseLong(st.nextToken()); \t\tlong[] arr = new long[(int) (N+2)]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Long.parseLong(st.nextToken()); \t\t} \t\t \t\tlong minCnt = 0; \t\tif(B&lt;C) { \t\t\tfor(int i=0; i&lt;N; i++){ \t\t\t\tminCnt += B * arr[i]; \t\t\t} \t\t} \t\telse { \t\t\tfor(int i=0; i&lt;N; i++) { \t\t\t\tif(arr[i+1] &gt; arr[i+2]) { \t\t\t\t\t// 2개짜리 \t\t\t\t\tlong cycle = Math.min(arr[i], arr[i+1] - arr[i+2]); \t\t\t\t\tfor(int j=0; j&lt;2; j++) { \t\t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t\t} \t\t\t\t\tminCnt += (B+C)*cycle; \t\t\t\t \t\t\t\t\t// 3개짜리 \t\t\t\t\tcycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2]));  \t\t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t\t} \t\t\t\t\tminCnt += (B+2*C)*cycle; \t\t\t\t\t \t\t\t\t\tcycle = arr[i]; \t\t\t\t\tarr[i] -= cycle; \t\t\t\t\tminCnt += B*cycle; \t\t\t\t} \t\t\t\telse { \t\t\t\t\tlong cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2]));  \t\t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t\t} \t\t\t\t\tminCnt += (B+2*C)*cycle; \t\t\t\t\t \t\t\t\t\tcycle = Math.min(arr[i], arr[i+1]); \t\t\t\t\tfor(int j=0; j&lt;2; j++) { \t\t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t\t} \t\t\t\t\tminCnt += (B+C)*cycle; \t\t\t\t\t \t\t\t\t\tcycle = arr[i]; \t\t\t\t\tarr[i] -= cycle; \t\t\t\t\tminCnt += B*cycle; \t\t\t\t} \t\t\t} \t\t} \t\t \t\tbw.write(String.valueOf(minCnt)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, B, C;     cin &gt;&gt; N &gt;&gt; B &gt;&gt; C;     vector&lt;int&gt; arr(N + 2);     for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; arr[i];     }      int minCnt = 0;     if (B &lt; C) {         for (int i = 0; i &lt; N; i++) {             minCnt += arr[i] * B;         }     } else {         for (int i = 0; i &lt; N; i++) {             int cycle;             if (arr[i + 1] &gt; arr[i + 2]) {                 // 2묶음                 cycle = min(arr[i], arr[i + 1] - arr[i + 2]);                 for (int j = 0; j &lt; 2; j++) {                     arr[i + j] -= cycle;                 }                 minCnt += (B + C) * cycle;                  // 3묶음                 cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));                 for (int j = 0; j &lt; 3; j++) {                     arr[i + j] -= cycle;                 }                 minCnt += (B + 2 * C) * cycle;                  // 1묶음                 cycle = arr[i];                 arr[i] -= cycle;                 minCnt += cycle * B;             } else {                 // 3묶음                 cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));                 for (int j = 0; j &lt; 3; j++) {                     arr[i + j] -= cycle;                 }                 minCnt += (B + 2 * C) * cycle;                  // 2묶음                 int cycle = min(arr[i], arr[i + 1]);                 for (int j = 0; j &lt; 2; j++) {                     arr[i + j] -= cycle;                 }                 minCnt += (B + C) * cycle;                  // 1묶음                 cycle = arr[i];                 arr[i] -= cycle;                 minCnt += cycle * B;             }         }     }     cout &lt;&lt; minCnt &lt;&lt; \"\\n\"; }  signed main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_18185_라면 사기 (Small) (Java, C++)",
    "url": "/posts/BOJ18185%EB%9D%BC%EB%A9%B4-%EC%82%AC%EA%B8%B0-Small-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-07 16:55:28 +0900",
    "content": "[Diamond V] 라면 사기 (Small) - 18185  문제 링크  성능 요약  메모리: 2180 KB, 시간: 0 ms  분류  그리디 알고리즘  제출 일자  2024년 12월 7일 16:43:43  문제 설명  라면매니아 교준이네 집 주변에는 N개의 라면 공장이 있다. 각 공장은 1번부터 N번까지 차례대로 번호가 부여되어 있다. 교준이는 i번 공장에서 정확하게 Ai개의 라면을 구매하고자 한다(1 ≤ i ≤ N).  교준이는 아래의 세 가지 방법으로 라면을 구매할 수 있다.   \ti번 공장에서 라면을 하나 구매한다(1 ≤ i ≤ N). 이 경우 비용은 3원이 든다. \ti번 공장과 (i+1)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ i ≤ N-1). 이 경우 비용은 5원이 든다. \ti번 공장과 (i+1)번 공장, (i+2)번 공장에서 각각 라면을 하나씩 구매한다(1 ≤ i ≤ N-2). 이 경우 비용은 7원이 든다.   최소의 비용으로 라면을 구매하고자 할 때, 교준이가 필요한 금액을 출력하는 프로그램을 작성하시오.  입력  첫 번째 줄에 라면 공장의 개수를 의미하는 자연수 N가 주어진다.  두번째 줄에 N개의 정수 A1, ···, AN가 사이에 공백을 두고 주어진다.  출력  첫 번째 줄에 교준이가 필요한 최소 금액을 출력한다.     문제 풀이   이전 Skyline문제를 이 문제를 풀기 위해 공부했다. 사실상 똑같은 문젠데왜 난이도 차이가 한 티어나 차이나는지 모르겠다. 그리디 문제로 Skyline과 똑같이 풀었다. 자세한 내용은 Skyline 문제 풀이 참고     코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint N = Integer.parseInt(br.readLine()); \t\tint[] arr = new int[N+2]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t} \t\t \t\tint minCnt = 0; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tif(arr[i+1] &gt; arr[i+2]) { \t\t\t\t// 2개짜리 \t\t\t\tint cycle = Math.min(arr[i], arr[i+1] - arr[i+2]); \t\t\t\tfor(int j=0; j&lt;2; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 5*cycle; \t\t\t \t\t\t\t// 3개짜리 \t\t\t\tcycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2]));  \t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 7*cycle; \t\t\t\t \t\t\t\tcycle = arr[i]; \t\t\t\tarr[i] -= cycle; \t\t\t\tminCnt += 3*cycle; \t\t\t} \t\t\telse { \t\t\t\tint cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2]));  \t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 7*cycle; \t\t\t\t \t\t\t\tcycle = Math.min(arr[i], arr[i+1]); \t\t\t\tfor(int j=0; j&lt;2; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 5*cycle; \t\t\t\t \t\t\t\tcycle = arr[i]; \t\t\t\tarr[i] -= cycle; \t\t\t\tminCnt += 3*cycle; \t\t\t} \t\t} \t\t \t\tbw.write(String.valueOf(minCnt)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;     vector&lt;int&gt; arr(N + 2);     for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; arr[i];     }      int minCnt = 0;     for (int i = 0; i &lt; N; i++) {         int cycle;         if (arr[i + 1] &gt; arr[i + 2]) {             // 2묶음             cycle = min(arr[i], arr[i + 1] - arr[i + 2]);             for (int j = 0; j &lt; 2; j++) {                 arr[i + j] -= cycle;             }             minCnt += cycle * 5;              // 3묶음             cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));             for (int j = 0; j &lt; 3; j++) {                 arr[i + j] -= cycle;             }             minCnt += cycle * 7;              // 1묶음             cycle = arr[i];             arr[i] -= cycle;             minCnt += cycle * 3;         } else {             // 3묶음             cycle = min(arr[i], min(arr[i + 1], arr[i + 2]));             for (int j = 0; j &lt; 3; j++) {                 arr[i + j] -= cycle;             }             minCnt += cycle * 7;              // 2묶음             int cycle = min(arr[i], arr[i + 1]);             for (int j = 0; j &lt; 2; j++) {                 arr[i + j] -= cycle;             }             minCnt += cycle * 5;              // 1묶음             cycle = arr[i];             arr[i] -= cycle;             minCnt += cycle * 3;         }     }     cout &lt;&lt; minCnt &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_11835_Skyline (Java, C++)",
    "url": "/posts/BOJ11835Skyline-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-07 16:14:19 +0900",
    "content": "[Platinum V] Skyline - 11835  문제 링크  성능 요약  메모리: 14140 KB, 시간: 104 ms  분류  다이나믹 프로그래밍, 그리디 알고리즘  제출 일자  2024년 12월 7일 16:06:07  문제 설명  You want to have in your city a beatiful skyline. You have decided to build N skyscrapers in a straight row. The i-th of them should have exactly h[i] floors.  You have got offers from different construction companies. One of them offers to build one floor in any of the skyscrapers for 3 Million Euros. The other one offers to build one floor in each of two neighbouring skyscrapers for 5 Millions in total. Note that it doesn’t matter whether these floors are on the same height or not. The third one can build one floor in each of three consecutive skyscrapers for only 7 Millions.  You can build the floors in any order you want. Calculate the minimal possible total amount of money needed to finish the construction.  입력  The first line contains integer number N (1 ≤ N ≤ 300). The second line contains space separated N integer numbers, h[1], h[2], ..., h[N], 1 ≤ h[i] ≤ 200.  출력  Output one integer number: the amount of money, in Millions.     문제 풀이     각 위치에서 어떤 연산을 먼저 수행하는 것이 최적인지를 판단해야 한다. 각 위치 i에서 현재 수 arr[i]를 0으로 만들어야 한다. a[i+1]과 a[i+2]를 비교하여 두 가지 경우로 나눌 수 있다.          Case 1: a[i+1] &gt; a[i+2]인 경우              먼저 2개묶음 연산으로 min(a[i], a[i+1] - a[i+2])만큼 두 번째 수와 세 번째 수의 차이를 줄인다.           그 다음 3개묶음 연산을 min(a[i], min(a[i+1], a[i+2]))만큼 한다.           마지막으로 남은 수에 대해 1개 묶음 연산을 수행합니다.              Case 2: a[i+1] ≤ a[i+2]인 경우              먼저 3개묶음 연산을 min(a[i], min(a[i+1], a[i+2]))만큼 최대한 수행한다.           그 다음 2개묶음 연산 count = min(a[i], a[i+1])만큼 수행한다.           마지막으로 남은 수에 대해 1묶음 연산을 수행한다.              시간 복잡도             각 위치에서 최대 3번의 연산을 수행하고 전체 시간 복잡도는 O(N)              코드   Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint N = Integer.parseInt(br.readLine()); \t\tint[] arr = new int[N+2]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t} \t\t \t\tint minCnt = 0; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tif(arr[i+1] &gt; arr[i+2]) { \t\t\t\t// 2개짜리 \t\t\t\tint cycle = Math.min(arr[i], arr[i+1] - arr[i+2]); \t\t\t\tfor(int j=0; j&lt;2; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 5*cycle; \t\t\t \t\t\t\t// 3개짜리 \t\t\t\tcycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2]));  \t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 7*cycle; \t\t\t\t \t\t\t\tcycle = arr[i]; \t\t\t\tarr[i] -= cycle; \t\t\t\tminCnt += 3*cycle; \t\t\t} \t\t\telse { \t\t\t\tint cycle = Math.min(arr[i], Math.min(arr[i+1], arr[i+2]));  \t\t\t\tfor(int j=0; j&lt;3; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 7*cycle; \t\t\t\t \t\t\t\tcycle = Math.min(arr[i], arr[i+1]); \t\t\t\tfor(int j=0; j&lt;2; j++) { \t\t\t\t\tarr[i+j] -= cycle; \t\t\t\t} \t\t\t\tminCnt += 5*cycle; \t\t\t\t \t\t\t\tcycle = arr[i]; \t\t\t\tarr[i] -= cycle; \t\t\t\tminCnt += 3*cycle; \t\t\t} \t\t} \t\t \t\tbw.write(String.valueOf(minCnt)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   C++ 코드   "
  },
  
  {
    "title": "BOJ_1981_배열에서 이동 (Java, C++)",
    "url": "/posts/BOJ1981%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C-%EC%9D%B4%EB%8F%99/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-07 05:30:17 +0900",
    "content": "[Platinum V] 배열에서 이동 - 1981  문제 링크  성능 요약  메모리: 157272 KB, 시간: 364 ms  분류  너비 우선 탐색, 이분 탐색, 그래프 이론, 그래프 탐색  제출 일자  2024년 12월 7일 05:28:49  문제 설명  n×n짜리의 배열이 하나 있다. 이 배열의 (1, 1)에서 (n, n)까지 이동하려고 한다. 이동할 때는 상, 하, 좌, 우의 네 인접한 칸으로만 이동할 수 있다.  이와 같이 이동하다 보면, 배열에서 몇 개의 수를 거쳐서 이동하게 된다. 이동하기 위해 거쳐 간 수들 중 최댓값과 최솟값의 차이가 가장 작아지는 경우를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 n(2 ≤ n ≤ 100)이 주어진다. 다음 n개의 줄에는 배열이 주어진다. 배열의 각 수는 0보다 크거나 같고, 200보다 작거나 같은 정수이다.  출력  첫째 줄에 (최대 - 최소)가 가장 작아질 때의 그 값을 출력한다.     문제 풀이      총 시간복잡도: O((maxVal-minVal) * N² * log(maxVal-minVal))   총 공간복잡도: O(N²)   이분 탐색 + BFS 조합 사용    이분 탐색: 가능한 “최대값-최소값의 차이”를 찾기 위해   BFS: 해당 차이로 경로가 가능한지 확인하기 위해   left 초기값: 시작점과 도착점의 차이 (이보다 작을 순 없음) right 초기값: 전체 배열의 최대값-최소값  놓쳤던 부분:  if (!(board[1][1] &gt;= i &amp;&amp; board[1][1] &lt;= j)) return false;    시작점이 범위 안에 있어야 한다는 조건을 놓치기 쉬움 이 조건이 없으면 시작부터 잘못된 경로 탐색 시작   실수하기 쉬운 부분 : int j = i + mid;  // 올바른 방법 int j = minVal + mid;  // 틀린 방법  i~j 범위를 [i, i+mid]로 잡아야 하는데 실수로 몇번 틀림.     코드   Java코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int[] dr = {0, -1, 0, 1}, dc = {-1, 0, 1, 0}; \tstatic int N, board[][], max=-210, min=210; \tstatic boolean visited[][]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tboard = new int[N+2][N+2]; \t\tfor(int i=0; i&lt;N+2; i++) { \t\t\tArrays.fill(board[i], -1); \t\t} \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j=1; j&lt;=N; j++) { \t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken()); \t\t\t\tif(board[i][j] &gt; max) max=board[i][j]; \t\t\t\tif(board[i][j]&lt;min) min = board[i][j]; \t\t\t} \t\t} \t\t \t\tint res = 210; \t\tint left = Math.abs(board[1][1]-board[N][N]); \t\tint right = max-min; \t\twhile(left&lt;=right) { \t\t\tint mid = left + (right-left)/2; \t\t\tboolean flag = false; \t\t\t \t\t\tfor(int i=min; i&lt;=max-mid; i++) { \t\t\t\tint j = i + mid; \t\t\t\tif(board[1][1]&gt;=i &amp;&amp; board[1][1] &lt;= j) { \t\t\t\t\tif(canGo(i, j)) { \t\t\t\t\t\tflag = true; \t\t\t\t\t\tbreak; \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t\t \t\t\tif(flag) { \t\t\t\tres = mid; \t\t\t\tright = mid-1; \t\t\t} \t\t\telse { \t\t\t\tleft = mid+1; \t\t\t} \t\t} \t\t \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate boolean canGo(int min, int max) { \t\tQueue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;(); \t\tvisited = new boolean[N+2][N+2]; \t\t \t\tqueue.offer(new int[]{1, 1}); \t\tvisited[1][1] = true; \t\t \t\twhile(!queue.isEmpty()) { \t\t\tint[] curr = queue.poll(); \t\t\tint currNum = board[curr[0]][curr[1]]; \t\t\t \t\t\tif(curr[0] == N &amp;&amp; curr[1] == N) return true; \t\t\t \t\t\tfor(int k=0; k&lt;4; k++) { \t\t\t\tint[] next = {curr[0] + dr[k], curr[1] + dc[k]}; \t\t\t\t \t\t\t\tif(board[next[0]][next[1]] == -1 || visited[next[0]][next[1]]) continue; \t\t\t\tif(board[next[0]][next[1]] &gt;= min &amp;&amp; board[next[0]][next[1]] &lt;= max) { \t\t\t\t\tqueue.offer(next); \t\t\t\t\tvisited[next[0]][next[1]] = true; \t\t\t\t} \t\t\t} \t\t} \t\treturn false; \t} }   C++코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int dr[] = {0, -1, 0, 1}, dc[] = {-1, 0, 1, 0}; int N; vector&lt;vector&lt;int&gt;&gt; board; vector&lt;vector&lt;bool&gt;&gt; visited; int maxVal = -210, minVal = 210;  bool canGo(int i, int j) {     if (!(board[1][1] &gt;= i &amp;&amp; board[1][1] &lt;= j)) return false;      queue&lt;pair&lt;int, int&gt;&gt; queue;     visited.assign(N + 2, vector&lt;bool&gt;(N + 2, false));     queue.push({1, 1});     visited[1][1] = true;      while (!queue.empty()) {         int curr[] = {queue.front().first, queue.front().second};         queue.pop();          if (curr[0] == N &amp;&amp; curr[1] == N) return true;          for (int k = 0; k &lt; 4; k++) {             int next[] = {curr[0] + dr[k], curr[1] + dc[k]};             if (board[next[0]][next[1]] == -1 || visited[next[0]][next[1]])                 continue;             if (board[next[0]][next[1]] &gt;= i &amp;&amp; board[next[0]][next[1]] &lt;= j) {                 queue.push({next[0], next[1]});                 visited[next[0]][next[1]] = true;             }         }     }     return false; }  void solve() {     cin &gt;&gt; N;      board.assign(N + 2, vector&lt;int&gt;(N + 2, -1));     visited.assign(N + 2, vector&lt;bool&gt;(N + 2, false));      for (int i = 1; i &lt;= N; i++) {         for (int j = 1; j &lt;= N; j++) {             cin &gt;&gt; board[i][j];             maxVal = max(maxVal, board[i][j]);             minVal = min(minVal, board[i][j]);         }     }      int res = 210;     int left = abs(board[1][1] - board[N][N]);     int right = maxVal - minVal;      while (left &lt;= right) {         int mid = left + (right - left) / 2;         bool flag = false;          for (int i = minVal; i &lt;= maxVal - mid; i++) {             int j = i + mid;             if (canGo(i, j)) {                 flag = true;                 break;             }         }          if (flag) {             right = mid - 1;             res = mid;         } else {             left = mid + 1;         }     }     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_2179_비슷한 단어 (Java, C++)",
    "url": "/posts/BOJ2179%EB%B9%84%EC%8A%B7%ED%95%9C-%EB%8B%A8%EC%96%B4-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-06 17:19:11 +0900",
    "content": "[Gold III] 비슷한 단어 - 2179  문제 링크  성능 요약  메모리: 2856 KB, 시간: 0 ms  분류  자료 구조, 해시를 사용한 집합과 맵, 정렬, 문자열  제출 일자  2024년 12월 6일 17:12:10  문제 설명  N개의 영단어들이 주어졌을 때, 가장 비슷한 두 단어를 구해내는 프로그램을 작성하시오.  두 단어의 비슷한 정도는 두 단어의 접두사의 길이로 측정한다. 접두사란 두 단어의 앞부분에서 공통적으로 나타나는 부분문자열을 말한다. 즉, 두 단어의 앞에서부터 M개의 글자들이 같으면서 M이 최대인 경우를 구하는 것이다. \"AHEHHEH\", \"AHAHEH\"의 접두사는 \"AH\"가 되고, \"AB\", \"CD\"의 접두사는 \"\"(길이가 0)이 된다.  접두사의 길이가 최대인 경우가 여러 개일 때에는 입력되는 순서대로 제일 앞쪽에 있는 단어를 답으로 한다. 즉, 답으로 S라는 문자열과 T라는 문자열을 출력한다고 했을 때, 우선 S가 입력되는 순서대로 제일 앞쪽에 있는 단어인 경우를 출력하고, 그런 경우도 여러 개 있을 때에는 그 중에서 T가 입력되는 순서대로 제일 앞쪽에 있는 단어인 경우를 출력한다.  입력  첫째 줄에 N(2 ≤ N ≤ 20,000)이 주어진다. 다음 N개의 줄에 알파벳 소문자로만 이루어진 길이 100자 이하의 서로 다른 영단어가 주어진다.  출력  첫째 줄에 S를, 둘째 줄에 T를 출력한다. 단, 이 두 단어는 서로 달라야 한다. 즉, 가장 비슷한 두 단어를 구할 때 같은 단어는 제외하는 것이다.     문제 풀이   먼저 푼 방법은 완전탐색이다. 반복문을 통해 O(N^2)에도 통과할 것 같아 바로 Java로 작성후 통과했다.  이후 좋은 풀이를 탐색 하던 중 HashMap을 활용해 Key에 문자를 넣고 그 인덱스를 Value로 넣어 i, j 형식으로 i문자열에서 j문자열을 모두 쪼개 패턴매칭해보며 최대길이를 찾았고 그 인덱스를 res1 res2에 기억해두었다. 해당 로직은 c++로 작성해봤다.  코드  Java코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;     static String[] arr;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2179_비슷한단어/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         N = Integer.parseInt(br.readLine());         arr = new String[N];         for (int i = 0; i &lt; N; i++) {             arr[i] = br.readLine();         }          int max = 0;         String str1 = \"\", str2 = \"\";         for (int i = 0; i &lt; arr.length; i++) {             for (int j = i + 1; j &lt; arr.length; j++) {                 int len = getLen(arr[i], arr[j]);                 if (len &gt; max) {                     str1 = arr[i];                     str2 = arr[j];                     max = len;                 }             }         }          bw.write(str1 + \"\\n\" + str2);          bw.flush();         bw.close();         br.close();     }      private int getLen(String s1, String s2) {         int minLen = Math.min(s1.length(), s2.length());         int cnt = 0;         for (int i = 0; i &lt; minLen; i++) {             if (s1.charAt(i) == s2.charAt(i)) {                 cnt++;             } else break;         }         return cnt;     }  }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;      vector&lt;string&gt; arr(N);      map&lt;string, int&gt; prefixMap;     int res1 = 0, res2 = 1;     int maxLen = 0;      for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; arr[i];         string str = arr[i];          for (int j = str.length(); j &gt;= 1; j--) {             string pattern = str.substr(0, j);             if (pattern.length() &lt; maxLen) break;              /*             map.find(key)는:              키를 찾으면 해당 요소를 가리키는 반복자(iterator)를 반환             키가 없으면 map.end()를 반환              그래서 it != map.end()는 \"키가 존재한다\"는 의미.             */             auto p = prefixMap.find(pattern);             if (p != prefixMap.end()) {                 if (pattern.length() == maxLen &amp;&amp; prefixMap[pattern] &gt; res1)                     break;                  if (pattern.length() == maxLen &amp;&amp; prefixMap[pattern] == res1 &amp;&amp;                     res2 &lt; i)                     break;                  res1 = prefixMap[pattern];                 res2 = i;                 maxLen = pattern.length();                 break;             }             prefixMap[pattern] = i;         }     }     cout &lt;&lt; arr[res1] &lt;&lt; \"\\n\" &lt;&lt; arr[res2] &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_9471_피사노 주기 (C++)",
    "url": "/posts/BOJ9471%ED%94%BC%EC%82%AC%EB%85%B8-%EC%A3%BC%EA%B8%B0-C/",
    "categories": "알고리즘",
    "tags": "C++, 백준, 알고리즘",
    "date": "2024-12-06 16:35:54 +0900",
    "content": "[Silver IV] 피사노 주기 - 9471  문제 링크  성능 요약  메모리: 8292 KB, 시간: 4 ms  분류  브루트포스 알고리즘, 수학, 정수론  제출 일자  2024년 12월 6일 16:24:49  문제 설명  1960년, IBM의 직원 Donald Wall은 피보나치 수열을 m으로 나눈 나머지가 주기를 이룬다는 것을 증명했다.  예를 들어, 피보나치 수열의 처음 10개를 11로 나눈 예는 다음과 같다.   \t \t\t \t\t\tn \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t4 \t\t\t5 \t\t\t6 \t\t\t7 \t\t\t8 \t\t\t9 \t\t\t10 \t\t \t \t \t\t \t\t\tF(n) \t\t\t1 \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t5 \t\t\t8 \t\t\t13 \t\t\t21 \t\t\t34 \t\t\t55 \t\t \t\t \t\t\tF(n) mod 11 \t\t\t1 \t\t\t1 \t\t\t2 \t\t\t3 \t\t\t5 \t\t\t8 \t\t\t2 \t\t\t10 \t\t\t1 \t\t\t0 \t\t \t   나머지를 이용해서 만든 수열은 주기가 나타날 수 있다. k(m)을 반복하는 부분 수열의 길이라고 했을 때, k(11) = 10임을 알 수 있다.  Wall은 아래와 같은 여러 가지 성질도 증명했다.   \tm &gt; 2인 경우에 k(m)은 짝수이다. \t임의의 짝수 정수 n &gt; 2에 대해서, k(m) = n인 m이 항상 존재한다. \tk(m) ≤ m2 - 1 \tk(2n) = 3×2(n-1) \tk(5n) = 4×5n \tk(2×5n) = 6n \tn &gt; 2라면, k(10n) = 15×10(n-1)   m이 주어졌을 때, k(m)을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 테스트 케이스의 개수 P가 주어진다. 각 테스트 케이스는 N과 M으로 이루어져 있다. N은 테스트 케이스의 번호이고, M은 문제에서 설명한 m이다.  출력  각 테스트 케이스마다 테스트 케이스 번호를 출력하고 k(M)을 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int n, m;     cin &gt;&gt; n &gt;&gt; m;     int first = 1;     int second = 1;     int third = (first + second) % m;     bool flag = false;     vector&lt;pair&lt;int, int&gt;&gt; pisanoPair;     pisanoPair.push_back({first, second});      while (!flag) {         third = (first + second) % m;         first = second;         second = third;          if (first == pisanoPair[0].first &amp;&amp; second == pisanoPair[0].second)             flag = true;          if (!flag) pisanoPair.push_back({first, second});     }     cout &lt;&lt; n &lt;&lt; \" \" &lt;&lt; pisanoPair.size() &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "CF_Round 991 (Div. 3)",
    "url": "/posts/CFRound-991-Div.-3/",
    "categories": "알고리즘",
    "tags": "codeforces, cp, 알고리즘",
    "date": "2024-12-06 03:18:23 +0900",
    "content": "   Codeforces Round 991 (Div. 3)     Codeforces Round 991 (Div. 3)  A. Line Breaks  문제 Kostya는 라틴 알파벳으로 구성된 n개의 단어로 이루어진 텍스트를 가지고 있습니다. 그는 이 텍스트를 두 개의 띠에 써야 하는데:    첫 번째 띠는 m개의 문자만 수용할 수 있습니다   두 번째 띠는 제한 없이 문자를 수용할 수 있습니다   첫 번째 띠에 x개의 단어를 쓰고, 나머지는 두 번째 띠에 써야 합니다   단어들은 공백 없이 이어서 쓰며, 각 단어는 하나의 띠에 완전히 들어가야 합니다   입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 1000)   각 테스트 케이스:            첫 줄: 단어 수 n (1 ≤ n ≤ 50)과 첫 번째 띠의 길이 m (1 ≤ m ≤ 500)       다음 n줄: 각 단어 (길이 ≤ 10)           출력 각 테스트 케이스마다 첫 번째 띠에 쓸 수 있는 최대 단어 수 x를 출력  예제 입력: 5 3 1 a b c 2 9 alpha beta 4 12 hello world and codeforces 3 2 ab c d 3 2 abc ab a   출력: 1 2 2 1 0   B. Transfusion  문제 길이 n의 배열 a가 주어집니다. 아래 연산을 임의의 횟수만큼 수행할 수 있습니다:    2부터 n-1까지의 인덱스 i를 선택   두 가지 연산 중 하나를 선택:            ai-1을 1 감소시키고 ai+1을 1 증가       ai+1을 1 감소시키고 ai-1을 1 증가           모든 값이 음수가 되면 안됩니다   입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 10^4)   각 테스트 케이스:            첫 줄: 배열의 길이 n (3 ≤ n ≤ 2×10^5)       두 번째 줄: n개의 정수 ai (1 ≤ ai ≤ 10^9)           출력 각 테스트 케이스마다 모든 원소를 같게 만들 수 있으면 “YES”, 아니면 “NO” 출력  C. Uninteresting Number  문제 10^5자리 이하의 숫자가 주어집니다. 아래 연산을 임의의 횟수만큼 수행할 수 있습니다:    임의의 자릿수를 선택하여 그 숫자를 제곱   제곱한 결과가 한 자릿수여야 함 (x^2 &lt; 10)   원래 자릿수를 제곱한 결과로 교체   위 연산을 통해 9의 배수를 만들 수 있는지 판단하세요.  입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 10^4)   각 테스트 케이스:            한 줄에 숫자 n (선행 0 없음)           출력 각 테스트 케이스마다 9의 배수를 만들 수 있으면 “YES”, 아니면 “NO” 출력  D. Digital String Maximization  문제 숫자로 이루어진 문자열 s가 주어집니다. 다음 연산을 임의의 횟수만큼 수행할 수 있습니다:    0이나 첫 자리를 제외한 임의의 숫자를 선택   선택한 숫자를 1 감소시키고   왼쪽 숫자와 교환   입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 10^4)   각 테스트 케이스:                                                            한 줄에 숫자로 이루어진 문자열 s (1 ≤               s               ≤ 2×10^5)                                                   출력 각 테스트 케이스마다 만들 수 있는 사전순으로 가장 큰 문자열 출력  E. Three Strings  문제 세 개의 문자열 a, b, c가 주어집니다. c는 다음과 같이 생성되었습니다:    각 단계마다 a나 b를 무작위로 선택하여 첫 글자를 제거하고 c의 끝에 추가   한 문자열이 비면 나머지 문자열의 모든 문자를 c의 끝에 추가   그 후 c의 일부 문자들이 임의로 변경됨   변경된 최소 문자 수를 찾으세요.  입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 10^3)   각 테스트 케이스:                                                            첫째 줄: 문자열 a (1 ≤               a               ≤ 10^3)                                                                                               둘째 줄: 문자열 b (1 ≤               b               ≤ 10^3)                                                                                               셋째 줄: 문자열 c (               c               =               a               +               b               )                                                   출력 각 테스트 케이스마다 c를 만들기 위해 필요한 최소 문자 변경 횟수를 출력  F. Maximum Modulo Equality  문제 길이 n의 배열과 q개의 쿼리가 주어집니다. 각 쿼리는 구간 [l,r]을 지정합니다.  al, al+1, …, ar이 모두 같은 나머지를 갖게 하는 가장 큰 모듈러스 m을 찾으세요. m이 무한대가 될 수 있다면 0을 출력하세요.  입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 10^4)   각 테스트 케이스:            첫 줄: n, q (1 ≤ n,q ≤ 2×10^5)       둘째 줄: n개의 정수 ai (1 ≤ ai ≤ 10^9)       다음 q줄: 두 정수 l, r (1 ≤ l ≤ r ≤ n)           출력 각 쿼리마다 최대 모듈러스 m을 출력  G. Tree Destruction  문제 n개의 정점을 가진 트리가 주어집니다. 한 번에 두 정점 a와 b를 선택하여 a에서 b까지의 경로 상의 모든 정점을 제거할 수 있습니다. 제거 후 생성될 수 있는 최대 연결 컴포넌트 수를 찾으세요.  입력    첫 줄: 테스트 케이스 수 t (1 ≤ t ≤ 10^4)   각 테스트 케이스:            첫 줄: 트리의 크기 n (2 ≤ n ≤ 2×10^5)       다음 n-1줄: 두 정수 u, v (간선 정보)           출력 각 테스트 케이스마다 가능한 최대 연결 컴포넌트 수를 출력  코드 A. Line Breaks  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int n, m;     cin &gt;&gt; n &gt;&gt; m;      vector&lt;string&gt; words(n);     for (int i = 0; i &lt; n; i++) {         cin &gt;&gt; words[i];     }      int len = 0;     int ans = 0;      for (const string&amp; word : words) {         if (word.length() &gt; m) break;         if (len + word.length() &gt; m) break;          len += word.length();         ans++;     }      cout &lt;&lt; ans &lt;&lt; '\\n'; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   B. Transfusion /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int n;     cin &gt;&gt; n;     vector&lt;int&gt; a(n);     for (int i = 0; i &lt; n; i++) {         cin &gt;&gt; a[i];     }      long long even_sum = 0, odd_sum = 0;     for (int i = 0; i &lt; n; i++) {         if (i % 2)             odd_sum += a[i];         else             even_sum += a[i];     }      int even_count = (n + 1) / 2;     int odd_count = n / 2;      if ((even_sum + odd_sum) % n != 0) {         cout &lt;&lt; \"NO\\n\";         return;     }      long long target = (even_sum + odd_sum) / n;     if (even_sum % even_count != 0 || odd_sum % odd_count != 0 ||         even_sum / even_count != target || odd_sum / odd_count != target) {         cout &lt;&lt; \"NO\\n\";         return;     }      cout &lt;&lt; \"YES\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   C. Uninteresting Number /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     string n;     cin &gt;&gt; n;     vector&lt;int&gt; digits;     for (char c : n) digits.push_back(c - '0');      int len = digits.size();     vector&lt;bool&gt; possible(9, false);     possible[0] = true;      for (int digit : digits) {         vector&lt;bool&gt; next(9, false);         for (int mod = 0; mod &lt; 9; mod++) {             if (!possible[mod]) continue;             next[(mod + digit) % 9] = true;             if (digit * digit &lt; 10) {                 next[(mod + digit * digit) % 9] = true;             }         }         possible = next;     }      cout &lt;&lt; (possible[0] ? \"YES\\n\" : \"NO\\n\"); }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   D. Digital string maximization /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     string s;     cin &gt;&gt; s;     int n = s.length();      // 각 위치에서 가능한 최대값을 한 번에 계산     for (int i = 0; i &lt; n - 1; i++) {         // 현재 위치에서 가능한 최대값과 그 위치 찾기         int maxVal = s[i] - '0';         int maxPos = i;          // i+1부터 시작하여 현재 위치까지 가져올 수 있는 최대값 찾기         for (int j = i + 1; j &lt; min(n, i + 10); j++) {             if (s[j] == '0') continue;             int val = s[j] - '0' - (j - i);             if (val &gt; maxVal) {                 maxVal = val;                 maxPos = j;             }         }          // 최대값을 찾았다면 문자열 업데이트         if (maxPos != i) {             char c = maxVal + '0';             for (int j = maxPos; j &gt; i; j--) {                 s[j] = s[j - 1];             }             s[i] = c;         }     }      cout &lt;&lt; s &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   E. Three Strings /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     string a, b, c;     cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;      int n = a.size(), m = b.size();     vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, n + m));     dp[0][0] = 0;      for (int i = 0; i &lt;= n; i++) {         for (int j = 0; j &lt;= m; j++) {             if (i &lt; n &amp;&amp; dp[i][j] &lt; n + m) {                 dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + (a[i] != c[i + j]));             }             if (j &lt; m &amp;&amp; dp[i][j] &lt; n + m) {                 dp[i][j + 1] = min(dp[i][j + 1], dp[i][j] + (b[j] != c[i + j]));             }         }     }      cout &lt;&lt; dp[n][m] &lt;&lt; '\\n'; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   F. Maximum modulo equality /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int n, q;     cin &gt;&gt; n &gt;&gt; q;     vector&lt;long long&gt; a(n);     for (int i = 0; i &lt; n; i++) {         cin &gt;&gt; a[i];     }      // 세그먼트 트리를 사용하여 구간 GCD를 효율적으로 계산     vector&lt;long long&gt; diff(n - 1);     for (int i = 0; i &lt; n - 1; i++) {         diff[i] = abs(a[i + 1] - a[i]);     }      // 세그먼트 트리 구성     int size = 1;     while (size &lt; n - 1) size *= 2;     vector&lt;long long&gt; seg(2 * size);      // 세그먼트 트리 초기화     for (int i = 0; i &lt; n - 1; i++) {         seg[size + i] = diff[i];     }     for (int i = size - 1; i &gt; 0; i--) {         seg[i] = gcd(seg[2 * i], seg[2 * i + 1]);     }      // 구간 GCD 쿼리 함수     auto query = [&amp;](int l, int r) {         l += size;         r += size;         long long result = 0;         while (l &lt; r) {             if (l &amp; 1) result = gcd(result, seg[l++]);             if (r &amp; 1) result = gcd(result, seg[--r]);             l &gt;&gt;= 1;             r &gt;&gt;= 1;         }         return result;     };      while (q--) {         int l, r;         cin &gt;&gt; l &gt;&gt; r;         l--;         r--;          if (l == r) {             cout &lt;&lt; \"0 \";             continue;         }          // 구간 내 모든 수가 같은지 빠르게 확인         if (query(l, r) == 0) {             cout &lt;&lt; \"0 \";             continue;         }          cout &lt;&lt; query(l, r) &lt;&lt; \" \";     }     cout &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   G. Tree Destruction (Fail) -&gt; tourist’s code /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int n;     cin &gt;&gt; n;     vector&lt;vector&lt;int&gt;&gt; g(n);     for (int i = 0; i &lt; n - 1; i++) {         int x, y;         cin &gt;&gt; x &gt;&gt; y;         --x;         --y;         g[x].push_back(y);         g[y].push_back(x);     }     vector&lt;int&gt; deg(n);     for (int i = 0; i &lt; n; i++) {         deg[i] = int(g[i].size());     }     int ans = -n;     auto Dfs = [&amp;](auto&amp;&amp; self, int v, int pr) -&gt; int {         int mx1 = 0;         int mx2 = 0;         for (int u : g[v]) {             if (u == pr) {                 continue;             }             int got = self(self, u, v);             if (got &gt; mx1) {                 mx2 = mx1;                 mx1 = got;             } else {                 mx2 = max(mx2, got);             }         }         ans = max(ans, mx1 + mx2 + (deg[v] - 2));         return mx1 + (deg[v] - 2);     };     Dfs(Dfs, 0, -1);     cout &lt;&lt; ans + 2 &lt;&lt; '\\n'; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_1090_체커(Java, C++)",
    "url": "/posts/BOJ1090%EC%B2%B4%EC%BB%A4Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-05 23:25:33 +0900",
    "content": "[Platinum IV] 체커 - 1090  문제 링크  성능 요약  메모리: 2024 KB, 시간: 4 ms  분류  브루트포스 알고리즘  제출 일자  2024년 12월 5일 23:23:08  문제 설명  N개의 체커가 엄청 큰 보드 위에 있다. i번 체커는 (xi, yi)에 있다. 같은 칸에 여러 체커가 있을 수도 있다. 체커를 한 번 움직이는 것은 그 체커를 위, 왼쪽, 오른쪽, 아래 중의 한 방향으로 한 칸 움직이는 것이다.  입력  첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 체커의 x좌표와 y좌표가 주어진다. 이 값은 1,000,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 수 N개를 출력한다. k번째 수는 적어도 k개의 체커가 같은 칸에 모이도록 체커를 이동해야 하는 최소 횟수이다.     문제 풀이     생각보다 간단하게 풀렸다… 그냥 사실상 완전탐색.  코드  Java 코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tclass Checker{ \t\tint x; \t\tint y; \t\tChecker(int x, int y){ \t\t\tthis.x = x; \t\t\tthis.y = y; \t\t} \t} \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int N; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\tint[] x_arr = new int[N]; \t\tint[] y_arr = new int[N]; \t\tint[] dist = new int[N]; \t\tArrays.fill(dist, Integer.MAX_VALUE); \t\tChecker[] checker = new Checker[N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint x = Integer.parseInt(st.nextToken()); \t\t\tint y = Integer.parseInt(st.nextToken()); \t\t\tx_arr[i] = x; \t\t\ty_arr[i] = y; \t\t\tchecker[i] = new Checker(x, y); \t\t} \t\t \t\tList&lt;Integer&gt; distances = new ArrayList&lt;Integer&gt;(); \t\tfor(int i=0; i&lt;x_arr.length; i++) { \t\t\tfor(int j=0; j&lt;y_arr.length; j++) { \t\t\t\tdistances.clear(); \t\t\t\tint dis = 0; \t\t\t\tfor(Checker c : checker) { \t\t\t\t\tdistances.add(getDis(x_arr[i], y_arr[j], c)); \t\t\t\t} \t\t\t\t \t\t\t\tCollections.sort(distances); \t\t\t\t \t\t\t\tint cnt = 0; \t\t\t\tfor(int k=0; k&lt;distances.size(); k++) { \t\t\t\t\tcnt += distances.get(k); \t\t\t\t\tdist[k] = Math.min(cnt, dist[k]); \t\t\t\t} \t\t\t} \t\t} \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tsb.append(dist[i] + \" \"); \t\t} \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int getDis(int i, int j, Checker c) { \t\treturn (int) Math.abs(i-c.x) + Math.abs(j-c.y); \t\t \t} }   C++ 코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  class Checker {    public:     int x, y;     Checker(int x, int y) : x(x), y(y) {} };  int getDis(int i, int j, Checker c) { return abs(i - c.x) + abs(j - c.y); }  void solve() {     int N;     cin &gt;&gt; N;     vector&lt;int&gt; x_arr(N), y_arr(N), dist(N, INT_MAX);     vector&lt;Checker&gt; checkers;      for (int i = 0; i &lt; N; i++) {         int x, y;         cin &gt;&gt; x &gt;&gt; y;         x_arr[i] = x;         y_arr[i] = y;         checkers.emplace_back(x, y);  // 객체 생성과 동시에 삽입     }      for (int i = 0; i &lt; x_arr.size(); i++) {         for (int j = 0; j &lt; y_arr.size(); j++) {             vector&lt;int&gt; distances;             for (auto&amp; c : checkers) {                 distances.push_back(getDis(x_arr[i], y_arr[j], c));             }              sort(ALL(distances));              int cnt = 0;             for (int k = 0; k &lt; distances.size(); k++) {                 cnt += distances[k];                 dist[k] = min(cnt, dist[k]);             }         }     }      for (int i = 0; i &lt; N; i++) {         cout &lt;&lt; dist[i] &lt;&lt; \" \";     }     cout &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_9007_카누 선수 (Java, C++)",
    "url": "/posts/BOJ9007%EC%B9%B4%EB%88%84-%EC%84%A0%EC%88%98/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-05 02:34:21 +0900",
    "content": "[Gold II] 카누 선수 - 9007  문제 링크  성능 요약  메모리: 120284 KB, 시간: 3992 ms  분류  이분 탐색, 중간에서 만나기, 정렬  제출 일자  2024년 12월 5일 02:28:07  문제 설명  국제 카누 경주 챔피언십 (International Canoe Sprint Championship : ICSC)가 머지 않아 개막된다. ICSC에서 인증하는 공식 보트는 C1, C2 그리고 C4로 구성되며, \"C\"는 카누를 그리고 숫자는 노를 젓는 사람의 수를 의미한다. 카누 경주는 잔잔한 물 위의 여러개로 구획된 직선 코스에서 이루어진다. ICSC에서는 국제 경기를 200m, 500m 그리고 1000m로 구분하고 있다.    한국 스포츠 학교(Korea Sports School : KSS)는 ICSC 의 C4 1000m 경기에 참가할 예정이다. KSS에는 같은 수의 학생으로 구성된 4개의 반을 가지며, 각 반에서 1명씩을 선출하여 경기에 참가한다. KSS에는 다수의 C4 보트를 가지고 있으며 각 보트는 선수들의 몸무게 합이 특정 값에 근사할 때 최대의 성과를 낼 수 있다. 예를 들어 특정 값이 300이고 각 반의 학생들의 몸무게가 아래와 같다고 하자.   \tClass-1: 60, 52, 80, 40 \tClass-2: 75, 68, 88, 63 \tClass-3: 48, 93, 48, 54 \tClass-4: 56, 73, 49, 75   각 반에서 차례로 60,75,93 그리고 73 학생을 선택하게 되면 몸무게 합이 301으로 300에 가장 근사하게 된다. 몇몇의 경우에는 두개의 근사값이 나올 수 있다. 예를 들어 특정 값이 200일 때, 몸무게의 합이 198과 202가 나올 수 있으며 이러한 경우에는 더 작은 값이 카누 게임 진행에 더 적합하다. 따라서 몸무게의 합이 198인 학생들이 선택받게 된다.  보트의 특정값과 학생들의 몸무게가 주어졌을때, 위의 조건을 만족하는 4명의 학생을 선택하시오.  입력  이 문제에서는 입력은 표준 입력을 사용한다. 입력의 첫 줄에는 T개의 테스트 케이스가 주어진다. 각 테스트 케이스에는 두 개의 정수 k와 n이 주어지며, k( 1 ≤ k ≤ 40,000,000)는 보트의 특정 값 그리고 n( 1 ≤ n ≤ 1,000 )은 KSS 각 반의 학생수이다.  이어지는 4개의 줄에 차례로 각 반의 학생들의 몸무게가 n개씩 주어진다. 이때 몸무게는 1에서 10,000,000까지이다.  출력  출력은 표준 출력을 이용한다. 각 테스트 케이스에 해당하는 값을 한 줄에 출력한다. 해당 줄에는 카누 선수로 지목된 학생들의 몸무게의 총합이 포함되어 있어야 한다.     문제풀이     코드  Java코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tint T = Integer.parseInt(br.readLine()); \t\twhile(T--&gt;0) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint k = Integer.parseInt(st.nextToken()); \t\t\tint n = Integer.parseInt(st.nextToken());  \t\t\tint[][] C = new int[4][n]; \t\t\t \t\t\tfor(int c=0; c&lt;4; c++) { \t\t\t\tst = new StringTokenizer(br.readLine()); \t\t\t\tfor(int num=0; num&lt;n; num++) { \t\t\t\t\tC[c][num] = Integer.parseInt(st.nextToken()); \t\t\t\t} \t\t\t}\t\t\t \t\t\t \t\t\tint[] C1plusC2 = new int[n*n]; \t\t\tint[] C3plusC4 = new int[n*n]; \t\t\t \t\t\tfor(int i=0; i&lt;n; i++) { \t\t\t\tfor(int j=0; j&lt;n; j++) { \t\t\t\t\tC1plusC2[i*n+j] = C[0][i] + C[1][j]; \t\t\t\t\tC3plusC4[i*n+j] = C[2][i] + C[3][j]; \t\t\t\t} \t\t\t} \t\t\t //\t\t\tC1plusC2 = Arrays.stream(C1plusC2) //\t\t\t\t\t\t\t .sorted() //\t\t\t\t\t\t\t .toArray(); //\t\t\tC3plusC4 = Arrays.stream(C3plusC4) //\t\t\t\t\t.sorted() //\t\t\t\t\t.toArray(); \t\t\tArrays.sort(C1plusC2); \t\t\tArrays.sort(C3plusC4); \t\t\t \t\t\t \t\t\tint res =  C1plusC2[0] + C3plusC4[0]; \t\t \t\t\tfor(int i=0; i&lt;C1plusC2.length; i++) { \t\t\t\tint target = k-C1plusC2[i]; \t\t\t\tint left = 0; int right = C3plusC4.length-1; \t\t\t\t \t\t\t\twhile(left &lt;= right) { \t\t\t\t\tint mid = left + (right - left)/2; \t\t\t\t\tint sum = C1plusC2[i] + C3plusC4[mid]; \t\t\t\t\t \t\t\t\t\tif(Math.abs(k-sum) &lt; Math.abs(k-res) ||  \t\t\t\t\t\t\t(Math.abs(k-sum) == Math.abs(k-res) &amp;&amp; sum &lt; res )) res=sum; \t\t\t\t\t \t\t\t\t\tif(sum==k)  break; \t\t\t\t\t \t\t\t\t\tif(C3plusC4[mid] &lt; target) left = mid+1; \t\t\t\t\telse right = mid-1; \t\t\t\t\t \t\t\t\t} \t\t\t} \t\t\t \t\t\t \t\t\tbw.write(String.valueOf(res)+\"\\n\"); \t\t}  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   C++코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int k, n;     cin &gt;&gt; k &gt;&gt; n;     vector&lt;vector&lt;int&gt;&gt; C(4, vector&lt;int&gt;(n));     for (int i = 0; i &lt; 4; i++) {         for (int j = 0; j &lt; n; j++) {             cin &gt;&gt; C[i][j];         }     }      vector&lt;int&gt; C1plusC2;     vector&lt;int&gt; C3plusC4;      for (int i = 0; i &lt; n; i++) {         for (int j = 0; j &lt; n; j++) {             C1plusC2.push_back(C[0][i] + C[1][j]);             C3plusC4.push_back(C[2][i] + C[3][j]);         }     }      sort(ALL(C1plusC2));     sort(ALL(C3plusC4));      int res = C1plusC2[0] + C3plusC4[0];      for (int i = 0; i &lt; C1plusC2.size(); i++) {         int target = k - C1plusC2[i];         int left = 0;         int right = C3plusC4.size() - 1;          while (left &lt;= right) {             int mid = left + (right - left) / 2;             int sum = C1plusC2[i] + C3plusC4[mid];              if (abs(k - sum) &lt; abs(k - res) ||                 (abs(k - sum) == abs(k - res) &amp;&amp; sum &lt; res))                 res = sum;              if (sum == k) break;             if (C3plusC4[mid] &lt; target)                 left = mid + 1;             else                 right = mid - 1;         }     }     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     cin &gt;&gt; tt;   // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_14400_편의점 2 (Java, C++)",
    "url": "/posts/BOJ14400%ED%8E%B8%EC%9D%98%EC%A0%90-2-Java-C/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-04 17:30:36 +0900",
    "content": "[Silver II] 편의점 2 - 14400  문제 링크  성능 요약  메모리: 46920 KB, 시간: 896 ms  분류  기하학, 수학, 정렬  제출 일자  2024년 12월 4일 17:28:10  문제 설명  영선이는 이번에 편의점으로 창업을 하려고 계획 중이다. 이번 창업을 위해 많은 준비를 하고 있는데, 아직 편의점을 세울 위치를 결정을 하지 못했다. 영선이는 미리 시장조사를 하여, 주요 고객들이 어느 위치에 존재하는지 파악을 하였고, 모든 고객들의 거리의 합을 최소로 하려한다. 두 위치 (x1, y1), (x2, y2)의 거리는 |x1 - x2| + |y1 - y2|로 정의한다.  n명의 주요 고객들의 위치 (xi, yi)이 주어질 때, 모든 고객들의 거리 합을 최소로 하는 위치에 편의점을 세울 때, 그 최소 거리 합을 출력하시오.  입력  첫째 줄에는 주요 고객들의 수 n이 주어진다.  다음 n줄에는 i번 고객의 위치 xi, yi가 주어진다.  출력  모든 고객들의 거리 합을 최소로 하는 위치에 편의점을 세울 때, 그 최소 거리 합을 출력하시오.     문제풀이     코드 Java코드  /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \t \tclass Coordinate implements Comparable&lt;Coordinate&gt;{ \t\tint x, y; \t\tpublic Coordinate(int x, int y) { \t\t\tthis.x = x; \t\t\tthis.y = y; \t\t} \t\t@Override \t\tpublic int compareTo(Coordinate o) { \t\t\tif(this.x == o.x) return this.y - o.y; \t\t\treturn this.x - o.x; \t\t} \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tint N = Integer.parseInt(br.readLine()); \t\tCoordinate[] coordinate = new Coordinate[N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint x = Integer.parseInt(st.nextToken()); \t\t\tint y = Integer.parseInt(st.nextToken()); \t\t\tcoordinate[i] = new Coordinate(x, y); \t\t} \t\t \t\tArrays.sort(coordinate, (o1, o2) -&gt; o1.x - o2.x);         int pos_x = coordinate[N/2].x;                  Arrays.sort(coordinate, (o1, o2) -&gt; o1.y - o2.y);         int pos_y = coordinate[N/2].y; \t\t \t\tlong res = 0; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tres += (int) (Math.abs(coordinate[i].x - pos_x) + Math.abs(coordinate[i].y - pos_y)); \t\t} \t\t \t\tbw.write(String.valueOf(res));  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }     C++ 코드  /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  using ll = long long; #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  int n; vector&lt;pair&lt;int, int&gt;&gt; board;  void solve() {     cin &gt;&gt; n;     for (int i = 0; i &lt; n; i++) {         int x, y;         cin &gt;&gt; x &gt;&gt; y;         board.push_back({x, y});     }      vector&lt;int&gt; pos_x;     for (auto&amp; p : board) {         pos_x.push_back(p.first);     }     sort(ALL(pos_x));     int mid_x = pos_x[n / 2];      vector&lt;int&gt; pos_y;     for (auto&amp; p : board) {         pos_y.push_back(p.second);     }     sort(ALL(pos_y));     int mid_y = pos_y[n / 2];      ll res = 0;     for (const auto&amp; p : board) {         res += abs(p.first - mid_x) + abs(p.second - mid_y);     }     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "BOJ_2110_공유기 설치 (C++, Java)",
    "url": "/posts/BOJ2110%EA%B3%B5%EC%9C%A0%EA%B8%B0-%EC%84%A4%EC%B9%98-C-Java/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-12-03 02:59:55 +0900",
    "content": "[Gold IV] 공유기 설치 - 2110  문제 링크  성능 요약  메모리: 31000 KB, 시간: 280 ms  분류  이분 탐색, 매개 변수 탐색  제출 일자  2024년 12월 3일 02:52:41  문제 설명  도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, ..., xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.  도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.  C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.  입력  첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.  출력  첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.     문제 풀이     집 간격 res로 이분탐색. 두가지 언어로 푸는데 50분정도 걸린 것 같다.  코드 C++코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N, C;     cin &gt;&gt; N &gt;&gt; C;     vector&lt;int&gt; arr;      int pos;     for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; pos;         arr.push_back(pos);     }     sort(ALL(arr));     int minlen = 1;     int maxlen = (arr[N - 1] - arr[0]) / (C - 1);     int res = 0;      while (minlen &lt;= maxlen) {         int mid = minlen + (maxlen - minlen) / 2;          int currPos = arr[0];         int tmpCnt = 1;         for (int i = 1; i &lt; N; i++) {             if (arr[i] - currPos &gt;= mid) {                 tmpCnt++;                 currPos = arr[i];             }         }          if (tmpCnt &lt; C) {             maxlen = mid - 1;         } else {             res = mid;             minlen = mid + 1;         }     }     cout &lt;&lt; res &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }   Java코드  /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, C, arr[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tN = Integer.parseInt(st.nextToken()); \t\tC = Integer.parseInt(st.nextToken()); \t\tarr = new int[N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(br.readLine()); \t\t} \t\t \t\tarr = Arrays.stream(arr) \t\t\t\t\t.sorted() \t\t\t\t\t.toArray(); \t\t \t\tint minLen = 1; \t\tint maxLen = (arr[N-1] - arr[0]) / (C-1); \t\tint res = 1; \t\t \t\twhile(minLen &lt;= maxLen) { \t\t\tint mid = minLen + (maxLen-minLen)/2; \t\t\tint currPos = arr[0]; \t\t\tint tmpCnt = 1; \t\t\t \t\t\tfor(int i=1; i&lt;N; i++) { \t\t\t\tif(arr[i] - currPos &gt;= mid) { \t\t\t\t\ttmpCnt++; \t\t\t\t\tcurrPos = arr[i]; \t\t\t\t} \t\t\t} \t\t\t \t\t\tif(tmpCnt &gt;= C) { \t\t\t\tres = mid; \t\t\t\tminLen = mid+1; \t\t\t} \t\t\telse { \t\t\t\tmaxLen = mid-1; \t\t\t} \t\t} \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "Java to C++ ",
    "url": "/posts/Java-to-C/",
    "categories": "공부",
    "tags": "C++, Java",
    "date": "2024-12-02 18:26:27 +0900",
    "content": "   개발 공부를 하다보면 다른 개발언어로 작성된 코드를 볼 일도 많고 특히 해외 사이트에서 discussion을 볼 일이 잦았는데 C/C++ 코드를 볼 일이 상당히 많았다. 자료구조 위주로 비교하며 자바를 C++로 어떻게 작성되는지 알아보고자 공부하였다.     데이터 유형 및 변수 C++에서 숫자를 저장하는 방법    자바와 마찬가지로 int, double가 있다. 하지만 int와 같은 숫자 유형의 범위는 machine에 따라 다르다. DOS, Windows 3.x를 실행하는 PC와 같은 16비트 시스템에서는 Java의 4바이트 int와 달리 2바이트다. 이러한 머신에서는 int범위가 충분하지 않을 때 마다 long으로 전환해야한다.   C++에는 숫자를 더 효율적으로 저장할 수 있는 short 및 unsigned 유형이 있다. 추가 효율성이 중요하지 않은 한 이러한 유형을 피하는 것이 가장 좋다.  boolean유형은 C++에서는 bool로 사용한다. string유형은 string이라고 하며 Java와 매우 유사하다. 다음과 같은 차이점이 있다.    C++ 문자열은 아스키코드가 아닌 유니코드로 저장된다.   C++ 문자열은 수정가능하지만 자바는 수정 불가능하다.   C++ 하위 문자열 연산은 substr아 합니다. s.substr(i, n)은 i위치에서 길이 n인 하위 문자열을 추출한다.   문자열은 다른 문자열과만 연결할 수 있으며, 임의의 객체와는 연결할 수 없다.   문자열을 비교하려면 관계 연산자 == != &lt; &lt;= &gt; &gt;= 를 사용한다. 마지막 4개의 연산자는 사전식으로 비교를 수행한다. 실제로 Java에서 equals와 compareTo를 사용하는것보다 편리하다.   변수와 상수 다음과 같이 지역 변수가 선언된다. int n = 5;  그러나 Java와 큰 차이가 있다. C++ 컴파일러는 모든 로컬 변수가 읽기 전에 초기화 되었는지 확인하지 않으므로 변수를 초기화하는것을 잊기 쉽다. 그러면 변수의 값은 로컬 변수가 차지하는 메모리 위치에 우연히 있던 무작위 비트 패턴이다. 이는 프로그래밍 오류의 원천이다.  Java에서와 같이 클래스는 데이터필드와 정적 변수를 가질 수 있다. 그리고 변수는 함수와 클래스 외부에서 선언될 수 있다. 이러한 전역변수는 프로그램의 모든 함수에서 엑세스할 수 있다. C++는 전연변수를 피해야한다.  C++ 에서 상수는 어디에서나 선언될 수 있다. (Java에서 상수는 클래스의 정적 데이터여야 했다). C++에서는 const키워드를 사용한다. const int 1년당일수 = 365;  클래스 C++에서 클래스의 정의는 Java와 다르다.  class Point { public:     Point();     Point(double xval, double yval);     void move(double dx, double dy);     double getX() const;     double getY() const; private: \tdouble x;     double y; };   몇 가지 중요한 차이점    C++에는 public 및 private 섹션이 있으며 키워드 public 및 private로 시작한다. Java에서는 각 개별 항목에 public 또는 private태그를 지정한다.   클래스 정의는 메서드 선언만 포함한다. 실제 구현은 별도로 나열된다.   접근자 메서드는 키워드 const로 태그된다.   클래스 끝에 세미콜론이 있다. 메서드 구현은 클래스 정의를 따른다. 메서드는 클래스 외부에서 정의되므로 각 메서드 이름 앞에 클래스 이름이 접두사로 붙는다. :: 연산자는 클래스와 메서드 이름을 구분한다. 암묵적 매개변수를 수정하지 않는 엑세서 메서드는 const로 태그가 지정된다.   Point::Point() { x = 0, y = 0 }  void Point::move(double dx, double dy) { \tx = x + dx;     y = y + dy; }  double Point::getX() const { \treturn x; }   객체 Java와 C++의 주요 차이점은 객체 변수의 동작이다. C++에서 객체 변수는 객체 참조가 아닌 값을 보유한다. C++에서 객체를 생성할 때는 new 연산자를 사용하지 않는다. 변수 이름 뒤에 생성 매개변수를 제공하기만 하면 된다. Point p(1, 2); 생성매개변수를 제공하지 않으면 객체는 기본 생성자를 사용해 생성된다. Time now;  이는 자바와 매우 다르다. Java에서 이 명령은 단지 초기화되지 않은 참조를 생성할 뿐이다. C++에서는 실제로 객체를 구성한다. 한 객체가 다른 객체에 할당되면 실제 값의 사본이 만들어진다. Java에서 객체 변수를 복사하면 객체에 대한 두번째 참조가 설정될 뿐이다. C++객체를 복사하는 것은 Java에서 clone을 호출하는 것과 같다. 사본을 수정해도 원본이 변경되지는 않는다.  Point q = p; q.move(1, 1);  대부분의 경우 객체가 값처럼 동작한다는 사실은 매우 편리하다. 그러나 이러한 동작이 바람직하지 않은 상황이 꽤 있다.    함수에서 객체를 수정할 때는 참조로 호출을 사용해야 한다는 점   두 객체 변수는 하나의 객체에 공동으로 접근할 수 없다. C++에서 이 효과가 필요한 경우 포인터를 사용해야한다.   객체 변수는 특정 유형의 값만 보관할 수 있다. 변수가 다른 하위 클래스의 객체를 보관하도록 하려면 포인터를 사용해야 한다.   변수가 null 또는 실제 객체를 가리키도록 하려면 C++에서 포인터를 사용해야한다.   기능 Java에서 모든 함수는 클래스의 인스턴스 메서드 또는 정적 함수여야 한다. C++는 클래스의 인스턴스 메서드와 정적 함수를 지원하지만, 어떤 클래스에도 속하지 않는 함수도 허용한다. 이러한 함수를 전역 함수라고 한다. 특히, 모든 C++함수는 전역 함수 main으로 시작한다. ` int main() { \t… } ` 명령줄 인수를 캡처하는데 사용할 수 있는 두 번째 main이 있지만 이를 사용하려면 C 스타일 배열과 문자열에 대한 지식이 필요하며, 여기서는 다루지 않겠다.  프로그램이 성공적으로 완료되면 main의 반환값은 0이고, 그렇지 않으면 0이 아닌 정수이다. Java에서와 마찬가지로 함수 인수는 값으로 전달된다. Java에서 함수는 그럼에도 불구하고 객체를 수정할 수 있었다. 하지만 C++객체값은 실제 객체에 대한 참조가 아니기 때문에 함수는 실제 인수의 사본을 받고 따라서 원본을 수정할 수 없다. 따라서 C++에는 두 가지 매개변수 전달 매커니즘이 있다. 값에 의한 호출(Java에서처럼)과 참조에 의한 호출이다. 매개변수가 참조에 의해 전달되면 함수는 원본을 수정할 수 있다. 참조에 의한 호출은 매개변수 유형 뒤에 &amp;로 표시된다.  void raiseSalary(Employee&amp; e, double by) { \t... }   다음은 참조에 의한 호출을 활용하는 전형적인 함수다. Java에서 이러한 함수를 작성하는것은 불가능하다. void swap(int&amp; a, int&amp; b) { \tint tmp = a;     a = b;     b = tmp; }  이 함수가 swap(x, y)로 호출되면 참조 매개변수 a, b는 인수 x와 y의 위치를 참조하며, 이러한 인수의 값을 참조하지 않는다. 따라서 함수는 실제로 이러한 변수의 내용을 스왑할 수 있다. C++에서는 함수가 매개변수를 수정해야할 때 항상 참조 호출을 사용한다.  벡터  C++ 벡터 구조는 Java에서 배열과 벡터의 가장 좋은 특징을 결합한다. C++벡터는 편리한 요소 엑세스가 가능하며 동적으로 커질 수 있다. T가 임의의 유형이면 vector&lt;T&gt;는 T유형의 요소의 동적 배열이다.  명령어 vector&lt;int&gt; a; 는 처음에 비어있는 벡터를 만든다. vector&lt;int&gt; a(100); 는 처음에 100개의 요소를 갖는 벡터를 만든다. push_back 메서드로 더 많은 요소를 추가할 수 있다. a.push_back(n);  a.pop_back() 호출은 a에서 마지막 요소를 제거한다. size메서드를 사용해 a의 현재 요소 수를 찾는다. 익숙한 [] 연산자를  사용해 요소에 접근한다. for(i=0; i&lt;a.size(); i++)     sum = sum + a[i];  Java에서와 같이 배열 인덱스는 0과 a.size() -  1 사이여야한다. 그러나 Java와 달리 합법적인 배열 인덱스에 대한 런타임 검사가 없다. 그렇기 때문에 잘못된 인덱스에 접근하면 매우 심각한 에러가 발생할 수 있다. 벡터도 마찬가지로 C++객체와 같이 값이기 때문에 한 벡터를 다르 벡터에 할당하면 모든 요소가 복사된다. vector&lt;int&gt; b = a; // 모든 요소가 복사됨  이를 Java와 비교해보자. Java에서 배열 변수는 배열에 대한 참조다. 변수의 사본을 만들면 같은 배열에 대한 두 번째 참조가 생성된다. 이러한 이유로 벡터를 수정하는 C++함수는 참조 매개변수를 사용해야한다! void sort(vector&lt;int&gt;&amp; a) { \t... }   입력 및 출력  C++에서 표준 입력 및 출력 스트림은 cin 및 cout 객체로 표현된다. &lt;&lt; 연산자를 사용해 출력을 작성한다. cout &lt;&lt; \"Hello World!\";  여러 항목도 가능 cout &lt;&lt; \"The answer is \" &lt;&lt; x &lt;&lt; \"\\n\";  입력에서 숫자나 단어를 읽으려면 &gt;&gt; 연산자를 사용한다. // 숫자 double x; cout &lt;&lt; \"Please enter x: \"; cin &gt;&gt; x;  // 문자 string name; cout &lt;&lt; \"Please enter your name: \"; cin &gt;&gt; name;  getline 메서드는 입력의 전체 줄을 읽는다. Java의 readLine()과 비슷하다. string inputLine; getline(cin, inputLine);  입력의 끝에 도달했거나 숫자를 올바르게 읽을 수 없는 경우 stream은 실패 상태로 설정된다. fail 메서드로 이를 테스트할 수 있다. int n; cin &gt;&gt; n; if (cin.fail()) cout &lt;&lt; \"Bac input\";  스트림 상태가 실패하면 쉽게 재설정할 수 없다. 프로그램에서 잘못된 입력을 처리해야 하는 경우 getline을 사용한 다음 수동으로 입력을 처리해야 한다.  포인터  C++에서 객체 변수는 객체 값을 보관한다. 이는 객체 변수가 다른곳에 저장된 객체 값에 대한 참조일 뿐 Java와 다르다. C++에서 동일한 배열이 필요한 상황이 있다. C++에서 객체를 참조할 수 있는 변수를 포인터라고 한다. T가 임의의 유형이면 T*는 T유형의 객체에 대한 포인터다.  Java에서와 마찬가지로 포인터 변수는 다른 포인터 변수 혹은 new 호출로 초기화될 수 있다. Employee* p = NULL; Employee* q = new Employee(\"Hacker, Harry\", 35000); Employee* r = q;  다른 네번째 방법은 &amp;연산자를 사용해 다른 객체의 주소로 초기화될 수 있다. Employee boss(\"Morris, Melinda\", 83000); Employee* s = &amp;boss;  이는 좋은 방법이 아니다. C++포인터는 new로 할당된 객체만 참조해야한다.  지금까지의 C++포인터는 Java 객체 변수와 매우 유사하다. 그러나 필수적인 구문적 차이가 있다. 포인터가 가리키는 객체에 엑세스하려면 * 연산자를 적용해야한다. p가 Employee객체에 대한 포인터인 경우 *p 는 해당 객체를 참조한다. Employee* p = ...; Employee boss = *p;  메서드를 실행하거나 데이터 필드에 엑세스하려면 *p를 참조해야한다. (*p).setSalary(91000);  여기서 괄호는 . 연산자가 *연산자보다 우선순위가 높기 때문에 필요함. C의 설계자들은 이것이 보기 흉하다는 생각에 *와 .을 결합하여 -&gt; 연산자를 제공한다. p-&gt;setSalary(91000);  *p 객체에서 setSalary메서드를 호출한다. 객체에서는 .연산자를 사용하는것과 포인터에서는 -&gt;연산자를 사용하는 것을 기억하자!  포인터를 초기화하지 않거나, NULL이거나, 더이상 존재하지 않는 객체를 참조하는 경우 * 또는 -&gt;연산자를 적용하는 것은 error다. 안타깝게도 C++ 런타임 시스템은 이러한 오류를 확인하지 않는다. 이러한 실수를 하면 프로그램들이 죽거나 불안정하게 작동할 수 있다.  Java에서는 이러한 오류가 발생할 수 없다. 초기화되지 않은 참조는 있을 수 없다. 모든 객체는 참조가 있는 한 살아있다. 따라서 삭제된 객체에 대한 참조는 있을 수 없다. 런타임 시스템은 null참조를 확인하고 null포인터에 엑세스하면 null pointer exception을 throw한다.  C++과 Java사이에는 또 다른 중요한 차이점이 있다. Java에는 더 이상 필요하지 않은 모든 객체를 자동으로 회수하는 Garbage Collector이 있다. C++에서는 프로그래머가 메모리를 관리해야한다.  객체 변수는 범위를 벗어나면 자동으로 회수된다. 그러나 new로 생성된 객체는 delete연산자로 수동으로 회수해야한다. Employee p = new Emplyee(\"Hacker, Harry\" 38000); \t.     .     . delete p; /* 더이상 이 객체가 필요하지 않음 */  객체를 삭제하는 것을 잊으면 결국 모든 메모리가 소진될 수 있다. 이를 Memory Leak이라고 한다. 더 중요한 것은, 객체를 삭제한 다음 계속 사용하면 더이상 소유하지 않는 데이터를 덮어쓸 수 있다는 것이다. 재활용 스토리지를 관리하는데 사용되는 데이터 필드를 덮어쓰면 할당 메커니즘이 오작동하여 진단 및 수정이 매우 어려운 미묘한 오류가 발생할 수 있다. 이러한 이유로 C++에서 포인터 사용을 최소화하는 것이 가장 좋다!  상속  상속의 기본 구문은 Java와 C++이 비슷하다. extends 대신 : public을 사용한다. (C++는 또한 Private 상속이라는 개념을 지원하지만 그다지 유용하진 않다.) 기본적으로 함수는 C++에서 동적으로 바인딩되지 않는다. 특정 함수에 대한 동적 바인딩을 원하면 virtual로 선언해야한다.  class Manager : public Employee { \tpublic:     \tManager(string name, double salary, string dept);         virtualvoid print() const; \tprivate:     \tstring department; };  Java에서와 같이 생성자가 슈퍼클래스의 생성자를 호출하는 특수 구문이 있다. 자바는 키워드 super를 사용한다. C++에서는 서브클래스 생성자의 본문 밖에서 슈퍼클래스 생성자를 호출해야한다.  Ex) Manager::Manager(string name, double salary, string dept) : Employee(name, salary) /* 슈퍼 클래스 메서드 호출 */ { \tdepartment = dept; }  Java는 서브클래스 메서드가 슈퍼클래스 메서드를 호출할 때 super키워드를 사용한다. C++에서는 슈퍼클래스 이름과 ::연산자를 사용한다. void Manager::print() const { \tEmployee::print(); /* 슈퍼클래스 메서드 호출*/ \tcout &lt;&lt; department &lt;&lt; \"\\n\"; }  C++ 객체 변수는 특정 유형의 객체를 보관한다. C++에서 다형성을 활용하려면 포인터가 필요하다. T* 포인터는 T의 모든 하위 클래스의 객체를 가리킬 수 있다. vector&lt;Employee*&gt; staff; \t.     .     .     for(i=0; i&lt;staff.size(); i++) {     \tstaff[i] -&gt; print();     }   References Java to C++ "
  },
  
  {
    "title": "BOJ_17510_Bigger Sokoban 40k",
    "url": "/posts/BOJ17510/",
    "categories": "알고리즘",
    "tags": "백준, 알고리즘",
    "date": "2024-12-02 03:14:42 +0900",
    "content": "[Ruby V] Bigger Sokoban 40k - 17510  문제 링크  성능 요약  메모리: 4528 KB, 시간: 0 ms  분류  해 구성하기  제출 일자  2024년 12월 2일 03:01:22  문제 설명 문제 Sokoban is a famous puzzle game, where the player moves around in the  $N \\times M$-size grid, and pushes $1 \\times 1$-size boxes to $1 \\times 1$-size storage locations.  Bigger Sokoban is a possible variation of Sokoban, but the size of boxes and storage locations are bigger than $1 \\times 1$. This problem especially uses  $2 \\times 2$ for both.  The rule of Bigger Sokoban is the same as Sokoban. Each square in the grid is an empty square or a wall. Some $2 \\times 2$ area of empty squares contain  $2 \\times 2$-size box each and some $2 \\times 2$ area of empty squares are marked as $2 \\times 2$-size storage location each.  The player is in the grid and may move up, down, left, right to the adjacent empty squares, but should not go through walls, boxes, or outside of the grid. If the player tries to move into a box, it is pushed to the adjacent squares in that direction. Boxes must not be pushed to other boxes, walls, or outside of the grid, and they cannot be pulled. The number of boxes is equal to the number of storage locations. The puzzle is solved when all boxes are at the storage locations.  Your mission is to make a Bigger Sokoban grid that needs at least 40 000 moves to solve. To make the situation easier, the grid must satisfy the following constraints:       $1 \\leq N, \\; M, \\; N+M \\leq 100$.   The grid contains one box and one storage location.   The player, the box, and the storage location must not intersect.   입력  There are no inputs for this problem.  출력  In the first line, print two space-separated integers  $N,\\ M$; they describe the size of the grid.  In each of the following $N$ lines, print a string of length $M$; it describes each row of the grid. Each string must consist of ., #, P, B, S; each character means empty square, wall, player, box, storage location respectively.  The grid must contain exactly one P, exactly four B, and exactly four S. B and S each must form a  $2 \\times 2$ square. The grid, of course, must be solvable.  Note that the sample output is only to demonstrate a well-formatted output. Since it can be solved in less than 40 000 moves, it is not a correct answer.     문제 풀이       요약그림이다. 일단 N+M이 100이하이므로 50x50그리드를 생각하고 시작했다. 이 안에서 최대한 많은 왕복 (최소 400회)를 해야했는데 그니까 이 그림처럼 꼬불꼬불한 연결되어있는미로를 생각했다. 박스 전후로 이어져있어 박스를 밀려면 다시 돌아가야하는 것이다. 이걸 이용하면 사실 꼬불꼬불한 길을 최대한 꼬불꼬불하게 해서 경로 길이를 늘리고 여러번 왕복시키면 된다. 이때 코너링, 즉 방향을 전환할 때 강제로 경로를 반대로 돌도록 만들었다. 목표는 100개의 코너링을 만드는거였지만 정사각형이 베스트고 이 그리드 크기제한에 의해 90개의 코너링을 만들었다. 그럼 이 경로x90회만큼 이동횟수가 복사가 된다. 이 경로는 길이 약 500정도로 계산하고 만들었는데 나의 목표였던 500x100보다 좀 작은 수준으로 40000을 넘어 성공하도록 만들었다.  코드 #######...#....##...#....##...#....##...#....##... #BB.......#.........#.........#.........#......... .BBP......#.........#.........#.........#......... .######...##..###...##..###...##..###...##..###... .######..###...##..###...##..###...##..###...##..# .#####.........#.........#.........#.........##..# .#####.........#.........#.........#.........##..# .#####....##...#....##...#....##...#....##...##..# .##############################################..# .######...##....#...##....#...##....#...##....#..# .######.........#.........#.........#.........#..# .######.........#.........#.........#.........#..# .######...###..##...###..##...###..##...###..##..# .#...###..##...###..##...###..##...###..##...##..# .#.........#.........#.........#.........#.......# .#.........#.........#.........#.........#........ .#...##....#...##....#...##....#...##....#...#.... .##..############################################# .##..##...#....##...#....##...#....##...#....##... .#........#.........#.........#.........#......... .#........#.........#.........#.........#......... .#....#...##..###...##..###...##..###...##..###... .######..###...##..###...##..###...##..###...##..# .#####.........#.........#.........#.........##..# .#####.........#.........#.........#.........##..# .#####....##...#....##...#....##...#....##...##..# .##############################################..# .######...##....#...##....#...##....#...##....#..# .######.........#.........#.........#.........#..# .######.........#.........#.........#.........#..# .######...###..##...###..##...###..##...###..##..# .#...###..##...###..##...###..##...###..##...##..# .#.........#.........#.........#.........#.......# .#.........#.........#.........#.........#........ .#...##....#...##....#...##....#...##....#...#.... .##..############################################# .##..##...#....##...#....##...#....##...#....##... .#........#.........#.........#.........#......... .#........#.........#.........#.........#......... .#....#...##..###...##..###...##..###...##..###... .######..###...##..###...##..###...##..###...##..# .#####.........#.........#.........#.........##..# .#####.........#.........#.........#.........##..# .#####....##...#....##...#....##...#....##...##..# .##############################################..# .#...#...#...#...#...#...#...#...#...#...#...##..# .#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#SS#..# .#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#SS.... .#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#...... ...#...#...#...#...#...#...#...#...#...#.....#....  "
  },
  
  {
    "title": "BOJ_14453_Hoof, Paper, Scissors (Silver) (C++)",
    "url": "/posts/BOJ14453Hoof-Paper-Scissors-Silver-C/",
    "categories": "알고리즘",
    "tags": "C++, 백준, 알고리즘",
    "date": "2024-12-01 23:00:18 +0900",
    "content": "[Silver II] Hoof, Paper, Scissors (Silver) - 14453  문제 링크  성능 요약  메모리: 3808 KB, 시간: 4 ms  분류  다이나믹 프로그래밍, 누적 합  제출 일자  2024년 12월 1일 22:54:53  문제 설명  You have probably heard of the game \"Rock, Paper, Scissors\". The cows like to play a similar game they call \"Hoof, Paper, Scissors\".  The rules of \"Hoof, Paper, Scissors\" are simple. Two cows play against each-other. They both count to three and then each simultaneously makes a gesture that represents either a hoof, a piece of paper, or a pair of scissors. Hoof beats scissors (since a hoof can smash a pair of scissors), scissors beats paper (since scissors can cut paper), and paper beats hoof (since the hoof can get a papercut). For example, if the first cow makes a \"hoof\" gesture and the second a \"paper\" gesture, then the second cow wins. Of course, it is also possible to tie, if both cows make the same gesture.  Farmer John wants to play against his prize cow, Bessie, at N games of \"Hoof, Paper, Scissors\" (1 ≤ N ≤ 100,000). Bessie, being an expert at the game, can predict each of FJ's gestures before he makes it. Unfortunately, Bessie, being a cow, is also very lazy. As a result, she tends to play the same gesture multiple times in a row. In fact, she is only willing to switch gestures at most once over the entire set of games. For example, she might play \"hoof\" for the first x games, then switch to \"paper\" for the remaining N−x games.  Given the sequence of gestures FJ will be playing, please determine the maximum number of games that Bessie can win.  입력  The first line of the input file contains N.  The remaining N lines contains FJ's gestures, each either H, P, or S.     출력  Print the maximum number of games Bessie can win, given that she can only change gestures at most once.     문제 풀이   기본적인 누적합 문제다. 주어진 char들로 미리 3xn짜리 2차원배열에서 입력받은 제스처에 몇번 이기는지를 적어놓고 반복문을 통해 스위칭인덱스까지 + 그뒤부터 끝까지의 합을 더해서 최대갱신으로 값을 구하면된다. 쉽지만 C++로 첫 실버를 풀어봐서 자료구조에서 좀 해맸다.  2차원 배열을 위해 vector 안에 vector을 만들었다. vector&lt;vector&lt;int&gt;&gt; prefixSum(3, vector&lt;int&gt;(N + 1));  최댓값은 java의 Math.max와 비슷하게 max(a, b) 처럼 바로 사용할 수 있다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ #include &lt;bits/stdc++.h&gt; using namespace std;  // #define int long long #define MOD 1000000007 #define INF LLONG_MAX #define ALL(v) v.begin(), v.end()  #ifdef LOCAL #include \"algo/debug.h\" #else #define debug(...) 42 #endif  void solve() {     int N;     cin &gt;&gt; N;     vector&lt;char&gt; gestures(N);     for (int i = 0; i &lt; N; i++) {         cin &gt;&gt; gestures[i];     }     /**      * prefixSum[0] : H, prefixSum[1] : S , prefixSum[2] : P      */     vector&lt;vector&lt;int&gt;&gt; prefixSum(3, vector&lt;int&gt;(N + 1));      for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; 3; j++) {             prefixSum[j][i + 1] = prefixSum[j][i];         }          if (gestures[i] == 'H') prefixSum[2][i + 1]++;         if (gestures[i] == 'S') prefixSum[0][i + 1]++;         if (gestures[i] == 'P') prefixSum[1][i + 1]++;     }     int maxCnt = 0;      for (int first = 0; first &lt; 3; first++) {         for (int second = 0; second &lt; 3; second++) {             for (int switchIdx = 0; switchIdx &lt;= N; switchIdx++) {                 int tmp = prefixSum[first][switchIdx] +                           (prefixSum[second][N] - prefixSum[second][switchIdx]);                 maxCnt = max(maxCnt, tmp);             }         }     }     cout &lt;&lt; maxCnt &lt;&lt; \"\\n\"; }  int main() {     ios::sync_with_stdio(false);     cin.tie(nullptr);      int tt = 1;  // 기본적으로 1번의 테스트 케이스를 처리     // cin &gt;&gt; tt;    // 테스트 케이스 수 입력 (필요 시)      while (tt--) {         solve();     }     return 0; }  "
  },
  
  {
    "title": "Java-Competitive-Programming (feat. Codeforces)",
    "url": "/posts/Java-Competitive-Programming-feat.-Codeforces/",
    "categories": "알고리즘",
    "tags": "codeforces, cp",
    "date": "2024-12-01 20:35:48 +0900",
    "content": "   다음과 같은 알고리즘 대회/코딩 테스트 백준, 코드포스 등의 온라인 저지 대량의 데이터를 빠르게 처리해야 하는 상황 수학적 계산이 많이 필요한 문제   /**  * Author: nowalex322, Kim HyeonJae  */ import java.util.*; import java.io.*; public class Main{     // Basic Template for Algorithm     static long inf = (long) (1e18);     static PrintWriter out;     static FastReader sc;     static final Random random=new Random();     static long mod=1000000007L;     static StringTokenizer st;     static BufferedReader br;;     // Math functions     public static long max(long a, long b) {return a &gt; b ? a : b;}     public static long min(long a, long b) {return a &lt; b ? a : b;}     public static long ceil(long a, long b) {return ((long) Math.ceil(((double) (a) / b)));}     public static long abs(long a) {return a &lt; 0 ? (-1 * a) : a;}     public static long log(long a) {return (long) (Math.log(a));}     //Math INTEGER FUNCITONS     public static int max(int a, int b) {return a &gt; b ? a : b;}     public static int min(int a, int b) {return a &lt; b ? a : b;}     public static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}     public static int lcm(int a, int b) {return (a / gcd(a, b)) * b;}     public static int abs(int a) {return a &lt; 0 ? -1 * a : a;}     //Log base 2     public static long log2(long a) {return (long) (Math.log(a) / Math.log(2));}     public static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}public static long lcm(long a, long b) {return ((a * b) / gcd(a, b));}     public static long add(long a, long b) {return (((a + mod) % mod + (b + mod) % mod) % mod);}     public static long sub(long a, long b) {return (((a + mod) % mod + ((-1 * b) + mod) % mod) % mod);}     public static long mul(long a, long b) {return ((a % mod * b % mod) % mod);}     public static long inv(long x) {return pow(x, mod - 2);}     public static long div(long x, long y) {return mul(x, inv(y));}     // Precise Integer square root     // Math.sqrt doesnt work precisely for big numbers :(     public static int sqrt(int x) {int start = 0, end = (int) 1e5, ans = 1;while (start &lt;= end) {int mid = (start + end) / 2;if ((long)mid * mid &lt;= x) {ans = mid;start = mid + 1;} else end = mid - 1;}return ans;}     public static long sqrt(long x) {long start = 0, end = (long) 3e9, ans = 1;while (start &lt;= end) {long mid = (start + end) / 2;if (mid * mid &lt;= x) {ans = mid;start = mid + 1;} else end = mid - 1;}return ans;}     // POWER CALCULATION IN SHORTER TIME     public static long pow(long a, long b) {a %= mod;long res = 1;while (b &gt; 0) {if ((b &amp; 1) != 0) res = mul(res, a);a = mul(a, a);b /= 2;}return res;}     // FACTORIAL calculation     public static long Fact(long n) {long fact = 1;if (n == 0 || n == 1) {} else {for (long i = 1; i &lt;= n; i++) fact = fact * i;}return fact;}     public static int Fact(int n) {int fact = 1;if (n == 0 || n == 1) {} else {for (int i = 1; i &lt;= n; i++) fact = fact * i;}return fact;}     // O(root n) Prime CHECK calculation     public static boolean prime(long n) {for (long i = 2; i &lt;= sqrt(n); i++) {if (n % i == 0) {return false;}}return true;}     //RUFFLE SORT 1-D INTEGER ARRAY     static void ruffleSort(int[] a) {int n = a.length;for (int i = 0; i &lt; n; i++) {int oi = random.nextInt(n), temp = a[oi];a[oi] = a[i];a[i] = temp;}Arrays.sort(a);}     // Sort 1-D LONG type array     public static void sort(long a[]) {divide(a, 0, a.length - 1);}public static void divide(long a[], int l, int r) {if (l &lt; r) {int m = l + (r - l) / 2;divide(a, l, m);divide(a, m + 1, r);merge(a, l, m, r);}}public static void merge(long a[], int l, int m, int r) {int n1 = m - l + 1;int n2 = r - m;long L[] = new long[n1];long R[] = new long[n2];for (int i = 0; i &lt; n1; ++i) {L[i] = a[l + i];}for (int j = 0; j &lt; n2; ++j) {R[j] = a[m + 1 + j];}int i = 0, j = 0;int k = l;while (i &lt; n1 &amp;&amp; j &lt; n2) {if (L[i] &lt;= R[j]) {a[k] = L[i];i++;} else {a[k] = R[j];j++;}k++;}while (i &lt; n1) {a[k] = L[i];i++;k++;}while (j &lt; n2) {a[k] = R[j];j++;k++;}}     // Sort 1-D LONG type array in descending order     public static void rsort(long a[]) {rdivide(a, 0, a.length - 1);}public static void rdivide(long a[], int l, int r) {if (l &lt; r) {int m = l + (r - l) / 2;rdivide(a, l, m);rdivide(a, m + 1, r);rmerge(a, l, m, r);}}public static void rmerge(long a[], int l, int m, int r) {int n1 = m - l + 1;int n2 = r - m;long L[] = new long[n1];long R[] = new long[n2];for (int i = 0; i &lt; n1; ++i) {L[i] = a[l + i];}for (int j = 0; j &lt; n2; ++j) {R[j] = a[m + 1 + j];}int i = 0, j = 0;int k = l;while (i &lt; n1 &amp;&amp; j &lt; n2) {if (L[i] &gt;= R[j]) {a[k] = L[i];i++;} else {a[k] = R[j];j++;}k++;}while (i &lt; n1) {a[k] = L[i];i++;k++;}while (j &lt; n2) {a[k] = R[j];j++;k++;}}     //PRINT ANYTHING FUNCTION     static &lt; E &gt; void print(E res) {out.println(res);out.flush();}     // Finding sum  and product of LONG TYPEarray elements     public static long sum(long a[]) {long s = 0;for (int i = 0; i &lt; a.length; i++) {s = (s + a[i]);}return s;}     public static long mul(long a[]) {long s = 1;for (int i = 0; i &lt; a.length; i++) {s = (s * a[i]);}return s;}     // Finding sum  and product of INT TYPEarray elements     public static int sum(int a[]) {int s = 0;for (int i = 0; i &lt; a.length; i++) {s = (s + a[i]);}return s;}     public static int mul(int a[]) {int s = 1;for (int i = 0; i &lt; a.length; i++) {s = (s * a[i]);}return s;}     // MAX IN ARRAY     public static int max(long a[]) {int in = 0;long m = a[0];for (int i = 1; i &lt; a.length; i++) {if (a[i] &gt; m) {m = a[i];in = i;}}return in;}     // MIN IN ARRAY     public static int min(long a[]) {int in = 0;long m = a[0];for (int i = 1; i &lt; a.length; i++) {if (a[i] &lt; m) {m = a[i];in = i;}}return in;}     public static long arrmax(long[] a) { return a[max(a)];}     public static long arrmin(long[] a) { return a[min(a)];}     // ARRAY PRINTING     public static void arrprint(long a[]) {for (int i = 0; i &lt; a.length; i++) {out.print(a[i] + \" \");out.flush();}out.println();out.flush();}     public static void arrprint(double a[]) {for (int i = 0; i &lt; a.length; i++) {out.print(a[i] + \" \");out.flush();}out.println();out.flush();}     public static void arrprint(int a[]) {for (int i = 0; i &lt; a.length; i++) {out.print(a[i] + \" \");out.flush();}out.println();out.flush();}     public static void arrprint(char a[]) {for (int i = 0; i &lt; a.length; i++) {out.print(a[i]);out.flush();}out.println();out.flush();}     //REVERSE ARRAY PRINTING     public static void revarrprint(long a[]) {for (int i = a.length - 1; i &gt;= 0; i--) {out.print(a[i] + \" \");}out.println();out.flush();}     public static void revarrprint(int a[]) {for (int i = a.length - 1; i &gt;= 0; i--) {out.print(a[i] + \" \");}out.println();out.flush();}     public static void revarrprint(double a[]) {for (int i = a.length - 1; i &gt;= 0; i--) {out.print(a[i] + \" \");}out.println();out.flush();}     //STRING MANIPULATION     //Reverse a char array     public static String rev(char s[]) {int n = s.length;for (int i = 0; i &lt; n / 2; i++) {char temp = s[i];s[i] = s[n - 1 - i];s[n - 1 - i] = temp;}return new String(s);}     //Reverse a String with spaces using StringBuilder     public static String rev(String s) {return new StringBuilder(s).reverse().toString();}     //FAST READER     static class FastReader {         BufferedReader br;         StringTokenizer st;         public FastReader() {             br = new BufferedReader(new InputStreamReader(System.in));         }         String next() {while (st == null || !st.hasMoreElements()) {try {st = new StringTokenizer(br.readLine());} catch (IOException e) {e.printStackTrace();}}return st.nextToken();}         int nextInt() {return Integer.parseInt(next());}         long nextLong() {return Long.parseLong(next());}         double nextDouble() {return Double.parseDouble(next());}         String nextLine() {String str = \"\";try {str = br.readLine();} catch (IOException e) {e.printStackTrace();}return str;}         //INPUT INT ARRAY         int[] readintarray(int n) {int res[] = new int[n];for (int i = 0; i &lt; n; i++) res[i] = nextInt();return res;}         //INPUT INT ARRAYLIST         ArrayList&lt;Integer&gt; readlist(int n) {ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; n; i++) {int a = nextInt();list.add(a);}return list;}         //INPUT LONG ARRAY         long[] readlongarray(int n) {long res[] = new long[n];for (int i = 0; i &lt; n; i++) res[i] = nextLong();return res;}         //INPUT STRING return char array         char[] readchararray() {String str = sc.nextLine();return str.toCharArray();}     }     //YES AND NO FUNCTION     public static void yes(){ out.println(\"YES\");out.flush();}     public static void no(){ out.println(\"NO\");out.flush();}          public static void main(String[] args) throws Exception {         new Main().solution();     }          public static void solution() throws Exception {         sc = new FastReader();         out = new PrintWriter(System.out);         StringBuilder res = new StringBuilder();         //int i,j,count=0;         ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();         //Stringmap map pq pqmax pqlong list longlist are defined above         int t = sc.nextInt();         //int t=1;         while(t--&gt;0) {             int n = sc.nextInt();             res.append(\"\\n\");         }         print(res);     } }  "
  },
  
  {
    "title": "C++ 시작하기 (VS Code + MinGW)",
    "url": "/posts/C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-VS-Code-MinGW/",
    "categories": "공부",
    "tags": "C++",
    "date": "2024-12-01 17:38:20 +0900",
    "content": "   C++ 개발 환경을 세팅해보자!   필수 조건    Visual Studio Code 설치   VS Code용 C/C++ 확장 프로그램 설치   MinGW-w64 툴체인 설치 MSYS2 를 통해 최신 버전의 MinGW-w64를 설치하자. 여기에는 최신 네이티브 빌드의 GCC, MinGW-w64 및 기타 유용한 C++ 도구와 라이브러리가 제공된다. 이를 통해 코드를 컴파일하고, 디버깅하고, IntelliSense 와 함께 작동하도록 구성하는 데 필요한 도구가 제공된다.            MSYS2 페이지에서 최신 설치 프로그램을 다운로드하거나 설치 프로그램에 대한 직접 링크를 사용할 수 있습니다 .           설치 프로그램을 실행하고 설치 마법사의 단계를 따르세요. MSYS2에는 64비트 Windows 8.1 이상이 필요하다는 점에 유의하세요.           마법사에서 원하는 설치 폴더를 선택합니다. 나중에 사용할 수 있도록 이 디렉토리를 기록해 둡니다. 대부분의 경우 권장 디렉토리가 허용됩니다. 시작 메뉴 바로가기 단계를 설정할 때도 마찬가지입니다. 완료되면 지금 MSYS2 실행 상자가 선택되어 있는지 확인하고 마침을 선택합니다 . 그러면 MSYS2 터미널 창이 열립니다.           이 터미널에서 다음 명령을 실행하여 MinGW-w64 툴체인을 설치합니다. pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain            Enter 키를toolchain 눌러 그룹 의 기본 패키지 수를 적용합니다 .           Y설치를 계속할지 묻는 메시지가 나타나면 입력하세요 .           다음 단계에 따라 binWindows 환경 변수에 MinGW-w64 폴더 경로를 추가합니다 .PATH            Windows 검색 창에 설정을 입력하여 Windows 설정을 엽니다.       계정에 대한 환경 변수 편집을 검색하세요 .       사용자 변수 에서 변수를 선택한 Path다음 편집을 선택한다 .       새로 만들기를 선택 하고 설치 과정에서 기록한 MinGW-w64 대상 폴더를 목록에 추가합니다. 위의 기본 설정을 사용한 경우 경로는 다음과 같다 C:\\msys64\\ucrt64\\bin.       OK를 선택한 다음 환경 변수 창에서 OK를 다시 선택하여 환경 변수를 업데이트한다. 업데이트된 환경 변수를 사용 하려면 콘솔 창을 다시 열어야 합니다 .PATHPATH MinGW 설치를 확인           MinGW설치 확인    Windows 명령 프롬프트를 시작합니다( Windows 검색 창에 cmd 혹은 Windows 명령 프롬프트를 입력).     gcc --version g++ --version gdb --version       PATH 변수 항목이 툴체인이 설치된 MinGW-w64 바이너리 위치와 일치하는지 확인. 해당 PATH 항목에 컴파일러가 없는 경우 이전 지침을 따랐는지 확인.   gcc올바른 출력이 나오지만 그렇지 않은 경우 gdbMinGW-w64 도구 세트에서 누락된 패키지를 설치해야 한다.            컴파일 시 “miDebuggerPath의 값이 잘못되었습니다.”라는 메시지가 나타나는 경우, mingw-w64-gdb패키지가 누락된 것이 원인 중 하나일 수 있다.           References 공식 웹 사이트 "
  },
  
  {
    "title": "BOJ_2015_수들의 합 4 (Java)",
    "url": "/posts/BOJ2015%EC%88%98%EB%93%A4%EC%9D%98-%ED%95%A9-4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-25 22:34:00 +0900",
    "content": "[Gold IV] 수들의 합 4 - 2015  문제 링크  성능 요약  메모리: 35308 KB, 시간: 352 ms  분류  자료 구조, 해시를 사용한 집합과 맵, 누적 합, 트리를 사용한 집합과 맵  제출 일자  2024년 11월 25일 22:31:56  문제 설명  A[1], A[2], ..., A[N]의 N개의 정수가 저장되어 있는 배열이 있다. 이 배열 A의 부분합이란 1 ≤ i ≤ j ≤ N인 정수 i와 j에 대해 A[i]부터 A[j]까지의 합을 말한다.  N과 A[1], A[2], ..., A[N]이 주어졌을 때, 이러한 N×(N+1)/2개의 부분합 중 합이 K인 것이 몇 개나 있는지를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 정수 N과 K가 주어진다. (1 ≤ N ≤ 200,000, |K| ≤ 2,000,000,000) N과 K 사이에는 빈칸이 하나 있다. 둘째 줄에는 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 A[1], A[2], ..., A[N]의 순서로 주어진다. 주어지는 정수의 절댓값은 10,000을 넘지 않는다.  출력  첫째 줄에 합이 K인 부분합의 개수를 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.HashMap; import java.util.Map; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;     static long K, prefixSum[];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2015_수들의합4/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         K = Long.parseLong(st.nextToken());         prefixSum = new long[N + 1];          Map&lt;Long, Long&gt; sumCnt = new HashMap&lt;&gt;();         long res = 0;          st = new StringTokenizer(br.readLine());         for (int i = 1; i &lt;= N; i++) {             prefixSum[i] = prefixSum[i - 1] + Long.parseLong(st.nextToken());              if (prefixSum[i] == K) res++;              res += sumCnt.getOrDefault(prefixSum[i] - K, 0L);             sumCnt.put(prefixSum[i], sumCnt.getOrDefault(prefixSum[i], 0L) + 1);         }          bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_14568_2017 연세대학교 프로그래밍 경시대회 (Java)",
    "url": "/posts/BOJ145682017-%EC%97%B0%EC%84%B8%EB%8C%80%ED%95%99%EA%B5%90-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B2%BD%EC%8B%9C%EB%8C%80%ED%9A%8C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-25 13:31:37 +0900",
    "content": "[Bronze III] 2017 연세대학교 프로그래밍 경시대회 - 14568  문제 링크  성능 요약  메모리: 14276 KB, 시간: 108 ms  분류  사칙연산, 브루트포스 알고리즘, 수학  제출 일자  2024년 11월 25일 13:27:46  문제 설명  2015, 2016년에 이어 2017년에도 연세대학교 교내 프로그래밍 경시대회가 열린다.  택희, 영훈이, 남규는 열심히 문제를 만들었고, 이에 대한 보상으로 과사로부터 사탕 N개를 받았다.  N개의 사탕을 적절히 나눠 가지기 위해 토론한 결과, 아래와 같은 방식으로 사탕을 나누기로 결정하였다.   \t남는 사탕은 없어야 한다. \t남규는 영훈이보다 2개 이상 많은 사탕을 가져야 한다. \t셋 중 사탕을 0개 받는 사람은 없어야 한다. \t택희가 받는 사탕의 수는 홀수개가 되어서는 안 된다.   이제 사탕을 적절히 나누어 집에 돌아가던 중, 택희는 위와 같은 규칙을 만족하도록 세 명에게 사탕을 나누어 주는 방법의 수가 궁금해졌다.  사탕의 개수 N이 주어지면, 사탕을 세 사람에게 분배하는 서로 다른 경우의 수를 세 보자.  입력  첫째 줄에 사탕의 총 개수 N이 주어진다. (1 ≤ N ≤ 100)  출력  규칙에 맞게 사탕을 분배하는 경우의 수를 출력한다. 택희, 영훈이, 남규가 받은 사탕의 수를 각각 A, B, C개라고 할 때, 서로 다른 (A, B, C) 순서쌍의 수를 세면 된다.  만일 규칙에 맞게 사탕을 분배하는 방법이 없다면 0을 출력한다.        문제 풀이   단순한 완전탐색 수학문제.  코드 package BOJ_14568_2017연세대학교프로그래밍경시대회;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14568_2017연세대학교프로그래밍경시대회/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         int cnt = 0;          int A = 0, B = 0, C = 0;         for (int i = 0; i &lt; N; i++) {             A = i;             for (int j = 2; j &lt; N - A; j++) {                 B = A + j;                 C = N - A - B;                 if ((A &gt; 0 &amp;&amp; B &gt; 0 &amp;&amp; C &gt; 0) &amp;&amp; C % 2 == 0) cnt++;             }         }          bw.write(String.valueOf(cnt));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_22988_재활용 캠페인 (Java)",
    "url": "/posts/BOJ22988%EC%9E%AC%ED%99%9C%EC%9A%A9-%EC%BA%A0%ED%8E%98%EC%9D%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-22 23:57:36 +0900",
    "content": "[Gold II] 재활용 캠페인 - 22988  문제 링크  성능 요약  메모리: 38760 KB, 시간: 492 ms  분류  그리디 알고리즘, 정렬, 두 포인터  제출 일자  2024년 11월 22일 23:49:58  문제 설명      고등학생 때였다. 친구의 손에 이끌려 처음으로 가게 된 화장품 가게는 문을 열자마자 은은한 향기가 코끝을 스치는 곳이었다. 친구를 따라가기에 급급했던 한별이의 발걸음은 이제 누가 말하지 않아도 무언가에 빨려 들어간 듯이 앞을 향했다. 파운데이션을 바르고, 블러셔를 두드리고. 거울을 본 한별이는 처음 보는 자신의 모습에 푹 빠져버렸다. 얼굴에 띈 홍조는 블러셔가 무색해질 정도였다. 그런 기분에 감화된 탓인지 화장품 가게를 나서서 집에 돌아갈 때까지도 거울의 그 모습을 잊을 수가 없었다. 마치 자기가 주목받는 느낌이 들어 볼이 한번 더 붉어져 왔다. 한별이는 이 기분을 다른 사람에게도 전해주고 싶어서 나중에 꼭 화장품 가게를 열겠다고 다짐했다.  그동안 이룬 결실도, 못다 한 각오도 있었다. 하지만 화장품 가게를 열겠다는 노력의 결과는 눈앞으로 다가와서, 내일은 한별이의 화장품 가게가 개점한 지 꼬박 1년 되는 날이 된다. 한별이의 화장품 가게는 만들어진 지 얼마 안 되었지만 많은 인기를 얻어 멀리서까지도 화장품을 사러 찾아온다. 이 화장품 가게의 인기 상품은 총 용량이  $X$㎖인 헤어에센스이고, 특유의 매력적인 딸기향은 모발의 상처만큼이나 마음의 상처를 치유하는 데에도 유용하다.  한별이의 화장품 가게에서는 불필요한 쓰레기를 줄이자는 재활용 캠페인을 하고 있다. 한별이의 가게의 모든 상품은 재활용이 가능한 용기에 담긴다. 가게로 사용하다 남은 헤어에센스 용기 두 개를 반납하면 새로운 용기에다가 남은 헤어에센스를 모아 주고, 추가로 총 용량의 절반만큼의 헤어에센스를 추가로 채워준다. 단, 총 용량을 넘쳐서 채워주지는 않는다. 다시 말해, 용량이 각각  $A$㎖와 $B$㎖ 남은 헤어에센스를 가져가면 $\\min\\left(A+B+\\frac{X}{2},\\ X\\right)$㎖의 헤어에센스가 담긴 새로운 용기로 바꿔준다.  한별이의 화장품 가게 단골인 히나는 이제까지 사모은 헤어에센스 용기가 $N$ 개 있다. $i$ 번째 용기에는 헤어에센스가 $C_i$㎖ 담겨 있다. 히나는 한별이의 화장품 가게에 적당한 순서로 헤어에센스를 교환해서 용량이 꽉 찬, 즉, $X$㎖가 담겨 있는 헤어에센스 용기를 최대한 많이 만들고 싶다. 히나가 용량이 꽉 찬 헤어에센스를 최대 몇 개 만들 수 있는지 알려주자.  입력  다음과 같이 입력이 주어진다.   출력  한별이의 화장품 가게에 가서 적당한 순서로 헤어에센스를 교환해서 용량이 꽉 찬 헤어에센스 용기를 몇 개 만들 수 있는지 출력하여라.     문제 풀이   코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.Arrays; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N;     static long X, arr[];     static double HALF = 0;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());         N = Integer.parseInt(st.nextToken());         X = Long.parseLong(st.nextToken());         HALF = X / 2.0;         arr = new long[N];         st = new StringTokenizer(br.readLine());         boolean flag = false;         int left = 0;         int right = N - 1;         int remainingCnt = N;          for (int i = 0; i &lt; N; i++) {             arr[i] = Long.parseLong(st.nextToken());         }          arr = Arrays.stream(arr)                 .sorted()                 .toArray();          for (int i = 0; i &lt; N; i++) {             if (arr[i] &gt;= X &amp;&amp; !flag) {                 right = i-1;                 flag = true;                 remainingCnt = i;             }         }          if (!flag) right = N - 1;         int res = flag ? N - (right+1) : 0;          while (left &lt; right) {             if (arr[left] + arr[right] &gt;= HALF) {             \tremainingCnt -= 2;                 res++;                 left++;                 right--;             } else {                 left++;             }         }                  if (remainingCnt &gt; 0) {             res += remainingCnt / 3 ;         }                   bw.write(String.valueOf(res));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "Gitlab 작업을 Github으로 옮기기 ( 커밋 내역 포함 미러링)",
    "url": "/posts/Gitlab-%EC%9E%91%EC%97%85%EC%9D%84-Github%EC%9C%BC%EB%A1%9C-%EC%98%AE%EA%B8%B0%EA%B8%B0-%EC%BB%A4%EB%B0%8B-%EB%82%B4%EC%97%AD-%ED%8F%AC%ED%95%A8-%EB%AF%B8%EB%9F%AC%EB%A7%81/",
    "categories": "프로젝트",
    "tags": "git, 프로젝트",
    "date": "2024-11-22 10:54:38 +0900",
    "content": "   Gitlab에서 작업한 프로젝트를 Github으로 옮겨야 할 상황이 생겼다.   이번 프로젝트는 큰 파일이 없는 경우였기 때문에 간단한 미러링으로 옮길 수 있었다. 용량이 큰 파일은 다른 방법을 사용해야한다. 매우 귀찮고 복잡하기 때문에 최대한 git에 커밋할 땐 용량이 큰 파일은 지양하자.(경험담)      ps. 파일을 지운다고 해서 다시 옮길 수 있는 상황이 되는것은 아니다! 커밋 내역에 용량이 큰 파일이 포함되어있기 때문에 그 커밋내역이 남아있는 한 Git Large File Storage (LFS) 를 사용해야 할 것이다. 사용해 본 경험으로는 잘 안되거나 매우 복잡하고 귀찮았다…   Gitlab -&gt; Github 작업 옮기기  1. Gitlab에서 작업한 원본 프로젝트를 로컬에 복사한다. 미리 만들어 둔 폴더에 gitlab 레포지토리를 복사 $ git clone --mirror [gitlab 원본 레포지토리 경로]   2. 복사한 디렉토리로 경로 옮기기. $ cd [gitlab 원본 저장소 이름].git   3. Github에 붙여넣을 레포지토리 생성 후 그 주소로 연결. $ git remote set-url --push origin [이동할 github 레포지토리 주소]   4. push로 완료하기. $ git push --mirror   이후 잘 옮겨진 모습을 볼 수 있다! "
  },
  
  {
    "title": "BOJ_1946_신입사원 (Java)",
    "url": "/posts/BOJ1946%EC%8B%A0%EC%9E%85%EC%82%AC%EC%9B%90-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-21 21:48:39 +0900",
    "content": "[Silver I] 신입 사원 - 1946  문제 링크  성능 요약  메모리: 300128 KB, 시간: 868 ms  분류  그리디 알고리즘, 정렬  제출 일자  2024년 11월 21일 18:01:37  문제 설명  언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.  그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.  이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.  출력  각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.     문제 풀이     해당 그림처럼 한 점수를 순위세운 뒤 나머지에서 비교하면 된다. 이를 처음에는 정렬로 구현하였지만 다른 메모리 짧은 코드를 참고하니 입력받을 때 N명의 순위라 1~N임을 감안해서 0~N-1로 인덱스로 바로 받았다. 이를 사용하면 정렬을 할 필요가 없어지므로 메모리가 확연히 줄어드는 것을 볼 수 있었다.  코드 이전 코드 package BOJ_1946_신입사원;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int T, N, arr[][];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1946_신입사원/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          T = Integer.parseInt(br.readLine());         while (T-- &gt; 0) {             N = Integer.parseInt(br.readLine());             arr = new int[N][2];             for (int i = 0; i &lt; N; i++) {                 st = new StringTokenizer(br.readLine());                 arr[i][0] = Integer.parseInt(st.nextToken());                 arr[i][1] = Integer.parseInt(st.nextToken());             }              arr = Arrays.stream(arr)                     .sorted((o1, o2) -&gt; o1[0] - o2[0])                     .toArray(int[][]::new);              int score = arr[0][1];             int cnt = 1;             for (int i = 1; i &lt; N; i++) {                 if (score &gt;= arr[i][1]) {                     score = arr[i][1];                     cnt++;                 }             }              sb.append(String.valueOf(cnt) + \"\\n\");         }                  bw.write(sb.toString());         bw.close();         br.close();     } }   수정 코드 ( 발전된 버전 ) package BOJ_1946_신입사원;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int T, N, arr[][];      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_1946_신입사원/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          T = Integer.parseInt(br.readLine());          while (T-- &gt; 0) {             int N = Integer.parseInt(br.readLine());             int[] interviews = new int[N];              for (int i = 0; i &lt; N; i++) {                 String[] scores = br.readLine().split(\" \");                 int document = Integer.parseInt(scores[0]) - 1;                 int interview = Integer.parseInt(scores[1]) - 1;                 interviews[document] = interview;             }              int score = interviews[0];             int cnt = 1;             for (int i = 1; i &lt; N; i++) {                 if (score &gt;= interviews[i]) {                     score = interviews[i];                     cnt++;                 }             }              sb.append(cnt).append('\\n');         }         bw.write(sb.toString());         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_14247_나무 자르기 (Java)",
    "url": "/posts/BOJ14247%EB%82%98%EB%AC%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-21 16:56:01 +0900",
    "content": "[Silver II] 나무 자르기 - 14247  문제 링크  성능 요약  메모리: 29544 KB, 시간: 400 ms  분류  그리디 알고리즘, 정렬  제출 일자  2024년 11월 21일 16:51:00  문제 설명    입력    출력  영선이가 나무를 잘라서 구할 수 있는 최대 양을 출력하시오.  제한       문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.Arrays; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, growth[];     static long sum, res;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_14247_나무자르기/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         growth = new int[N];         sum = 0;         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             sum += Integer.parseInt(st.nextToken());         }          st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; N; i++) {             growth[i] = Integer.parseInt(st.nextToken());         }          growth = Arrays.stream(growth)                 .sorted()                 .toArray();  //        System.out.println(Arrays.toString(growth));         res = sum;         for (int i = 0; i &lt; N; i++) {             res += growth[i] * i;         }          bw.write(Long.toString(res));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_2217_로프 (Java)",
    "url": "/posts/BOJ2217%EB%A1%9C%ED%94%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-21 15:00:56 +0900",
    "content": "[Silver IV] 로프 - 2217  문제 링크  성능 요약  메모리: 29816 KB, 시간: 400 ms  분류  그리디 알고리즘, 수학, 정렬  제출 일자  2024년 11월 21일 14:54:10  문제 설명  N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.  하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.  각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.  입력  첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.  출력  첫째 줄에 답을 출력한다.     문제 풀이   간단한 그리디 및 정렬 문제다. 무거운 하중을 들 수 있는 로프부터 사용하며 그때그때 각 로프별 들 수 있는 최소 하중을 계산해 사용한 로프 개수만큼 곱해주면 들 수 있는 전체 하중을 계산할 수 있다. 이 계산값을 최대값으로 갱신하며 계산하면된다.  코드 package BOJ_2217_로프;  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.Arrays; import java.util.Collections; import java.util.StringTokenizer;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static int N, arr[], res, min;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/BOJ_2217_로프/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));          N = Integer.parseInt(br.readLine());         arr = new int[N];         for (int i = 0; i &lt; N; i++) {             arr[i] = Integer.parseInt(br.readLine());         }          arr = Arrays.stream(arr)                 .boxed()                 .sorted(Collections.reverseOrder())                 .mapToInt(Integer::intValue)                 .toArray();          res = 0;         min = Integer.MAX_VALUE;         for (int i = 1; i &lt;= arr.length; i++) {             min = Math.min(min, arr[i - 1]);             res = Math.max(res, min * i);         }          bw.write(Integer.toString(res));         bw.flush();         bw.close();         br.close();     } }  "
  },
  
  {
    "title": "BOJ_1194_달이 차오른다, 가자 (Java)",
    "url": "/posts/BOJ1194%EB%8B%AC%EC%9D%B4-%EC%B0%A8%EC%98%A4%EB%A5%B8%EB%8B%A4-%EA%B0%80%EC%9E%90-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-21 11:15:17 +0900",
    "content": "[Gold I] 달이 차오른다, 가자. - 1194  문제 링크  성능 요약  메모리: 16388 KB, 시간: 128 ms  분류  너비 우선 탐색, 비트마스킹, 그래프 이론, 그래프 탐색  제출 일자  2024년 11월 21일 11:05:29  문제 설명  지금 민식이가 계획한 여행은 달이 맨 처음 뜨기 시작할 때 부터, 준비했던 여행길이다. 하지만, 매번 달이 차오를 때마다 민식이는 어쩔 수 없는 현실의 벽 앞에서 다짐을 포기하고 말았다.  민식이는 매번 자신의 다짐을 말하려고 노력했지만, 말을 하면 아무도 못 알아들을 것만 같아서, 지레 겁먹고 벙어리가 되어버렸다. 결국 민식이는 모두 잠든 새벽 네시 반쯤 홀로 일어나, 창 밖에 떠있는 달을 보았다.  하루밖에 남지 않았다. 달은 내일이면 다 차오른다. 이번이 마지막기회다. 이걸 놓치면 영영 못간다.  영식이는 민식이가 오늘도 여태것처럼 그냥 잠 들어버려서 못 갈지도 모른다고 생각했다. 하지만 그러기엔 민식이의 눈에는 저기 뜬 달이 너무나 떨렸다.  민식이는 지금 미로 속에 있다. 미로는 직사각형 모양이고, 여행길을 떠나기 위해 미로를 탈출하려고 한다. 미로는 다음과 같이 구성되어져있다.   \t빈 칸: 언제나 이동할 수 있다. ('.') \t벽: 절대 이동할 수 없다. ('#') \t열쇠: 언제나 이동할 수 있다. 이 곳에 처음 들어가면 열쇠를 집는다. ('a', 'b', 'c', 'd', 'e', 'f') \t문: 대응하는 열쇠가 있을 때만 이동할 수 있다. ('A', 'B', 'C', 'D', 'E', 'F') \t민식이의 현재 위치: 빈 곳이고, 민식이가 현재 서 있는 곳이다. ('0') \t출구: 달이 차오르기 때문에, 민식이가 가야하는 곳이다. 이 곳에 오면 미로를 탈출한다. ('1')   달이 차오르는 기회를 놓치지 않기 위해서, 미로를 탈출하려고 한다. 한 번의 움직임은 현재 위치에서 수평이나 수직으로 한 칸 이동하는 것이다.  민식이가 미로를 탈출하는데 걸리는 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 미로의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 50) 둘째 줄부터 N개의 줄에 미로의 모양이 주어진다. 같은 타입의 열쇠가 여러 개 있을 수 있고, 문도 마찬가지이다. 그리고, 문에 대응하는 열쇠가 없을 수도 있다. '0'은 한 개, '1'은 적어도 한 개 있다. 열쇠는 여러 번 사용할 수 있다.  출력  첫째 줄에 민식이가 미로를 탈출하는데 드는 이동 횟수의 최솟값을 출력한다. 만약 민식이가 미로를 탈출 할 수 없으면, -1을 출력한다.     문제 풀이   간단한 bfs 구현 문제다. 이렇게 방문처리에 조건이 있는경우 3차원으로 visited 배열을 만들면 된다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \t \tclass Person{ \t\tint r, c, key, cnt; \t\tPerson(int r, int c, int key, int cnt) { \t\t\tthis.r = r; \t\t\tthis.c = c; \t\t\tthis.key = key; \t\t\tthis.cnt = cnt; \t\t} \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, res; \tstatic char board[][]; \tstatic boolean visited[][][]; \tstatic int[] dr = {0, -1, 0, 1}, dc = {-1, 0, 1, 0}; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tboard = new char[N+2][M+2]; \t\tvisited = new boolean[N+2][M+2][1&lt;&lt;(6)]; \t\tboolean flag = false; // 0이 있는지 체크 \t\tfor(int i=0; i&lt;N+2; i++) { \t\t\tfor(int j=0; j&lt;M+2; j++) { \t\t\t\tboard[i][j] = '#'; \t\t\t} \t\t} \t\tPerson p = new Person(1, 1, 0, 0); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tString s = br.readLine(); \t\t\tfor(int j=1; j&lt;=M; j++) { \t\t\t\tboard[i][j] = s.charAt(j-1); \t\t\t\tif (board[i][j] == '0') { \t\t\t\t\tp.r = i; \t\t\t\t\tp.c = j; \t\t\t\t\tflag = true; \t\t\t\t} \t\t\t} \t\t} \t\t \t\tif(!flag) { \t\t\tSystem.out.println(-1); \t\t\treturn; \t\t} \t\tres = 0; \t\tbfs(p);  \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void bfs(Person p) { \t\tQueue&lt;Person&gt; queue = new LinkedList&lt;&gt;(); \t\tPerson start = p; \t\tvisited[start.r][start.c][start.key] = true; \t\tqueue.offer(start); \t\t \t\twhile(!queue.isEmpty()) { \t\t\tPerson curr = queue.poll(); \t\t\tfor(int k=0; k&lt;4; k++) { \t\t\t\tint nr = curr.r + dr[k]; \t\t\t\tint nc = curr.c + dc[k]; \t\t\t\tchar square = board[nr][nc]; \t\t\t  \t\t\t\tif(visited[nr][nc][curr.key]) continue; \t\t\t\tif(square == '#') continue; \t\t\t\t \t\t\t\tPerson next = new Person (nr, nc, curr.key, curr.cnt); \t\t\t\t \t\t\t\tif(square == '.' || square == '0') { \t\t\t\t\tnext.cnt++; \t\t\t\t\tvisited[nr][nc][next.key] = true; \t\t\t\t\tqueue.offer(next); \t\t\t\t} else if(square &gt;= 'a' &amp;&amp; square &lt;= 'f') { \t\t\t\t\tnext.key |= 1 &lt;&lt; (square - 'a'); \t\t\t\t\tnext.cnt++; \t\t\t\t\tvisited[nr][nc][next.key] = true; \t\t\t\t\tqueue.offer(next); \t\t\t\t} else if(square &gt;= 'A' &amp;&amp; square &lt;= 'F') { \t\t\t\t\tif((next.key &amp; 1 &lt;&lt; (square - 'A')) != 0) { \t\t\t\t\t\tnext.cnt++; \t\t\t\t\t\tvisited[nr][nc][next.key] = true; \t\t\t\t\t\tqueue.offer(next); \t\t\t\t\t} \t\t\t\t} else if(square == '1') { \t\t\t\t\tres = next.cnt + 1; \t\t\t\t\treturn; \t\t\t\t} \t\t\t} \t\t} \t\tres = -1; \t} }  "
  },
  
  {
    "title": "BOJ_21815_Portals (Java)",
    "url": "/posts/BOJ21815Portals-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-20 18:12:24 +0900",
    "content": "[Platinum III] Portals - 21815  문제 링크  성능 요약  메모리: 68080 KB, 시간: 756 ms  분류  그래프 이론, 최소 스패닝 트리  제출 일자  2024년 11월 20일 18:05:31  문제 설명    입력    출력  A single line containing the minimum total amount of moonies required to modify the network in order to make it possible to reach every possible location from every other location.     문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, p[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tN = Integer.parseInt(br.readLine()); \t\tp = new int[2*N + 1]; \t\tfor(int i=0; i&lt;p.length; i++) { \t\t\tp[i] = i; \t\t} \t\t \t\tPriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;int[]&gt;((o1, o2) -&gt; o1[0]-o2[0]); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint c = Integer.parseInt(st.nextToken()); \t\t\tint p1 = Integer.parseInt(st.nextToken()); \t\t\tint p2 = Integer.parseInt(st.nextToken()); \t\t\tint p3 = Integer.parseInt(st.nextToken()); \t\t\tint p4 = Integer.parseInt(st.nextToken()); \t\t\tpq.add(new int[] {c, p1, p3}); \t\t\tunion(p1, p2); \t\t\tunion(p3, p4); \t\t} \t\tint res = 0; \t\twhile(!pq.isEmpty()) { \t\t\tint[] curr = pq.poll(); \t\t\tif(union(curr[1], curr[2])) res += curr[0]; \t\t} \t\tbw.write(String.valueOf(res));  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate boolean union(int x, int y) { \t\tint px = find(x); \t\tint py = find(y); \t\tif(px == py) return false; \t\tp[py] = px; \t\treturn true; \t} \t \tprivate int find(int x) { \t\tif(p[x] != x) return p[x] = find(p[x]); \t\treturn x; \t} }  "
  },
  
  {
    "title": "BOJ_2673_교차하지 않는 원의 현들의 최대 집합 (Java)",
    "url": "/posts/BOJ2673%EA%B5%90%EC%B0%A8%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EC%9B%90%EC%9D%98-%ED%98%84%EB%93%A4%EC%9D%98-%EC%B5%9C%EB%8C%80-%EC%A7%91%ED%95%A9/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-20 14:42:23 +0900",
    "content": "[Platinum IV] 교차하지 않는 원의 현들의 최대집합 - 2673  문제 링크  성능 요약  메모리: 12056 KB, 시간: 84 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 11월 20일 14:36:19  문제 설명  평면상에 있는 원의 둘레에 100개의 점이 일정한 간격으로 시계방향으로 번호가 1, 2, ... 100으로 붙여져 있다. 이 점들을 끝점으로 갖는 N개의 선분(원의 현)이 입력으로 주어질 때, 이들중에서 서로 교차하지 않는 것들을 최대한 많이 찾아서 그 개수를 출력하는 프로그램을 작성하라.  단, 1 ≤ N ≤ 50이고, 주어진 각 점은 많아야 한 현의 끝점이 될 수 있다.  입력  첫 번째 줄은 주어지는 현의 개수 N이고, 다음의 N줄은 각 현의 양끝점의 번호가 주어진다.  출력  구한 현의 개수를 출력한다.     문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, line[][], dp[][]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \t/* \t * 교차되지 않는 정답군 크기를 dp로 저장할거고 그 dp배열 채울 값을 구간으로 정의하여 구분. \t * i~j구간의 정답크기는 dp[i][j]로. 이때 이를 작은 부분으로 쪼개면 i&lt;=mid&lt;j일 때 \t * dp[i][j]를 갱신하려면 dp[i][mid] + dp[mid][j]로 쪼갤 수 있다. \t * 또한 구간 전체를 길이로 하는 선분도 고려해야하므로 이를 검색해 더해줌. \t */ \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\tline = new int[101][101]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint A = Integer.parseInt(st.nextToken()); \t\t\tint B = Integer.parseInt(st.nextToken()); \t\t\t \t\t\tline[A][B]++; \t\t\tline[B][A]++; \t\t} \t\t \t\tdp = new int[101][101]; \t\tfor(int i=1; i&lt;=100; i++) { \t\t\tfor(int j=i; j&gt;=1; j--) { \t\t\t\tfor(int mid = j; mid&lt;i; mid++) { \t\t\t\t\tdp[j][i] = Math.max(dp[j][i], dp[j][mid] + dp[mid][i] + line[j][i]); \t\t\t\t} \t\t\t} \t\t} \t\tbw.write(String.valueOf(dp[1][100]));  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_16235_나무 제테크 (Java)",
    "url": "/posts/BOJ16235%EB%82%98%EB%AC%B4-%EC%A0%9C%ED%85%8C%ED%81%AC-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-19 13:24:36 +0900",
    "content": "[Gold III] 나무 재테크 - 16235  문제 링크  성능 요약  메모리: 298368 KB, 시간: 732 ms  분류  자료 구조, 구현, 시뮬레이션  제출 일자  2024년 11월 19일 13:12:13  문제 설명  부동산 투자로 억대의 돈을 번 상도는 최근 N×N 크기의 땅을 구매했다. 상도는 손쉬운 땅 관리를 위해 땅을 1×1 크기의 칸으로 나누어 놓았다. 각각의 칸은 (r, c)로 나타내며, r은 가장 위에서부터 떨어진 칸의 개수, c는 가장 왼쪽으로부터 떨어진 칸의 개수이다. r과 c는 1부터 시작한다.  상도는 전자통신공학과 출신답게 땅의 양분을 조사하는 로봇 S2D2를 만들었다. S2D2는 1×1 크기의 칸에 들어있는 양분을 조사해 상도에게 전송하고, 모든 칸에 대해서 조사를 한다. 가장 처음에 양분은 모든 칸에 5만큼 들어있다.  매일 매일 넓은 땅을 보면서 뿌듯한 하루를 보내고 있던 어느 날 이런 생각이 들었다.   나무 재테크를 하자!   나무 재테크란 작은 묘목을 구매해 어느정도 키운 후 팔아서 수익을 얻는 재테크이다. 상도는 나무 재테크로 더 큰 돈을 벌기 위해 M개의 나무를 구매해 땅에 심었다. 같은 1×1 크기의 칸에 여러 개의 나무가 심어져 있을 수도 있다.  이 나무는 사계절을 보내며, 아래와 같은 과정을 반복한다.  봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다. 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다. 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.  여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다.  가을에는 나무가 번식한다. 번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다. 어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r+1, c+1) 이다. 상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다.  겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다.  K년이 지난 후 상도의 땅에 살아있는 나무의 개수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 N, M, K가 주어진다.  둘째 줄부터 N개의 줄에 A배열의 값이 주어진다. r번째 줄의 c번째 값은 A[r][c]이다.  다음 M개의 줄에는 상도가 심은 나무의 정보를 나타내는 세 정수 x, y, z가 주어진다. 처음 두 개의 정수는 나무의 위치 (x, y)를 의미하고, 마지막 정수는 그 나무의 나이를 의미한다.  출력  첫째 줄에 K년이 지난 후 살아남은 나무의 수를 출력한다.     문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, K, A[][], energy[][]; \tstatic int[] dr = {0, -1, -1, -1, 0, 1, 1, 1}; \tstatic int[] dc = {-1, -1, 0, 1, 1, 1, 0, -1}; \tstatic Deque&lt;Tree&gt; trees = new LinkedList&lt;Main.Tree&gt;(); \tstatic Queue&lt;Tree&gt; deadTrees; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tclass Tree implements Comparable&lt;Tree&gt; { \t\tint x, y, age;  \t\tpublic Tree(int x, int y, int age) { \t\t\tthis.x = x; \t\t\tthis.y = y; \t\t\tthis.age = age; \t\t}  \t\t@Override \t\tpublic int compareTo(Tree o) { \t\t\treturn this.age - o.age; \t\t} \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tK = Integer.parseInt(st.nextToken()); \t\tA = new int[N+1][N+1]; \t\tenergy = new int[N+1][N+1]; \t\tfor (int i = 1; i &lt;= N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor (int j = 1; j &lt;= N; j++) { \t\t\t\tA[i][j] = Integer.parseInt(st.nextToken()); \t\t\t\tenergy[i][j] = 5; \t\t\t} \t\t}  \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint x = Integer.parseInt(st.nextToken()); \t\t\tint y = Integer.parseInt(st.nextToken()); \t\t\tint z = Integer.parseInt(st.nextToken()); \t\t\ttrees.addFirst(new Tree(x, y, z)); \t\t}  \t\twhile (K-- &gt; 0) { \t\t\tdeadTrees = new LinkedList&lt;Main.Tree&gt;(); \t\t\tyear(); \t\t} \t\tbw.write(String.valueOf(trees.size())); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void year() { \t\tspring(); \t\tsummer(); \t\tfall(); \t\twinter(); \t}  \tprivate void spring() { \t\tDeque&lt;Tree&gt; tmpTrees = new ArrayDeque&lt;Main.Tree&gt;(); \t\tint size = trees.size(); \t\twhile(size--&gt;0) { \t\t\tTree currTree = trees.poll(); \t\t\tif (currTree.age &lt;= energy[currTree.x][currTree.y]) { \t\t\t\tenergy[currTree.x][currTree.y] -= currTree.age; \t\t\t\tcurrTree.age++; \t\t\t\ttmpTrees.add(currTree); \t\t\t} else { \t\t\t\tdeadTrees.add(currTree); \t\t\t} \t\t} \t\ttrees = tmpTrees; \t}  \tprivate void summer() { \t\twhile(!deadTrees.isEmpty()) { \t\t\tTree currTree = deadTrees.poll(); \t\t\tint newEnergy = currTree.age/2; \t\t\tenergy[currTree.x][currTree.y] += newEnergy; \t\t} \t}  \tprivate void fall() { \t\tDeque&lt;Tree&gt; tmpTrees = new ArrayDeque&lt;Main.Tree&gt;(); \t\tint size = trees.size(); \t\twhile(size--&gt;0) { \t\t\tTree currTree = trees.poll(); \t\t\tif(currTree.age %5 == 0) { \t\t\t\tfor(int k=0; k&lt;8; k++) { \t\t\t\t\tint newr = currTree.x + dr[k]; \t\t\t\t\tint newc = currTree.y + dc[k]; //\t\t\t\t\tSystem.out.println(\"newr : \" + newr); //\t\t\t\t\tSystem.out.println(\"newc : \" + newc); \t\t\t\t\tif(isValidCoordinate(newr, newc)) { \t\t\t\t\t\tTree newTree = new Tree(newr, newc, 1); \t\t\t\t\t\ttmpTrees.addFirst(newTree); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t\ttmpTrees.addLast(currTree); \t\t} \t\ttrees = tmpTrees; \t}  \tprivate void winter() { \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tfor(int j=1; j&lt;=N;j++) { \t\t\t\tenergy[i][j] += A[i][j]; \t\t\t} \t\t} \t} \t \tprivate boolean isValidCoordinate(int r, int c) { \t\treturn r &gt; 0 &amp;&amp; r &lt;= N &amp;&amp; c &gt; 0 &amp;&amp; c &lt;= N; \t} }  "
  },
  
  {
    "title": "BOJ_11694_님 게임 (Java)",
    "url": "/posts/BOJ11694%EB%8B%98-%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-18 15:54:52 +0900",
    "content": "[Platinum II] 님 게임 - 11694  문제 링크  성능 요약  메모리: 14288 KB, 시간: 108 ms  분류  게임 이론, 스프라그–그런디 정리  제출 일자  2024년 11월 18일 15:51:18  문제 설명  koosaga와 cubelover가 님 게임을 하고 있다. 님 게임은 돌을 차곡 차곡 위로 쌓아올린 돌 더미 k개를 이용한다. 각각의 돌 더미에는 한 개 이상의 돌이 있다. 두 사람은 서로 턴을 번갈아가면서 님 게임을 진행한다. 각 사람의 턴이 되면, 돌이 있는 돌 더미를 하나 선택하고, 그 돌 더미에서 돌을 하나 이상 제거한다. 전체 돌 더미에서 마지막 돌을 제거하는 사람이 게임을 지게 된다.   게임은 koosaga가 먼저 시작한다. 두 사람이 최적의 방법으로 게임을 진행했을 때, 이기는 사람을 출력한다.  입력  첫째 줄에 돌 더미의 개수 N (1 ≤ N ≤ 100)이 주어진다.  둘째 줄에는 각 돌 더미에 쌓여있는 돌의 개수 Pi (1 ≤ Pi ≤ 2×109)가 주어진다.  출력  koosaga가 이기는 경우에는 'koosaga'를, cubelover가 이기는 경우에는 'cubelover'를 출력한다.     문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint N = Integer.parseInt(br.readLine()); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tint first = Integer.parseInt(st.nextToken()); \t\t \t\tif(N==1) { \t\t\tSystem.out.println(first==1? \"cubelover\" : \"koosaga\"); \t\t\treturn; \t\t} \t\t \t\tint XOR = first; \t\tboolean flag = (first == 1); // 모든 숫자가 1인지 check \t\t \t\tfor(int i = 1; i &lt; N; i++) { \t\t\tint num = Integer.parseInt(st.nextToken()); \t\t\tXOR ^= num; \t\t\tif(num != 1) flag = false; \t\t} \t\tif(flag == true) bw.write(N%2==1? \"cubelover\" : \"koosaga\"); \t\telse bw.write(XOR==0? \"cubelover\" : \"koosaga\"); \t\t \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_11868_님 게임 2 (Java)",
    "url": "/posts/BOJ11868%EB%8B%98-%EA%B2%8C%EC%9E%84-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-18 14:43:10 +0900",
    "content": "[Platinum IV] 님 게임 2 - 11868  문제 링크  성능 요약  메모리: 14236 KB, 시간: 108 ms  분류  게임 이론, 스프라그–그런디 정리  제출 일자  2024년 11월 18일 14:39:39  문제 설명  koosaga와 cubelover가 님 게임을 하고 있다. 님 게임은 돌을 차곡 차곡 위로 쌓아올린 돌 더미 k개를 이용한다. 각각의 돌 더미에는 한 개 이상의 돌이 있다. 두 사람은 서로 턴을 번갈아가면서 님 게임을 진행한다. 각 사람의 턴이 되면, 돌이 있는 돌 더미를 하나 선택하고, 그 돌 더미에서 돌을 하나 이상 제거한다. 전체 돌 더미에서 마지막 돌을 제거하는 사람이 게임을 이기게 된다.   게임은 koosaga가 먼저 시작한다. 두 사람이 최적의 방법으로 게임을 진행했을 때, 이기는 사람을 출력한다.  입력  첫째 줄에 돌 더미의 개수 N (1 ≤ N ≤ 100)이 주어진다.  둘째 줄에는 각 돌 더미에 쌓여있는 돌의 개수 Pi (1 ≤ Pi ≤ 109)가 주어진다.  출력  koosaga가 이기는 경우에는 'koosaga'를, cubelover가 이기는 경우에는 'cubelover'를 출력한다.     문제 풀이     처음 접해보는 스프라그-그런디 정리를 사용했다. 재미있는 애드혹 문제풀이인 것 같다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint N = Integer.parseInt(br.readLine()); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tint res = Integer.parseInt(st.nextToken()); \t\tfor(int i = 1; i &lt; N; i++) { \t\t\tres ^= Integer.parseInt(st.nextToken()); \t\t} \t\tbw.write(res != 0 ? \"koosaga\" : \"cubelover\"); \t\t \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_21818_Do You Know Your ABCs?",
    "url": "/posts/BOJ21818Do-You-Know-Your-ABCs/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-18 04:05:44 +0900",
    "content": "[Platinum V] Do You Know Your ABCs? - 21818  문제 링크  성능 요약  메모리: 21520 KB, 시간: 204 ms  분류  브루트포스 알고리즘, 구현, 수학  제출 일자  2024년 11월 18일 03:51:48  문제 설명   입력   출력 For each test case, output the number of triples $(A,B,C)$ that are consistent with the numbers Elsie presented.     문제 풀이   코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint T = Integer.parseInt(br.readLine()); \t\twhile(T--&gt;0) { \t\t\tint N = Integer.parseInt(br.readLine()); \t\t\tint[] arr = new int[N+1]; \t\t\t\t\t \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int i=1; i&lt;=N; i++) { \t\t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t\t} \t\t\tint res = solve(arr, N); \t\t\tbw.write(String.valueOf(res) + \"\\n\"); \t\t}  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \t/** \t * A, B, C 가능한 숫자 찾기 \t * 숫자 찾은 후 가능한 경우의 수 리턴 \t *  \t * @param arr \t * @param n \t * @return 가능한 조합 경우의 수 \t */ \tprivate int solve(int[] arr, int N) { \t\tSet&lt;Integer&gt; nums = new HashSet&lt;Integer&gt;(); // N개의 숫자 가능 후보 \t\tfor(int i=0; i&lt;=N; i++) { \t\t\tfor(int j=i+1; j&lt;=N; j++) { \t\t\t\t// 각 값 + 0끼리의 차이 \t\t\t\tint diff = Math.abs(arr[j] - arr[i]); \t\t\t\tif(diff&gt;0) nums.add(diff); \t\t\t} \t\t} \t\t \t\tint cnt = 0; \t\tfor(int A : nums) { \t\t\tfor(int B : nums) { \t\t\t\tfor(int C : nums) { \t\t\t\t\tif(A&gt;B || B&gt;C) continue; // 1&lt;=A&lt;=B&lt;=C \t\t\t\t\tif(isAns(A, B, C, arr, N)) cnt++; \t\t\t\t} \t\t\t} \t\t} \t\treturn cnt; \t}  \tprivate boolean isAns(int A, int B, int C, int[] arr, int N) { \t\tint A_plus_B = A+B; \t\tint B_plus_C = B+C; \t\tint C_plus_A = C+A; \t\tint A_plus_B_plus_C = A+B+C; \t\t \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tif(arr[i] != A &amp;&amp;  \t\t\t   arr[i] != B &amp;&amp;  \t\t\t   arr[i] != C &amp;&amp;  \t\t\t   arr[i] != A_plus_B &amp;&amp;  \t\t\t   arr[i] != B_plus_C &amp;&amp;  \t\t\t   arr[i] != C_plus_A &amp;&amp;  \t\t\t   arr[i] != A_plus_B_plus_C) return false; \t\t} \t\treturn true; \t} }  "
  },
  
  {
    "title": "BOJ_19942_다이어트 (Java)",
    "url": "/posts/BOJ19942%EB%8B%A4%EC%9D%B4%EC%96%B4%ED%8A%B8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-14 16:41:54 +0900",
    "content": "[Gold IV] 다이어트 - 19942  문제 링크  성능 요약  메모리: 19636 KB, 시간: 156 ms  분류  백트래킹, 브루트포스 알고리즘  제출 일자  2024년 11월 14일 16:29:06  문제 설명  식재료 N개 중에서 몇 개를 선택해서 이들의 영양분(단백질, 탄수화물, 지방, 비타민)이 일정 이상이 되어야 한다. 아래 표에 제시된 6가지의 식재료 중에서 몇 개를 선택해서 이들의 영양분의 각각 합이 최소 100, 70, 90, 10가 되도록 하는 경우를 생각해보자. 이 경우 모든 재료를 선택하면 쉽게 해결되지만, 우리는 조건을 만족시키면서도 비용이 최소가 되는 선택을 하려고 한다.                 재료       단백질       지방       탄수화물       비타민       가격                       1       30       55       10       8       100                 2       60       10       10       2       70                 3       10       80       50       0       50                 4       40       30       30       8       60                 5       60       10       70       2       120                 6       20       70       50       4       40           예를 들어, 식재료 1, 3, 5를 선택하면 영양분은 100, 145, 130, 10으로 조건을 만족하지만 가격은 270이 된다. 대신 2, 3, 4를 선택하면 영양분의 합은 110, 130, 90, 10, 비용은 180이 되므로, 앞의 방법보다는 더 나은 선택이 된다.  입력으로 식재료 표가 주어졌을 때, 최저 영양소 기준을 만족하는 최소 비용의 식재료 집합을 찾아야 한다.  입력    첫 줄에 식재료의 개수 N이 주어진다.   다음 줄에는 단백질, 지방, 탄수화물, 비타민의 최소 영양성분을 나타내는 정수 mp, mf, ms, mv가 주어진다.   이어지는 N개의 각 줄에는 i번째 식재료의 단백질, 지방, 탄수화물, 비타민과 가격이 5개의 정수 pᵢ, fᵢ, sᵢ, vᵢ, cᵢ와 같이 주어진다.   식재료의 번호는 1부터 시작한다.   출력    첫 번째 줄에 최소 비용을 출력하고, 두 번째 줄에 조건을 만족하는 최소 비용 식재료의 번호를 공백으로 구분해 오름차순으로 한 줄에 출력한다.   같은 비용의 집합이 하나 이상이면 사전 순으로 가장 빠른 것을 출력한다.   조건을 만족하는 답이 없다면 -1을 출력하고, 둘째 줄에 아무것도 출력하지 않는다.   제한    3 ≤ N ≤ 15   0 ≤ mp, mf, ms, mv ≤ 500   mp + mf + ms + mv &gt; 0   0 ≤ pᵢ, fᵢ, sᵢ, vᵢ, cᵢ ≤ 500   코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \t \tclass Ingredient{ \t\tint protein; \t\tint fat; \t\tint carbohydrate; \t\tint vitamin; \t\tint cost; \t\t \t\tpublic Ingredient(int protein, int fat, int carbohydrate, int vitamin, int cost){ \t\t\tthis.protein = protein; \t\t\tthis.fat = fat; \t\t\tthis.carbohydrate = carbohydrate; \t\t\tthis.vitamin = vitamin; \t\t\tthis.cost = cost; \t\t} \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, min[] = new int [4], res = Integer.MAX_VALUE; \tstatic Map&lt;Integer, Ingredient&gt; ingredients = new HashMap&lt;Integer, Ingredient&gt;(); \tstatic List&lt;Integer&gt; currChoosed = new ArrayList&lt;Integer&gt;(); \tstatic List&lt;Integer&gt; resIngredient = new ArrayList&lt;Integer&gt;(); \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;4; i++) { \t\t\tmin[i] = Integer.parseInt(st.nextToken()); \t\t} \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint protein = Integer.parseInt(st.nextToken()); \t\t\tint fat = Integer.parseInt(st.nextToken()); \t\t\tint carbohydrate = Integer.parseInt(st.nextToken()); \t\t\tint vitamin = Integer.parseInt(st.nextToken()); \t\t\tint cost = Integer.parseInt(st.nextToken()); \t\t\t \t\t\tingredients.put(i, new Ingredient(protein, fat, carbohydrate, vitamin, cost)); \t\t} \t\t \t\tdfs(0, 0, 0, 0, 0, 0); \t\t \t\tif(res == Integer.MAX_VALUE) { \t\t\tSystem.out.println(-1); \t\t\treturn; \t\t}  \t\tSystem.out.println(res); \t\tfor(int i=0; i&lt;resIngredient.size(); i++) { \t\t\tSystem.out.print(resIngredient.get(i) + 1 + \" \" ); \t\t} \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void dfs(int depth, int sumProtein, int sumFat, int sumCarbo, int sumVitamin, int sumCost) { \t\tif(sumCost &gt; res) return; \t\t \t\tif(sumProtein &gt;= min[0] &amp;&amp; sumFat &gt;= min[1] &amp;&amp; sumCarbo &gt;= min[2] &amp;&amp; sumVitamin &gt;= min[3]) { \t\t\tif(res &gt; sumCost) { \t\t\t\tres = sumCost; \t\t\t\tresIngredient = new ArrayList&lt;Integer&gt;(currChoosed); \t\t\t} \t\t\treturn; \t\t} \t\t \t\tif(depth &gt;= N) return; \t\t \t\tcurrChoosed.add(depth); \t\tIngredient ingredient = ingredients.get(depth); \t\tdfs(depth + 1, \t\t\tsumProtein + ingredient.protein, \t\t\tsumFat + ingredient.fat, \t\t\tsumCarbo + ingredient.carbohydrate, \t\t\tsumVitamin + ingredient.vitamin, \t\t\tsumCost + ingredient.cost); \t\t \t\tcurrChoosed.remove(Integer.valueOf(depth)); \t\t \t\tdfs(depth +1, sumProtein, sumFat, sumCarbo, sumVitamin, sumCost); \t} }  "
  },
  
  {
    "title": "BOJ_16884_나이트 게임 (Java)",
    "url": "/posts/BOJ16884%EB%82%98%EC%9D%B4%ED%8A%B8-%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-14 09:04:53 +0900",
    "content": "[Gold III] 나이트 게임 - 16884  문제 링크  성능 요약  메모리: 14412 KB, 시간: 104 ms  분류  애드 혹, 게임 이론  제출 일자  2024년 11월 13일 20:50:05  문제 설명  나이트 게임은 크기가 N×N인 체스판 위에서 진행되는 게임이고, 나이트를 하나씩 턴을 번갈아가며 놓는 게임이다.  나이트는 이미 놓여져 있는 나이트가 공격할 수 있는 칸에 놓을 수 없다. 나이트를 (r, c)에 놓은 경우에는 (r-2, c+1), (r-1, c+2), (r+1, c+2), (r+2, c+1), (r+2, c-1), (r+1, c-2), (r-1, c-2), (r-2, c-1)이 공격할 수 있는 칸이다.  나이트를 놓을 수 있는 칸이 없는 사람이 게임을 지게 된다. 구사과와 큐브러버가 이 게임을 최적의 방법으로 플레이했을 때, 이기는 사람을 구하는 프로그램을 작성하시오. 게임은 구사과가 먼저 시작한다.  입력  첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 100)가 주어진다. 둘째 줄부터 T개의 줄에 테스트 케이스가 한 줄에 하나씩 주어지며, 체스판의 크기 N(1 ≤ N ≤ 10,000)으로 이루어져 있다.  출력  각각의 테스트 케이스마다 게임을 이기는 사람을 출력한다. 구사과가 이기는 경우에는 \"koosaga\", 큐브러버가 이기는 경우에는 \"cubelover\"를 출력한다.     문제 풀이   점 대칭으로 패를 놓을 경우 후공이 항상 이길 수 있다. 보드의 크기가 짝수면 성립하지만 홀수일 경우 점대칭의 중심이 1+ n/2, 1 + n/2에 존재하므로 선공이 중점에 놓으면 후공이 선공으로 바뀌기 때문에 승리자가 반대가 된다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\t// br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tint T = Integer.parseInt(br.readLine()); \t\twhile(T --&gt; 0) { \t\t\tbw.write(Integer.parseInt(br.readLine())%2==1?\"koosaga\\n\" : \"cubelover\\n\"); \t\t} \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "PGMS_사칙연산 (Java)",
    "url": "/posts/PGMS%EC%82%AC%EC%B9%99%EC%97%B0%EC%82%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2024-11-12 11:32:09 +0900",
    "content": "[level 4] 사칙연산 - 1843 문제 링크    성능 요약 메모리: 52 MB, 시간: 0.96 ms 구분 코딩테스트 연습 &gt; 동적계획법（Dynamic Programming） 채점결과 정확성: 55.6효율성: 44.4합계: 100.0 / 100.0 제출 일자 2024년 11월 12일 11:25:18 문제 설명 사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다. 예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다.  ((1 - 5) - 3) = -7 (1 - (5 - 3)) = -1  위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다. 또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다.  (((1 - 3) + 5) - 8) = -5 ((1 - (3 + 5)) - 8) = -15 (1 - ((3 + 5) - 8)) = 1 (1 - (3 + (5 - 8))) = 1 ((1 - 3) + (5 - 8)) = -5  위와 같이 서로 다른 연산 순서의 계산 결과는 [-15, -5, -5, 1, 1]이 되며, 이중 최댓값은 1입니다. 문자열 형태의 숫자와, 더하기 기호(\"+\"), 뺄셈 기호(\"-\")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요. 제한 사항  arr는 두 연산자 \"+\", \"-\" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다.  arr의 길이는 항상 홀수입니다. arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다. 숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : \"456\")  배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다.    입출력 예           arr result            [\"1\", \"-\", \"3\", \"+\", \"5\", \"-\", \"8\"] 1   [\"5\", \"-\", \"3\", \"+\", \"1\", \"+\", \"2\", \"-\", \"4\"] 3          입출력 예시 입출력 예 #1 위의 예시와 같이 (1-(3+(5-8))) = 1 입니다. 입출력 예 #2 (5-(3+((1+2)-4))) = 3 입니다.    출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges   코드 import java.util.*;  class Solution {     static StringBuilder sb = new StringBuilder();     List&lt;String&gt; divideInMinus = new ArrayList&lt;&gt;();     public int solution(String arr[]) {         for(String s : arr){             if(s.equals(\"-\")){                 if(sb.length()&gt;0){                     divideInMinus.add(sb.toString());                     sb.setLength(0); // 새로운 객체 생성보다 부담 적고 delete연산은 이것보다 더 많은 연산 수행하므로 이게 제일 효율적                 }             }             else{                 sb.append(s);             }         }         if(sb.length() &gt; 0) divideInMinus.add(sb.toString());              // 이제 뒤에서부터 덧셈으로 묶인 부분의 최솟값과 최댓값을 찾는다. 제일 첫번째 항목은 -가 불가능하므로 1번인덱스부터 끝인덱스를 역순으로.                  // 맨 앞 양수 항         String[] firstNums = divideInMinus.get(0).split(\"\\\\+\");         int firstSum = 0;         for(String num : firstNums){             firstSum += Integer.parseInt(num);         }                  int fromBackToSecond_Max = 0;         int fromBackToSecond_Min = 0;                  for(int i=divideInMinus.size()-1; i&gt;=1; i--){             int currMax = calMax(divideInMinus.get(i));             int currMin = calMin(divideInMinus.get(i));                          fromBackToSecond_Max = Math.max(currMax + fromBackToSecond_Max, currMin - fromBackToSecond_Min);             fromBackToSecond_Min = Math.min(currMin + fromBackToSecond_Min, currMin - fromBackToSecond_Min);         }                  int res = firstSum + fromBackToSecond_Max;         return res;     }     private int calMax(String str){         String[] nums = str.split(\"\\\\+\"); // regex         // String[] nums = str.split(Pattern.quote(\"+\"));         int max = (-1) * Integer.parseInt(nums[0]);         for(int i=1; i&lt;nums.length; i++){             max += Integer.parseInt(nums[i]);         }         return max;     }     private int calMin(String str){         String[] nums = str.split(\"\\\\+\"); // regex         // String[] nums = str.split(Pattern.quote(\"+\"));         int min = 0;         for(String num : nums){             min += Integer.parseInt(num);         }         return (-1) * min;     } }  "
  },
  
  {
    "title": "BOJ_2170_선 긋기 (Java)",
    "url": "/posts/BOJ2170%EC%84%A0-%EA%B8%8B%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-12 00:49:38 +0900",
    "content": "[Gold V] 선 긋기 - 2170  문제 링크  성능 요약  메모리: 280852 KB, 시간: 2268 ms  분류  정렬, 스위핑  제출 일자  2024년 11월 12일 00:38:46  문제 설명  매우 큰 도화지에 자를 대고 선을 그으려고 한다. 선을 그을 때에는 자의 한 점에서 다른 한 점까지 긋게 된다. 선을 그을 때에는 이미 선이 있는 위치에 겹쳐서 그릴 수도 있는데, 여러 번 그은 곳과 한 번 그은 곳의 차이를 구별할 수 없다고 하자.  이와 같은 식으로 선을 그었을 때, 그려진 선(들)의 총 길이를 구하는 프로그램을 작성하시오. 선이 여러 번 그려진 곳은 한 번씩만 계산한다.  입력  첫째 줄에 선을 그은 횟수 N (1 ≤ N ≤ 1,000,000)이 주어진다. 다음 N개의 줄에는 선을 그을 때 선택한 두 점의 위치 x, y (-1,000,000,000 ≤ x &lt; y ≤ 1,000,000,000)가 주어진다.  출력  첫째 줄에 그은 선의 총 길이를 출력한다.     문제 풀이   선을 긋는 경우가 두가지 있다. 연결될때/연결되지 않을 때  연결되면 오른쪽 max값만 갱신해가면되고 끊어지면 끊어지기 전 길이까지 저장하고 (더해주고) 다시 새로운 선부터 길이 측정해나간다.  최종으로 더한값 반환.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, line[][];  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tline = new int[N][2]; \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint x = Integer.parseInt(st.nextToken()); \t\t\tint y = Integer.parseInt(st.nextToken()); \t\t\tline[i][0] = x; \t\t\tline[i][1] = y; \t\t}  \t\tArrays.sort(line, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]); // 오름차순  \t\tlong res = 0; \t\tint left = line[0][0]; \t\tint right = line[0][1];  \t\tfor (int[] l : line) { \t\t\t// 새 선 시작이 원래 선 내부일때 (겹침포함) \t\t\tif (l[0] &lt;= right) { \t\t\t\tright = Math.max(right, l[1]); \t\t\t} \t\t\t// 외부일떄 \t\t\telse { \t\t\t\tres += right - left; \t\t\t\tleft = l[0]; \t\t\t\tright = l[1]; \t\t\t} \t\t}  \t\tres += right - left; \t\t \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_2792_보석 상자 (Java)",
    "url": "/posts/BOJ2792%EB%B3%B4%EC%84%9D-%EC%83%81%EC%9E%90-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-10 16:23:40 +0900",
    "content": "[Silver I] 보석 상자 - 2792 문제 링크 성능 요약 메모리: 34716 KB, 시간: 320 ms 분류 이분 탐색, 매개 변수 탐색 제출 일자 2024년 11월 10일 16:08:43 문제 설명 보석 공장에서 보석 상자를 유치원에 기증했다. 각각의 보석은 M가지 서로 다른 색상 중 한 색상이다. 원장 선생님은 모든 보석을 N명의 학생들에게 나누어 주려고 한다. 이때, 보석을 받지 못하는 학생이 있어도 된다. 하지만, 학생은 항상 같은 색상의 보석만 가져간다. 한 아이가 너무 많은 보석을 가져가게 되면, 다른 아이들이 질투를 한다. 원장 선생님은 이런 질투심을 수치화하는데 성공했는데, 질투심은 가장 많은 보석을 가져간 학생이 가지고 있는 보석의 개수이다. 원장 선생님은 질투심이 최소가 되게 보석을 나누어 주려고 한다. 상자에 빨간 보석이 4개 (RRRR), 파란 보석이 7개 (BBBBBBB) 있었고, 이 보석을 5명의 아이들에게 나누어 주는 경우를 생각해보자. RR, RR, BB, BB, BBB로 보석을 나누어주면 질투심은 3이 되고, 이 값보다 작게 나누어 줄 수 없다. 상자 안의 보석 정보와 학생의 수가 주어졌을 때, 질투심이 최소가 되게 보석을 나누어주는 방법을 알아내는 프로그램을 작성하시오. 입력 첫째 줄에 아이들의 수 N과 색상의 수 M이 주어진다. (1 ≤ N ≤ 109, 1 ≤ M ≤ 300,000, M ≤ N) 다음 M개 줄에는 구간 [1, 109]에 포함되는 양의 정수가 하나씩 주어진다. K번째 줄에 주어지는 숫자는 K번 색상 보석의 개수이다. 출력 첫째 줄에 질투심의 최솟값을 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*; public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, arr[], res; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t} \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\t \t\tarr = new int[M]; \t\tint left = 1; \t\tint right = -987654321; \t\tres = 0; \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tarr[i] = Integer.parseInt(br.readLine()); \t\t\tright = Math.max(right, arr[i]); \t\t} \t\twhile (left &lt;= right) { \t\t\tint mid = (right - left) / 2 + left; \t\t\tif (canDivideBead(mid)) { \t\t\t\tright = mid - 1; \t\t\t\tres = mid; \t\t\t} else { \t\t\t\tleft = mid + 1; \t\t\t} \t\t} \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \tprivate boolean canDivideBead(int mid) { \t\tint cnt = 0; \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tcnt += (arr[i] % mid) == 0 ? arr[i]/mid : arr[i]/mid + 1; \t\t} \t\treturn cnt &lt;= N; \t} }  "
  },
  
  {
    "title": "PGMS_대장균 크기에 따라 분류하기 (2) - SQL",
    "url": "/posts/PGMS%EB%8C%80%EC%9E%A5%EA%B7%A0-%ED%81%AC%EA%B8%B0%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%B6%84%EB%A5%98%ED%95%98%EA%B8%B0-2-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-11-09 17:33:29 +0900",
    "content": "[level 3] 대장균의 크기에 따라 분류하기 2 - 301649  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SELECT  채점결과  합계: 100.0 / 100.0  제출 일자  2024년 11월 09일 17:30:00  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  대장균 개체의 크기를 내름차순으로 정렬했을 때 상위 0% ~ 25% 를 'CRITICAL', 26% ~ 50% 를 'HIGH', 51% ~ 75% 를 'MEDIUM', 76% ~ 100% 를 'LOW' 라고 분류합니다. 대장균 개체의 ID(ID) 와 분류된 이름(COLONY_NAME)을 출력하는 SQL 문을 작성해주세요. 이때 결과는 개체의 ID 에 대해 오름차순 정렬해주세요 . 단, 총 데이터의 수는 4의 배수이며 같은 사이즈의 대장균 개체가 서로 다른 이름으로 분류되는 경우는 없습니다.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 10 2019/01/01 5   2 NULL 2 2019/01/01 3   3 1 100 2020/01/01 4   4 2 16 2020/01/01 4   5 2 17 2020/01/01 6   6 4 101 2021/01/01 22   7 6 101 2022/01/01 23   8 6 1 2022/01/01 27          기준에 의해 분류된 대장균들의 ID는 다음과 같습니다.  CRITICAL (상위 0% ~ 25%) : ID 6, ID 7 HIGH (상위 26% ~ 50%) : ID 3, ID 5 MEDIUM (상위 51% ~ 75%) : ID 1, ID 4 LOW (상위 76% ~ 100%) : ID 2, ID 8  따라서 결과를 ID 에 대해 오름차순 정렬하면 다음과 같아야 합니다.           ID COLONY_NAME            1 MEDIUM   2 LOW   3 HIGH   4 MEDIUM   5 HIGH   6 CRITICAL   7 CRITICAL   8 LOW              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges   코드 SELECT e.ID,      CASE         WHEN PERCENT_RANK() OVER (ORDER BY e.SIZE_OF_COLONY DESC) &lt;= 0.25 THEN 'CRITICAL'         WHEN PERCENT_RANK() OVER (ORDER BY e.SIZE_OF_COLONY DESC) &lt;= 0.5 THEN 'HIGH'         WHEN PERCENT_RANK() OVER (ORDER BY e.SIZE_OF_COLONY DESC) &lt;= 0.75 THEN 'MEDIUM'         ELSE 'LOW'     END AS COLONY_NAME     FROM ECOLI_DATA AS e         ORDER BY ID;  "
  },
  
  {
    "title": "BOJ_17307_색깔 통일하기 (Java)",
    "url": "/posts/BOJ17307%EC%83%89%EA%B9%94-%ED%86%B5%EC%9D%BC%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-08 18:10:21 +0900",
    "content": "[Gold II] 색깔 통일하기 - 17307  문제 링크  성능 요약  메모리: 49200 KB, 시간: 432 ms  분류  누적 합  제출 일자  2024년 11월 8일 18:05:43  문제 설명  N개의 버튼이 일렬로 나열되어 있다. 이 버튼들은 바로 양옆에 인접한 버튼끼리 연결되어 있다. 각 버튼은 LED가 내장되어있어 총 C 종류의 색을 띨 수 있다. 그 색깔들을 각각 0번 색깔, 1번 색깔, ..., (C-1)번 색깔이라고 하자.  이때 현재 색깔이 x인 한 버튼을 누르면 누른 버튼과 함께 해당 버튼의 양옆으로 같은 색으로 연속해서 이어진 모든 버튼이 (x+1)%C 번 색깔로 변한다. 우리의 목표는 버튼을 누르는 횟수를 최소화하며 모든 버튼을 같은 색깔로 만드는 것이다.  예를 들어, N=5, C=4일 때 아래와 같은 색의 버튼들이 있다고 하자.    여기서 4번 버튼을 누르면 현재 4번 버튼의 양옆에 같은 색의 버튼이 없으므로 4번 버튼의 색만 0번 색깔로 바뀌게 된다.    그 이후 2번째 버튼을 누르면 2번의 왼쪽으로는 같은 색의 버튼이 없고, 오른쪽으로 연속한 3, 4번 버튼이 2번 버튼의 색과 같으므로 2, 3, 4번 버튼의 색이 1번 색깔로 바뀐다.    그 이후 3번째 버튼을 누르면 1, 2, 3, 4, 5번 버튼의 색이 모두 함께 2번 색깔로 바뀌게 된다.    우리의 목적은 버튼을 누르는 횟수를 최소화 하면서 모든 버튼의 색을 한 색으로 통일시키는 것이다. 위의 방법대로면 4번 버튼을 누른 후 2번 버튼을 누르면서 2회만에 1번 색으로 통일된다.  하지만 지금은 어떤 이유로 오직 하나의 버튼만 누를 수 있기에, 4번 버튼을 누르고 2번 버튼을 누르는 방법은 쓸 수 없게 되었다. 그렇다면 어떤 버튼을 선택해야 해당 버튼을 최소한으로 누르며 모든 버튼의 색을 통일시킬 수 있을까?  입력  첫 번째 줄에 버튼의 수 N(1 ≤ N ≤ 250,000)과 가능한 색의 수 (1 ≤ C ≤ 109)가 공백으로 구분되어 주어진다.  다음 줄에 현재 각 버튼의 색 Xi (0 ≤ Xi &lt; C, 1 ≤ i ≤ N)가 공백으로 구분되어 주어진다.  출력  첫 번째 줄에 몇 번 버튼을 눌러야 하는지 출력한다, 버튼에는 가장 왼쪽에서 시작해 1번부터 N번까지 번호가 차례로 매겨져 있다.  두 번째 줄에 모든 버튼을 같은 색으로 통일시키기 위해 그 버튼을 눌러야 할 횟수를 출력한다. 만약 최소 횟수가 되는 버튼이 여러 개 존재한다면 그중 가장 왼쪽의 버튼을 출력한다.     문제 풀이      코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, C, colors[]; \tstatic long rightPrefixSum[], leftPrefixSum[], finalCnt[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tN = Integer.parseInt(st.nextToken()); \t\tC = Integer.parseInt(st.nextToken()); \t\tcolors = new int[N]; \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tcolors[i] = Integer.parseInt(st.nextToken()); \t\t} \t\t \t\trightPrefixSum = new long[N]; \t\tleftPrefixSum = new long[N]; \t\trightPrefixSum[0] = 0; \t\tleftPrefixSum[N-1] =0; \t\t \t\tfor(int i=1; i&lt;N; i++) { \t\t\tint y = colors[i]; \t\t\tint x = colors[i-1]; //\t\t\tSystem.out.print(x + \" 에서 \" + y + \" 까지 가는데  \"); \t\t\trightPrefixSum[i] = rightPrefixSum[i-1] + calButtonClickCnt(x, y); //\t\t\tSystem.out.println(\"만큼 걸려\"); \t\t} \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tlong tmp = rightPrefixSum[i]; \t\t\trightPrefixSum[i] = rightPrefixSum[N-1] - tmp; \t\t} \t\t \t\tfor(int i=N-2; i&gt;=0; i--) { \t\t\tint y = colors[i]; \t\t\tint x = colors[i+1]; //\t\t\tSystem.out.print(x + \" 에서 \" + y + \" 까지 가는데  \"); \t\t\tleftPrefixSum[i] = leftPrefixSum[i+1] + calButtonClickCnt(x, y); //\t\t\tSystem.out.println(\" 만큼 걸려\"); \t\t} \t\t \t\tfor(int i=N-1; i&gt;=0; i--) { \t\t\tlong tmp = leftPrefixSum[i]; \t\t\tleftPrefixSum[i] = leftPrefixSum[0] - tmp; \t\t} \t\t \t\tfinalCnt = new long[N]; \t\tlong res = Long.MAX_VALUE; \t\tint residx = -1; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfinalCnt[i] = Math.max(leftPrefixSum[i], rightPrefixSum[i]); \t\t\tif (finalCnt[i] &lt; res) { \t            res = finalCnt[i]; \t            residx = i; \t        } \t\t} \t\t //\t\tSystem.out.println(Arrays.toString(colors)); //\t\tSystem.out.println(Arrays.toString(rightPrefixSum)); //\t\tSystem.out.println(Arrays.toString(leftPrefixSum)); //\t\tSystem.out.println(Arrays.toString(finalCnt)); \t\t\t \t\t \t\tbw.write(String.valueOf(residx+1 + \"\\n\" + res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t \tprivate static long calButtonClickCnt(int x, int y) { //\t\tSystem.out.print((y+C-x) %C); \t\treturn (y+C-x) %C; \t} }  "
  },
  
  {
    "title": "BOJ_10972_다음 순열(Java)",
    "url": "/posts/BOJ10972%EB%8B%A4%EC%9D%8C-%EC%88%9C%EC%97%B4Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-06 06:10:52 +0900",
    "content": "[Silver III] 다음 순열 - 10972  문제 링크  성능 요약  메모리: 17140 KB, 시간: 176 ms  분류  조합론, 수학  제출 일자  2024년 11월 6일 06:06:48  문제 설명  1부터 N까지의 수로 이루어진 순열이 있다. 이때, 사전순으로 다음에 오는 순열을 구하는 프로그램을 작성하시오.  사전 순으로 가장 앞서는 순열은 오름차순으로 이루어진 순열이고, 가장 마지막에 오는 순열은 내림차순으로 이루어진 순열이다.  N = 3인 경우에 사전순으로 순열을 나열하면 다음과 같다.   \t1, 2, 3 \t1, 3, 2 \t2, 1, 3 \t2, 3, 1 \t3, 1, 2 \t3, 2, 1   입력  첫째 줄에 N(1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄에 순열이 주어진다.  출력  첫째 줄에 입력으로 주어진 순열의 다음에 오는 순열을 출력한다. 만약, 사전순으로 마지막에 오는 순열인 경우에는 -1을 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, nums[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tst = new StringTokenizer(br.readLine());         nums = new int[N];         for (int i = 0; i &lt; N; i++) {             nums[i] = Integer.parseInt(st.nextToken());         } \t\t \t\tif(isNextPermutation()) bw.write(getNextPermutation()); \t\telse bw.write(String.valueOf(-1)); \t\t  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t\t/* \t\t * 3 5 4 2 1 \t\t * 다음순열 구하는법 \t\t * 끝에서부터 작아지는 구간 있는지 체크해서 5에서 3으로 내려가니까 다음 순열이 존재. (끝까지 오름차순으로 끝나면 없다는거) \t\t * 3보다 큰 수 찾아서 바꾸고 \t\t * 4 5 3 2 1 \t\t * 다시 끝에서부터 체크해서 전부 내림차순이어야함. \t\t *  \t\t * 3 4 5 2 1였으면 \t\t *idx : 인덱스2, target : 인덱스2 , target이랑 idx-1을 교환 \t\t * 3 5 4 2 1가 됐다가 \t\t * 3 5 1 2 4로 돌려야함.  \t\t */ \tprivate String getNextPermutation() { \t\tStringBuilder sb = new StringBuilder(); \t\tfor (int i = 0; i &lt; N; i++) {             sb.append(nums[i] + \" \");         } \t\treturn sb.toString(); \t}  \tprivate void swap(int i, int j) { \t\tint temp = nums[i];         nums[i] = nums[j];         nums[j] = temp;\t\t \t}  \tprivate boolean isNextPermutation() { \t\tint i = N-1; \t\t while (i&gt;0 &amp;&amp; nums[i-1] &gt;= nums[i]) { \t            i--;  \t        } \t        if (i &lt;= 0) return false; \t  \t        int j = nums.length - 1; \t        while (nums[j] &lt;= nums[i-1]) { \t            j--;  \t        } \t  \t        swap(i-1, j); \t        j = nums.length - 1; \t        while (i&lt;j) { \t            swap(i, j); \t            i++; \t            j--; \t        } \t        return true; \t} }  "
  },
  
  {
    "title": "BOJ_1011_Fly me to the Alpha Centauri(Java)",
    "url": "/posts/BOJ1011Fly-me-to-the-Alpha-Centauri/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-05 12:57:17 +0900",
    "content": "[Gold V] Fly me to the Alpha Centauri - 1011  문제 링크  성능 요약  메모리: 15812 KB, 시간: 112 ms  분류  수학  제출 일자  2024년 11월 5일 12:37:39  문제 설명  우현이는 어린 시절, 지구 외의 다른 행성에서도 인류들이 살아갈 수 있는 미래가 오리라 믿었다. 그리고 그가 지구라는 세상에 발을 내려 놓은 지 23년이 지난 지금, 세계 최연소 ASNA 우주 비행사가 되어 새로운 세계에 발을 내려 놓는 영광의 순간을 기다리고 있다.  그가 탑승하게 될 우주선은 Alpha Centauri라는 새로운 인류의 보금자리를 개척하기 위한 대규모 생활 유지 시스템을 탑재하고 있기 때문에, 그 크기와 질량이 엄청난 이유로 최신기술력을 총 동원하여 개발한 공간이동 장치를 탑재하였다. 하지만 이 공간이동 장치는 이동 거리를 급격하게 늘릴 경우 기계에 심각한 결함이 발생하는 단점이 있어서, 이전 작동시기에 k광년을 이동하였을 때는 k-1 , k 혹은 k+1 광년만을 다시 이동할 수 있다. 예를 들어, 이 장치를 처음 작동시킬 경우 -1 , 0 , 1 광년을 이론상 이동할 수 있으나 사실상 음수 혹은 0 거리만큼의 이동은 의미가 없으므로 1 광년을 이동할 수 있으며, 그 다음에는 0 , 1 , 2 광년을 이동할 수 있는 것이다. ( 여기서 다시 2광년을 이동한다면 다음 시기엔 1, 2, 3 광년을 이동할 수 있다. )    김우현은 공간이동 장치 작동시의 에너지 소모가 크다는 점을 잘 알고 있기 때문에 x지점에서 y지점을 향해 최소한의 작동 횟수로 이동하려 한다. 하지만 y지점에 도착해서도 공간 이동장치의 안전성을 위하여 y지점에 도착하기 바로 직전의 이동거리는 반드시 1광년으로 하려 한다.  김우현을 위해 x지점부터 정확히 y지점으로 이동하는데 필요한 공간 이동 장치 작동 횟수의 최솟값을 구하는 프로그램을 작성하라.  입력  입력의 첫 줄에는 테스트케이스의 개수 T가 주어진다. 각각의 테스트 케이스에 대해 현재 위치 x 와 목표 위치 y 가 정수로 주어지며, x는 항상 y보다 작은 값을 갖는다. (0 ≤ x &lt; y &lt; 231)  출력  각 테스트 케이스에 대해 x지점으로부터 y지점까지 정확히 도달하는데 필요한 최소한의 공간이동 장치 작동 횟수를 출력한다.     문제 풀이    규칙을 찾아내서 풀었다!  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tsb = new StringBuilder(); \t\tint T = Integer.parseInt(br.readLine());                  for (int i = 0; i &lt; T; i++) {             StringTokenizer st = new StringTokenizer(br.readLine());             int x = Integer.parseInt(st.nextToken());             int y = Integer.parseInt(st.nextToken());                          sb.append(move(x, y)+\"\\n\");         }         bw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t \tpublic static int move(int x, int y) {         long len = y - x;                  long root = (long)Math.sqrt(len);               if (len &lt;= root * root) {             return (int) (root * 2 - 1);         } else if (len &lt;= root * (root + 1)) {             return (int) (root * 2);         } else {             return (int) (root * 2 + 1);         }     } }  "
  },
  
  {
    "title": "BOJ_19590_비드맨 (Java)",
    "url": "/posts/BOJ19590%EB%B9%84%EB%93%9C%EB%A7%A8-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-03 16:21:53 +0900",
    "content": "[Gold I] 비드맨 - 19590 문제 링크 성능 요약 메모리: 28228 KB, 시간: 268 ms 분류 그리디 알고리즘 제출 일자 2024년 11월 3일 16:10:57 문제 설명 구슬을 엄청 좋아하는 비드맨이 있다. 구슬만 보면 갖고 싶어 하는 비드맨은 오늘도 갖고 싶은 구슬을 발견했다. 그러나 비드맨은 현재 구슬을 너무 많이 갖고 있기 때문에 더 이상 구슬을 가질 수 없는 지경에 이르렀다. 비드맨은 서로 다른 종류의 구슬 두 개를 부딪히면 서로 깨져 없어진다는 것을 알고 있다. 이 사실을 이용해서 비드맨은 현재 가지고 있는 구슬의 개수를 최소로 하고자 한다. 그러나 구슬의 개수가 많기 때문에 비드맨은 도저히 계산을 할 수가 없었다. 길거리 해결사인 당신은 길거리에서 고민에 빠진 비드맨을 발견했고, 비드맨에게 고민에 빠진 이유를 듣게 된다. 인연인 만큼 당신은 비드맨의 고민을 해결해주려고 한다. 서로 다른 종류의 구슬 두 개를 부딪혀서 최대한 구슬을 없앤다고 할 때 남게 되는 구슬의 개수는 몇 개인지를 구하면 된다. 입력 첫 번째 줄에는 비드맨이 가지고 있는 구슬의 종류 N이 주어진다. (1 ≤ N ≤ 105) 두 번째 줄부터 N개의 줄에는 x1, x2​, x3, ..., xN이 주어진다. xi는 비드맨이 가지고 있는 i번째 종류의 구슬의 개수이다. (1 ≤ xi ≤ 109) 출력 비드맨이 최대한 많이 구슬을 없앴을 때 남는 구슬의 개수를 출력한다.     문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*; public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N; \tstatic long[] bead; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t} \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tN = Integer.parseInt(br.readLine()); \t\tbead = new long[N]; \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tlong beadNum = Long.parseLong(br.readLine()); \t\t\tbead[i] = beadNum; \t\t} \t\t \t\tPriorityQueue&lt;Long&gt; pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder()); // 최대힙 \t\t \t\tfor(long n : bead)  \t\t\tpq.offer(n); \t\t \t\tif(N==1) { \t\t\tbw.write(String.valueOf(bead[0])); \t\t} \t\telse { \t\t\tlong max = pq.poll(); \t\t\t \t\t\tlong sum = pq.stream() \t\t\t\t\t.mapToLong(Long::longValue) \t\t\t\t\t.sum(); \t\t\t \t\t\tlong totalSum = sum + max; \t\t\t \t\t\tif(max &gt; sum) { \t\t\t\tbw.write(String.valueOf(max - sum)); \t\t\t} \t\t\telse { \t\t\t\tif(totalSum %2 == 0) bw.write(String.valueOf(0)); \t\t\t\telse bw.write(String.valueOf(1)); \t\t\t} \t\t} \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_1600_말이 되고픈 원숭이 (Java)",
    "url": "/posts/BOJ1600%EB%A7%90%EC%9D%B4-%EB%90%98%EA%B3%A0%ED%94%88-%EC%9B%90%EC%88%AD%EC%9D%B4/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-11-02 22:58:11 +0900",
    "content": "[Gold III] 말이 되고픈 원숭이 - 1600  문제 링크  성능 요약  메모리: 93616 KB, 시간: 576 ms  분류  너비 우선 탐색, 그래프 이론, 그래프 탐색  제출 일자  2024년 11월 2일 22:56:49  문제 설명  동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 녀석은 말(Horse)이 되기를 간절히 원했다. 그래서 그는 말의 움직임을 유심히 살펴보고 그대로 따라 하기로 하였다. 말은 말이다. 말은 격자판에서 체스의 나이트와 같은 이동방식을 가진다. 다음 그림에 말의 이동방법이 나타나있다. x표시한 곳으로 말이 갈 수 있다는 뜻이다. 참고로 말은 장애물을 뛰어넘을 수 있다.   \t \t\t \t\t\t  \t\t\tx \t\t\t  \t\t\tx \t\t\t  \t\t \t\t \t\t\tx \t\t\t  \t\t\t  \t\t\t  \t\t\tx \t\t \t\t \t\t\t  \t\t\t  \t\t\t말 \t\t\t  \t\t\t  \t\t \t\t \t\t\tx \t\t\t  \t\t\t  \t\t\t  \t\t\tx \t\t \t\t \t\t\t  \t\t\tx \t\t\t  \t\t\tx \t\t\t  \t\t \t   근데 원숭이는 한 가지 착각하고 있는 것이 있다. 말은 저렇게 움직일 수 있지만 원숭이는 능력이 부족해서 총 K번만 위와 같이 움직일 수 있고, 그 외에는 그냥 인접한 칸으로만 움직일 수 있다. 대각선 방향은 인접한 칸에 포함되지 않는다.  이제 원숭이는 머나먼 여행길을 떠난다. 격자판의 맨 왼쪽 위에서 시작해서 맨 오른쪽 아래까지 가야한다. 인접한 네 방향으로 한 번 움직이는 것, 말의 움직임으로 한 번 움직이는 것, 모두 한 번의 동작으로 친다. 격자판이 주어졌을 때, 원숭이가 최소한의 동작으로 시작지점에서 도착지점까지 갈 수 있는 방법을 알아내는 프로그램을 작성하시오.  입력  첫째 줄에 정수 K가 주어진다. 둘째 줄에 격자판의 가로길이 W, 세로길이 H가 주어진다. 그 다음 H줄에 걸쳐 W개의 숫자가 주어지는데, 0은 아무것도 없는 평지, 1은 장애물을 뜻한다. 장애물이 있는 곳으로는 이동할 수 없다. 시작점과 도착점은 항상 평지이다. W와 H는 1이상 200이하의 자연수이고, K는 0이상 30이하의 정수이다.  출력  첫째 줄에 원숭이의 동작수의 최솟값을 출력한다. 시작점에서 도착점까지 갈 수 없는 경우엔 -1을 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tstatic int W, H, K; \tstatic int[][] board; \tstatic boolean[][][] visited; \tstatic int[] dr = {-1, 1, 0, 0}; // 상하좌우 \tstatic int[] dc = {0, 0, -1, 1}; \tstatic int[] hr = {-1, -2, -2, -1, 1, 2, 2, 1}; \tstatic int[] hc = {-2, -1, 1, 2, 2, 1, -1, -2}; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tK = Integer.parseInt(br.readLine()); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tW = Integer.parseInt(st.nextToken()); \t\tH = Integer.parseInt(st.nextToken()); \t\tboard = new int[H][W]; \t\tvisited = new boolean[H][W][K+1]; \t\tfor(int i=0; i&lt;H; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j=0; j&lt;W; j++) { \t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken()); \t\t\t\tif(board[i][j] == 1) { \t\t\t\t} \t\t\t} \t\t} \t\tint res = bfs(0, 0, K); \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int bfs(int r, int c, int k) { \t\tQueue&lt;Pos&gt; queue = new LinkedList&lt;&gt;(); \t\tqueue.add(new Pos(r, c, 0, 0)); \t\tvisited[r][c][0] = true; \t\t \t\twhile(!queue.isEmpty()) { \t\t\tPos curr = queue.poll(); \t\t\t \t\t\tint currR = curr.r; \t\t\tint currC = curr.c; \t\t\tif(currR == H-1 &amp;&amp; currC == W-1) return curr.mCnt; \t\t\t \t\t\tfor(int idx=0; idx&lt;4; idx++) { \t\t\t\tint newR = currR + dr[idx]; \t\t\t\tint newC = currC + dc[idx]; \t\t\t\t \t\t\t\t// 경계조건 \t\t\t\tif(newR &lt; 0 || newR &gt;= H || newC &lt; 0 || newC &gt;= W) continue; \t\t\t\t// 방문한곳 or 장애물                 if(visited[newR][newC][curr.hCnt] || board[newR][newC] == 1) continue; \t\t\t\t \t\t\t\tif(board[newR][newC] == 0) { \t\t\t\t\tvisited[newR][newC][curr.hCnt] = true; \t\t\t\t\tqueue.offer(new Pos(newR, newC, curr.hCnt, curr.mCnt+1)); \t\t\t\t}\t\t\t \t\t\t} \t\t\t \t\t\t// 말 점프 가능하면 말점프 \t\t\tif(curr.hCnt&lt;k) { \t\t\t\tfor(int idx = 0; idx&lt;8; idx++) { \t\t\t\t\tint newR = currR + hr[idx]; \t\t\t\t\tint newC = currC + hc[idx]; \t\t\t\t\t \t\t\t\t\tif(newR &lt; 0 || newR &gt;= H || newC &lt; 0 || newC &gt;= W) continue; \t\t\t\t\t                     if(visited[newR][newC][curr.hCnt+1] || board[newR][newC] == 1) continue; \t\t\t\t \t\t\t\t\tif(board[newR][newC] == 0) { \t\t\t\t\t\tvisited[newR][newC][curr.hCnt+1] = true; \t\t\t\t\t\tqueue.offer(new Pos(newR, newC, curr.hCnt+1, curr.mCnt+1)); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t\t \t\treturn -1; \t} \t \tstatic class Pos{ \t\tint r, c; \t\tint hCnt; //말 점프 횟수 \t\tint mCnt; //움직인 횟수 \t\t \t\tPos(int r, int c, int hCnt, int mCnt){ \t\t\tthis.r = r; \t\t\tthis.c = c; \t\t\tthis.hCnt = hCnt; \t\t\tthis.mCnt = mCnt; \t\t} \t} }   "
  },
  
  {
    "title": "PGMS_산 모양 타일링",
    "url": "/posts/PGMS%EC%82%B0-%EB%AA%A8%EC%96%91-%ED%83%80%EC%9D%BC%EB%A7%81/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2024-10-31 04:35:10 +0900",
    "content": "[level 3] 산 모양 타일링 - 258705  문제 링크  성능 요약  메모리: 92.4 MB, 시간: 8.65 ms  구분  코딩테스트 연습 &gt; 2024 KAKAO WINTER INTERNSHIP  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2024년 10월 31일 04:31:55  문제 설명  한 변의 길이가 1인 정삼각형 2n+1개를 이어붙여 윗변의 길이가 n, 아랫변의 길이가 n+1인 사다리꼴을 만들 수 있습니다. 이때 사다리꼴의 윗변과 변을 공유하는 n개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양을 만들었습니다. 예를 들어 n이 4이고, 1번째, 2번째, 4번째 정삼각형 위에 정삼각형을 붙인 모양은 다음과 같습니다.    이렇게 만든 모양을 정삼각형 타일 또는 정삼각형 2개를 이어 붙인 마름모 타일로 빈 곳이 없도록 채우려고 합니다. 정삼각형 타일과 마름모 타일은 돌려서 사용할 수 있습니다.    타일을 놓을 때 다른 타일과 겹치거나 모양을 벗어나게 놓을 수는 없습니다. 위의 예시 모양을 채우는 방법 중 일부는 다음과 같습니다.    사다리꼴의 윗변의 길이를 나타내는 정수 n과 사다리꼴 윗변에 붙인 정삼각형을 나타내는 1차원 정수 배열 tops가 매개변수로 주어집니다. 이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 10007로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요.    제한사항   1 ≤ n ≤ 100,000 tops의 길이 = n   tops[i]는 사다리꼴의 윗변과 변을 공유하는 i+1번째 정삼각형의 위쪽에 정삼각형을 붙이는 경우 1, 붙이지 않는 경우 0입니다.      입출력 예           n tops result            4 [1, 1, 0, 1] 149   2 [0, 1] 11   10 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 7704            입출력 예 설명  입출력 예 #1  문제의 예시와 같습니다. 문제에서 설명한 방법을 포함해 총 149가지 방법이 존재합니다.  따라서 149를 return 해야 합니다.  입출력 예 #2  문제 설명에 따라 만든 모양은 다음과 같습니다.    이 모양을 타일로 채우는 방법은 다음과 같이 총 11가지입니다.    따라서 11을 return 해야 합니다.  입출력 예 #3  경우의 수는 총 17,711가지입니다. 따라서 17711을 10007로 나눈 나머지인 7704를 return 해야 합니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     코드 /**  * Author : nowalex322, Kim HyeonJae( KR )  */ class Solution {     private static final int MOD = 10007;     public int solution(int n, int[] tops) {         int answer = 0;         int[] hasTail = new int[n]; // 3번 모양으로 끝났는가? o         int[] noTail  = new int[n]; // x                 hasTail[0] = 1;         noTail[0] = 2;         noTail[0] += tops[0];                  for(int i=1; i&lt;n; i++){             hasTail[i] = hasTail[i-1] + noTail[i-1] ;             if(tops[i] == 1) noTail[i] = hasTail[i-1]*2 + noTail[i-1]*3;             else noTail[i] = hasTail[i-1]*1 + noTail[i-1]*2;                          hasTail[i] %= MOD;             noTail[i] %= MOD;         }                     return (hasTail[n-1] + noTail[n-1])%MOD;     } }  "
  },
  
  {
    "title": "BOJ_2437_저울",
    "url": "/posts/BOJ2437%EC%A0%80%EC%9A%B8/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-31 02:03:11 +0900",
    "content": "[Gold II] 저울 - 2437  문제 링크  성능 요약  메모리: 14788 KB, 시간: 112 ms  분류  그리디 알고리즘, 정렬  제출 일자  2024년 10월 31일 01:59:38  문제 설명  하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 한다. 이 저울의 양 팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있다.    무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 프로그램을 작성하시오.  예를 들어, 무게가 각각 3, 1, 6, 2, 7, 30, 1인 7개의 저울추가 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21이다.   입력  첫 째 줄에는 저울추의 개수를 나타내는 양의 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 둘째 줄에는 저울추의 무게를 나타내는 N개의 양의 정수가 빈칸을 사이에 두고 주어진다. 각 추의 무게는 1이상 1,000,000 이하이다.  출력  첫째 줄에 주어진 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tint N = Integer.parseInt(br.readLine()); \t\tint[] arr = new int[N]; \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t} \t\tArrays.sort(arr); \t\t \t\tint res = 1; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tif(arr[i] &gt; res) break; \t\t\tres += arr[i]; \t\t}  \t\tbw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_2580_스도쿠",
    "url": "/posts/BOJ2580%EC%8A%A4%EB%8F%84%EC%BF%A0/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-30 09:34:15 +0900",
    "content": "  [Gold IV] 스도쿠 - 2580  문제 링크  성능 요약  메모리: 17948 KB, 시간: 268 ms  분류  백트래킹  제출 일자  2024년 10월 30일 09:26:35  문제 설명  스도쿠는 18세기 스위스 수학자가 만든 '라틴 사각형'이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 일부 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.    나머지 빈 칸을 채우는 방식은 다음과 같다.   \t각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다. \t굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.   위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.    또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.    이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.    게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.  입력  아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.  출력  모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉 줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.  스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.  코드 /**  * Author : nowalex322, Kim hyeonjae  */ import java.io.*; import java.util.*;  /**  * 비트마스킹 연습  */ public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw;     static StringTokenizer st; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int map[][], checkRow[], checkCol[], check3by3[][];     static List&lt;int[]&gt; listToSolve = new ArrayList&lt;&gt;();     private static boolean solved = false;     public static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                  map = new int[10][10];         checkRow = new int[10];         checkCol = new int[10];         check3by3 = new int[4][4];          for (int i=1; i&lt;=9; i++) {             st = new StringTokenizer(br.readLine());             for (int j=1; j&lt;=9; j++) {                 int num = Integer.parseInt(st.nextToken());                 checkRow[i] |= 1 &lt;&lt; num;                 checkCol[j] |= 1 &lt;&lt; num;                 check3by3[((i-1)/3)+1][((j-1)/3)+1] |= 1 &lt;&lt; num;                 map[i][j] = num;                 if (num == 0) {                 \tlistToSolve.add(new int[]{i, j});                 }             }         }          sudoku(0);          br.close();         bw.write(sb.toString());         bw.flush();         bw.close();     }      private static void sudoku(int idx) {         if (solved) return;                  if (idx == (listToSolve.size())) {             for (int i=1; i&lt;=9; i++) {                 for (int j=1; j&lt;=9; j++) {                     sb.append(map[i][j] + \" \");                 }                 sb.append(\"\\n\");             }             solved = true;             return;         }          int[] zero = listToSolve.get(idx);         int r = zero[0];         int c = zero[1];         for (int i=1; i&lt;=9; i++) {             if (((checkRow[r] &amp; 1&lt;&lt;i) == 0) &amp;&amp; ((checkCol[c] &amp; 1&lt;&lt;i) == 0) &amp;&amp; ((check3by3[((r-1)/3)+1][((c-1)/3)+1] &amp; 1&lt;&lt;i) == 0)) {                 map[r][c] = i;                 checkRow[r] |= 1 &lt;&lt; i;                 checkCol[c] |= 1 &lt;&lt; i;                 check3by3[((r - 1) / 3) + 1][((c - 1) / 3) + 1] |= 1 &lt;&lt; i;                 sudoku(idx + 1);                                  map[r][c] = 0;                 checkRow[r] &amp;= ~(1 &lt;&lt; i);                 checkCol[c] &amp;= ~(1 &lt;&lt; i);                 check3by3[((r - 1) / 3) + 1][((c - 1) / 3) + 1] &amp;= ~(1 &lt;&lt; i);             }         }     } }  "
  },
  
  {
    "title": "PGMS_특정 세대의 대장균 찾기",
    "url": "/posts/PGMS%ED%8A%B9%EC%A0%95-%EC%84%B8%EB%8C%80%EC%9D%98-%EB%8C%80%EC%9E%A5%EA%B7%A0-%EC%B0%BE%EA%B8%B0/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-10-29 21:01:07 +0900",
    "content": "  [level 4] 특정 세대의 대장균 찾기 - 301650  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SELECT  채점결과  합계: 100.0 / 100.0  제출 일자  2024년 10월 29일 20:52:35  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  3세대의 대장균의 ID(ID) 를 출력하는 SQL 문을 작성해주세요. 이때 결과는 대장균의 ID 에 대해 오름차순 정렬해주세요.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 10 2019/01/01 5   2 NULL 2 2019/01/01 3   3 1 100 2020/01/01 4   4 2 16 2020/01/01 4   5 2 17 2020/01/01 6   6 4 101 2021/01/01 22   7 3 101 2022/01/01 23   8 6 1 2022/01/01 27          PARENT ID 가 NULL 인 ID 1, ID 2가 1 세대이며 ID 1에서 분화된 ID 3, ID 2에서 분화된 ID 4, ID 5 가 2 세대입니다. ID 4 에서 분화된 ID 6, ID 3에서 분화된 ID 7 이 3 세대이며 ID 6에서 분화된 ID 8은 4 세대입니다.  따라서 결과를 ID 에 대해 오름차순 정렬하면 다음과 같아야 합니다.           ID            6   7              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   재귀적으로 반복을 어떻게 sql 문을 통해 해야할 지 고민하다가 조인을 2번 사용하기로 했다.  코드 SELECT e3.ID     FROM ECOLI_DATA AS e1         JOIN ECOLI_DATA AS e2             ON e2.PARENT_ID = e1.ID                 JOIN ECOLI_DATA AS e3                     ON e3.PARENT_ID = e2.ID                         WHERE e1.PARENT_ID IS NULL                             ORDER BY e3.ID ASC;  "
  },
  
  {
    "title": "BOJ_2250_트리의 높이와 너비",
    "url": "/posts/BOJ2250%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%86%92%EC%9D%B4%EC%99%80-%EB%84%88%EB%B9%84/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-29 20:57:21 +0900",
    "content": "[Gold II] 트리의 높이와 너비 - 2250  문제 링크  성능 요약  메모리: 23036 KB, 시간: 284 ms  분류  깊이 우선 탐색, 그래프 이론, 그래프 탐색, 트리  제출 일자  2024년 10월 29일 07:50:45  문제 설명  이진트리를 다음의 규칙에 따라 행과 열에 번호가 붙어있는 격자 모양의 틀 속에 그리려고 한다. 이때 다음의 규칙에 따라 그리려고 한다.   \t이진트리에서 같은 레벨(level)에 있는 노드는 같은 행에 위치한다. \t한 열에는 한 노드만 존재한다. \t임의의 노드의 왼쪽 부트리(left subtree)에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고, 오른쪽 부트리(right subtree)에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다. \t노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.   이와 같은 규칙에 따라 이진트리를 그릴 때 각 레벨의 너비는 그 레벨에 할당된 노드 중 가장 오른쪽에 위치한 노드의 열 번호에서 가장 왼쪽에 위치한 노드의 열 번호를 뺀 값 더하기 1로 정의한다. 트리의 레벨은 가장 위쪽에 있는 루트 노드가 1이고 아래로 1씩 증가한다.  아래 그림은 어떤 이진트리를 위의 규칙에 따라 그려 본 것이다. 첫 번째 레벨의 너비는 1, 두 번째 레벨의 너비는 13, 3번째, 4번째 레벨의 너비는 각각 18이고, 5번째 레벨의 너비는 13이며, 그리고 6번째 레벨의 너비는 12이다.    우리는 주어진 이진트리를 위의 규칙에 따라 그릴 때에 너비가 가장 넓은 레벨과 그 레벨의 너비를 계산하려고 한다. 위의 그림의 예에서 너비가 가장 넓은 레벨은 3번째와 4번째로 그 너비는 18이다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때는 번호가 작은 레벨을 답으로 한다. 그러므로 이 예에 대한 답은 레벨은 3이고, 너비는 18이다.  임의의 이진트리가 입력으로 주어질 때 너비가 가장 넓은 레벨과 그 레벨의 너비를 출력하는 프로그램을 작성하시오  입력  첫째 줄에 노드의 개수를 나타내는 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 각 줄마다 노드 번호와 해당 노드의 왼쪽 자식 노드와 오른쪽 자식 노드의 번호가 순서대로 주어진다. 노드들의 번호는 1부터 N까지이며, 자식이 없는 경우에는 자식 노드의 번호에 -1이 주어진다.  출력  첫째 줄에 너비가 가장 넓은 레벨과 그 레벨의 너비를 순서대로 출력한다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때에는 번호가 작은 레벨을 출력한다.     문제 풀이   트리의 행을 dfs로 찾아가며 부여하고 depth를 레벨로 생각하였다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \t \tclass Node{ \t\tint num; \t\tint left, right; \t\t \t\tpublic Node(int num, int left, int right) { \t\t\tthis.num = num; \t\t\tthis.left = left; \t\t\tthis.right = right; \t\t} \t\t \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic Set&lt;Integer&gt; rootList = new HashSet&lt;&gt;(); \tstatic Map&lt;Integer, Node&gt; tree = new HashMap&lt;Integer, Node&gt;(); \tstatic Map&lt;Integer, List&lt;Integer&gt;&gt; levelColumn = new HashMap&lt;&gt;(); // 레벨별 열 list     static int columnCnt=0;     static int maxLevel=0, maxLength=0; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tint N = Integer.parseInt(st.nextToken()); \t\t \t\tfor(int i=1; i&lt;=N; i++) { \t\t\trootList.add(i); \t\t} \t\t \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint num = Integer.parseInt(st.nextToken()); \t\t\tint left = Integer.parseInt(st.nextToken()); \t\t\tint right = Integer.parseInt(st.nextToken()); \t\t\ttree.put(num, new Node(num, left, right)); \t\t\t \t\t\tif(left != -1) rootList.remove(left); \t\t\tif(right != -1) rootList.remove(right); \t\t\t \t\t} \t\t \t\tint root = rootList.stream().findFirst().get(); \t\tdfs(root, 1);  \t\tfor(Map.Entry&lt;Integer, List&lt;Integer&gt;&gt; entry : levelColumn.entrySet()){ \t\t\tint level = entry.getKey(); \t\t\tList&lt;Integer&gt; column = entry.getValue(); \t\t\t \t\t\t// 길이 =  마지막열 - 첫번째열 + 1 \t\t\tint len = column.get(column.size()-1) - column.get(0) + 1; \t\t\t \t\t\tif(len &gt; maxLength) { \t\t\t\tmaxLevel = level; \t\t\t\tmaxLength = len; \t\t\t} \t\t}          \t\tbw.write(maxLevel + \" \" + maxLength); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void dfs(int num, int level) { \t\tNode node = tree.get(num); \t\t \t\tif(node.left != -1) { \t\t\tdfs(node.left, level+1); \t\t} \t\t         // 현재 노드의 열 번호 처리         columnCnt++;         levelColumn.computeIfAbsent(level, columnIdx -&gt; new ArrayList&lt;&gt;()).add(columnCnt);          \t\tif(node.right != -1) { \t\t\tdfs(node.right, level+1); \t\t} \t} \t }  "
  },
  
  {
    "title": "Pycharm and FastAPI - (2)",
    "url": "/posts/Pycharm-and-FastAPI-2/",
    "categories": "",
    "tags": "FastAPI, pycharm, python",
    "date": "2024-10-29 20:54:19 +0900",
    "content": "   이어서 FastAPI 기본 학습 기록입니다     Multiple Parameters  from fastapi import Body, FastAPI, Path from pydantic import BaseModel  app = FastAPI()  \"\"\" Part 7 -&gt; Body - Multiple Parameters \"\"\"   class Item(BaseModel):     name: str     description: str | None = None     price: float     tax: float | None = None   class User(BaseModel):     username: str     full_name: str | None = None   @app.put(\"/items/{item_id}\") async def update_item(         *,         item_id: int = Path(..., title=\"The ID of the item to get\", ge=0, le=150),         q: str | None = None,         item: Item = Body(..., embed=True),         user: User,         importance: int = Body(...), ):     results = {\"item_id\": item_id}     if q:         results.update({\"q\": q})     if item:         results.update({\"item\": item.name})     if user:         results.update({\"user\": user})     if importance:         results.update({\"importance\": importance})     return results    Body - Fields from fastapi import FastAPI, Body from pydantic import BaseModel, Field  app = FastAPI()  \"\"\" Part 8 -&gt; Body - Fields \"\"\"   class Item(BaseModel):     name: str     description: str | None = Field(         None, title=\"The description of the item\", max_length=300     )     price: float = Field(..., gt=0, description=\"The price must be greater than zero\")     tax: float | None = None   @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item = Body(..., embed=True)):     results = {\"item_id\": item_id, \"item\": item}     return results   Nested Models from fastapi import FastAPI, Body from pydantic import BaseModel, HttpUrl  app = FastAPI()  \"\"\" Part 9 -&gt; Body - Nested Models \"\"\"   class Image(BaseModel):     url: HttpUrl     name: str   class Item(BaseModel):     name: str     description: str | None     price: float     tax: float | None = None     tags: set[str] = set()     image: Image | None = None   class Offer(BaseModel):     name: str     description: str | None = None     price: float     items: list[Item]   @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item):     results = {\"item_id\": item_id, \"item\": item}     return results   @app.put(\"/offers\") async def create_offer(offer: Offer = Body(..., embed=True)):     return offer   @app.pose(\"images/multiple\") async def create_multiple_images(images: list[Image]):     return images   @app.post(\"/blah\") async def create_some_blahs(blahs: dict[int, float]):     return blahs   "
  },
  
  {
    "title": "Pycharm and FastAPI",
    "url": "/posts/Pycharm-and-FastAPI/",
    "categories": "",
    "tags": "FastAPI, pycharm, python",
    "date": "2024-10-29 14:05:32 +0900",
    "content": "   fastapi를 pycharm을 통해 학습해봅시다 실습환경 : Mac(M3), IDE : Pycharm     Python 다운로드 및 프로젝트 생성 먼저 python을 brew를 통해 다운받는다. 만약 brew가 없다면 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"  brew로 다운로드 brew update brew install python python3 --version   pycharm 프로젝트 생성 후 requirements.txt를 생성 및 작성 fastapi uvicorn[standard]   이제 가상환경을 생성하고 활성화한다. python -m venv env source env/bin/activate  참고로 비활성화 하고싶을 땐 deactivate  이제 이 요구사항을 다운받는다 pip install -r requirements.txt   main.py를 생성 후 작성한다 from math import trunc  from fastapi import FastAPI  app = FastAPI()  @app.get(\"/\", description=\"This is our first route.\", deprecated=True) async def base_get_route():     return {\"message\": \"Hello World\"}  @app.post(\"/\") async def post():     return {\"message\": \"Hello From the Post Route\"}  @app.put(\"/\") async def put():     return {\"message\": \"Hello From the Put Route\"}   이후  ` uvicorn main:app –reload ` 으로 실행해보면 제대로 동작한다. Swagger 명세서를 보고싶다면 뒤에 /docs, 다른 버전으로 보려면 /redoc 붙이면 된다.  Path Parameters from enum import Enum  from math import trunc from pyexpat.errors import messages  from fastapi import FastAPI  app = FastAPI()  @app.get(\"/users\") async def list_users():     return {\"message\": \"list users route\"}  @app.get(\"/users/{user_id}\") async def get_user(user_id: str):     return {\"user_id\": user_id}  @app.get(\"/users/me\") async def get_current_user():     return {\"Message\": \"this is the current user\"}  class FoodEnum(str, Enum):     fruits = \"fruits\"     vegetables = \"vegetables\"     dairy = \"dairy\"  @app.get(\"/foods/{food_name}\") async def get_food(food_name: FoodEnum):     if food_name == FoodEnum.vegetables:         return {\"food_name\": food_name,                 \"message\": \"you are healthy\"}      if food_name.value == \"fruits\":         return {\"food_name\": food_name,                 \"message\": \"you are still healthy, but like sweet things\"}      return {\"food_name\": food_name,             \"message\": \"you are not healthy\"}   Request Body from enum import Enum  from fastapi import FastAPI from pydantic import BaseModel from typing import Optional  app = FastAPI()  @app.get(\"/items2\") async def read_items(         q: str            | None = Query(             ...,             min_length=3,             max_length=10,             regex=\"^[a-zA-Z]*$\",             title=\"Sample Query String\",             description=\"This is a sample query string\",             deprecated=True,             alias=\"item-query\"             )         ):     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}, {\"item_id\": \"Baz\"}]}     if q:         results.update({\"q\": q})     return results  @app.get(\"/items2/hidden\") async def hidden_query_route(hidden_query: str | None = Query(None, include_in_schema=False)):     if hidden_query:         return {\"hidden_query\": hidden_query}     return {\"hidden_query\": \"Not Found\"}   Query Parameter and Numeric Validation from math import trunc from pyexpat.errors import messages  from fastapi import FastAPI from fastapi import FastAPI, Query from pydantic import BaseModel from typing import Optional  @app.get(\"/items2\") async def read_items(         q: str            | None = Query(             ...,             min_length=3,             max_length=10,             regex=\"^[a-zA-Z]*$\",             title=\"Sample Query String\",             description=\"This is a sample query string\",             deprecated=True,             alias=\"item-query\"             )         ):     results = {\"items\": [{\"item_id\": \"Foo\"}, {\"item_id\": \"Bar\"}, {\"item_id\": \"Baz\"}]}     if q:         results.update({\"q\": q})     return results @app.get(\"/items2/hidden\") async def hidden_query_route(hidden_query: str | None = Query(None, include_in_schema=False)):     if hidden_query:         return {\"hidden_query\": hidden_query}     return {\"hidden_query\": \"Not Found\"}  "
  },
  
  {
    "title": "Pytorch로 시작하는 딥러닝",
    "url": "/posts/Pytorch%EB%A1%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-%EB%94%A5%EB%9F%AC%EB%8B%9D-1/",
    "categories": "머신러닝",
    "tags": "DL, ML, PyTorch",
    "date": "2024-10-22 21:15:27 +0900",
    "content": "   Pytorch와 딥러닝 공부를 시작하며 기록하고자 한다.   머신 러닝 워크플로우(Machine Learning Workflow)   1. 데이터 수집 (Acquisition) 자연어 데이터인 코퍼스(corpus) 수집 다양한 출처(음성 데이터, 웹 크롤링, 리뷰 등)와 형식(txt, csv, xml 등)의 텍스트 데이터 확보 2. 데이터 탐색 (Exploration) 탐색적 데이터 분석(EDA) 수행 데이터 구조, 노이즈, 변수 특성 파악 시각화 및 기초 통계 분석 3. 데이터 전처리 (Preprocessing) 토큰화, 정제, 정규화, 불용어 제거 등 수행 다양한 라이브러리 활용 4. 모델링 및 훈련 (Modeling &amp; Training) 적절한 머신러닝 알고리즘 선택 및 모델 구축 데이터를 훈련/검증/테스트 세트로 분리 훈련 데이터로 모델 학습  5. 평가 (Evaluation) 테스트 데이터로 모델 성능 평가 예측 결과와 실제 정답 비교 6. 배포 (Deployment) 완성된 모델 실제 환경에 배포 필요시 피드백 반영하여 프로세스 반복  판다스(Pandas) and 넘파이(Numpy) and 맷플롭립(Matplotlib) 판다스(Pandas) 판다스(Pandas)는 파이썬 데이터 처리를 위한 라이브러리  시리즈 클래스는 1차원 배열의 값(values)에 각 값에 대응되는 인덱스(index)를 부여할 수 있는 구조를 갖고 있습니다. 데이터프레임은 2차원 리스트를 매개변수로 전달합니다. 2차원이므로 행방향 인덱스(index)와 열방향 인덱스(column)가 존재합니다. 다시 말해 행과 열을 가지는 자료구조입니다.  데이터프레임은 리스트(List), 시리즈(Series), 딕셔너리(dict), Numpy의 ndarrays, 또 다른 데이터프레임으로부터 생성할 수 있습니다. 아래의 명령어는 데이터프레임에서 원하는 구간만 확인하기 위한 명령어로서 유용하게 사용됩니다.    df.head(n) - 앞 부분을 n개만 보기   df.tail(n) - 뒷 부분을 n개만 보기   df[‘열이름’] - 해당되는 열을 확인     넘파이(Numpy) 넘파이(Numpy)는 수치 데이터를 다루는 파이썬 패키지입니다. Numpy의 핵심이라고 불리는 다차원 행렬 자료구조인 ndarray를 통해 벡터 및 행렬을 사용하는 선형 대수 계산에서 주로 사용됩니다. Numpy는 편의성뿐만 아니라, 속도면에서도 순수 파이썬에 비해 압도적으로 빠르다는 장점이 있습니다.  Numpy의 핵심은 ndarray입니다. np.array()는 리스트, 튜플, 배열로 부터 ndarray를 생성합니다. 맷플롯립(Matplotlib) 맷플롯립(Matplotlib)은 데이터를 차트(chart)나 플롯(plot)으로 시각화하는 패키지입니다. 데이터 분석에서 Matplotlib은 데이터 분석 이전에 데이터 이해를 위한 시각화나, 데이터 분석 후에 결과를 시각화하기 위해서 사용됩니다.   데이터의 분리(Splitting Data)  1. 지도 학습(Supervised Learning)  2. X와 y분리하기 zip 함수를 이용하여 분리하기 + 데이터프레임을 이용하여 분리하기  Numpy를 이용하여 분리하기   3. 테스트 데이터 분리하기 사이킷 런을 이용하여 분리하기  수동으로 분리하기   "
  },
  
  {
    "title": "BOJ_16724_피리 부는 사나이",
    "url": "/posts/BOJ16724%ED%94%BC%EB%A6%AC-%EB%B6%80%EB%8A%94-%EC%82%AC%EB%82%98%EC%9D%B4/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-22 05:40:36 +0900",
    "content": "[Gold III] 피리 부는 사나이 - 16724  문제 링크  성능 요약  메모리: 65212 KB, 시간: 432 ms  분류  자료 구조, 깊이 우선 탐색, 분리 집합, 그래프 이론, 그래프 탐색  제출 일자  2024년 10월 22일 05:38:59  문제 설명  피리 부는 사나이 성우는 오늘도 피리를 분다.  성우가 피리를 불 때면 영과일 회원들은 자기도 모르게 성우가 정해놓은 방향대로 움직이기 시작한다. 성우가 정해놓은 방향은 총 4가지로 U, D, L, R이고 각각 위, 아래, 왼쪽, 오른쪽으로 이동하게 한다.  이를 지켜보던 재훈이는 더 이상 움직이기 힘들어하는 영과일 회원들을 지키기 위해 특정 지점에 ‘SAFE ZONE’ 이라는 최첨단 방음 시설을 만들어 회원들이 성우의 피리 소리를 듣지 못하게 하려고 한다. 하지만 예산이 넉넉하지 않은 재훈이는 성우가 설정해 놓은 방향을 분석해서 최소 개수의 ‘SAFE ZONE’을 만들려 한다.   성우가 설정한 방향 지도가 주어졌을 때 재훈이를 도와서 영과일 회원들이 지도 어느 구역에 있더라도 성우가 피리를 불 때 ‘SAFE ZONE’에 들어갈 수 있게 하는 ‘SAFE ZONE’의 최소 개수를 출력하는 프로그램을 작성하시오.  입력  첫 번째 줄에 지도의 행의 수를 나타내는 N(1 ≤ N ≤ 1,000)과 지도의 열의 수를 나타내는 M(1 ≤ M ≤ 1,000)이 주어진다.  두 번째 줄부터 N개의 줄에 지도의 정보를 나타내는 길이가 M인 문자열이 주어진다.  지도 밖으로 나가는 방향의 입력은 주어지지 않는다.  출력  첫 번째 줄에 ‘SAFE ZONE’의 최소 개수를 출력한다.     문제 풀이   유니온 파인드로 풀었다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic char[][] board; \tstatic int p[], N, M; \tstatic final int[] dr = { -1, 1, 0, 0 }; \tstatic final int[] dc = { 0, 0, -1, 1 };  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());  \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tp = new int[N * M]; \t\tfor (int i = 0; i &lt; p.length; i++) { \t\t\tp[i] = i; \t\t}  \t\tboard = new char[N][M]; \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tString dir = br.readLine(); \t\t\tfor (int j = 0; j &lt; M; j++) { \t\t\t\tboard[i][j] = dir.charAt(j); \t\t\t} \t\t}  \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tfor (int j = 0; j &lt; M; j++) { \t\t\t\tint newr, newc; \t\t\t\tswitch (board[i][j]) { \t\t\t\t\tcase 'U': { \t\t\t\t\t\tint k = 0; \t\t\t\t\t\tnewr = i + dr[k]; \t\t\t\t\t\tnewc = j + dc[k]; \t\t\t\t\t\tbreak; \t\t\t\t\t} \t\t\t\t\tcase 'D': { \t\t\t\t\t\tint k = 1; \t\t\t\t\t\tnewr = i + dr[k]; \t\t\t\t\t\tnewc = j + dc[k]; \t\t\t\t\t\tbreak; \t\t\t\t\t} \t\t\t\t\tcase 'L': { \t\t\t\t\t\tint k = 2; \t\t\t\t\t\tnewr = i + dr[k]; \t\t\t\t\t\tnewc = j + dc[k]; \t\t\t\t\t\tbreak; \t\t\t\t\t} \t\t\t\t\tcase 'R': { \t\t\t\t\t\tint k = 3; \t\t\t\t\t\tnewr = i + dr[k]; \t\t\t\t\t\tnewc = j + dc[k]; \t\t\t\t\t\tbreak; \t\t\t\t\t} \t\t\t\t\tdefault: \t\t\t\t\t\tthrow new IllegalArgumentException(\"Unexpected value: \" + board[i][j]); \t\t\t\t} \t\t\t\tunion(i*M + j, newr * M + newc); \t\t\t\t \t\t\t} \t\t} \t\t \t\tSet&lt;Integer&gt; set = new  HashSet&lt;Integer&gt;(); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfor(int j=0; j&lt;M; j++) { \t\t\t\tset.add(find(i*M+j)); \t\t\t} \t\t} \t\tbw.write(String.valueOf(set.size())); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate int find(int x) { \t\tif(p[x] != x) p[x] = find(p[x]); \t\treturn p[x]; \t}  \tprivate void union(int x, int y) { \t\tint a = find(x); \t\tint b = find(y); \t\tif(a != b) { \t\t\tif(a&lt;b) p[a] = b; \t\t\telse p[b] = a; \t\t} \t} }  "
  },
  
  {
    "title": "BOJ_1407_2로 몇 번 나누어질까",
    "url": "/posts/BOJ14072%EB%A1%9C-%EB%AA%87-%EB%B2%88-%EB%82%98%EB%88%84%EC%96%B4%EC%A7%88%EA%B9%8C/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-22 05:11:50 +0900",
    "content": "[Gold IV] 2로 몇 번 나누어질까 - 1407 문제 링크 성능 요약 메모리: 14312 KB, 시간: 100 ms 분류 수학 제출 일자 2024년 10월 22일 05:09:50 문제 설명 자연수 N이 주어지면, 자연수를 유지하면서 N을 2로 몇 번까지 나눌 수 있는지를 생각해 볼 수 있다. 즉, N의 모든 약수 중 2의 거듭제곱 꼴이면서 가장 큰 약수를 생각하는 것이다. 예를 들어 15의 경우는 2로 한 번도 나눌 수 없으므로 2^0 = 1이 해당되고, 40의 경우는 2로 세 번까지 나눌 수 있으므로 2^3 = 8이 해당된다. 이러한 약수를 함수값으로 가지는 함수 f(x)를 정의하자. 즉, f(15) = 1이고, f(40) = 8이다. 두 자연수 A, B(A≤B)가 주어지면, A 이상 B 이하의 모든 자연수에 대해서, 그 자연수의 모든 약수 중 2의 거듭제곱 꼴이면서 가장 큰 약수들의 총 합을 구하는 프로그램을 작성하시오. 즉 아래와 같은 수식의 값을 구해야 한다. f(A) + f(A+1) + ... + f(B-1) + f(B) 입력 첫째 줄에 자연수 A와 B가 빈 칸을 사이에 두고 주어진다. (1≤A≤B≤10^15) 출력 첫째 줄에 구하고자 하는 수를 출력한다.     문제 풀이   1의배수 - 2의배수 - 4의배수 이런식으로 좁혀 찾아나가고 이렇게 새로 찾으면 /2를 더해주면 된다. 4를 찾으면 2를 더했으므로 나머지 2 더해주기 이런식.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*; public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic long A, B; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t} \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tA = Long.parseLong(st.nextToken()); \t\tB = Long.parseLong(st.nextToken()); \t\tlong res = calNum(B) - calNum(A-1);          bw.write(String.valueOf(res)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \tprivate long calNum(long num) { \t\tlong tmp = num; \t\tfor(long i=2; i&lt;=num; i&lt;&lt;=1) { \t\t\ttmp += (num/i) * (i&gt;&gt;1); \t\t} \t\treturn tmp; \t} }  "
  },
  
  {
    "title": "Artillery 부하 테스트",
    "url": "/posts/Artillery-%EB%B6%80%ED%95%98-%ED%85%8C%EC%8A%A4%ED%8A%B8/",
    "categories": "프로젝트",
    "tags": "",
    "date": "2024-10-14 05:00:30 +0900",
    "content": "   Spring 백엔드 서버의 부하테스트를 진행하기 위헤 Artillery라는 라이브러리를 사용했습니다. VS Code로 간단하게 테스트 할 수 있기에 좋은 것 같습니다. Jmeter로 테스트 하실 분들은 패스해주세요   Artillery 테스트 실행 가이드 1. 백엔드 서버 준비  스프링 백엔드 프로젝트 디렉토리로 이동: cd path/to/spring-backend  스프링 애플리케이션 실행 : ./mvnw spring-boot:run 또는 Gradle을 사용하는 경우 : ./gradlew bootRun  백엔드 서버가 정상적으로 실행되었는지 확인 (보통 http://localhost:8080)  2. Artillery 테스트 환경 설정  프로젝트 루트 디렉토리나 별도의 테스트 디렉토리를 만들어 이동: mkdir artillery-tests cd artillery-tests  Artillery 설치: npm install -g artillery  3. Artillery 테스트 구성 파일 생성     test.yml 파일 생성:touch test.yml   에디터로 test.yml 열고 테스트 구성 작성: yamlCopyconfig:   target: \"ws://localhost:8080\"   phases:     - duration: 60       arrivalRate: 10   plugins:     metrics-by-endpoint: {}  scenarios:   - engine: ws     flow:       - connect: \"/omg\"       - send:            channel: \"/pub/game-initialize\"                      data: '{\"roomId\": \"ROOM_ID_{{ $randomNumber(1,1000) }}\"}'       - think: 1       - loop:           - send:               channel: \"/pub/player-move\"               data: '{\"roomId\": \"ROOM_ID_{{ $randomNumber(1,1000) }}\", \"x\": {{ $randomNumber(0,100) }}, \"y\": {{ $randomNumber(0,100) }}}'                          - think: 0.016         count: 250   4. Artillery 테스트 실행  테스트 실행: artillery run test.yml  결과를 파일로 저장하려면: `artillery run –output test-report.json test.yml  5. 테스트 결과 분석  추가적으로 저장된 테스트 결과 test.json 을 그래프화 할 수 있는 명령어도 제공합니다.  JSON 결과를 HTML 보고서로 변환: artillery report test-report.json  생성된 test-report.html 파일을 웹 브라우저에서 열어 결과 확인  6. 추가 고려사항  실제 프로덕션 환경과 유사한 조건에서 테스트 수행 다양한 시나리오와 부하 패턴으로 여러 번 테스트 실행 백엔드 서버의 리소스 사용량 모니터링 (CPU, 메모리, 네트워크 I/O) 필요에 따라 테스트 구성 파일 수정 및 최적화  테스트 분석 환경 artillery.io 해당 URL에서 깃헙으로 로그인 하여 사용합니다.    "
  },
  
  {
    "title": "BOJ_17387_선분 교차 2 (Java)",
    "url": "/posts/BOJ17387%EC%84%A0%EB%B6%84-%EA%B5%90%EC%B0%A8-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-14 05:00:07 +0900",
    "content": "[Gold II] 선분 교차 2 - 17387  문제 링크  성능 요약  메모리: 14264 KB, 시간: 100 ms  분류  많은 조건 분기, 기하학, 선분 교차 판정  제출 일자  2024년 10월 14일 04:18:15  문제 설명  2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자. 한 선분의 끝 점이 다른 선분이나 끝 점 위에 있는 것도 교차하는 것이다.  L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.  입력  첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다.  출력  L1과 L2가 교차하면 1, 아니면 0을 출력한다.     문제 풀이     코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tlong x1 = 0, y1 = 0, x2 = 0, y2 = 0, x3 = 0, y3 = 0, x4 = 0, y4 = 0; \t\tx1 = Long.parseLong(st.nextToken()); \t\ty1 = Long.parseLong(st.nextToken()); \t\tx2 = Long.parseLong(st.nextToken()); \t\ty2 = Long.parseLong(st.nextToken());  \t\tst = new StringTokenizer(br.readLine()); \t\tx3 = Long.parseLong(st.nextToken()); \t\ty3 = Long.parseLong(st.nextToken()); \t\tx4 = Long.parseLong(st.nextToken()); \t\ty4 = Long.parseLong(st.nextToken());  \t\tint res = isCrossed(x1, y1, x2, y2, x3, y3, x4, y4) ? 1 : 0; \t\tSystem.out.println(res); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) { \t\tlong res = (x1 * y2 + x2 * y3 + x3 * y1) - (x1 * y3 + x2 * y1 + x3 * y2); \t\tif (res == 0) return 0; \t\telse if (res &gt; 0) return 1; \t\telse return -1; \t}  \tprivate static boolean isCrossed(long x1, long y1, long x2, long y2, long x3, long y3, long x4, long y4) { \t\tint ccw1 = ccw(x1, y1, x2, y2, x3, y3); \t\tint ccw2 = ccw(x1, y1, x2, y2, x4, y4); \t\tint ccw3 = ccw(x3, y3, x4, y4, x1, y1); \t\tint ccw4 = ccw(x3, y3, x4, y4, x2, y2); \t\t \t\tif (ccw1 * ccw2 == 0 &amp;&amp; ccw3 * ccw4 == 0) { \t        return isOverlap(x1, y1, x2, y2, x3, y3, x4, y4); \t    }  \t\treturn (ccw1 * ccw2 &lt;= 0 &amp;&amp; ccw3 * ccw4 &lt;= 0); \t}  \tprivate static boolean isOverlap(long x1, long y1, long x2, long y2, long x3, long y3, long x4, long y4) { \t\treturn Math.min(x1, x2) &lt;= Math.max(x3, x4) &amp;&amp; Math.min(x3, x4) &lt;= Math.max(x1, x2) &amp;&amp; \t\t           Math.min(y1, y2) &lt;= Math.max(y3, y4) &amp;&amp; Math.min(y3, y4) &lt;= Math.max(y1, y2); \t} }    "
  },
  
  {
    "title": "docker compose 로 Kafka + ELK stack 사용",
    "url": "/posts/docker-compose-%EB%A1%9C-Kafka-ELK-stack-%EC%82%AC%EC%9A%A9/",
    "categories": "프로젝트",
    "tags": "ELK, docker, kafka",
    "date": "2024-10-09 17:28:51 +0900",
    "content": "   여러 채용 공고 및 회사별 기술 스택을 보며 대부분 MSA아키텍처를 채택하며 이를 분석하는데 ELK Stack을 사용하는것을 보고 파이프라인을 구현해보았습니다.   ELK 스택 파이프라인  먼저 전체적인 파이프라인 및 디렉토리 구조입니다. ( 터미널에서 tree 혹은 tree -f 로 볼 수 있음 ) ├── docker-elk-stack  \t\t\t\t\t\t# ELK 스택을 위한 Docker 구성 디렉토리 │   ├── docker-compose.yml  \t\t\t\t# 전체 ELK 스택 서비스 정의 및 구성 │   ├── elasticsearch  \t\t\t\t\t\t# Elasticsearch 관련 파일 │   │   ├── Dockerfile  \t\t\t\t\t# Elasticsearch 컨테이너 빌드 스크립트 │   │   └── config │   │       └── elasticsearch.yml  \t\t\t# Elasticsearch 설정 파일 │   ├── filebeat  \t\t\t\t\t\t\t# Filebeat 관련 파일 │   │   └── config │   │       └── filebeat.yml  \t\t\t\t# Filebeat 설정 파일 (로그 수집 및 전송 구성) │   ├── kibana  \t\t\t\t\t\t\t# Kibana 관련 파일 │   │   ├── Dockerfile  \t\t\t\t\t# Kibana 컨테이너 빌드 스크립트 │   │   └── config │   │       └── kibana.yml  \t\t\t\t# Kibana 설정 파일 │   └── logstash  \t\t\t\t\t\t\t# Logstash 관련 파일 │       ├── Dockerfile  \t\t\t\t\t# Logstash 컨테이너 빌드 스크립트 │       ├── config │       │   ├── logstash.yml  \t\t\t\t# Logstash 주 설정 파일 │       │   └── pipelines.yml  \t\t\t\t# Logstash 파이프라인 정의 파일 │       └── pipeline │           └── logstash.conf  \t\t\t\t# Logstash 파이프라인 설정 파일 ├── logs │   ├── application.log  \t\t\t\t\t# 애플리케이션 로그 파일 (Filebeat가 수집할 대상)     올바른 ELK stack + Kafka 흐름    애플리케이션이 application.log에 로그를 작성합니다.   Filebeat가 application.log 파일을 읽습니다.   Filebeat가 로그 데이터를 Kafka(토픽: “OMG”)로 전송합니다.   Logstash가 Kafka 토픽에서 데이터를 읽습니다.   Logstash가 로그 데이터를 처리(필터 적용)하고 Elasticsearch로 전송합니다.   Kibana가 Elasticsearch에서 로그 데이터를 읽어 시각화합니다.   일반적인 ELK 스택 구성과의 주요 차이점은 Filebeat와 Logstash 사이에 Kafka가 있다는 것입니다. 이 구성은 더 나은 확장성과 컴포넌트 간의 분리를 가능하게 합니다.  기본적으로 모두 도커로 띄워 설치관리하였습니다. 로컬에서만 테스트해볼 예정이라면 Docker Desktop 사용을 권장드립니다. 참고로 진행환경은 MacOS M3입니다.  다음으로 코드를 알아보겠습니다.  application.yml logging:   file:     name: /app/logs/application.log   pattern:     console: \"%d{yyyy-MM-dd HH:mm:ss} - %msg%n\"     file: \"%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n\"   level:     org.hibernate.SQL: debug     com.ssafy.omg: debug     kafka:     producer:       bootstrap-servers: kafka:9092       key-serializer: org.apache.kafka.common.serialization.StringSerializer       value-serializer: org.apache.kafka.common.serialization.StringSerializer     consumer:       bootstrap-servers: kafka:9092       group-id: your-group-id       auto-offset-reset: earliest       key-deserializer: org.apache.kafka.common.serialization.StringDeserializer       value-deserializer: org.apache.kafka.common.serialization.StringDeserializer   로컬에서 테스트하신다면 kafka 설정 부분에서 localhost:9092로 바꾸면 됩니다.  docker-compose.yml services:   elasticsearch:     image: docker.elastic.co/elasticsearch/elasticsearch:8.11.1     container_name: elasticsearch     environment:       - discovery.type=single-node       - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"       - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}       - xpack.security.enabled=true       - xpack.security.authc.token.enabled=true       - xpack.security.authc.api_key.enabled=true       ports:       - 9200:9200       - 9300:9300     volumes:       - elasticsearch_data:/usr/share/elasticsearch/data     healthcheck:       test: [ \"CMD-SHELL\", \"curl -s -u elastic:${ELASTIC_PASSWORD} http://localhost:9200 &gt;/dev/null || exit 1\" ]       interval: 30s       timeout: 10s       retries: 5     networks:       - elk_network    logstash:     build:       context: ./logstash       dockerfile: Dockerfile       args:         ELK_VERSION: 8.11.1     container_name: logstash     ports:       - 5001:5000     volumes:       - ./logstash/pipeline:/usr/share/logstash/pipeline       - ./logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml       - ./logstash/config/pipelines.yml:/usr/share/logstash/config/pipelines.yml       - /home/ubuntu/logs:/usr/share/logstash/logs     depends_on:       elasticsearch:         condition: service_healthy       kafka:         condition: service_started     environment:       - SLACK_WEBHOOK_URL=${SLACK_WEBHOOK_URL}       - LANG=en_US.UTF-8       - LC_ALL=en_US.UTF-8       - LS_JAVA_OPTS=-Xmx1g -Xms1g       - ELASTIC_USERNAME=elastic       - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}       - LOG_LEVEL_DEBUG     healthcheck:       test: [ \"CMD\", \"curl\", \"-f\", \"http://localhost:9600\" ]       interval: 30s       timeout: 10s       retries: 5     networks:       - elk_network     kibana:     image: docker.elastic.co/kibana/kibana:8.11.1     container_name: kibana     ports:       - 5601:5601     depends_on:       elasticsearch:         condition: service_healthy     environment:       - ELASTICSEARCH_HOSTS=http://elasticsearch:9200       - ELASTICSEARCH_SERVICEACCOUNTTOKEN=${KIBANA_SERVICE_TOKEN}       - ELASTICSEARCH_SSL_VERIFICATIONMODE=none     networks:       - elk_network     zookeeper:     image: wurstmeister/zookeeper     container_name: zookeeper     ports:       - 2181:2181     networks:       - elk_network     kafka:     image: wurstmeister/kafka     container_name: kafka     ports:       - \"9092:9092\"       - \"9093:9093\"     volumes:       - /home/ubuntu/logs:/logs     environment:       KAFKA_ADVERTISED_LISTENERS: INSIDE://kafka:9092,OUTSIDE://localhost:9093       KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INSIDE:PLAINTEXT,OUTSIDE:PLAINTEXT       KAFKA_LISTENERS: INSIDE://0.0.0.0:9092,OUTSIDE://0.0.0.0:9093       KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181       KAFKA_INTER_BROKER_LISTENER_NAME: INSIDE       KAFKA_NUM_PARTITIONS: 3       KAFKA_LOG_FLUSH_INTERVAL_MESSAGES: 10000       KAFKA_LOG_FLUSH_INTERVAL_MS: 1000     depends_on:       - zookeeper     networks:       - elk_network     filebeat:     image: docker.elastic.co/beats/filebeat:8.11.1     container_name: filebeat     volumes:       - ./filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml       - /home/ubuntu/logs:/logs     command: [ \"filebeat\", \"-e\", \"-strict.perms=false\" ]     depends_on:       - kafka       - logstash     networks:       - elk_network   volumes:   elasticsearch_data:     driver: local   networks:   elk_network:     driver: bridge   마찬가지로 로컬 환경에서 테스트 하신다면 volume에서 마운트 하는 경로를 /home/ubuntu 부분을 ../logs등으로 바꾸시면됩니다.   Filebeat filebeat.yml filebeat.inputs:   - type: log     paths:       - /logs/*.log     close_inactive: 5s     scan_frequency: 1s  output.kafka:   hosts: [ \"kafka:9092\" ]   topic: \"OMG\"   partition.round_robin:     reachable_only: false   required_acks: 1   compression: gzip   max_message_bytes: 1000000   codec.json:     pretty: false  processors:   - add_host_metadata: ~   - add_cloud_metadata: ~  queue.mem:   events: 1024   flush.min_events: 10   flush.timeout: \"100ms\"    Kafka 카프카는 이벤트 메시지 브로커로 도커로 이미지를 실행하여 진행했습니다. 차후 실행 방법과 함께 다루도록 하겠습니다.    logstash logstash.yml ## Default Logstash configuration from Logstash base image. ## https://github.com/elastic/logstash/blob/master/docker/data/logstash/config/logstash-full.yml # http.host: \"0.0.0.0\" xpack.monitoring.elasticsearch.hosts: [ \"elasticsearch:9200\" ] xpack.monitoring.enabled: true xpack.monitoring.elasticsearch.username: \"elastic\" xpack.monitoring.elasticsearch.password: ${ELASTIC_PASSWORD} xpack.monitoring.collection.pipeline.details.enabled: true #xpack.monitoring.elasticsearch.api_key: null #xpack.monitoring.elasticsearch.data_stream: true pipeline.ordered: false pipeline.workers: 2 pipeline.batch.size: 125 pipeline.batch.delay: 50  log.level: debug  pipelines.yml - pipeline.id: main   path.config: \"/usr/share/logstash/pipeline/*.conf\"   logstash.conf input {   kafka {     bootstrap_servers =&gt; \"kafka:9092\"     topics =&gt; [\"OMG\"]     group_id =&gt; \"logstash\"     auto_offset_reset =&gt; \"latest\"     consumer_threads =&gt; 3     decorate_events =&gt; true   } }  filter {     json {         source =&gt; \"message\"         target =&gt; \"parsed_json\"         skip_on_invalid_json =&gt; true     }      if [parsed_json] {         mutate {             rename =&gt; { \"[parsed_json][message]\" =&gt; \"log_entry\" }         }     } else {         mutate {             rename =&gt; { \"message\" =&gt; \"log_entry\" }         }     }      grok {         match =&gt; {             \"log_entry\" =&gt; [                 \"%{TIMESTAMP_ISO8601:timestamp} \\[%{DATA:thread}\\] %{LOGLEVEL:log_level} %{DATA:logger} - %{GREEDYDATA:log_message}\",                 \"%{TIMESTAMP_ISO8601:timestamp} \\[%{DATA:thread}\\] %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}\",                 \"%{GREEDYDATA:log_message}\"             ]         }     }      date {         match =&gt; [ \"timestamp\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm:ss.SSS\", \"ISO8601\" ]         target =&gt; \"@timestamp\"     }      if [log_level] == \"ERROR\" {         mutate {             add_field =&gt; {                 \"error_type\" =&gt; \"application_error\"                 \"slack_message\" =&gt; \"🚨 *에러 발생* 🚨\\n*Timestamp:* %{timestamp}\\n*Thread:* %{thread}\\n*Logger:* %{logger}\\n*Message:* %{log_message}\"             }         }     } }  output {     if [log_level] == \"ERROR\" {         http {             url =&gt; \"${SLACK_WEBHOOK_URL}\"             http_method =&gt; \"post\"             content_type =&gt; \"application/json\"             format =&gt; \"message\"             message =&gt; '{\"text\":\"%{slack_message}\"}'             request_timeout =&gt; 60             retry_failed =&gt; true             retryable_codes =&gt; [500, 502, 503, 504]         }         elasticsearch {             hosts =&gt; [\"http://elasticsearch:9200\"]             index =&gt; \"omg-game-error-log-%{+YYYY.MM.dd}\"             user =&gt; \"${ELASTIC_USERNAME}\"             password =&gt; \"${ELASTIC_PASSWORD}\"         }     } else {         elasticsearch {             hosts =&gt; [\"http://elasticsearch:9200\"]             index =&gt; \"omg-game-log-%{+YYYY.MM.dd}\"             user =&gt; \"${ELASTIC_USERNAME}\"             password =&gt; \"${ELASTIC_PASSWORD}\"         }     } }  http output 부분은 slack 에러 수신 웹훅 메시징도 추가한 부분입니다.  Dockerfile ARG ELK_VERSION  # https://www.docker.elastic.co/ FROM docker.elastic.co/logstash/logstash:${ELK_VERSION}  USER root  RUN apt-get update &amp;&amp; apt-get install -y locales RUN locale-gen en_US.UTF-8 ENV LANG en_US.UTF-8 ENV LANGUAGE en_US:en ENV LC_ALL en_US.UTF-8  # Add your logstash plugins setup here # Example: RUN logstash-plugin install logstash-filter-json RUN logstash-plugin install logstash-output-http  COPY config/logstash.yml /usr/share/logstash/config/logstash.yml COPY config/pipelines.yml /usr/share/logstash/config/pipelines.yml COPY pipeline /usr/share/logstash/pipeline  USER logstash  CMD [\"logstash\", \"-f\", \"/usr/share/logstash/pipeline/logstash.conf\", \"--config.reload.automatic\"]    elasticsearch elasticsearch.yml ## Default Elasticsearch configuration from Elasticsearch base image. ## https://github.com/elastic/elasticsearch/blob/master/distribution/docker/src/docker/config/elasticsearch.yml # cluster.name: \"docker-cluster\" network.host: 0.0.0.0  ## X-Pack settings ## see https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-xpack.html # xpack.license.self_generated.type: trial xpack.security.enabled: true xpack.security.authc.token.enabled: true xpack.monitoring.collection.enabled: true discovery.type: single-node index.refresh_interval: \"1s\"  Dockerfile ARG ELK_VERSION  # https://www.docker.elastic.co/ FROM docker.elastic.co/elasticsearch/elasticsearch:${ELK_VERSION}  # Add your elasticsearch plugins setup here # Example: RUN elasticsearch-plugin install analysis-icu    kibana ## Default Kibana configuration from Kibana base image. ## https://github.com/elastic/kibana/blob/master/src/dev/build/tasks/os_packages/docker_generator/templates/kibana_yml.template.js # server.name: kibana server.host: \"0\" elasticsearch.hosts: [ \"http://elasticsearch:9200\" ] xpack.monitoring.ui.container.elasticsearch.enabled: true xpack.security.encryptionKey: \"${KIBANA_ENCRYPTION_KEY}\" xpack.encryptedSavedObjects.encryptionKey: \"${KIBANA_ENCRYPTION_KEY}\" xpack.reporting.encryptionKey: \"${KIBANA_ENCRYPTION_KEY}\"  ## X-Pack security credentials elasticsearch.serviceAccountToken: \"${KIBANA_SERVICE_TOKEN}\" elasticsearch.requestTimeout: 30000 elasticsearch.ssl.verificationMode: none    password로 인증하는 방법도 있고 encryption키 토큰으로 인증하는 방법도 있는데 전 더 선호되는 기술을 사용해봤습니다.  Dockerfile ARG ELK_VERSION  # https://www.docker.elastic.co/ FROM docker.elastic.co/kibana/kibana:${ELK_VERSION}   # Add your kibana plugins setup here # Example: RUN kibana-plugin install &lt;name|url&gt;    환경변수 .env ELASTIC_USERNAME=elastic ELASTIC_PASSWORD=ssafya206 SLACK_WEBHOOK_URL=https://hooks.slack.com/services/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  KIBANA_SERVICE_TOKEN=AAEAAWVsYXN0aWMva2liYW5hL2tpYmFuYS10b2tlbjp3cW02cFdSTlFsMlh5SDltakdzYjBn   이 환경변수 파일을 추가하는 방법도 아래 설명하겠습니다.  실행 방법  먼저 로컬에서 실행해봅시다. Docker Desktop을 실행해봅시다. 물론 터미널에서도 진행 가능하지만 처음 여러 도커 이미지를 띄우고 실행하며, 종료됐을 때 docker logs [컨테이너]로 로그 분석 및 각 컨테이터 터미널을 쉽게 접속하려면 도커 데스크탑을 추천합니다. 물론 리눅스 개발 환경이 더 익숙하신 분들은 터미널로 똑같이 진행하시면 됩니다.  1. docker-elk-stack 이 있는 루트 디렉토리로 이동   2. docker로 실행          Elasticsearch만 먼저 시작합니다 docker-compose up -d elasticsearch      Elasticsearch가 완전히 시작될 때까지 기다립니다. 서비스 계정 토큰을 생성하고 .env 파일에 설정합니다. docker exec -it elasticsearch /bin/bash -c \"bin/elasticsearch-service-tokens create elastic/kibana kibana-token\"   나머지 서비스를 시작합니다 docker-compose up -d   docker ps로 실행중인 컨테이너 확인합니다 docker ps   실행 후 로그 확인 각각 잘 실행되었는지, 뭔가가 exited되면 왜 종료되었는지를 확인하기 위해 logs를 봐야할 때가 있습니다. 이때는 docker-compose logs filebeat docker-compose logs kafka docker-compose logs logstash docker-compose logs elasticsearch docker-compose logs kibana  다음 5개 순서대로 플로우가 흘러가니 문제가 생긴 컨테이너의 터미널로 가 실행하여 오류를 로그를 통해 해결할 수 있습니다.  카프카의 경우 토픽에 제대로 로그가 들어오는지를 확인해야 하는 경우가 있기 때문에 복잡한 명령어를 미리 적어두었습니다.  카프카 터미널 명령어 (서버의 경우 kafka:9092, 로컬의 경우 localhost:9092)         Kafka 컨테이너에 접속하기 :  docker exec -it kafka /bin/bash           Kafka 스크립트 경로로 이동: 컨테이너에 접속한 후, Kafka 스크립트가 위치한 경로로 이동합니다. 일반적으로 Kafka의 스크립트는 /opt/kafka/bin에 위치합니다. :  cd /opt/kafka           토픽 목록 확인: 이제 kafka-topics.sh 스크립트를 실행하여 현재 Kafka 클러스터의 토픽 목록을 확인할 수 있습니다. :  ./bin/kafka-topics.sh --list --bootstrap-server localhost:9092 사진의 경우 바로 cd /opt/kafka/bin으로 이동해 진행한 모습           토픽 리스트 확인: ./bin/kafka-topics.sh --list --bootstrap-server kafka:9092      특정 토픽의 메시지 확인 (예: “OMG” 토픽): ./bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic OMG --from-beginning 이 명령어는 “OMG” 토픽의 모든 메시지를 처음부터 보여줍니다.        실시간으로 새로운 메시지만 보고 싶다면: ./bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic OMG           메시지와 함께 키, 타임스탬프 등을 보려면: ./bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic OMG --property print.key=true --property print.timestamp=true --from-beginning           특정 파티션의 메시지만 보려면 (예: 파티션 0): ./bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic OMG --partition 0 --from-beginning      메시지 생산을 테스트 : ./bin/kafka-console-producer.sh --bootstrap-server kafka:9092 --topic OMG     elastic 접속 localhost:5601(http://localhost:5601/ ) 또는 도메인:5601(http://j11a206.p.ssafy.io:5601/ )로 접속합니다 이때 저희가 설정한 ELASTIC_USERNAME과 ELASTIC_PASSWORD로 로그인 합니다. https 면 접속이 안되니까 주의!  인덱스 생성 좌측 탭에서 맨 아래 Stack Management로 들어간다.  이후 다시 좌측 탭을 보면 여러 카테고리가 변경되는데 여기서 Index Management로 들어간다.   아마 아무것도 없고 새로 생성해야할텐데 이미 로그를 생성할 때 logstash의 output에서 index =&gt; \"omg-game-error-log-%{+YYYY.MM.dd}\",          index =&gt; \"omg-game-log-%{+YYYY.MM.dd}\"  와 같이 인덱스를 지정했으므로 해당 인덱스를 적어준다. 둘 다 포함하기 위해 omg-game*과 같이 적어주었다.  만약 인덱스를 모르겠으면  에서 Dev Tools로 들어가 간단한 콘솔문으로 인덱스를 모두 출력해볼 수 있다.  GET _cat/indices?v   로그 분석 이제 로그를 확인해 볼 차례다. 결국 이 단계를 위해 모든 과정을 거친것이다.   Discover에 들어간다.   이런식으로 분석 페이지 및 로그 내용이 나온다. 우리 서비스를 많이 이용했는지 로그데이터가 130만건이 쌓였다.  어떤 로그가 있는지 보도록 해보자. 일단 우측상단 시간을 통해 원하는 시간대를 설정한다. 이런식으로 설정을 한 뒤 원하는 조건을 걸어보자. message 중 에러가 있는걸 보도록 하자.  이렇게 message : error과 같이 필터를 걸어주면 원하는 로그 데이터만 볼 수 있다. 분석해보니   웹소켓 연결을 계속 시도하면서 에러가 발생했음을 알 수 있다. 이렇게 특정 에러를 분석하고 바로 대응할 수 있다.  이에 특정 에러를 감지하여 수신 웹후크 앱을 통해 Slack으로 에러메시지를 실시간 전송하도록 추가했다.  먼저 슬랙을 통해  자동화 앱을 선택한다.  우측 상단 Slack 마켓플레이스를 선택한다.   찾아보기에서 web을 검색해 수신 웹후크를 선택.  이후 사용자화 한 뒤 사용   생성된 웹후크 URL은 .env에 추가하면된다.  결과 화면은 다음과 같다.  "
  },
  
  {
    "title": "BOJ_2467_용액 (Java)",
    "url": "/posts/BOJ2467%EC%9A%A9%EC%95%A1-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-06 08:59:31 +0900",
    "content": "[Gold V] 용액 - 2467  문제 링크  성능 요약  메모리: 28520 KB, 시간: 332 ms  분류  이분 탐색, 두 포인터  제출 일자  2024년 10월 6일 08:58:06  문제 설명  KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.  같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.   예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.  산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.  입력  첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.  출력  첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int n, arr[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tn = Integer.parseInt(br.readLine()); \t\t \t\tst = new StringTokenizer(br.readLine());\t\t \t\tarr = new int[n]; \t\tfor(int i=0; i&lt;n; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t} \t\tint ans1=0, ans2=0; \t\t \t\tint min = Integer.MAX_VALUE; \t\tint left = 0; int right = n-1; \t\twhile(left &lt; right) { \t\t\tint sum = arr[left] + arr[right]; \t\t\tif(Math.abs(sum) &lt; Math.abs(min)) { \t\t\t\tmin = sum; \t\t\t\tans1 = arr[left]; \t\t\t\tans2 = arr[right]; \t\t\t} \t\t\t \t\t\tif(sum &lt; 0) left ++; \t\t\telse if(sum &gt; 0) right--; \t\t\telse break; \t\t} \t\t \t\tbw.write(ans1 + \" \" + ans2); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_9655_돌게임 (Java)",
    "url": "/posts/BOJ9655%EB%8F%8C%EA%B2%8C%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-02 09:35:07 +0900",
    "content": "[Silver V] 돌 게임 - 9655  문제 링크  성능 요약  메모리: 14304 KB, 시간: 104 ms  분류  다이나믹 프로그래밍, 게임 이론, 수학  제출 일자  2024년 10월 2일 09:28:31  문제 설명  돌 게임은 두 명이서 즐기는 재밌는 게임이다.  탁자 위에 돌 N개가 있다. 상근이와 창영이는 턴을 번갈아가면서 돌을 가져가며, 돌은 1개 또는 3개 가져갈 수 있다. 마지막 돌을 가져가는 사람이 게임을 이기게 된다.  두 사람이 완벽하게 게임을 했을 때, 이기는 사람을 구하는 프로그램을 작성하시오. 게임은 상근이가 먼저 시작한다.  입력  첫째 줄에 N이 주어진다. (1 ≤ N ≤ 1000)  출력  상근이가 게임을 이기면 SK를, 창영이가 게임을 이기면 CY을 출력한다.     문제 풀이   애드혹 문제라고 생각됐다. DP로도 풀 순 있지만 문제 답의 규칙성이 보여 그냥 규칙성으로 풀었다.DP로 푼다면 N번째에 N-1상태와 N-3상태를 보고 거기서 끝낼 수 있다면 승리함을 보여주면 될 것 같다.  게임의 답을 구하는 규칙성은 1대 or 3개를 살 수 있으므로 홀수개만 사고있음에 집중했다 (1~3개중 사는게 아니다)  그래서 남은 개수가 1개, 즉 홀수개가 남았다면 그 사람이 승리한다고 생각했고 나머지는 1혹은3이라 처음엔 1, 2, 3, 4 4가지로 나눠 1,3 / 2,4 처럼 하려했지만 나머지가 0, 1인걸로 해서 더 짧고 직관적으로 구현했다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\t// br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\t/* \t\t * 완벽하게 게임 시 남은 개수로 승리조건 분석 \t\t * 1개 : 시작하는 사람 승  \t\t * 2개 : 두번쨰 사람 승  \t\t * 3개 : 시작하는 사람 승  \t\t * 4개 : 두번째 사람  \t\t * 5개 : 시작하는 사람  \t\t * 즉 서로 홀수개밖에 사지 못하므로 홀수개가 남으면 시작하는사람 승, 짝수개가 남으면 두번째 사람 승이다   \t\t */ \t\t \t\tint N = Integer.parseInt(br.readLine()); \t\t \t\tif(N %2 == 1) bw.write(\"SK\"); \t\telse bw.write(\"CY\"); \t\t \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_11054_가장 긴 바이토닉 부분수열 (Java)",
    "url": "/posts/BOJ11054%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EB%B0%94%EC%9D%B4%ED%86%A0%EB%8B%89-%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-10-02 07:46:47 +0900",
    "content": "[Gold IV] 가장 긴 바이토닉 부분 수열 - 11054 문제 링크 성능 요약 메모리: 15564 KB, 시간: 132 ms 분류 다이나믹 프로그래밍 제출 일자 2024년 10월 2일 07:44:13 문제 설명 수열 S가 어떤 수 Sk를 기준으로 S1 &lt; S2 &lt; ... Sk-1 &lt; Sk &gt; Sk+1 &gt; ... SN-1 &gt; SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다. 예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다. 수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오. 입력 첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000) 출력 첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.     문제 풀이   가장 긴 증가하는 부분수열을 풀 줄 알면 쉽게 풀 수 있다. 꺾이는 부분을 생각하면 되는데 이때부턴 감소하므로 그냥 응용해서 한 점에서 양쪽으로 반대로 구하고 -1해주면 된다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, A[], ASC[], DESC[], ans[]; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine()); \t\tA = new int [N]; \t\tASC = new int [N]; \t\tDESC = new int [N]; \t\tans = new int[N];  \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tA[i] = Integer.parseInt(st.nextToken()); \t\t} \t\t \t\t// 오름차순 \t\tfor(int i=0; i&lt;N; i++) { \t\t\tASC[i] = 1; \t\t\tfor(int j=0; j&lt;i; j++) { \t\t\t\tif(A[j] &lt; A[i] &amp;&amp; ASC[i] &lt; ASC[j] + 1) ASC[i] = ASC[j] + 1; \t\t\t} \t\t} \t\t \t\t// 내림차순 \t\tfor(int i=N-1; i&gt;=0; i--) { \t\t\tDESC[i] = 1; \t\t\tfor(int j=N-1; j&gt;i; j--) { \t\t\t\tif(A[j] &lt; A[i] &amp;&amp; DESC[i] &lt; DESC[j] + 1) DESC[i] = DESC[j] + 1; \t\t\t} \t\t} \t\t \t\tint max = -987654321;         for (int i = 0; i &lt; N; i++) {             ans[i] = ASC[i] + DESC[i] - 1;             max = Math.max(max, ans[i]);         } \t\t         bw.write(String.valueOf(max)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   "
  },
  
  {
    "title": "BOJ_6549_히스토그램에서 가장 큰 직사각형(Java)",
    "url": "/posts/BOJ6549%ED%9E%88%EC%8A%A4%ED%86%A0%EA%B7%B8%EB%9E%A8%EC%97%90%EC%84%9C-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-30 03:09:42 +0900",
    "content": "[Platinum V] 히스토그램에서 가장 큰 직사각형 - 6549  문제 링크  성능 요약  메모리: 56948 KB, 시간: 968 ms  분류  자료 구조, 분할 정복, 세그먼트 트리, 스택  제출 일자  2024년 9월 30일 02:59:54  문제 설명  히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.    히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.  입력  입력은 테스트 케이스 여러 개로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다. 이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.  출력  각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.     문제 풀이     1. 분할 정복  분할 정복 방식은 문제를 더 작은 부분으로 나누어 해결하는 방법입니다. 이 문제에서는 다음과 같이 적용됩니다:     전체 히스토그램에서 가장 낮은 직사각형을 찾습니다.   이 가장 낮은 직사각형을 기준으로 만들 수 있는 직사각형의 넓이를 계산합니다.   가장 낮은 직사각형의 왼쪽 부분에 대해 1-2 과정을 반복합니다.   가장 낮은 직사각형의 오른쪽 부분에 대해 1-2 과정을 반복합니다.   2, 3, 4에서 구한 넓이 중 가장 큰 값을 선택합니다.   2. 세그먼트 트리  세그먼트 트리는 구간에 대한 정보를 빠르게 계산할 수 있게 해주는 자료구조입니다. 이 문제에서는 구간 내 최소 높이를 가진 직사각형의 인덱스를 빠르게 찾는 데 사용됩니다.  먼저 세그먼트 트리를 응용하는 것이 어려웠다. 기존 구간합, 구간 곱과 달리 넣는 값이 어려웠다. 각 구간에 최소높이를 넣으려 했는데 이후 모든 탐색을 통해 최소높이를 가져오긴 힘들었고, 결국 구간에서 최소 높이를 가진 블럭의 인덱스를 넣는 것으로 분할 정복을 가능하도록 만들었다.  그리고 최소 높이를 가진 좌 우를 탐색하였고 그럼 최대구간의 최소높이부터 좌우로 두 직사각형이 생기고 계속 나누며 최대 직사각형 넓이를 탐색했다. 시간복잡도는 O NlogN  코드 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic StringBuilder sb; \tstatic int n, tree[], num[]; \t \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tsb = new StringBuilder(); \t\t \t\twhile(true) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tn = Integer.parseInt(st.nextToken()); \t\t\tif(n==0) break; \t\t\t \t\t\tnum = new int[n+1]; \t\t\tfor(int i=1; i&lt;=n; i++) { \t\t\t\tnum[i] = Integer.parseInt(st.nextToken()); \t\t\t} \t\t\t \t\t\ttree = new int[4*n]; \t\t\tinit(1, n, 1); \t\t\t \t\t\tlong maxRecS = getMaxRectangle(1, n); \t\t\tsb.append(maxRecS).append(\"\\n\"); \t\t} \t\t         bw.write(sb.toString());  \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \t/** \t * a~b 까지 최대 직사각형 S 계산 후 \t * 좌우 분할정복으로 다시 계산 ( 다이아몬드 모양 ) \t *  \t * @param left \t * @param right \t * @return \t */ \tprivate long getMaxRectangle(int left, int right) {         if (left &gt; right) return 0;  \t\tlong maxS = 0L; \t\tlong tmpS = 0L; \t\tint idx = getMinH_idx(1, n, 1, left, right); \t\t \t\tmaxS = (long)(right-left+1) * (long)num[idx];  \t\ttmpS = getMaxRectangle(left, idx-1);         maxS = Math.max(maxS, tmpS);                  tmpS = getMaxRectangle(idx+1, right);         maxS = Math.max(maxS, tmpS);          \t\treturn maxS; \t\t \t}  \t/** \t * 주어진 구간에서 가장 낮은 직사각형의 인덱스 \t *  \t * @param start \t * @param end \t * @param node \t * @param left \t * @param right \t * @return \t */     private int getMinH_idx(int start, int end, int node, int left, int right) {     \t         // 찾고자 하는 구간과 현재 노드의 구간이 겹치지 않으면 0 반환     \tif(left &gt; end || right &lt; start) return 0;              \t// 현재 노드의 구간이 찾고자 하는 구간에 완전히 포함되면 현재 노드의 값 반환         if(left &lt;= start &amp;&amp; end &lt;= right) return tree[node];                           // 그 외의 경우, 왼쪽 자식과 오른쪽 자식을 재귀적으로 탐색하여 더 낮은 높이를 가진 직사각형의 인덱스 반환         int mid = (start + end) / 2;         int leftIdx = getMinH_idx(start, mid, node*2, left, right);         int rightIdx = getMinH_idx(mid+1, end, node*2+1, left, right);                  if(leftIdx == 0) return rightIdx;         if(rightIdx == 0) return leftIdx;         return num[leftIdx] &lt; num[rightIdx] ? leftIdx : rightIdx;     }  \t/** \t * 세그먼트 트리 초기화 \t * 최소 인덱스 저장 \t *  \t * @param start \t * @param end \t * @param node \t * @return \t */ \tprivate int init(int start, int end, int node) { \t\tif(start == end) return tree[node] = start; \t\t \t\tint mid = (start + end) / 2; \t\tint left = init(start, mid, node*2); \t\tint right = init(mid+1, end, node*2+1); \t\t \t\treturn tree[node] = num[left] &lt; num[right] ? left : right; \t} \t }  "
  },
  
  {
    "title": "BOJ_2631_줄 세우기 (Java)",
    "url": "/posts/BOJ2631%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-25 06:12:42 +0900",
    "content": "[Gold IV] 줄세우기 - 2631  문제 링크  성능 요약  메모리: 14288 KB, 시간: 100 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 9월 25일 06:10:48  문제 설명  KOI 어린이집에는 N명의 아이들이 있다. 오늘은 소풍을 가는 날이다. 선생님은 1번부터 N번까지 번호가 적혀있는 번호표를 아이들의 가슴에 붙여주었다. 선생님은 아이들을 효과적으로 보호하기 위해 목적지까지 번호순서대로 일렬로 서서 걸어가도록 하였다. 이동 도중에 보니 아이들의 번호순서가 바뀌었다. 그래서 선생님은 다시 번호 순서대로 줄을 세우기 위해서 아이들의 위치를 옮기려고 한다. 그리고 아이들이 혼란스러워하지 않도록 하기 위해 위치를 옮기는 아이들의 수를 최소로 하려고 한다.  예를 들어, 7명의 아이들이 다음과 같은 순서대로 줄을 서 있다고 하자.  3 7 5 2 6 1 4  아이들을 순서대로 줄을 세우기 위해, 먼저 4번 아이를 7번 아이의 뒤로 옮겨보자. 그러면 다음과 같은 순서가 된다.  3 7 4 5 2 6 1  이제, 7번 아이를 맨 뒤로 옮긴다.  3 4 5 2 6 1 7  다음 1번 아이를 맨 앞으로 옮긴다.  1 3 4 5 2 6 7  마지막으로 2번 아이를 1번 아이의 뒤로 옮기면 번호 순서대로 배치된다.  1 2 3 4 5 6 7  위의 방법으로 모두 4명의 아이를 옮겨 번호 순서대로 줄을 세운다. 위의 예에서 3명의 아이만을 옮겨서는 순서대로 배치할 수가 없다. 따라서, 4명을 옮기는 것이 가장 적은 수의 아이를 옮기는 것이다.  N명의 아이들이 임의의 순서로 줄을 서 있을 때, 번호 순서대로 배치하기 위해 옮겨지는 아이의 최소 수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에는 아이들의 수 N이 주어진다. 둘째 줄부터는 1부터 N까지의 숫자가 한 줄에 하나씩 주어진다. N은 2 이상 200 이하의 정수이다.  출력  첫째 줄에는 번호 순서대로 줄을 세우는데 옮겨지는 아이들의 최소 수를 출력한다.     문제 풀이   수열이 주어지면 여기서 어떤 정수가 가장 오름차순으로 증가하는 수열을 이루는지 찾고 나머지 숫자들은 뽑아서 알맞게 넣어준다고 생각하면된다.  LIS 알고리즘 관련 문제같다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tstatic PriorityQueue&lt;Integer&gt; ASC_PQ = new PriorityQueue&lt;Integer&gt;(); \tstatic PriorityQueue&lt;Integer&gt; DESC_PQ = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); \tstatic int N, arr[], dp[], cnt;  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tN = Integer.parseInt(br.readLine()); \t\tarr = new int[N]; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(br.readLine()); \t\t} \t\t \t\tdp = new int[N]; \t\tArrays.fill(dp, 1); \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfor(int j=0; j&lt;i; j++) { \t\t\t\tif (arr[i] &gt; arr[j] &amp;&amp; dp[i] &lt; dp[j]+1) dp[i] = dp[j]+1; \t\t\t} \t\t} \t\tcnt = dp[0]; \t\tfor(int i=1; i&lt;dp.length; i++) { \t\t\tcnt = Math.max(cnt, dp[i]); \t\t} //\t\tSystem.out.println(Arrays.toString(dp)); \t\t \t\tbw.write(String.valueOf(arr.length-cnt)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_7662_이중 우선순위 큐(Java)",
    "url": "/posts/BOJ7662%EC%9D%B4%EC%A4%91-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-25 05:43:17 +0900",
    "content": "[Gold IV] 이중 우선순위 큐 - 7662  문제 링크  성능 요약  메모리: 451072 KB, 시간: 2648 ms  분류  자료 구조, 우선순위 큐, 트리를 사용한 집합과 맵  제출 일자  2024년 9월 25일 05:27:29  문제 설명  이중 우선순위 큐(dual priority queue)는 전형적인 우선순위 큐처럼 데이터를 삽입, 삭제할 수 있는 자료 구조이다. 전형적인 큐와의 차이점은 데이터를 삭제할 때 연산(operation) 명령에 따라 우선순위가 가장 높은 데이터 또는 가장 낮은 데이터 중 하나를 삭제하는 점이다. 이중 우선순위 큐를 위해선 두 가지 연산이 사용되는데, 하나는 데이터를 삽입하는 연산이고 다른 하나는 데이터를 삭제하는 연산이다. 데이터를 삭제하는 연산은 또 두 가지로 구분되는데 하나는 우선순위가 가장 높은 것을 삭제하기 위한 것이고 다른 하나는 우선순위가 가장 낮은 것을 삭제하기 위한 것이다.   정수만 저장하는 이중 우선순위 큐 Q가 있다고 가정하자. Q에 저장된 각 정수의 값 자체를 우선순위라고 간주하자.   Q에 적용될 일련의 연산이 주어질 때 이를 처리한 후 최종적으로 Q에 저장된 데이터 중 최댓값과 최솟값을 출력하는 프로그램을 작성하라.  입력  입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 Q에 적용할 연산의 개수를 나타내는 정수 k (k ≤ 1,000,000)가 주어진다. 이어지는 k 줄 각각엔 연산을 나타내는 문자(‘D’ 또는 ‘I’)와 정수 n이 주어진다. ‘I n’은 정수 n을 Q에 삽입하는 연산을 의미한다. 동일한 정수가 삽입될 수 있음을 참고하기 바란다. ‘D 1’는 Q에서 최댓값을 삭제하는 연산을 의미하며, ‘D -1’는 Q 에서 최솟값을 삭제하는 연산을 의미한다. 최댓값(최솟값)을 삭제하는 연산에서 최댓값(최솟값)이 둘 이상인 경우, 하나만 삭제됨을 유념하기 바란다.  만약 Q가 비어있는데 적용할 연산이 ‘D’라면 이 연산은 무시해도 좋다. Q에 저장될 모든 정수는 -231 이상 231 미만인 정수이다.   출력  출력은 표준출력을 사용한다. 각 테스트 데이터에 대해, 모든 연산을 처리한 후 Q에 남아 있는 값 중 최댓값과 최솟값을 출력하라. 두 값은 한 줄에 출력하되 하나의 공백으로 구분하라. 만약 Q가 비어있다면 ‘EMPTY’를 출력하라.     문제풀이   O(N) 으로 최대 최소 우선순위큐에서 찾아 삭제하면 시간초과가 발생, 지울 값을 map별로 저장해 key를 통해 O(1)로 찾아 삭제.  코드         시간초과 코드(Map 사용 X)      /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tstatic PriorityQueue&lt;Integer&gt; ASC_PQ = new PriorityQueue&lt;Integer&gt;(); \tstatic PriorityQueue&lt;Integer&gt; DESC_PQ = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); \tstatic int T, N;  \tpublic void solution() throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tT = Integer.parseInt(br.readLine());  \t\twhile (T-- &gt; 0) { \t\t\tASC_PQ.clear(); \t\t\tDESC_PQ.clear();  \t\t\tN = Integer.parseInt(br.readLine()); \t\t\tfor (int i = 0; i &lt; N; i++) { \t\t\t\tst = new StringTokenizer(br.readLine()); \t\t\t\tString mode = st.nextToken(); \t\t\t\tint num = Integer.parseInt(st.nextToken());  \t\t\t\tswitch (mode) {                 case \"I\": {                     ASC_PQ.add(num);                     DESC_PQ.add(num);                     break;                 }                 case \"D\": {                     if (!ASC_PQ.isEmpty()) {                         int deletedNum = (num == 1) ? deleteMax() : deleteMin();                     }                     break;                 }             } \t\t\t} \t\t\tif (ASC_PQ.size() &lt; 1) \t\t\t\tSystem.out.println(\"EMPTY\"); \t\t\telse if (ASC_PQ.size() == 1) \t\t\t\tSystem.out.println(ASC_PQ.poll()); \t\t\telse { \t\t\t\tSystem.out.print(DESC_PQ.poll() + \" \"); \t\t\t\tSystem.out.print(ASC_PQ.poll() + \" \"); \t\t\t\tSystem.out.println(\"시간초과\"); \t\t\t} \t\t}  \t\tbw.close(); \t\tbr.close(); \t}  \t// num == 1 \tprivate int deleteMax() { \t\tint deletedNum = DESC_PQ.poll(); \t\tASC_PQ.remove(deletedNum); \t\treturn deletedNum; \t}  \t// num == -1 \tprivate int deleteMin() { \t\tint deletedNum = ASC_PQ.poll(); \t\tDESC_PQ.remove(deletedNum); \t\treturn deletedNum; \t} }           정답코드 (Map 사용 O)      /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static StringBuilder sb;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      static PriorityQueue&lt;Integer&gt; ASC_PQ = new PriorityQueue&lt;Integer&gt;();     static PriorityQueue&lt;Integer&gt; DESC_PQ = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());     static Map&lt;Integer, Integer&gt; map; // 숫자 개수     static int T, N;      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         sb = new StringBuilder();          T = Integer.parseInt(br.readLine());          while (T-- &gt; 0) {             ASC_PQ.clear();             DESC_PQ.clear();             map = new HashMap&lt;&gt;();              N = Integer.parseInt(br.readLine());             for (int i = 0; i &lt; N; i++) {                 st = new StringTokenizer(br.readLine());                 String mode = st.nextToken();                 int num = Integer.parseInt(st.nextToken());                  switch (mode) {                     case \"I\": {                         ASC_PQ.add(num);                         DESC_PQ.add(num);                         map.put(num, map.getOrDefault(num, 0) + 1); //                        System.out.println(map);                         break;                     }                     case \"D\": {                         if (!map.isEmpty()) {                             if (num == 1) {                                 delete(DESC_PQ);                             } else {                                 delete(ASC_PQ);                             }                         }                         break;                     }                 }             }              if (map.isEmpty()) {                 sb.append(\"EMPTY\\n\");             } else {                 int max = delete(DESC_PQ);                 sb.append(max).append(\" \");                                  // 하나뿐인지                 if (!map.isEmpty()) {                     int min = delete(ASC_PQ);                     sb.append(min); //                    System.out.println(\"min : \" + min);                 }                  else {                     sb.append(max); //                    System..println(\"max : \" + max);                 }                 sb.append(\"\\n\");             }         }          System.out.print(sb);         br.close();     }      private int delete(Queue&lt;Integer&gt; pq) {         int deleteNum;         while (true) {             deleteNum = pq.poll();             int cnt = map.getOrDefault(deleteNum, 0); //            System.out.println(\"cnt : \" + cnt);             if (cnt == 0) continue;                          if (cnt == 1) map.remove(deleteNum);             else map.put(deleteNum, cnt - 1);             break;         }         return deleteNum;     } }  "
  },
  
  {
    "title": "BOJ_16934_게임 닉네임 (Java)",
    "url": "/posts/BOJ16934%EA%B2%8C%EC%9E%84-%EB%8B%89%EB%84%A4%EC%9E%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-22 20:13:15 +0900",
    "content": "[Gold III] 게임 닉네임 - 16934  문제 링크  성능 요약  메모리: 85120 KB, 시간: 508 ms  분류  자료 구조, 해시를 사용한 집합과 맵, 문자열, 트리, 트라이  제출 일자  2024년 9월 22일 20:01:14  문제 설명  스타트링크에서 매우 재미있는 게임을 만들었다. 이 게임은 정말 재미있다.  게임에는 유저가 접속하는 기능이 있고, 각 유저는 가입할 때, 자신의 닉네임을 정해야 한다. 닉네임은 알파벳 소문자로만 이루어져 있고, 두 유저가 같은 닉네임을 정하는 것도 가능하다.  이 게임은 유저의 닉네임을 이용해서 내부에 저장할 별칭을 만든다. 별칭은 유저에게 보여지지는 않고, 내부에서만 사용된다. 저장 공간을 최소로 하기 위해서 별칭의 길이를 최소로 하려고 한다.  별칭은 유저 닉네임의 접두사(Prefix) 중에서 가장 길이가 짧은 것을 사용한다. 이때, 접두사가 이전에 가입한 닉네임의 접두사가 아니어야 한다. 가능한 별칭이 없는 경우에는 유저가 가입한 시점까지 같은 닉네임으로 가입한 사람의 수 x를 계산해야 한다. x가 1인 경우에는 닉네임을 별칭으로 사용하고, x가 2 이상인 경우에는 닉네임의 뒤에 x를 붙여서 별칭으로 사용한다.  예를 들어, 닉네임을 \"baekjoon\"으로 정한 유저가 가입하면, 이 유저의 별칭은 \"b\"가 된다.   그 다음, 닉네임이 \"startlink\"로 정한 유저가 가입하면, 이 유저의 별칭은 \"s\"이다. \"bakejoon\"이 닉네임인 유저가 가입하면, 별칭은 \"bak\"가 되고, \"beakjoon\"인 유저가 가입하면, 별칭은 \"be\"가 된다. 마지막으로 \"baekjoon\"으로 유저가 가입하면 별칭은 \"baekjoon2\"가 된다.  유저가 가입한 순서대로 닉네임이 주어졌을 때, 각 유저의 별칭을 구해보자. 위의 규칙을 이용해 별칭을 정하면 두 유저가 같은 별칭을 갖는 것도 가능하다.  입력  첫째 줄에 가입한 유저의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 유저의 닉네임이 가입한 순서대로 한 줄에 하나씩 주어진다. 닉네임은 알파벳 소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.  출력  유저가 가입한 순서대로 별칭을 한 줄에 하나씩 출력한다.     문제 풀이   기본적인 트라이 사용 문제다. 먼저 트라이라는 구조에 대해 공부 후 적용해보았다. 트리 구조로 일치하는 항목에 접근하여 분기가 생길 때 새로 나누어 데이터를 저장한다. isEnd로 끝인지 판별 가능한 변수도 넣어주었다.(이 문제에선 사실 필요없지만 정석적인 구현 해봄)  나머지는 문제에 맞게 구현해주었다.  최근 입출력 실수 및 선언 위치 실수가 나오는데 주의해야겠다. 급하게 CP식으로 풀지 말고 기본기부터 다시 다져야겠다.  코드 /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st;  \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tstatic Trie root;  \tpublic void solution() throws Exception { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tint N = Integer.parseInt(br.readLine()); \t\troot = new Trie(); \t\t \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tString name = br.readLine(); \t\t\tinsertName(name); \t\t}   \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t}  \tprivate void insertName(String name) throws IOException { \t\tTrie trie = root; \t\tStringBuilder sb = new StringBuilder(); \t\t// 새로운 분기인지 판별  \t\tboolean flag = false; \t\t \t\tfor (int i = 0; i &lt; name.length(); i++) { \t\t\tint idx = name.charAt(i) - 'a'; \t\t\tif(!flag) sb.append(name.charAt(i)); \t\t\t \t\t\t// 새로 분기를 만들어야 하면 생성하고 별칭에 추가.  \t\t\tif (trie.children[idx] == null) { \t\t\t\tflag = true; \t\t\t\ttrie.children[idx] = new Trie(); \t\t\t}  \t\t\ttrie = trie.children[idx]; \t\t} \t\t \t\ttrie.isEnd = true; \t\t\tif(trie.count == 0)  trie.count++; \t\t\telse { \t\t\t\tString x = String.valueOf(++trie.count); \t\t\t\tsb.append(x); \t\t\t} \t\tbw.write(sb.toString() + \"\\n\"); \t}  }  class Trie { \tTrie[] children = new Trie[26]; \tint count; \tboolean isEnd;  \tTrie() { \t\tthis.isEnd = false; \t\tfor (int i = 0; i &lt; 26; i++) { \t\t\tchildren[i] = null; \t\t} \t\tthis.count = 0; \t} }  "
  },
  
  {
    "title": "PGMS_보호소에서 중성화한 동물",
    "url": "/posts/PGMS%EB%B3%B4%ED%98%B8%EC%86%8C%EC%97%90%EC%84%9C-%EC%A4%91%EC%84%B1%ED%99%94%ED%95%9C-%EB%8F%99%EB%AC%BC/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-09-22 18:42:49 +0900",
    "content": "[level 4] 보호소에서 중성화한 동물 - 59045  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; JOIN  채점결과  Empty  제출 일자  2024년 09월 22일 18:24:09  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_OUTCOME VARCHAR(N) FALSE          보호소에서 중성화 수술을 거친 동물 정보를 알아보려 합니다. 보호소에 들어올 당시에는 중성화1되지 않았지만, 보호소를 나갈 당시에는 중성화된 동물의 아이디와 생물 종, 이름을 조회하는 아이디 순으로 조회하는 SQL 문을 작성해주세요.  예시  예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면  ANIMAL_INS           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A367438 Dog 2015-09-10 16:01:00 Normal Cookie Spayed Female   A382192 Dog 2015-03-13 13:14:00 Normal Maxwell 2 Intact Male   A405494 Dog 2014-05-16 14:17:00 Normal Kaila Spayed Female   A410330 Dog 2016-09-11 14:09:00 Sick Chewy Intact Female          ANIMAL_OUTS           ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME            A367438 Dog 2015-09-12 13:30:00 Cookie Spayed Female   A382192 Dog 2015-03-16 13:46:00 Maxwell 2 Neutered Male   A405494 Dog 2014-05-20 11:44:00 Kaila Spayed Female   A410330 Dog 2016-09-13 13:46:00 Chewy Spayed Female           Cookie는 보호소에 들어올 당시에 이미 중성화되어있었습니다. Maxwell 2는 보호소에 들어온 후 중성화되었습니다. Kaila는 보호소에 들어올 당시에 이미 중성화되어있었습니다. Chewy는 보호소에 들어온 후 중성화되었습니다.   따라서 SQL문을 실행하면 다음과 같이 나와야 합니다.           ANIMAL_ID ANIMAL_TYPE NAME            A382192 Dog Maxwell 2   A410330 Dog Chewy            본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.       중성화를 거치지 않은 동물은 성별 및 중성화 여부에 Intact, 중성화를 거친 동물은 Spayed 또는 Neutered라고 표시되어있습니다.&nbsp;↩         출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   ID로 조인하고, 이때 INS테이블과 OUT테이블에서 찾는 조건을 LIKE로 문자열 검색을 진행  코드      SELECT ao.ANIMAL_ID, ao.ANIMAL_TYPE, ao.NAME         FROM ANIMAL_OUTS AS ao             JOIN ANIMAL_INS AS ai                 ON ai.ANIMAL_ID = ao.ANIMAL_ID                     WHERE ai.SEX_UPON_INTAKE LIKE 'Intact%'                         AND (ao.SEX_UPON_OUTCOME LIKE 'Spayed%' OR ao.SEX_UPON_OUTCOME LIKE 'Neutered%')                             ORDER BY ao.ANIMAL_ID ASC;   다른 방법 있을 것 같아서 검색해본 방법     서브쿼리           SELECT ao.ANIMAL_ID, ao.ANIMAL_TYPE, ao.NAME         FROM ANIMAL_OUTS ao         WHERE EXISTS (             SELECT 1             FROM ANIMAL_INS ai             WHERE ai.ANIMAL_ID = ao.ANIMAL_ID             AND ai.SEX_UPON_INTAKE LIKE 'Intact%'         )         AND (ao.SEX_UPON_OUTCOME LIKE 'Spayed%' OR ao.SEX_UPON_OUTCOME LIKE 'Neutered%')         ORDER BY ao.ANIMAL_ID ASC;      View           SELECT ao.ANIMAL_ID, ao.ANIMAL_TYPE, ao.NAME         FROM ANIMAL_OUTS ao         JOIN (             SELECT ANIMAL_ID             FROM ANIMAL_INS             WHERE SEX_UPON_INTAKE LIKE 'Intact%'         ) ai ON ao.ANIMAL_ID = ai.ANIMAL_ID         WHERE ao.SEX_UPON_OUTCOME LIKE 'Spayed%' OR ao.SEX_UPON_OUTCOME LIKE 'Neutered%'         ORDER BY ao.ANIMAL_ID ASC;   +유니온 하는 방법도 있는데 별로같음 다중 Join이 아니라면 Join 하는게 좋아보임  "
  },
  
  {
    "title": "BOJ_2252_줄 세우기(Java)",
    "url": "/posts/BOJ2252%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0Java-r9p49ffk/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-22 17:06:42 +0900",
    "content": "[Gold III] 줄 세우기 - 2252  문제 링크  성능 요약  메모리: 51328 KB, 시간: 456 ms  분류  방향 비순환 그래프, 그래프 이론, 위상 정렬  제출 일자  2024년 9월 8일 23:19:24  문제 설명  N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.  일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.  입력  첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.  학생들의 번호는 1번부터 N번이다.  출력  첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.  코드 /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic StringTokenizer st; \tstatic ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); \tstatic int N, M, inDegree[]; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\t \t\tfor(int i=0; i&lt;=N; i++) { \t\t\tarr.add(new ArrayList&lt;&gt;()); \t\t} \t\t \t\tinDegree = new int[N+1]; \t\tfor(int i=0; i&lt;M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint front = Integer.parseInt(st.nextToken()); \t\t\tint back = Integer.parseInt(st.nextToken()); \t\t\tarr.get(front).add(back); \t\t\tinDegree[back]++; \t\t\t \t\t} \t\tQueue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tif(inDegree[i]==0) queue.add(i); \t\t} \t\t \t\twhile(!queue.isEmpty()) { \t\t\tint curr = queue.poll(); \t\t\tbw.write(curr + \" \"); \t\t\tfor(int next : arr.get(curr)) { \t\t\t\tinDegree[next]--; \t\t\t\tif(inDegree[next]==0) queue.add(next); \t\t\t} \t\t} \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "BOJ_2162_선분 그룹 (Java)",
    "url": "/posts/BOJ2162%EC%84%A0%EB%B6%84-%EA%B7%B8%EB%A3%B9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-22 14:23:56 +0900",
    "content": "[Platinum V] 선분 그룹 - 2162  문제 링크  성능 요약  메모리: 19176 KB, 시간: 368 ms  분류  자료 구조, 분리 집합, 기하학, 선분 교차 판정  제출 일자  2024년 9월 22일 14:17:57  문제 설명  N개의 선분들이 2차원 평면상에 주어져 있다. 선분은 양 끝점의 x, y 좌표로 표현이 된다.  두 선분이 서로 만나는 경우에, 두 선분은 같은 그룹에 속한다고 정의하며, 그룹의 크기는 그 그룹에 속한 선분의 개수로 정의한다. 두 선분이 만난다는 것은 선분의 끝점을 스치듯이 만나는 경우도 포함하는 것으로 한다.  N개의 선분들이 주어졌을 때, 이 선분들은 총 몇 개의 그룹으로 되어 있을까? 또, 가장 크기가 큰 그룹에 속한 선분의 개수는 몇 개일까? 이 두 가지를 구하는 프로그램을 작성해 보자.  입력  첫째 줄에 N(1 ≤ N ≤ 3,000)이 주어진다. 둘째 줄부터 N+1번째 줄에는 양 끝점의 좌표가 x1, y1, x2, y2의 순서로 주어진다. 각 좌표의 절댓값은 5,000을 넘지 않으며, 입력되는 좌표 사이에는 빈칸이 하나 있다.  출력  첫째 줄에 그룹의 수를, 둘째 줄에 가장 크기가 큰 그룹에 속한 선분의 개수를 출력한다.     문제 풀이    풀이 방법은 쉽게 떠올렸지만 케이스 처리 부분에서 생각을 오래했던 문제. 일자로 두 선분이 나란히 있을때 어떻게 처리해야할 지 , 동 떨어져 있던 두 선분이 새로운 선분에 의해 한 그룹으로 바뀔 때 ( ㅣㅣ 에서 ㅐ 모양 같이 ) 어떻게 처리 할 지 고민을 많이 했다. 경로압축 및 분리집합, 벡터 외적 스칼라곱을 활용해 풀었다.  코드  /**  * Author: nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N; \tstatic Line[] lines;     static Group[] groups; \tpublic static void main(String[] args) throws Exception { \t\tnew Main().solution(); \t}  \tpublic void solution() throws Exception { \t\t// br = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tN = Integer.parseInt(br.readLine());  \t\tlines = new Line[N];         groups = new Group[N];  \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint x1 = Integer.parseInt(st.nextToken()); \t\t\tint y1 = Integer.parseInt(st.nextToken()); \t\t\tint x2 = Integer.parseInt(st.nextToken()); \t\t\tint y2 = Integer.parseInt(st.nextToken()); \t\t\tlines[i] = new Line(x1, y1, x2, y2);             groups[i] = new Group(i); \t\t} \t\t\t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tfor(int j=i+1; j&lt;N; j++) { \t\t\t\tif(isLineCrossed(lines[i], lines[j])) union(i, j); \t\t\t} \t\t} \t\t \t\tint groutCnt = 0; \t\tint maxSize = 0; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tif(groups[i].parent == i) { \t\t\t\tgroutCnt++; \t\t\t\tmaxSize = Math.max(maxSize, groups[i].size); \t\t\t} \t\t} \t\t         bw.write(groutCnt + \"\\n\" + maxSize); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} \t \tprivate int find(int start) { \t\tif(groups[start].parent != start) groups[start].parent = find(groups[start].parent); \t\treturn groups[start].parent; \t} \t \tprivate void union(int start, int end) { \t\tint root1 = find(start); \t\tint root2 = find(end); \t\t \t\tif(root1 != root2) { \t\t\tif (groups[root1].size &lt; groups[root2].size) { // 그룹2에 1을 포함시키기                 groups[root1].parent = root2;                 groups[root2].size += groups[root1].size;             } else { // 그룹1에 2을 포함시키기                 groups[root2].parent = root1;                 groups[root1].size += groups[root2].size;             } \t\t} \t}  \tprivate static int ccw(Point p1, Point p2, Point p3) {         long res = (p1.x * p2.y + p2.x * p3.y + p3.x * p1.y) - (p1.x * p3.y + p3.x * p2.y + p2.x * p1.y); \t\tif(res == 0) return 0; \t\telse if (res &gt; 0) return 1; \t\telse return -1; \t} \t \tprivate static boolean isLineCrossed(Line l1, Line l2) { \t\tPoint p1 = l1.p1; \t\tPoint p2 = l1.p2; \t\t \t\tPoint p3 = l2.p1; \t\tPoint p4 = l2.p2; \t\t \t\tint ccw1 = ccw(p1, p2, p3) * ccw(p1, p2, p4); \t\tint ccw2 = ccw(p3, p4, p1) * ccw(p3, p4, p2); \t\t \t\t// 1. 한 줄 일때  \t\t// 1 3 2 4 처럼 겹칠텐데 1&lt;4 고 2&gt;3 임을 수식으로 작성 \t\tif (ccw1 == 0 &amp;&amp; ccw2 == 0) {             if (Math.min(p1.x, p2.x) &lt;= Math.max(p3.x, p4.x) &amp;&amp;             \tMath.min(p3.x, p4.x) &lt;= Math.max(p1.x, p2.x) &amp;&amp;              \tMath.min(p1.y, p2.y) &lt;= Math.max(p3.y, p4.y) &amp;&amp;              \tMath.min(p3.y, p4.y) &lt;= Math.max(p1.y, p2.y)) {                 return true;             }              else return false;         }  \t\t// 2. 크로스가 있을 가능성이 있을 때 \t\t// 2-1. 둘 다 ccw 곱이 음수면 완전 크로스 : true \t\telse if (ccw1 &lt;= 0 &amp;&amp; ccw2 &lt;= 0) return true;          \t\t// 그 외는 한쪽 음수 한쪽 양수이므로 ㅡ ㅣ 같은 모양임 : false \t\telse return false;          \t}  \tclass Point implements Comparable&lt;Point&gt;{ \t\tint x, y;  \t\tpublic Point(int x, int y) { \t\t\tthis.x = x; \t\t\tthis.y = y; \t\t}  \t\t@Override \t\tpublic int compareTo(Point o) { \t\t\tif(this.x == o.x) return this.y - o.y; \t\t\treturn this.x - o.x; \t\t} \t} \t \tclass Line{  \t    Point p1, p2;  \t    public Line(int x1, int y1, int x2, int y2) { \t        Point point1 = new Point(x1, y1); \t        Point point2 = new Point(x2, y2);  \t        p1 = point1.compareTo(point2) &lt;= 0 ? point1 : point2; \t        p2 = point1.compareTo(point2) &lt;= 0 ? point2 : point1; \t    }  \t} \t \tclass Group{ \t\tint parent; \t\tint size; \t\tpublic Group(int parent) { \t\t\tthis.parent = parent; \t\t\tthis.size = 1; \t\t} \t}  }  "
  },
  
  {
    "title": "JWT 학습",
    "url": "/posts/JWT-%ED%95%99%EC%8A%B5/",
    "categories": "공부",
    "tags": "JWT, Java",
    "date": "2024-09-22 13:13:08 +0900",
    "content": "  "
  },
  
  {
    "title": "BOJ_11967_불켜기 (Java)",
    "url": "/posts/BOJ11967%EB%B6%88%EC%BC%9C%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-21 10:15:00 +0900",
    "content": "[Gold II] 불켜기 - 11967  문제 링크  성능 요약  메모리: 26468 KB, 시간: 248 ms  분류  너비 우선 탐색, 그래프 이론, 그래프 탐색  제출 일자  2024년 9월 21일 10:11:57  문제 설명  농부 존은 최근에 N × N개의 방이 있는 거대한 헛간을 새로 지었다. 각 방은 (1, 1)부터 (N,N)까지 번호가 매겨져있다(2 ≤ N ≤ 100). 어둠을 무서워하는 암소 베시는 최대한 많은 방에 불을 밝히고 싶어한다.  베시는 유일하게 불이 켜져있는 방인 (1, 1)방에서 출발한다. 어떤 방에는 다른 방의 불을 끄고 켤 수 있는 스위치가 달려있다. 예를 들어, (1, 1)방에 있는 스위치로 (1, 2)방의 불을 끄고 켤 수 있다. 베시는 불이 켜져있는 방으로만 들어갈 수 있고, 각 방에서는 상하좌우에 인접한 방으로 움직일 수 있다.   베시가 불을 켤 수 있는 방의 최대 개수를 구하시오.  입력  첫 번째 줄에는 N(2 ≤ N ≤ 100)과, M(1 ≤ M ≤ 20,000)이 정수로 주어진다.  다음 M줄에는 네 개의 정수 x, y, a, b가 주어진다. (x, y)방에서 (a, b)방의 불을 켜고 끌 수 있다는 의미이다. 한 방에 여러개의 스위치가 있을 수 있고, 하나의 불을 조절하는 스위치 역시 여러개 있을 수 있다.   출력  베시가 불을 켤 수 있는 방의 최대 개수를 출력하시오.     문제 풀이   Area 클래스: (r,c) 좌표를 나타내는 클래스로, HashMap에서 키로 사용하기 위해 hashCode와 equals 메서드를 오버라이드합니다.  각 방의 상태를 3가지로 나누어 저장 (LIGHT_ON, VISITED, CAN_VISIT).  (1, 1) 부터 BFS 현재 위치의 스위치로 켤 수 있는 모든 불을 켭니다. 상하좌우로 이동할 수 있는지 확인합니다. 이동할 수 있으면 큐에 추가하고 상태를 업데이트합니다.  코드 import java.io.*; import java.util.*;  public class Main {     static int[] dr = { 0, 0, 1, -1 };     static int[] dc = { 1, -1, 0, 0 };     private static final int LIGHT_ON = 1;     private static final int VISITED = 2;     private static final int CAN_VISIT = 3;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception { //        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         StringTokenizer st = new StringTokenizer(br.readLine());         int n = Integer.parseInt(st.nextToken());         int m = Integer.parseInt(st.nextToken());         Map&lt;Area, List&lt;Area&gt;&gt; map = new HashMap&lt;&gt;();          while (m-- &gt; 0) {             st = new StringTokenizer(br.readLine());             int x = Integer.parseInt(st.nextToken());             int y = Integer.parseInt(st.nextToken());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             Area cur = new Area(x, y);             map.computeIfAbsent(cur, k -&gt; new ArrayList&lt;&gt;()).add(new Area(a, b));         }          int result = bfs(n, map);         System.out.println(result);          br.close();     }      private int bfs(int n, Map&lt;Area, List&lt;Area&gt;&gt; map) {         Queue&lt;Area&gt; queue = new ArrayDeque&lt;&gt;();         int[][] board = new int[n+1][n+1];         board[1][1] = VISITED;         queue.add(new Area(1, 1));         int cnt = 1;          while (!queue.isEmpty()) {             Area current = queue.poll();             if (map.containsKey(current)) {                 for (Area light : map.get(current)) {                     if (board[light.r][light.c] == VISITED || board[light.r][light.c] == LIGHT_ON) continue;                     cnt++;                     if (board[light.r][light.c] == CAN_VISIT) {                         queue.add(light);                         board[light.r][light.c] = VISITED;                     } else {                         board[light.r][light.c] = LIGHT_ON;                     }                 }             }              for (int d = 0; d &lt; 4; d++) {                 int nr = current.r + dr[d];                 int nc = current.c + dc[d];                 if (nr &lt; 1 || nr &gt; n || nc &lt; 1 || nc &gt; n || board[nr][nc] == VISITED || board[nr][nc] == CAN_VISIT) continue;                  if (board[nr][nc] == LIGHT_ON) {                     board[nr][nc] = VISITED;                     queue.add(new Area(nr, nc));                     continue;                 }                  board[nr][nc] = CAN_VISIT;             }         }         return cnt;     } }  class Area {     int r, c;      public Area(int r, int c) {         this.r = r;         this.c = c;     }      @Override     public int hashCode() {         return c * 20000 + r;     }      @Override     public boolean equals(Object o) {         if (this == o) return true;         if (o == null || getClass() != o.getClass()) return false;         Area a = (Area) o;         return this.r == a.r &amp;&amp; this.c == a.c;     } }  "
  },
  
  {
    "title": "백준 문제 풀이 세팅 템플릿",
    "url": "/posts/%EB%B0%B1%EC%A4%80-%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4-%EC%84%B8%ED%8C%85-%ED%85%9C%ED%94%8C%EB%A6%BF/",
    "categories": "알고리즘",
    "tags": "C++, Java, 백준, 알고리즘",
    "date": "2024-09-21 09:51:38 +0900",
    "content": "   백준 문제를 풀 때 매번 Main함수부터 입출력까지 입력하는 부분이 귀찮아서 자동화했습니다.   Eclipse   1. 먼저 이클립스에서 Window를 켜 Preferences로 들어갑니다  2. Java &gt; Editor &gt; Templates를 찾습니다 이 안에 자주 사용하는 main 도 볼 수 있을것입니다.  3. New를 눌러 원하는 템플릿을 입력해줍니다(자동화시킬) 저의 경우 다음과 같이 매번 작성하기 때문에 다음과 같이 만들어두었습니다. ${cursor}은 템플릿이 생성되었을 때 커서가 위치할 곳을 정해주는 명령어입니다.  결과 /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new Main().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         // br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));           // 여기서부터 문제 풀이 로직을 작성하세요.         ${cursor}                  // 예시: 입력 받기         // st = new StringTokenizer(br.readLine());                  // 예시: 출력하기         // bw.write(result + \"\\n\");          bw.flush();         bw.close();         br.close();     } }   4. 원하는 이름으로 저장 후 Apply하여 실행해봅니다. 전 BOJ라는 명령어를 입력하고 ctrl + Enter로 실행합니다.   잘 생성됨을 확인 할 수 있습니다.   IntelliJ   1. 먼저 인텔리제이에서 settings…로 들어갑니다  2. Editor &gt; Live Templates &gt; Java를 찾습니다  3. + 를 눌러 원하는 템플릿을 입력해줍니다(자동화시킬)   저의 경우 다음과 같이 매번 작성하기 때문에 다음과 같이 만들어두었습니다. $PACKAGE$는 현재 파일이 있는 디렉토리 이름을 패키지명으로 가져옵니다. $NAME$는 파일 이름에서 .java 확장자를 제외한 이름만 가져옵니다. $END$는 커서를 이 위치로 마무리 설정합니다. 이러한 변수값은 다음과 같이 Edit Variables…에서 커스텀하였습니다.   변수 설정:  $PACKAGE$: groovyScript(\"def pkgName = _editor.getVirtualFile().getParent().getName(); return pkgName\") $NAME$: groovyScript(\"def fileName = _editor.getVirtualFile().getNameWithoutExtension(); return fileName\")   package $PACKAGE$;          /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class $NAME$ {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;      public static void main(String[] args) throws Exception {         new $NAME$().solution();     }      public void solution() throws Exception {         br = new BufferedReader(new InputStreamReader(System.in));         //br = new BufferedReader(new InputStreamReader(new FileInputStream(\"src/main/java/$PACKAGE$/input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));                           $END$                   bw.flush();         bw.close();         br.close();     } }   결과  "
  },
  
  {
    "title": "BOJ_13397_구간 나누기 2 (Java)",
    "url": "/posts/BOJ13397%EA%B5%AC%EA%B0%84-%EB%82%98%EB%88%84%EA%B8%B0-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-19 02:05:08 +0900",
    "content": "[Gold IV] 구간 나누기 2 - 13397  문제 링크  성능 요약  메모리: 14940 KB, 시간: 132 ms  분류  이분 탐색, 매개 변수 탐색  제출 일자  2024년 9월 19일 01:56:49  문제 설명  N개의 수로 이루어진 1차원 배열이 있다. 이 배열을 M개 이하의 구간으로 나누어서 구간의 점수의 최댓값을 최소로 하려고 한다. 구간은 다음과 같은 조건을 만족해야 한다.   \t하나의 구간은 하나 이상의 연속된 수들로 이루어져 있다. \t배열의 각 수는 모두 하나의 구간에 포함되어 있어야 한다.   구간의 점수란 구간에 속한 수의 최댓값과 최솟값의 차이이다.  예를 들어, 배열이 [1, 5, 4, 6, 2, 1, 3, 7] 이고, M = 3인 경우가 있다.  이때, [1, 5], [4, 6, 2], [1, 3, 7]로 구간을 나누면 각 구간의 점수는 4, 4, 6점이 된다. 이때, 최댓값은 6점이다.  만약, [1, 5, 4], [6, 2, 1], [3, 7]로 구간을 나누었다면, 각 구간의 점수는 4, 5, 4점이 되고, 이때 최댓값은 5점이 된다.  두 경우 중에서 최댓값이 최소인 것은 5점인 것이고, 5점보다 최댓값을 작게 만드는 방법은 없다.  배열과 M이 주어졌을 때, 구간의 점수의 최댓값의 최솟값을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 배열의 크기 N과 M이 주어진다. (1 ≤ N ≤ 5,000, 1 ≤ M ≤ N)  둘째 줄에 배열에 들어있는 수가 순서대로 주어진다. 배열에 들어있는 수는 1보다 크거나 같고, 10,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 구간의 점수의 최댓값의 최솟값을 출력한다.     문제 풀이     코드  /**  * Author: nowalex322, Kim HyeonJae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int N, M, arr[], left, right, mid;  \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tarr = new int[N]; \t\tst = new StringTokenizer(br.readLine()); \t\tleft = 0; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tarr[i] = Integer.parseInt(st.nextToken()); \t\t\tright= Math.max(right, arr[i]); \t\t} \t\twhile (left &lt;= right) { \t\t\tmid = left + (right - left) / 2; \t\t\tif (countSection()) { \t\t\t\tright = mid -1; \t\t\t} else { \t\t\t\tleft = mid + 1; \t\t\t} \t\t} \t\tSystem.out.println(left); \t}  \tprivate static boolean countSection() { \t\tint cnt = 1; \t\tint min = 987654321; \t\tint max = -min; \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tmin = Math.min(min, arr[i]); \t\t\tmax = Math.max(max, arr[i]); \t\t\tint gap = max - min; \t\t\tif (gap &gt; mid) { \t\t\t\tcnt++; \t\t\t\ti--; \t\t\t\tmin = 987654321; \t\t\t\tmax = -min; \t\t\t} \t\t} \t\treturn cnt &lt;= M; \t} }  "
  },
  
  {
    "title": "PGMS_오랜 기간 보호한 동물(2) (SQL)",
    "url": "/posts/PGMS%EC%98%A4%EB%9E%9C-%EA%B8%B0%EA%B0%84-%EB%B3%B4%ED%98%B8%ED%95%9C-%EB%8F%99%EB%AC%BC2-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-09-19 00:50:52 +0900",
    "content": "[level 3] 오랜 기간 보호한 동물(2) - 59411  문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; String， Date  채점결과  Empty  제출 일자  2024년 09월 19일 00:49:28  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_OUTCOME VARCHAR(N) FALSE          입양을 간 동물 중, 보호 기간이 가장 길었던 동물 두 마리의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 기간이 긴 순으로 조회해야 합니다.  예시  예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면  ANIMAL_INS           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A354597 Cat 2014-05-02 12:16:00 Normal Ariel Spayed Female   A362707 Dog 2016-01-27 12:27:00 Sick Girly Girl Spayed Female   A370507 Cat 2014-10-27 14:43:00 Normal Emily Spayed Female   A414513 Dog 2016-06-07 09:17:00 Normal Rocky Neutered Male          ANIMAL_OUTS           ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME            A354597 Cat 2014-06-03 12:30:00 Ariel Spayed Female   A362707 Dog 2017-01-10 10:44:00 Girly Girl Spayed Female   A370507 Cat 2015-08-15 09:24:00 Emily Spayed Female          SQL문을 실행하면 다음과 같이 나와야 합니다.           ANIMAL_ID NAME            A362707 Girly Girl   A370507 Emily          ※ 입양을 간 동물이 2마리 이상인 경우만 입력으로 주어집니다.    본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이   간단한 조인 및 날짜 계산 문제다. 두 테이블을 조인해 일치하는 데이터들 중 날짜 차이가 가장 많이나는것을 내림차순으로 2개만 출력하면된다.  코드 SELECT ai.ANIMAL_ID, ai.NAME     FROM ANIMAL_INS as ai         JOIN ANIMAL_OUTS as ao ON ai.ANIMAL_ID = ao.ANIMAL_ID             ORDER BY (ao.DATETIME - ai.DATETIME) DESC                 LIMIT 2;  "
  },
  
  {
    "title": "BOJ_1167_트리의 지름 (Java)",
    "url": "/posts/BOJ1167%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%A7%80%EB%A6%84-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-18 00:59:03 +0900",
    "content": "[Gold II] 트리의 지름 - 1167  문제 링크  성능 요약  메모리: 87836 KB, 시간: 764 ms  분류  깊이 우선 탐색, 그래프 이론, 그래프 탐색, 트리  제출 일자  2024년 9월 18일 00:52:01  문제 설명  트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.  입력  트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.  먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.  출력  첫째 줄에 트리의 지름을 출력한다.     문제 풀이    생각의 전환이 필요했다.  코드 /**  * Author : nowalex322, Kim HyeonJae  */ import java.io.*; import java.util.*;  public class Main { \tstatic class Node{ \t\tint V; \t\tint dist; \t\tpublic Node(int V, int dist) { \t\t\tthis.V = V; \t\t\tthis.dist =  dist; \t\t} \t} \t \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int N, max, node; \tstatic ArrayList&lt;Node&gt;[] list; \tstatic boolean[] visited; \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\t \t\tN = Integer.parseInt(br.readLine()); \t\tlist = new ArrayList[N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tlist[i] = new ArrayList&lt;Node&gt;(); \t\t} \t\tfor(int i=0; i&lt;N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint a = Integer.parseInt(st.nextToken()); \t\t\twhile(true) { \t\t\t\tint b = Integer.parseInt(st.nextToken()); \t\t\t\tif(b == -1) break; \t\t\t\tint value = Integer.parseInt(st.nextToken()); \t\t\t\tlist[a].add(new Node(b, value)); \t\t\t} \t\t} \t\t \t\tvisited = new boolean[N + 1]; \t\tdfs(1, 0); \t\t \t\tvisited = new boolean[N+1]; \t\tdfs(node, 0); \t\t \t\tSystem.out.println(max); \t\t\t\t \t\t \t} \tprivate static void dfs(int v, int l) { \t\tif(l &gt; max) { \t\t\tmax = l; \t\t\tnode = v; \t\t} \t\tvisited[v] = true; \t\tfor(int i=0; i&lt;list[v].size(); i++) { \t\t\tNode n = list[v].get(i); \t\t\tif(!visited[n.V]) { \t\t\t\tdfs(n.V, n.dist + l); \t\t\t\tvisited[n.V] = true; \t\t\t} \t\t} \t} }   "
  },
  
  {
    "title": "BOJ_17386_선분 교차 1 ( Java )",
    "url": "/posts/BOJ17386%EC%84%A0%EB%B6%84-%EA%B5%90%EC%B0%A8-1-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-17 11:04:58 +0900",
    "content": "[Gold III] 선분 교차 1 - 17386  문제 링크  성능 요약  메모리: 14284 KB, 시간: 100 ms  분류  기하학, 선분 교차 판정  제출 일자  2024년 9월 17일 10:58:52  문제 설명  2차원 좌표 평면 위의 두 선분 L1, L2가 주어졌을 때, 두 선분이 교차하는지 아닌지 구해보자.  L1의 양 끝 점은 (x1, y1), (x2, y2), L2의 양 끝 점은 (x3, y3), (x4, y4)이다.  입력  첫째 줄에 L1의 양 끝 점 x1, y1, x2, y2가, 둘째 줄에 L2의 양 끝 점 x3, y3, x4, y4가 주어진다. 세 점이 일직선 위에 있는 경우는 없다.  출력  L1과 L2가 교차하면 1, 아니면 0을 출력한다.     문제 풀이   CCW알고리즘을 이용해 풀었다. CCW 알고리즘이란 두 벡터의 스칼라 곱을 계산하는방법을 응용한 것인데 두 벡터 u, v 의 스칼라 곱 u x v 는 |u||v|sin(theta_) 이다. 이로 인해 두 벡터의 순서에 따라 부호가 정해지고 이를 사용해 4 점을 ccw해보면 x1, y1, x2, y2, x3, y3 곱하기 x1, y1, x2, y2, x4, y4가 음수이면서 (서로 반대방향) x3, y3, x4, y4, x1, y1 곱하기 x3, y3, x4, y4, x2, y2가 음수면 선분이 겹쳐있는 것이고 이 중 하나라도 0이상이면 두 선분이 겹치지 않는다는 뜻이다. 그림으로 그려보면 알 수 있다. 따라서 둘 다 음수 일 때 선분이 겹친하는 의미의 1을 리턴하면 된다.  코드 import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tst = new StringTokenizer(br.readLine()); \t\tint x1 = Integer.parseInt(st.nextToken()); \t\tint y1 = Integer.parseInt(st.nextToken()); \t\tint x2 = Integer.parseInt(st.nextToken()); \t\tint y2 = Integer.parseInt(st.nextToken()); \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tint x3 = Integer.parseInt(st.nextToken()); \t\tint y3 = Integer.parseInt(st.nextToken()); \t\tint x4 = Integer.parseInt(st.nextToken()); \t\tint y4 = Integer.parseInt(st.nextToken()); \t\t \t\tint ans = 0; \t\t \t\tif(ccw(x1, y1, x2, y2, x3, y3) * ccw(x1, y1, x2, y2, x4, y4) &lt; 0 &amp;&amp; ccw(x3, y3, x4, y4, x1, y1) * ccw(x3, y3, x4, y4, x2, y2) &lt; 0) ans = 1;  \t \t\tSystem.out.println(ans); \t} \tprivate static int ccw(long x1, long y1, long x2, long y2, long x3, long y3) { \t\treturn x1*y2+x2*y3+x3*y1 - x2*y1-x3*y2-x1*y3 &lt; 0 ? 1 : -1; \t} }   "
  },
  
  {
    "title": "BOJ_2143_두 배열의 합 (Java)",
    "url": "/posts/BOJ2143%EB%91%90-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%95%A9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-17 00:41:31 +0900",
    "content": "[Gold III] 두 배열의 합 - 2143  문제 링크  성능 요약  메모리: 73020 KB, 시간: 340 ms  분류  이분 탐색, 자료 구조, 해시를 사용한 집합과 맵, 누적 합  제출 일자  2024년 9월 17일 00:35:10  문제 설명  한 배열 A[1], A[2], …, A[n]에 대해서, 부 배열은 A[i], A[i+1], …, A[j-1], A[j] (단, 1 ≤ i ≤ j ≤ n)을 말한다. 이러한 부 배열의 합은 A[i]+…+A[j]를 의미한다. 각 원소가 정수인 두 배열 A[1], …, A[n]과 B[1], …, B[m]이 주어졌을 때, A의 부 배열의 합에 B의 부 배열의 합을 더해서 T가 되는 모든 부 배열 쌍의 개수를 구하는 프로그램을 작성하시오.  예를 들어 A = {1, 3, 1, 2}, B = {1, 3, 2}, T=5인 경우, 부 배열 쌍의 개수는 다음의 7가지 경우가 있다.  T(=5) = A[1] + B[1] + B[2]       = A[1] + A[2] + B[1]       = A[2] + B[3]       = A[2] + A[3] + B[1]       = A[3] + B[1] + B[2]       = A[3] + A[4] + B[3]       = A[4] + B[2]   입력  첫째 줄에 T(-1,000,000,000 ≤ T ≤ 1,000,000,000)가 주어진다. 다음 줄에는 n(1 ≤ n ≤ 1,000)이 주어지고, 그 다음 줄에 n개의 정수로 A[1], …, A[n]이 주어진다. 다음 줄에는 m(1 ≤ m ≤ 1,000)이 주어지고, 그 다음 줄에 m개의 정수로 B[1], …, B[m]이 주어진다. 각각의 배열 원소는 절댓값이 1,000,000을 넘지 않는 정수이다.  출력  첫째 줄에 답을 출력한다. 가능한 경우가 한 가지도 없을 경우에는 0을 출력한다.     문제 풀이   누적합으로 문제를 풀어보았다. 누적합 배열 a, b, 에서 i까지의 값은 1~i까지의 합을 나타낸다. 이후 HashMap 자료구조를 통해 일치 조건을 탐색했다.  Key값으로 합, value값으로 횟수를 넣었다.  특정 구간의 i~j값은 배열에서 arr[j] - arr[i]로 구할 수 있고 이때의 값을 Key로 하여 나오는 횟수를 value로 넣었다. map의 getOrDefault함수는 값이 있으면 그 키 값의 값을 사용, 없으면 0을 사용하는 메서드다. 매우 유용하니 Map자료구조를 사용하면 꼭 사용해보자.  이렇게 한 배열을 순회하였으면 나머지 배열을 순회하며 모든 구간합마다 T-sum를 key값으로 가지는 것이 있으면 그 횟수만큼 더해주는 식으로 풀었다.  코드 import java.io.BufferedReader; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStreamReader; import java.util.HashMap; import java.util.StringTokenizer;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int a[], b[]; \tstatic HashMap&lt;Long, Integer&gt; map; \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\t \t\tint T = Integer.parseInt(br.readLine()); \t\t \t\tint N = Integer.parseInt(br.readLine()); \t\ta = new int[N+1]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\ta[i] = a[i-1] + Integer.parseInt(st.nextToken()); \t\t} \t\t \t\tint M = Integer.parseInt(br.readLine()); \t\tb = new int[M+1]; \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=1; i&lt;=M; i++) { \t\t\tb[i] = b[i-1] + Integer.parseInt(st.nextToken()); \t\t} \t\t \t\tmap = new HashMap&lt;Long, Integer&gt;(); \t\tlong ans = 0; \t\t \t\tfor(int i=0; i&lt;=M; i++) { \t\t\tfor(int j=i+1; j&lt;=M; j++) { \t\t\t\tlong sum = b[j] - b[i]; \t\t\t\tmap.put(sum, map.getOrDefault(sum, 0)+1); \t\t\t} \t\t} \t\t \t\tfor(int i=0; i&lt;=N; i++) { \t\t\tfor(int j=i+1; j&lt;=N; j++) { \t\t\t\tlong sum = a[j] - a[i]; \t\t\t\tans += map.getOrDefault(T-sum, 0); \t\t\t} \t\t} \t\t \t\tSystem.out.println(ans); \t\t \t} }   "
  },
  
  {
    "title": "BOJ_2166_다각형의 면적 (Java)",
    "url": "/posts/BOJ2166%EB%8B%A4%EA%B0%81%ED%98%95%EC%9D%98-%EB%A9%B4%EC%A0%81-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-09 02:12:00 +0900",
    "content": "[Gold V] 다각형의 면적 - 2166  문제 링크  성능 요약  메모리: 19708 KB, 시간: 184 ms  분류  기하학, 다각형의 넓이  제출 일자  2024년 9월 9일 02:08:44  문제 설명  2차원 평면상에 N(3 ≤ N ≤ 10,000)개의 점으로 이루어진 다각형이 있다. 이 다각형의 면적을 구하는 프로그램을 작성하시오.  입력  첫째 줄에 N이 주어진다. 다음 N개의 줄에는 다각형을 이루는 순서대로 N개의 점의 x, y좌표가 주어진다. 좌표값은 절댓값이 100,000을 넘지 않는 정수이다.  출력  첫째 줄에 면적을 출력한다. 면적을 출력할 때에는 소수점 아래 둘째 자리에서 반올림하여 첫째 자리까지 출력한다.     문제 풀이     CCW라는 세 점으로 이루어진 평행사변형 넓이를 벡터외적으로 구하는 방법을 사용했다.  코드 /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N; \tstatic long x[], y[];  \tpublic static void main(String[] args) throws IOException {     \tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken());  \t\tx = new long[N + 1]; \t\ty = new long[N + 1];  \t\tfor (int i = 0; i &lt; N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tx[i] = Integer.parseInt(st.nextToken()); \t\t\ty[i] = Integer.parseInt(st.nextToken());  \t\t} \t\tx[N] = x[0]; \t\ty[N] = y[0];  \t\tdouble ans = 0; \t\tfor(int i=0; i&lt;N; i++){ \t\t\tans += x[i]*y[i+1] - x[i+1]*y[i]; \t\t} \t\tans = Math.abs(ans)/2.0; \t\tSystem.out.println(String.format(\"%.1f\", ans)); \t} }  "
  },
  
  {
    "title": "BOJ_1799_비숍 (Java)",
    "url": "/posts/BOJ1799%EB%B9%84%EC%88%8D-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-09 01:36:09 +0900",
    "content": "[Gold I] 비숍 - 1799  문제 링크  성능 요약  메모리: 18572 KB, 시간: 276 ms  분류  백트래킹  제출 일자  2024년 9월 9일 01:33:43  문제 설명  서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. &lt; 그림 1 &gt;과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.    &lt; 그림 1 &gt;  그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. &lt; 그림 2 &gt;에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 &lt; 그림 3 &gt;과 같이 최대 7개의 비숍을 놓을 수 있다.  색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.    &lt; 그림 2 &gt;    &lt; 그림 3 &gt;  정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.  출력  첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.     문제 풀이   검은 칸과 흰 칸을 나누어 계산 -&gt; 절대 겹치지 않으므로   첫 검은칸 dfs, 첫 흰칸 dfs   이때, 각 칸에서 대각선으로 쭉 진행, 비숍 놓은칸은 2로.  코드 /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main {     public static BufferedReader br;     public static BufferedWriter bw;     public static int N, tmp, ans;     public static int[][] board;     public static int[] dr = {-1, 1, 1, -1};     public static int[] dc = {1, 1, -1, -1};     public static void main(String[] args) throws IOException { //    \tbr = new BufferedReader(new InputStreamReader(System.in));     \tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));     \tbw = new BufferedWriter(new OutputStreamWriter(System.out));     \tN = Integer.parseInt(br.readLine());     \tboard = new int[N][N];     \t     \tfor (int i = 0; i &lt; N; i++) {     \t\tStringTokenizer st = new StringTokenizer(br.readLine());     \t\tfor (int j = 0; j &lt; N; j++) {     \t\t\tboard[i][j] = Integer.parseInt(st.nextToken());     \t\t}     \t}     \t//첫째칸부터(흰칸) DFS         dfs(0, 0);         ans += tmp;                  tmp = 0;         //두번째칸부터(흑칸) DFS         dfs(1, 0);         ans += tmp;                  bw.write(ans + \"\\n\");         bw.flush();         bw.close();         br.close();     }      public static boolean isPuttable(int i, int j) {         for (int k = 0; k &lt; 4; k++) {         \t// 대각선으로 늘어날 길이 n             int n = 1;             while(true) {                 int r = i + n * dr[k];                 int c = j + n * dc[k];                 // 경계조건 밖일때                 if (r &lt; 0 || c &lt; 0 || r &gt;= N || c &gt;= N) break;                                      // 비숍 놓아져 있는경우                 if (board[r][c] == 2) return false;                 n++;             }         }         return true;     }      /**      * 이동할 칸 계산      * 판 길이 홀수x홀수면 2씩증가, 짝수면 흑백 계산해서 증가      * @param i      * @return      */     public static int calNext(int i) {         //크기가 홀 수일 경우 -&gt; 2증가         if (N % 2 == 1) return 2;                  //크기가 짝수일 경우         if (i % N == N-1) return 1;         else if (i % N == N-2) return 3;         else return 2;     }      public static void dfs(int i, int cnt) {         if (i &gt;= N*N) {             tmp = Math.max(tmp, cnt);             return;         }         int c = i % N;         int r = i / N;         int next = calNext(i);          // 둘 수 없는 곳일 경우         if (board[r][c] == 0) {             dfs(i + next, cnt);             return;         }          // 둘 수 있는 곳일 경우         if (isPuttable(r, c)) {             board[r][c] = 2;             dfs(i+next, cnt+1);             board[r][c] = 1;         }         // 그냥 안두는 케이스         dfs(i+next, cnt);     }  }  "
  },
  
  {
    "title": "BOJ_2342_Dance Dance Revolution (Java)",
    "url": "/posts/BOJ2342Dance-Dance-Revolution-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-09 00:52:40 +0900",
    "content": "[Gold III] Dance Dance Revolution - 2342  문제 링크  성능 요약  메모리: 53108 KB, 시간: 408 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 9월 9일 00:50:40  문제 설명  승환이는 요즘 \"Dance Dance Revolution\"이라는 게임에 빠져 살고 있다. 하지만 그의 춤 솜씨를 보면 알 수 있듯이, 그는 DDR을 잘 하지 못한다. 그럼에도 불구하고 그는 살을 뺄 수 있다는 일념으로 DDR을 즐긴다.  DDR은 아래의 그림과 같은 모양의 발판이 있고, 주어진 스텝에 맞춰 나가는 게임이다. 발판은 하나의 중점을 기준으로 위, 아래, 왼쪽, 오른쪽으로 연결되어 있다. 편의상 중점을 0, 위를 1, 왼쪽을 2, 아래를 3, 오른쪽을 4라고 정하자.    처음에 게이머는 두 발을 중앙에 모으고 있다.(그림에서 0의 위치) 그리고 게임이 시작하면, 지시에 따라 왼쪽 또는 오른쪽 발을 움직인다. 하지만 그의 두 발이 동시에 움직이지는 않는다.  이 게임에는 이상한 규칙이 더 있다. 두 발이 같은 지점에 있는 것이 허락되지 않는 것이다. (물론 게임 시작시에는 예외이다) 만약, 한 발이 1의 위치에 있고, 다른 한 발이 3의 위치에 있을 때, 3을 연속으로 눌러야 한다면, 3의 위치에 있는 발로 반복해야 눌러야 한다는 것이다.  오랫동안 DDR을 해 온 백승환은 발이 움직이는 위치에 따라서 드는 힘이 다르다는 것을 알게 되었다. 만약, 중앙에 있던 발이 다른 지점으로 움직일 때, 2의 힘을 사용하게 된다. 그리고 다른 지점에서 인접한 지점으로 움직일 때는 3의 힘을 사용하게 된다. (예를 들면 왼쪽에서 위나 아래로 이동할 때의 이야기이다.) 그리고 반대편으로 움직일때는 4의 힘을 사용하게 된다. (위쪽에서 아래쪽으로, 또는 오른쪽에서 왼쪽으로). 만약 같은 지점을 한번 더 누른다면, 그때는 1의 힘을 사용하게 된다.  만약 1 → 2 → 2 → 4를 눌러야 한다고 가정해 보자. 당신의 두 발은 처음에 (point 0, point 0)에 위치하여 있을 것이다. 그리고 (0, 0) → (0, 1) → (2, 1) → (2, 1) → (2, 4)로 이동하면, 당신은 8의 힘을 사용하게 된다. 다른 방법으로 발을 움직이려고 해도, 당신은 8의 힘보다 더 적게 힘을 사용해서 1 → 2 → 2 → 4를 누를 수는 없을 것이다.  입력  입력은 지시 사항으로 이루어진다. 각각의 지시 사항은 하나의 수열로 이루어진다. 각각의 수열은 1, 2, 3, 4의 숫자들로 이루어지고, 이 숫자들은 각각의 방향을 나타낸다. 그리고 0은 수열의 마지막을 의미한다. 즉, 입력 파일의 마지막에는 0이 입력된다. 입력되는 수열의 길이는 100,000을 넘지 않는다.  출력  한 줄에 모든 지시 사항을 만족하는 데 사용되는 최소의 힘을 출력한다.     문제풀이   왼발과 오른발을 따로 계산해야된다. dp배열을 3차원으로 횟수, 왼발위치, 오른발위치 를 인자로 사용하고 이때의 최솟값을 dp에 저장한다. board는 2차원배열로 i-&gt;j 이동시 드는 힘을 저장할 것이다. 미리 계산하고 static으로 만들어둔다. 충분히 점화식으로 해결 할 수 있는 문제였다.  코드 /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic StringTokenizer st; \tstatic int dp[][][], n=0, cnt=0; \tstatic int board[][] = {{0,2,2,2,2}, \t\t\t\t\t\t\t{2,1,3,4,3}, \t\t\t\t\t\t\t{2,3,1,3,4}, \t\t\t\t\t\t\t{2,4,3,1,3}, \t\t\t\t\t\t\t{2,3,4,3,1}}; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\t \t\tdp = new int[100010][5][5]; \t\tfor(int k=0; k&lt;100010; k++) { \t\t    for(int i=0; i&lt;5; i++) { \t\t    \tfor(int j=0; j&lt;5; j++) { \t\t    \t\tdp[k][i][j] = 987654321; \t\t    \t} \t\t    } \t\t} \t\tdp[0][0][0] = 0; \t\tst = new StringTokenizer(br.readLine()); \t\t         while(st.hasMoreTokens()) {             n = Integer.parseInt(st.nextToken());             if (n == 0) break;                          cnt++;  \t\t\tfor(int i=0; i&lt;5; i++) { \t\t\t\t// 같은곳에 같은발 2개 불가능 \t\t\t\tif(n==i) continue; \t\t\t\tfor(int j=0; j&lt;5; j++) { \t\t\t\t\t// 오른발 옮겨서 현재모습 됐을 때 최소 힘 \t\t\t\t\t// dp[cnt-1][i][j] + board[j][n] : 이전 모든 경우의 수 + j=&gt;n으로 오른발 옮기기 \t\t\t\t\tdp[cnt][i][n] = Math.min(dp[cnt-1][i][j] + board[j][n], dp[cnt][i][n]); \t\t\t\t} \t\t\t} \t\t\t \t\t\tfor(int j=0; j&lt;5; j++) { \t\t\t\t// 같은곳에 같은발 2개 불가능 \t\t\t\tif(n==j) continue; \t\t\t\tfor(int i=0; i&lt;5; i++) { \t\t\t\t\t// 왼발 옮겨서 현재모습 됐을 때 최소 힘 \t\t\t\t\t// dp[cnt-1][i][j] + board[i][n] : 이전 모든 경우의 수 + j=&gt;n으로 왼발 옮기기 \t\t\t\t\tdp[cnt][n][j] = Math.min(dp[cnt-1][i][j] + board[i][n], dp[cnt][n][j]); \t\t\t\t} \t\t\t} \t\t}          \t\tint min = Integer.MAX_VALUE; \t\tfor(int i=0; i&lt;5; i++) { \t\t\tfor(int j=0; j&lt;5; j++) { \t\t\t\tmin = Math.min(min,  dp[cnt][i][j]); \t\t\t} \t\t} \t\tSystem.out.println(min); \t} }  "
  },
  
  {
    "title": "BOJ_9252_LCS 2 (Java)",
    "url": "/posts/BOJ9252LCS-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-08 23:57:51 +0900",
    "content": "[Gold IV] LCS 2 - 9252  문제 링크  성능 요약  메모리: 23060 KB, 시간: 140 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 9월 8일 23:49:15  문제 설명  LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.  예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.  입력  첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.  출력  첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를, 둘째 줄에 LCS를 출력한다.  LCS가 여러 가지인 경우에는 아무거나 출력하고, LCS의 길이가 0인 경우에는 둘째 줄을 출력하지 않는다.  코드 /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic StringTokenizer st; \tstatic long[][] dp; \tstatic char[] str1, str2; \tstatic ArrayList&lt;Character&gt; LCS; \tstatic int N, M, inDegree[]; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\t \t\tstr1 = br.readLine().toCharArray(); \t\tstr2 = br.readLine().toCharArray(); \t\t \t\t \t\tdp = new long[str1.length+1][str2.length+1]; \t\tLCS = new  ArrayList&lt;Character&gt;(); \t\tfor(int i=1; i&lt;str1.length+1; i++) { \t\t\tfor(int j=1; j&lt;str2.length+1; j++) { \t\t\t\tif(str1[i-1] == str2[j-1]) dp[i][j] = dp[i-1][j-1]+1; \t\t\t\telse dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); \t\t\t\t \t\t\t} \t\t} \t\tgetLCS(str1.length, str2.length); \t\t \t\tbw.write((int) dp[str1.length][str2.length] + \"\\n\"); \t\tmakeLCS(); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t\t \t} \t \tprivate static void makeLCS() throws IOException { \t\tfor(int i=LCS.size()-1; i&gt;=0; i--) { \t\t\tbw.write(LCS.get(i)); \t\t} \t}  \t/** \t * LCS 문자열구하기 \t */ \tprivate static void getLCS(int i, int j) { \t\tif(i==0 || j==0) return; \t\tif(str1[i-1]==str2[j-1]) { \t\t\tLCS.add(str1[i-1]); \t\t\tgetLCS(i-1, j-1); \t\t} \t\telse { \t\t\tif(dp[i-1][j] &gt; dp[i][j-1]) getLCS(i-1, j); \t\t\telse getLCS(i, j-1); \t\t} \t} \t \t }  "
  },
  
  {
    "title": "BOJ_2252_줄 세우기(Java)",
    "url": "/posts/BOJ2252%EC%A4%84-%EC%84%B8%EC%9A%B0%EA%B8%B0Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-08 23:21:38 +0900",
    "content": "[Gold III] 줄 세우기 - 2252  문제 링크  성능 요약  메모리: 51328 KB, 시간: 456 ms  분류  방향 비순환 그래프, 그래프 이론, 위상 정렬  제출 일자  2024년 9월 8일 23:19:24  문제 설명  N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.  일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.  입력  첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.  학생들의 번호는 1번부터 N번이다.  출력  첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.  코드 /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic StringTokenizer st; \tstatic ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); \tstatic int N, M, inDegree[]; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\t \t\tfor(int i=0; i&lt;=N; i++) { \t\t\tarr.add(new ArrayList&lt;&gt;()); \t\t} \t\t \t\tinDegree = new int[N+1]; \t\tfor(int i=0; i&lt;M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint front = Integer.parseInt(st.nextToken()); \t\t\tint back = Integer.parseInt(st.nextToken()); \t\t\tarr.get(front).add(back); \t\t\tinDegree[back]++; \t\t\t \t\t} \t\tQueue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;(); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tif(inDegree[i]==0) queue.add(i); \t\t} \t\t \t\twhile(!queue.isEmpty()) { \t\t\tint curr = queue.poll(); \t\t\tbw.write(curr + \" \"); \t\t\tfor(int next : arr.get(curr)) { \t\t\t\tinDegree[next]--; \t\t\t\tif(inDegree[next]==0) queue.add(next); \t\t\t} \t\t} \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }  "
  },
  
  {
    "title": "Windows 환경변수 설정시 재부팅 하지 않기",
    "url": "/posts/Windows-%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%84%A4%EC%A0%95%EC%8B%9C-%EC%9E%AC%EB%B6%80%ED%8C%85-%ED%95%98%EC%A7%80-%EC%95%8A%EA%B8%B0/",
    "categories": "오류, 해결",
    "tags": "settings, 환경설정",
    "date": "2024-09-08 22:04:29 +0900",
    "content": "개발자로서 컴퓨터 환경 세팅시 환경변수를 설정하는 것은 프로그램을 설치하면 거의 필수적이다. 이때 실행파일이 아닌 시스템 관련 설정이라면 재부팅을 해야 적용이 되는데 이를 명령 프롬프트창을 통해 재부팅을 건너뛸 수 있다.  먼저 환경 변수를 설정한다 환경변수 설정 Windows + X -&gt; 시스템 -&gt; 고급 시스템 설정에서 환경변수를 설정한다. 보통 Path를 편집해 디렉토리를 복사 붙여넣기 할 것이다.  이후 해당 파일을 설치했는지 확인하거나 버전을 확인해보면 나오지 않을 것이다.  1. 커맨드 화면 호출 Windows + R -&gt; cmd 입력  2. 명령어 실행  taskkill /f /im explorer.exe   해당 명령어를 입력한다. 그러면 윈도우 배경이 사라질 것이다. 이때 다시  explorer.exe  명령어를 입력해 다시 실행해주면 재부팅 없이 환경변수가 적용된다.  "
  },
  
  {
    "title": "BOJ_1766_문제집 (Java)",
    "url": "/posts/BOJ1766%EB%AC%B8%EC%A0%9C%EC%A7%91-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-05 00:37:36 +0900",
    "content": "[Gold II] 문제집 - 1766  문제 링크  성능 요약  메모리: 49020 KB, 시간: 488 ms  분류  방향 비순환 그래프, 자료 구조, 그래프 이론, 우선순위 큐, 위상 정렬  제출 일자  2024년 9월 5일 00:35:03  문제 설명  민오는 1번부터 N번까지 총 N개의 문제로 되어 있는 문제집을 풀려고 한다. 문제는 난이도 순서로 출제되어 있다. 즉 1번 문제가 가장 쉬운 문제이고 N번 문제가 가장 어려운 문제가 된다.  어떤 문제부터 풀까 고민하면서 문제를 훑어보던 민오는, 몇몇 문제들 사이에는 '먼저 푸는 것이 좋은 문제'가 있다는 것을 알게 되었다. 예를 들어 1번 문제를 풀고 나면 4번 문제가 쉽게 풀린다거나 하는 식이다. 민오는 다음의 세 가지 조건에 따라 문제를 풀 순서를 정하기로 하였다.   \tN개의 문제는 모두 풀어야 한다. \t먼저 푸는 것이 좋은 문제가 있는 문제는, 먼저 푸는 것이 좋은 문제를 반드시 먼저 풀어야 한다. \t가능하면 쉬운 문제부터 풀어야 한다.   예를 들어서 네 개의 문제가 있다고 하자. 4번 문제는 2번 문제보다 먼저 푸는 것이 좋고, 3번 문제는 1번 문제보다 먼저 푸는 것이 좋다고 하자. 만일 4-3-2-1의 순서로 문제를 풀게 되면 조건 1과 조건 2를 만족한다. 하지만 조건 3을 만족하지 않는다. 4보다 3을 충분히 먼저 풀 수 있기 때문이다. 따라서 조건 3을 만족하는 문제를 풀 순서는 3-1-4-2가 된다.  문제의 개수와 먼저 푸는 것이 좋은 문제에 대한 정보가 주어졌을 때, 주어진 조건을 만족하면서 민오가 풀 문제의 순서를 결정해 주는 프로그램을 작성하시오.  입력  첫째 줄에 문제의 수 N(1 ≤ N ≤ 32,000)과 먼저 푸는 것이 좋은 문제에 대한 정보의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 둘째 줄부터 M개의 줄에 걸쳐 두 정수의 순서쌍 A,B가 빈칸을 사이에 두고 주어진다. 이는 A번 문제는 B번 문제보다 먼저 푸는 것이 좋다는 의미이다.  항상 문제를 모두 풀 수 있는 경우만 입력으로 주어진다.  출력  첫째 줄에 문제 번호를 나타내는 1 이상 N 이하의 정수들을 민오가 풀어야 하는 순서대로 빈칸을 사이에 두고 출력한다.     문제 풀이   선행 문제가 필요한 문제들을 진입차수 1 증가시키면서 dfs로 차례대로 풀면서 진입차수 0인 문제 우선순위큐에 넣고 연결된 하위문제 진입차수 낮추기  코드 /**  * Author : nowalex322, Kim Hyeonjae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic StringBuilder sb; \tstatic int N, M, degree[]; \tstatic List&lt;Integer&gt;[] list; \tpublic static void main(String[] args) throws IOException { \t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //\t\tBufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tStringTokenizer st = new StringTokenizer(br.readLine()); \t\tsb = new StringBuilder(); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tlist = new ArrayList[N+1]; \t\tdegree = new int[N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tlist[i] = new ArrayList&lt;Integer&gt;(); \t\t} \t\tfor(int i=0; i&lt;M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint A = Integer.parseInt(st.nextToken()); \t\t\tint B = Integer.parseInt(st.nextToken()); \t\t\tlist[A].add(B); \t\t\tdegree[B]++; \t\t} \t\tsolve(); \t\tSystem.out.println(sb.toString()); \t\t \t} \tprivate static void solve() { \t\tPriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;(); \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tif(degree[i] == 0) pq.add(i); \t\t} \t\t \t\twhile(!pq.isEmpty()) { \t\t\tint curr = pq.poll(); \t\t\tsolveProblem(curr); \t\t\tsb.append(curr + \" \"); \t\t\t \t\t\tfor(int next : list[curr]) { \t\t\t\tif(degree[next]==0) pq.add(next); \t\t\t} \t\t} \t} \tprivate static void solveProblem(int curr) { \t\tfor(int n : list[curr]) degree[n]--; \t} }  "
  },
  
  {
    "title": "BOJ_1644_소수의 연속합",
    "url": "/posts/BOJ1644%EC%86%8C%EC%88%98%EC%9D%98-%EC%97%B0%EC%86%8D%ED%95%A9/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-04 13:21:00 +0900",
    "content": "[Gold III] 소수의 연속합 - 1644  문제 링크  성능 요약  메모리: 27052 KB, 시간: 204 ms  분류  수학, 정수론, 소수 판정, 에라토스테네스의 체, 두 포인터  제출 일자  2024년 9월 4일 13:17:35  문제 설명  하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.   \t3 : 3 (한 가지) \t41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지) \t53 : 5+7+11+13+17 = 53 (두 가지)   하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.  자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)  출력  첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.  코드  /**  * Author : nowalex322, Kim hyeonjae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic int N, num[], cnt; \tstatic List&lt;Integer&gt; primeNum = new ArrayList&lt;Integer&gt;();  \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));  \t\tN = Integer.parseInt(br.readLine()); \t\tif (N == 1) { \t\t\tSystem.out.println(0); \t\t\treturn; \t\t} \t\tif (N == 2) { \t\t\tSystem.out.println(1); \t\t\treturn; \t\t} \t\tmakePrimeNum();  \t\tcnt = 0; \t\tint left = 0, right = 0, sum = primeNum.get(left);  \t\twhile (right &lt; primeNum.size() &amp;&amp; left &lt; primeNum.size() &amp;&amp; left &lt;= right) { \t\t\tif(left == primeNum.size()-1 &amp;&amp; right == primeNum.size()-1){ \t\t\t\tsum = primeNum.get(right); \t\t\t\tbreak; \t\t\t} \t\t\tif (sum &gt;= N &amp;&amp; left &lt; right) { \t\t\t\tsum -= primeNum.get(left++); \t\t\t} else { \t\t\t\tif (right &lt; primeNum.size()-1) { \t\t\t\t\tsum += primeNum.get(++right); \t\t\t\t} \t\t\t}  \t\t\tif (sum == N) { \t\t\t\tcnt++; \t\t\t} \t\t}  \t\tSystem.out.println(cnt); \t}  \tprivate static void makePrimeNum() { \t\tboolean[] isPrime = new boolean[N + 1]; \t\tArrays.fill(isPrime, true); \t\tisPrime[0] = isPrime[1] = false;  \t\tfor (int i = 2; i * i &lt;= N; i++) { \t\t\tif (isPrime[i]) { \t\t\t\tfor (int j = i * i; j &lt;= N; j += i) { \t\t\t\t\tisPrime[j] = false; \t\t\t\t} \t\t\t} \t\t}  \t\tfor (int i = 2; i &lt;= N; i++) { \t\t\tif (isPrime[i]) { \t\t\t\tprimeNum.add(i); \t\t\t} \t\t} \t} }  "
  },
  
  {
    "title": "BOJ_2239_스도쿠(Java)",
    "url": "/posts/BOJ2239%EC%8A%A4%EB%8F%84%EC%BF%A0Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-04 04:03:25 +0900",
    "content": "[Gold IV] 스도쿠 - 2239  문제 링크  성능 요약  메모리: 16872 KB, 시간: 336 ms  분류  백트래킹, 구현  제출 일자  2024년 9월 4일 03:56:00  문제 설명  스도쿠는 매우 간단한 숫자 퍼즐이다. 9×9 크기의 보드가 있을 때, 각 행과 각 열, 그리고 9개의 3×3 크기의 보드에 1부터 9까지의 숫자가 중복 없이 나타나도록 보드를 채우면 된다. 예를 들어 다음을 보자.    위 그림은 참 잘도 스도쿠 퍼즐을 푼 경우이다. 각 행에 1부터 9까지의 숫자가 중복 없이 나오고, 각 열에 1부터 9까지의 숫자가 중복 없이 나오고, 각 3×3짜리 사각형(9개이며, 위에서 색깔로 표시되었다)에 1부터 9까지의 숫자가 중복 없이 나오기 때문이다.  하다 만 스도쿠 퍼즐이 주어졌을 때, 마저 끝내는 프로그램을 작성하시오.  입력  9개의 줄에 9개의 숫자로 보드가 입력된다. 아직 숫자가 채워지지 않은 칸에는 0이 주어진다.  출력  9개의 줄에 9개의 숫자로 답을 출력한다. 답이 여러 개 있다면 그 중 사전식으로 앞서는 것을 출력한다. 즉, 81자리의 수가 제일 작은 경우를 출력한다.     문제 풀이   비트마스킹으로 세로, 가로, 3x3 격자를 체크한다. 재귀적으로 진행하며 조건 만족시 체크 및 재귀호출 후 다시 되돌리는 백트래킹 작업 필요.  코드 /**  * Author : nowalex322, Kim hyeonjae  */  import java.io.*; import java.util.*;  /**  * 비트마스킹 연습  */ public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringBuilder sb = new StringBuilder(); \tstatic int map[][], checkRow[], checkCol[], check3by3[][];     static List&lt;int[]&gt; listToSolve = new ArrayList&lt;&gt;();     private static boolean solved = false;     public static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         map = new int[10][10];         checkRow = new int[10];         checkCol = new int[10];         check3by3 = new int[4][4];          for (int i=1; i&lt;=9; i++) {             String s = br.readLine();             for (int j=1; j&lt;=9; j++) {                 int num = s.charAt(j-1) - '0';                 checkRow[i] |= 1 &lt;&lt; num;                 checkCol[j] |= 1 &lt;&lt; num;                 check3by3[((i-1)/3)+1][((j-1)/3)+1] |= 1 &lt;&lt; num;                 map[i][j] = num;                 if (num == 0) {                 \tlistToSolve.add(new int[]{i, j});                 }             }         }          sudoku(0);          br.close();         bw.write(sb.toString());         bw.flush();         bw.close();     }      private static void sudoku(int idx) {         if (solved) return;                  if (idx == (listToSolve.size())) {             for (int i=1; i&lt;=9; i++) {                 for (int j=1; j&lt;=9; j++) {                     sb.append(map[i][j]);                 }                 sb.append(\"\\n\");             }             solved = true;             return;         }          int[] zero = listToSolve.get(idx);         int r = zero[0];         int c = zero[1];         for (int i=1; i&lt;=9; i++) {             if (((checkRow[r] &amp; 1&lt;&lt;i) == 0) &amp;&amp; ((checkCol[c] &amp; 1&lt;&lt;i) == 0) &amp;&amp; ((check3by3[((r-1)/3)+1][((c-1)/3)+1] &amp; 1&lt;&lt;i) == 0)) {                 map[r][c] = i;                 checkRow[r] |= 1 &lt;&lt; i;                 checkCol[c] |= 1 &lt;&lt; i;                 check3by3[((r - 1) / 3) + 1][((c - 1) / 3) + 1] |= 1 &lt;&lt; i;                 sudoku(idx + 1);                                  map[r][c] = 0;                 checkRow[r] &amp;= ~(1 &lt;&lt; i);                 checkCol[c] &amp;= ~(1 &lt;&lt; i);                 check3by3[((r - 1) / 3) + 1][((c - 1) / 3) + 1] &amp;= ~(1 &lt;&lt; i);             }         }     } }  "
  },
  
  {
    "title": "BOJ_1700_멀티탭 스케줄링(Java)",
    "url": "/posts/BOJ1700%EB%A9%80%ED%8B%B0%ED%83%AD-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-04 02:28:43 +0900",
    "content": "[Gold I] 멀티탭 스케줄링 - 1700  문제 링크  성능 요약  메모리: 14164 KB, 시간: 100 ms  분류  그리디 알고리즘  제출 일자  2024년 9월 4일 02:20:56  문제 설명  기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다. 준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을 사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다. 그래서 준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고, 이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.  예를 들어 3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면,    \t키보드 \t헤어드라이기 \t핸드폰 충전기 \t디지털 카메라 충전기 \t키보드 \t헤어드라이기   키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음 디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다.   입력  첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 100)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 100)가 정수로 주어진다. 두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다.   출력  하나씩 플러그를 빼는 최소의 횟수를 출력하시오.      문제풀이     코드 /**  * Author : nowalex322, Kim Hyeonjae  */ import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic Queue&lt;Integer&gt; queue; \tstatic Set&lt;Integer&gt; plugged;\t \tstatic StringTokenizer st; \tstatic int n, k, originarr[], arr[], next[];     public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         st = new StringTokenizer(br.readLine());                  n = Integer.parseInt(st.nextToken());         k = Integer.parseInt(st.nextToken());                  originarr = new int[k];         arr = new int[k];         st = new StringTokenizer(br.readLine());         for (int i = 0; i &lt; k; i++) {         \tint num = Integer.parseInt(st.nextToken());             arr[i] = num;         }                  System.out.println(solve());                  br.close();     }      public static int solve(){     \t         plugged = new HashSet&lt;&gt;();         next = new int[k + 1];         // arr : 해당 인덱스 전기용품의 다음 사용 시점 인덱스 계산 (ex i번째 인덱스의 다음 사용 시점은 j인덱스 - 같은 제품일 것임)         // next : 각 전기용품 다음 사용 시점 저장 ( k번 제품이 l인덱스 일 때 사용됩니다, arr 사용해서 계속 업데이트됨)                  int count = 0;          for (int i = 0; i &lt; k; i++) { //        \tSystem.out.println(Arrays.toString(next));             if (!plugged.contains(arr[i])) {                 if (plugged.size() == n) {                     int unplug = unplug(i);                     plugged.remove(unplug);                     count++; //                    System.out.println(\"뽑기이벤트: \" + unplug + \" 뽑기\");                 }                 plugged.add(arr[i]);             }             updateNext(i);;         }          return count;     }      private static int unplug(int idx) {     \tint furthest = -987654321;         int unplug = 0;         for (int p : plugged) {         \tint next = findNext(p,idx);         \t// plugged중 다음 사용시점이 제일 먼 용품 뽑을거기 때문에             if (next &gt; furthest) {             \tfurthest = next;                 unplug = p;             }         }         return unplug;     }          private static int findNext(int p, int curr) {         for (int i = curr + 1; i &lt; k; i++) {             if (arr[i] == p) {                 return i;             }         }         return k;     }          private static void updateNext(int currentIndex) {         for (int i = currentIndex; i &lt; k; i++) {             if (next[arr[i]] &lt;= currentIndex) {                 next[arr[i]] = i;             }         }     } }  "
  },
  
  {
    "title": "BOJ_9084_동전(Java)",
    "url": "/posts/BOJ9084%EB%8F%99%EC%A0%84Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-04 00:00:00 +0900",
    "content": "[Gold V] 동전 - 9084  문제 링크  성능 요약  메모리: 15268 KB, 시간: 112 ms  분류  다이나믹 프로그래밍, 배낭 문제  제출 일자  2024년 9월 4일 03:03:05  문제 설명  우리나라 화폐단위, 특히 동전에는 1원, 5원, 10원, 50원, 100원, 500원이 있다. 이 동전들로는 정수의 금액을 만들 수 있으며 그 방법도 여러 가지가 있을 수 있다. 예를 들어, 30원을 만들기 위해서는 1원짜리 30개 또는 10원짜리 2개와 5원짜리 2개 등의 방법이 가능하다.  동전의 종류가 주어질 때에 주어진 금액을 만드는 모든 방법을 세는 프로그램을 작성하시오.  입력  입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 동전의 가지 수 N(1 ≤ N ≤ 20)이 주어지고 두 번째 줄에는 N가지 동전의 각 금액이 오름차순으로 정렬되어 주어진다. 각 금액은 정수로서 1원부터 10000원까지 있을 수 있으며 공백으로 구분된다. 세 번째 줄에는 주어진 N가지 동전으로 만들어야 할 금액 M(1 ≤ M ≤ 10000)이 주어진다.  편의를 위해 방법의 수는 231 - 1 보다 작고, 같은 동전이 여러 번 주어지는 경우는 없다.  출력  각 테스트 케이스에 대해 입력으로 주어지는 N가지 동전으로 금액 M을 만드는 모든 방법의 수를 한 줄에 하나씩 출력한다.  코드 import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static StringTokenizer st;     static StringBuilder sb = new StringBuilder();     static int N, T, M, coin[], dp[][];     public static void main(String[] args) throws IOException { //    \tbr = new BufferedReader(new InputStreamReader(System.in));     \tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         st = new StringTokenizer(br.readLine());         T = Integer.parseInt(st.nextToken());         while(T--&gt;0){             N = Integer.parseInt(br.readLine());             coin = new int[N];             st = new StringTokenizer(br.readLine());             for (int i = 0; i &lt; N; i++) {                 coin[i] = Integer.parseInt(st.nextToken());             }             M = Integer.parseInt(br.readLine());             dp = new int[N][M + 1];                          for(int i = 1; i &lt; coin.length;i++){                 dp[i][0] = 1;             }                          for (int i = 0; i &lt; N; i++) {                 dp[i][0] = 1;                 for (int j = 1; j &lt;= M; j++) {                     if (i &gt; 0) dp[i][j] = dp[i - 1][j];                     if (j-coin[i] &gt;= 0) dp[i][j] += dp[i][j - coin[i]];                 }             }             System.out.println(dp[N-1][M]); //            for (int[] arr : dp) { //                System.out.println(Arrays.toString(arr)); //            }         }      }  }  "
  },
  
  {
    "title": "PGMS_대장균의 크기에 따라 분류하기 1 (SQL)",
    "url": "/posts/PGMS%EB%8C%80%EC%9E%A5%EA%B7%A0%EC%9D%98-%ED%81%AC%EA%B8%B0%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%B6%84%EB%A5%98%ED%95%98%EA%B8%B0-1-SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-09-02 16:06:50 +0900",
    "content": "[level 3] 대장균의 크기에 따라 분류하기 1 - 299307  문제 링크  성능 요약  메모리: undefined, 시간:  구분  코딩테스트 연습 &gt; SELECT  채점결과  합계: 100.0 / 100.0  제출 일자  2024년 09월 02일 16:02:20  문제 설명  대장균들은 일정 주기로 분화하며, 분화를 시작한 개체를 부모 개체, 분화가 되어 나온 개체를 자식 개체라고 합니다. 다음은 실험실에서 배양한 대장균들의 정보를 담은 ECOLI_DATA 테이블입니다. ECOLI_DATA 테이블의 구조는 다음과 같으며,  ID, PARENT_ID, SIZE_OF_COLONY, DIFFERENTIATION_DATE, GENOTYPE 은 각각 대장균 개체의 ID, 부모 개체의 ID, 개체의 크기, 분화되어 나온 날짜, 개체의 형질을 나타냅니다.           Column name Type Nullable            ID INTEGER FALSE   PARENT_ID INTEGER TRUE   SIZE_OF_COLONY INTEGER FALSE   DIFFERENTIATION_DATE DATE FALSE   GENOTYPE INTEGER FALSE          최초의 대장균 개체의 PARENT_ID 는 NULL 값입니다.    문제  대장균 개체의 크기가 100 이하라면 'LOW', 100 초과 1000 이하라면 'MEDIUM', 1000 초과라면 'HIGH' 라고 분류합니다. 대장균 개체의 ID(ID) 와 분류(SIZE)를 출력하는 SQL 문을 작성해주세요.이때 결과는 개체의 ID 에 대해 오름차순 정렬해주세요.    예시  예를 들어 ECOLI_DATA 테이블이 다음과 같다면           ID PARENT_ID SIZE_OF_COLONY DIFFERENTIATION_DATE GENOTYPE            1 NULL 17 2019/01/01 5   2 NULL 150 2019/01/01 3   3 1 4000 2020/01/01 4          대장균 개체 ID(ID) 1,2,3 에 대해 개체의 크기는 각각 17, 150, 4000 이므로 분류된 이름은 각각 'LOW', 'MEDIUM', 'HIGH' 입니다. 따라서 결과를 개체의 ID 에 대해 오름차순 정렬하면 다음과 같아야 합니다.           ID SIZE            1 LOW   2 MEDIUM   3 HIGH              출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges   코드 SELECT ed.ID AS ID,     CASE // CASE문은 select안에 작성         WHEN ed.SIZE_OF_COLONY &lt;= 100 THEN 'LOW'         WHEN ed.SIZE_OF_COLONY &gt;100 AND SIZE_OF_COLONY &lt;= 1000 THEN 'MEDIUM'         WHEN ed.SIZE_OF_COLONY &gt; 1000 THEN 'HIGH'     END AS SIZE // 별칭 지어줘야함 테이블에 SIZE라 되어있음         FROM ECOLI_DATA AS ed             ORDER BY ID ASC;   "
  },
  
  {
    "title": "BOJ_1562_계단수(Java)",
    "url": "/posts/BOJ1562%EA%B3%84%EB%8B%A8%EC%88%98Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-02 15:40:29 +0900",
    "content": "[Gold I] 계단 수 - 1562  문제 링크  성능 요약  메모리: 19936 KB, 시간: 144 ms  분류  비트마스킹, 다이나믹 프로그래밍, 비트필드를 이용한 다이나믹 프로그래밍  제출 일자  2024년 9월 2일 15:34:15  문제 설명  45656이란 수를 보자.  이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.  N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.  입력  첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.  출력  첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.     문제 풀이     코드  /**  * Author : nowalex322, Kim Hyeonjae  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic final long MOD = (long) 1e9;  \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tint len = Integer.parseInt(br.readLine());  \t\t/** \t\t * dp에 필요한 저장값 : 끝 숫자, 길이, 방문처리 비트마스킹 \t\t */ \t\tint dp[][][] = new int[10][len + 1][1 &lt;&lt; 10];  \t\tfor (int i = 0; i &lt;= 9; i++) { \t\t\tdp[i][1][1 &lt;&lt; i] = 1; \t\t}  \t\t// 우선순위 : 숫자 길이 -&gt; 숫자 -&gt; 방문처리 체크\t\t \t\tfor (int j = 2; j &lt;= len; j++) { \t\t\tfor (int i = 0; i &lt;= 9; i++) { \t\t\t\tfor (int k = 0; k &lt; (1 &lt;&lt; 10); k++) { \t\t\t\t\tint visited = k | (1 &lt;&lt; i); \t\t\t\t\t \t\t\t\t\tif (i == 0) dp[i][j][visited] += dp[1][j - 1][k] % MOD; \t\t\t\t\telse if (i == 9) dp[i][j][visited] += dp[8][j - 1][k] % MOD; \t\t\t\t\telse dp[i][j][visited] += (dp[i - 1][j - 1][k] % MOD + dp[i + 1][j - 1][k] % MOD); \t\t\t\t\t \t\t\t\t\tdp[i][j][visited] %= MOD; \t\t\t\t} \t\t\t} \t\t} \t\t \t\tlong ans = 0; \t\tfor (int i = 1; i &lt;= 9; i++) { \t\t\tans += dp[i][len][(1 &lt;&lt; 10) - 1];// 여기 %MOD넣으면 1e9넘는 값 더할때 이상하게 더해져서 long으로 큰 값 더해놓고 마무리로 나머지 구하기 \t\t} \t\tSystem.out.println(ans % MOD); \t} }  "
  },
  
  {
    "title": "BOJ_1509_팰린드롬 분할(Java)",
    "url": "/posts/BOJ1509%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC-%EB%B6%84%ED%95%A0Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-02 13:27:50 +0900",
    "content": "[Gold I] 팰린드롬 분할 - 1509  문제 링크  성능 요약  메모리: 46856 KB, 시간: 188 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 9월 2일 13:18:03  문제 설명  세준이는 어떤 문자열을 팰린드롬으로 분할하려고 한다. 예를 들어, ABACABA를 팰린드롬으로 분할하면, {A, B, A, C, A, B, A}, {A, BACAB, A}, {ABA, C, ABA}, {ABACABA}등이 있다.  분할의 개수의 최솟값을 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 문자열이 주어진다. 이 문자열은 알파벳 대문자로만 이루어져 있고, 최대 길이는 2,500이다.  출력  첫째 줄에 팰린드롬 분할의 개수의 최솟값을 출력한다.     문제풀이     코드 /**  * Author : nowalex322, Kim HyeonJae( KR )  */  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tpublic static void main(String[] args) throws IOException { \t\tbr = new  BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\t \t\tString str = br.readLine(); \t\tint len = str.length(); \t\tchar[] arr = str.toCharArray(); \t\t         boolean[][] isPalindrome = new boolean[len][len]; \t\tint[][] dp = new int[len][len]; \t\t         for (int i = 0; i &lt; len; i++) {             isPalindrome[i][i] = true;             if (i &gt;0 &amp;&amp; arr[i-1] == arr[i]) isPalindrome[i-1][i] = true;         }         for(int i=3; i&lt;=len; i++) {         \tfor(int start=0; start&lt;=len-i; start++) {         \t\tint end = start+i-1; // 끝 인덱스         \t\tif(arr[start] == arr[end] &amp;&amp; isPalindrome[start+1][end-1]) isPalindrome[start][end] = true;         \t}         } \t\t \t\tfor(int i=0; i&lt;len; i++) { \t\t\tif(isPalindrome[0][i]) dp[0][i] = 1; \t\t\telse { \t\t\t\tdp[0][i] = i+1; // 최악의 경우로 세팅 \t\t\t\tfor(int j=0; j&lt;i; j++) { \t\t\t\t\tif(isPalindrome[j+1][i]) dp[0][i] = Math.min(dp[0][i],  dp[0][j] + 1); \t\t\t\t} \t\t\t} \t\t} //\t\tfor(int i=0; i&lt;len; i++) { //\t\t\tfor(int j=0; j&lt;len; j++) { //\t\t\t\tSystem.out.print(dp[i][j] + \" \"); //\t\t\t} //\t\t\tSystem.out.println(); //\t\t} \t\tSystem.out.println(dp[0][len-1]); \t} }  "
  },
  
  {
    "title": "BOJ_1005_ACM Craft(Java)",
    "url": "/posts/BOJ1005ACM-Craft/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-09-02 13:22:21 +0900",
    "content": "[Gold III] ACM Craft - 1005  문제 링크  성능 요약  메모리: 242104 KB, 시간: 700 ms  분류  방향 비순환 그래프, 다이나믹 프로그래밍, 그래프 이론, 위상 정렬  제출 일자  2024년 8월 30일 01:08:43  문제 설명  서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.  이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.       위의 예시를 보자.  이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할수 있다. (동시에 진행이 가능하다) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번건물의 건설을 시작할수 있다.  따라서 4번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.  프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.  입력  첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다)   둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, ..., DN이 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다)   마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.  출력  건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.  건설순서는 모든 건물이 건설 가능하도록 주어진다.     문제풀이     코드 import java.io.*; import java.util.*;  public class Main { \t \tpublic static class Node{ \t\tint start; \t\tList&lt;Integer&gt; end; \t\tint value; \t\tint totalV; \t\tint intoNum; // 진입차수 \t\t \t\tNode(int start, int value){ \t\t\tthis.start = start; \t\t\tthis.end = new ArrayList&lt;&gt;(); \t\t\tthis.value = value; \t\t\tthis.totalV = value; \t\t\tthis.intoNum = 0; \t\t} \t} \t \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int T, N, K, X, Y, W; \tstatic Node[] nodes; \tpublic static void main(String[] args) throws IOException{ \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tT = Integer.parseInt(br.readLine()); \t\t \t\tfor(int tc = 0; tc&lt;T; tc++) {  \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tN = Integer.parseInt(st.nextToken()); \t\t\tK = Integer.parseInt(st.nextToken()); \t\t\tnodes = new Node[N+1]; \t\t\t \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int i=1; i&lt;=N; i++) { \t\t\t\tint v = Integer.parseInt(st.nextToken()); \t\t\t\tnodes[i] = new Node(i, v); \t\t\t} \t\t\t \t\t\tfor(int i=0; i&lt;K; i++) {                 st = new StringTokenizer(br.readLine());                 X = Integer.parseInt(st.nextToken());                 Y = Integer.parseInt(st.nextToken());                  \t\t\t\tnodes[X].end.add(Y); \t\t\t\tnodes[Y].intoNum++; \t\t\t}             W = Integer.parseInt(br.readLine());  \t\t\tQueue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); \t\t\tfor(int i=1; i&lt;=N; i++) { \t\t\t\tif(nodes[i].intoNum == 0) queue.add(nodes[i]); \t\t\t} \t\t\t \t\t\twhile(!queue.isEmpty()) { \t\t\t\tNode current = queue.poll(); \t\t\t\tfor(int next : current.end) { \t\t\t\t\tnodes[next].totalV = Math.max(nodes[next].totalV, current.totalV + nodes[next].value); \t\t\t\t\tif(--nodes[next].intoNum == 0) queue.add(nodes[next]); \t\t\t\t} \t\t\t} \t\t\tSystem.out.println(nodes[W].totalV);\t\t \t\t} \t} }  "
  },
  
  {
    "title": "Codeforces Round 970 (Div. 3) Reviews",
    "url": "/posts/Codeforces-Round-970-Div.-3-Reviews/",
    "categories": "Code, Contests",
    "tags": "Java, codeforces, 알고리즘",
    "date": "2024-09-02 04:03:02 +0900",
    "content": "Problem A      Submission      Code  /**  * Author : nowalex322, KimHyeonJae  */ import java.io.*; import java.util.*;  public class SakurakoExam {     static BufferedReader br;     static StringTokenizer st;      public static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));          int t = Integer.parseInt(br.readLine());          for (int i = 0; i &lt; t; i++) {             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());              if (makeZero(a, b)) {                 System.out.println(\"YES\");             } else {                 System.out.println(\"NO\");             }         }          br.close();     }      public static boolean makeZero(int a, int b) {         for (int i = -a; i &lt;= a; i += 2) {             for (int j = -2*b; j &lt;= 2*b; j += 4) {                 if (i + j == 0) {                     return true;                 }             }         }         return false;     } }   Problem B      Submission      Code /**  * Author : nowalex322, KimHyeonJae  */ import java.io.*; import java.util.*;  public class SquareOrNot {     static BufferedReader br;     static StringTokenizer st;      public static void main(String[] args) throws IOException {         // br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));                  int t = Integer.parseInt(br.readLine());         StringBuilder sb = new StringBuilder();          for (int i = 0; i &lt; t; i++) {             int n = Integer.parseInt(br.readLine());             String s = br.readLine();             sb.append(squareOrNot(n, s) ? \"Yes\\n\" : \"No\\n\");         }          System.out.print(sb);         br.close();     }      private static boolean squareOrNot(int n, String s) {         int sqrtN = (int) Math.sqrt(n);                  // 제곱수 먼저 확인         if (sqrtN * sqrtN != n) return false;          // 가로 모서리 확인         for (int i = 0; i &lt; sqrtN; i++) {             if (s.charAt(i) != '1' || s.charAt(n - sqrtN + i) != '1') return false;         }                  // 세로 모서리 확인         for (int i = 0; i &lt; sqrtN; i++) {             if (s.charAt(i * sqrtN) != '1' || s.charAt((i + 1) * sqrtN - 1) != '1') {                 return false;             }         }          // 내부 0 확인         if (sqrtN &gt; 2) {             for (int i = 1; i &lt; sqrtN - 1; i++) {                 for (int j = 1; j &lt; sqrtN - 1; j++) {                     if (s.charAt(i * sqrtN + j) != '0') {                         return false;                     }                 }             }         }          return true;     } }   Problem C      Submission      Code /**  * Author : nowalex322, KimHyeonJae  */ import java.io.*; import java.util.*;  public class LongestGoodArray {     static BufferedReader br;     static StringTokenizer st;      public static void main(String[] args) throws IOException {         // br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));          int t = Integer.parseInt(br.readLine());         StringBuilder sb = new StringBuilder();                  for (int i = 0; i &lt; t; i++) {             String[] input = br.readLine().split(\" \");             long l = Long.parseLong(input[0]);             long r = Long.parseLong(input[1]);              long maxLen = 0;             long current = l;             long difference = 1; // 처음 차이는 1로 설정              while (current &lt;= r) {                 maxLen++;                 current += difference;                 difference++;             }              sb.append(maxLen).append(\"\\n\");         }          System.out.print(sb.toString());          br.close();     } }   Problem D      Submission      Code /**  * Author : nowalex322, KimHyeonJae  */ import java.io.*; import java.util.*;  public class SakurakoHobby {     static BufferedReader br;     static StringTokenizer st;     static int n, p[], F[];     static boolean[] visited;      public static void main(String[] args) throws IOException {         // br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));          int t = Integer.parseInt(br.readLine());         StringBuilder sb = new StringBuilder();          while (t-- &gt; 0) {             n = Integer.parseInt(br.readLine()); // 순열의 크기             p = new int[n]; // 순열 p             visited = new boolean[n];             F = new int[n];              st = new StringTokenizer(br.readLine());                          for (int i = 0; i &lt; n; i++) {                 p[i] = Integer.parseInt(st.nextToken()) - 1;             }              String s = br.readLine();              for (int i = 0; i &lt; n; i++) {                 if (!visited[i]) {                     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                     int current = i;                      // 사이클을 탐색하면서 방문하지 않은 정점들을 기록                     while (!visited[current]) {                         visited[current] = true;                         list.add(current);                         current = p[current];                     }                      // 해당 사이클 내의 검정색 숫자 개수 카운트                     int cnt = 0;                     for (int idx : list) {                     \t// 색상이 검정색(0)인 경우 카운트++                         if (s.charAt(idx) == '0') cnt++;                     }                      // 사이클 내의 모든 정점에 대해 F 값을 동일하게 설정 - 메모이제이션                     for (int idx : list) {                         F[idx] = cnt;                     }                 }             }              // 결과를 StringBuilder에 추가하여 출력 속도 최적화             for (int i = 0; i &lt; n; i++) {                 sb.append(F[i]).append(\" \");             }             sb.append(\"\\n\");         }          System.out.print(sb.toString());         br.close();     } }   Problem F      Submission      Code /**  * Author : nowalex322, KimHyeonJae  */ import java.io.*; import java.util.*;  public class SakurakoBox {     static BufferedReader br;     static StringTokenizer st;     private static final int MOD = 1000000007;      public static void main(String[] args) throws IOException {         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));          int t = Integer.parseInt(br.readLine());         StringBuilder sb = new StringBuilder();          while (t-- &gt; 0) {             int n = Integer.parseInt(br.readLine());  // 배열의 크기             String[] tokens = br.readLine().split(\" \");             long[] a = new long[n];             long sum = 0;             for (int i = 0; i &lt; n; i++) {                 a[i] = Long.parseLong(tokens[i]);                 sum = (sum + a[i]) % MOD;             }              long result = 0;             for (int i = 0; i &lt; n; i++) {                 sum = (sum - a[i] + MOD) % MOD;                 result = (result + a[i] * sum) % MOD;             }              // 두 개의 공을 선택하는 조합의 수는 nC2 = n * (n-1) / 2!             long combinationCount = (long) n * (n - 1) / 2 % MOD;              // 기대값 계산: P * Q^(-1) % MOD             long expectedValue = result * modInverse(combinationCount, MOD) % MOD;              sb.append(expectedValue).append(\"\\n\");         }          System.out.print(sb.toString());         br.close();     }      // 모듈러 역수를 계산하는 함수 (페르마의 소정리 이용)     private static long modInverse(long a, int mod) {         return power(a, mod - 2, mod);     }      // 거듭제곱을 계산하는 함수     private static long power(long a, long b, int mod) {         long result = 1;         while (b &gt; 0) {             if ((b &amp; 1) == 1) {                 result = result * a % mod;             }             a = a * a % mod;             b &gt;&gt;= 1;         }         return result;     } }    Problem E (Failed)      Submission      Code /**  * Author : nowalex322, KimHyeonJae  */ import java.io.*; import java.util.*;  public class AlternatingString {     static BufferedReader br;     static BufferedWriter bw;     static StringBuilder sb;      public static void main(String[] args) throws IOException {         br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         sb = new StringBuilder();          int t = Integer.parseInt(br.readLine());         while (t-- &gt; 0) {             solve();         }                  bw.write(sb.toString());         bw.flush();         br.close();         bw.close();     }      static void solve() throws IOException {         int n = Integer.parseInt(br.readLine());         String s = br.readLine();                  if (n % 2 == 1) {  // 홀수 길이 문자열 처리             int[][] cnt = new int[2][26];             for (int i = 0; i &lt; n - 1; ++i) {                 cnt[i % 2][s.charAt(i) - 'a']++;             }             int ans = Arrays.stream(cnt[0]).max().getAsInt() + Arrays.stream(cnt[1]).max().getAsInt();             for (int i = n - 2; i &gt;= 0; i--) {                 cnt[i % 2][s.charAt(i) - 'a']--;                 cnt[(i + 1) % 2][s.charAt(i + 1) - 'a']++;                 ans = Math.max(ans, Arrays.stream(cnt[0]).max().getAsInt() + Arrays.stream(cnt[1]).max().getAsInt());             }             sb.append(n - ans).append('\\n');         } else {  // 짝수 길이 문자열 처리             int[][] cnt = new int[2][26];             for (int i = 0; i &lt; n; ++i) {                 cnt[i % 2][s.charAt(i) - 'a']++;             }             int maxEven = Arrays.stream(cnt[0]).max().getAsInt();             int maxOdd = Arrays.stream(cnt[1]).max().getAsInt();             sb.append(n - maxEven - maxOdd).append('\\n');         }     } }    Overall Review  Div.3 난이도라 생각보다 괜찮았고 재밌게 풀어봤다. "
  },
  
  {
    "title": "Operating System Concepts - (6)",
    "url": "/posts/Operating-System-Concepts-6/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2024-09-01 21:43:07 +0900",
    "content": "    Memory Management   Logical vs Physical Address ✔ Logical Address (= virtual address, 가상 주소)    프로세스마다 독립적으로 가지는 주소 공간   각 프로세스마다 0번지부터 시작   CPU가 보는 주소는 logical address   ✔ Physical Address    메모리에 실제 올라가는 위치   물리적인 메모리 아래에는 OS가 올라가 있고, 그 위에 프로세스들이 올라가는 형태   주소 바인딩 (Address binding) 주소 바인딩    물리적인 메모리에 저장되는 위치, 즉 주소를 결정하는 것   Symbolic Address –&gt; Logical Address –&gt; Physical Address   Symbolic Address            숫자보다는 Symbol로 되어 있는 Address를 사용하기 때문에 개발자가 보기 편하도록 사용하는 주소       Symbolic Address에서 Logical, Physical Address로 컴파일 되는 것.           주소 바인딩의 종류     Compile time binding            물리적 메모리 주소(physical address)가 컴파일 시 알려짐       시작 위치 변경시 재컴파일       컴파일러는 절대 코드(absolute code) 생성           Load time binding            Loader의 책임하에 물리적 메모리 주소 부여       실행 시작시 비어있는 메모리 주소를 찾아 부여함       컴파일러가 재배치가능코드(relocatable code)를 생성한 경우 가능           Execution time binding (= Run time binding)            수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음.       바인딩이 됐다가 실행 중에 프로세스의 메모리 위치가 변경되기도 하는 것.       CPU가 주소를 참조할 때마다 binding을 점검 (address mapping table)       하드웨어적인 지원이 필요 (ex) base and limit registers, MMU                    MMU가 메모리 위치를 변경(주소 변환)해주는 역할을 함.                               현재는 Run time binding을 사용함.   CPU가 바라보는 주소는 Logical Address.   Memory Management Unit (MMU)    주소 변환을 도와주는 하드웨어 장치   Logical Address를 Physical Address로 매핑해 주는 Hardware Device   MMU Scheme                     사용자 프로세스가 CPU에서 수행되며 생성해내는 모든 주소값에 대해 base register (= relocation register)의 값을 더한다.              relocation register, limit register 이렇게 두개의 레지스터로 주소 변환을 도와준다.       논리 주소 + 시작 위치를 더해서 실제 위치를 파악함.       limit register는 프로그램의 크기를 담고 있는 레지스터. logical address가 범위 밖을 벗어나게 되는 경우 다른 프로그램의 위치를 요청하게 되기 때문에 이러한 악의적인 요청을 방어해야 함. 맨 처음 limit register가 범위 안에 존재하는 logical address인지 판별하고, 범위를 벗어나는 경우 트랩을 발생시켜 OS가 해당 요청을 파악하도록 함.           user program            logical address만을 다룬다.       실제 physical address를 볼 수 없으며 알 필요가 없다.       physical address는 MMU를 거쳐서 접근 가능함.           Dynamic Loading    프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때(동적으로, 필요할 때마다) 메모리에 Load 하는 것.   memory utilization의 향상   가끔씩 사용되는 많은 양의 코드의 경우 유용 ex) 오류 처리 루틴   운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능 (OS는 라이브러리를 통해 지원 가능)   지금 시스템에서 OS가 페이징 기법을 통해 메모리를 관리하고 있지만, Dynamic loading은 프로그래머가 구현하는 영역. (페이징 기법과 Dynamic Loading은 다른 부분이 있지만, 같은 용어로 사용하기도 함.)   Loading : 메모리로 올리는 것.   Overlay    메모리에 프로세스의 부분 중 실제 필요한 정보만을 올림 (Dynamic Loading과 비슷)   프로세스의 크기가 메모리보다 클 때 유용   운영체제의 지원 없이 사용자에 의해 구현   작은 공간의 메모리를 사용하던 초창기 시스템에서 수작업으로 프로그래머가 구현            Manual Overlay (프로그래밍이 매우 복잡함. 어렵고 불편했음.)           Swapping    프로세스를 일시적으로 메모리에서 backing store로 쫒아내는 것   Backing Store (= Swap area)            디스크 : 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간           Swap in / Swap out            일반적으로 중기 스케줄러 (swapper)에 의해 swap out 시킬 프로세스 선정       priority-based CPU scheduling algorithm                    priority가 낮은 프로세스를 swapped out 시킴           priority가 높은 프로세스를 메모리에 올려 놓음                       Compile time 혹은 load time binding에서는 원래 메모리 위치로 swap in 해야 함.       Execution time binding(= Run time binding)에서는 추후 빈 메모리 영역 아무 곳에나 올릴 수 있음. 더 효율적임.       swap time은 대부분 transfer time (swap 되는 양에 비례하는 시간)임. transfer time은 원래 미미한 수준이지만 swap에서는 중요.           Dynamic Linking    Linking을 실행 시간 (execution time)까지 미루는 기법   Static Linking (&lt;- static library)            라이브러리가 프로그램의 실행 파일 코드에 포함됨.       실행 파일의 크기가 커짐       동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비 ex) printf 함수의 라이브러리 코드       static linking : 라이브러리 복제 (printf가 있는 프로세스 100개면 라이브러리도 100개 존재할 것)       dynamic linking : 라이브러리 링킹 (해당 주소만 복사, 라이브러리는 1개만 존재)           Dynamic Linking (&lt;- shared library ex) .so, .dll)            라이브러리가 실행시 연결(Link)됨.       실행 파일에는 라이브러리가 별도로 존재하고, 라이브러리 자체는 포함시키지 않고 Link만 두는 것.       라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠       라이브러리가 이미 메모리에 있으면, 그 루틴의 주소로 가고 없으면 디스크에서 읽어옴       운영체제의 도움이 필요.           Allocation of Physical Memory    메모리는 일반적으로 두 영역으로 나뉘어 사용            OS 상주 영역                    interrupt vector와 함께 낮은 주소 영역 사용                       사용자 프로세스 영역                    높은 주소 영역 사용                           사용자 프로세스 영역의 할당 방법            Contiguous Allocation (연속 할당)                    각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것 (통째로 올라가는 것)           Fixed partition allocation           variable partition allocation                       Noncontiguous Allocation (불연속 할당)                    하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음 (잘게 쪼개서 여러곳에 올라가는 것)           Paging           Segmentation           Paged Segmentation                           Contiguous Allocation      ** Fixed partition allocation** (고정 분할 방식)            물리적인 메모리를 몇 개의 영구적 분할 (partition)으로 나눔       분할의 크기가 모두 동일한 방식과 서로 다른 방식이 존재       분할 당 하나의 프로그램 적재       융통성이 없음                    동시에 메모리에 Load되는 프로그램의 수가 고정됨.           최대 수행 가능 프로그램 크기 제한                       외부 조각 (External Fragmentation)                    분할된 부분이 작아서 생기는 문제                       내부 조각 (Internal Fragmentation)                    분할된 부분이 커서 남는 부분이 발생해서 생기는 문제                           variable partition allocation (가변 분할 방식)            프로그램의 크기를 고려해 할당하는 방식       분할의 크기, 개수가 동적으로 변형       기술적 관리 기법 필요       외부 조각 (External Fragmentation) 이 발생할 수 있음.           Hole            가용 메모리 공간       다양한 크기의 hole들이 메모리 여러 곳에 흩어져 있음.       프로세스가 도착하면 수용 가능한 hole을 할당       운영체제는 할당 공간(사용중인 공간), 가용 공간(hole) 정보를 유지함.           Dynamic Storage Allocation Problem    가변 분할 방식에서 size n인 요청을 만족하는 가장 적절한 hole을 찾는 문제   ✔ First-fit    size가 n 이상인 것 중 최초로 찾아지는 hole에 할당   ✔ Best-fit    Size가 n 이상인 가장 작은 hole을 찾아서 할당 (프로그램의 크기와 가장 비슷한 Hole 탐색)   Hole들의 리스트가 크기순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야 함.   많은 수의 아주 작은 hole들이 생성됨. 3, Worst-fit   가장 큰 hole에 할당.   역시 모든 리스트를 탐색해야 함.   상대적으로 아주 큰 hole들이 생성됨.   First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 더 효과적인 것으로 알려짐. (실험적인 결과, 약간 당연하기도 함)      Compaction            External Fragmentation(외부 조각) 문제를 해결하는 한 가지 방법       사용 중인 메모리 영역을 한군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것       매우 비용이 많이 드는 방법임       최소한의 메모리 이동으로 compaction하는 방법 (매우 복잡한 문제)       Compaction은 프로세스의 주소가 실행 시간에 동적으로 재배치 가능한 경우에만 수행될 수 있다.           Noncontiguous Allocation 주소 변환을 페이징 별로 해야하기 때문에 바인딩이 어려워짐.     Paging (페이징 기법)            Process의 Virtual Memory를 동일한 사이즈의 Page 단위로 나눔       Virtual Memory의 내용이 page 단위로 noncontiguous하게 저장됨.       일부는 backing storage에, 일부는 physical memory에 저장됨.       Basic Method                    Physical memory를 동일한 크기의 frame으로 나눔.           Logical memory를 동일 크기의 page로 나눔 (frame과 같은 크기)           모든 가용 frame들을 관리           page table(각각의 페이지의 주소공간을 관리하는 배열)을 사용하여 logical address를 physical address로 변환           External fragmentation 발생 안함 (같은 크기로 분할하기 때문)           Internal Fragmentation 발생 가능 (마지막에 페이지 하나보다 남는 공간이 생길 수 있음. memory 공간이 페이지 개수만큼 할당되지는 않기 때문에.)                       주소변환을 위해 paging table(배열)이 사용됨.       page가 들어갈 수 있는 공간을 paging frame이라고 함.       앞부분이 논리적인 페이지 번호(p) / 뒤부분은 논리적인 주소(d)           "
  },
  
  {
    "title": "BOJ_10266_시계 사진들(Java)",
    "url": "/posts/BOJ10266%EC%8B%9C%EA%B3%84-%EC%82%AC%EC%A7%84%EB%93%A4Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-28 16:32:38 +0900",
    "content": "[Platinum IV] 시계 사진들 - 10266  문제 링크  성능 요약  메모리: 50832 KB, 시간: 532 ms  분류  KMP, 문자열  제출 일자  2024년 8월 28일 16:23:56  문제 설명  상근이는 보통의 시계와는 다른 독특한 시계 사진 두장이 있습니다. 시계는 n개의 동일한 길이와 목적을 가진 시계 바늘들을 가지고 있습니다. 애석하게도 시계의 숫자들은 희미해져 각 시계 바늘들의 위치만 구분 할 수 있습니다.  우리의 상근이는 두 사진의 시계가 같은 시각을 나타낼 수 있는지 궁금해져 각 사진을 서로 다른 각도로 돌려보려고 합니다.  두 사진에 대한 묘사가 주어질 때, 두 사진의 시계가 같은 시각을 나타내는지 결정하세요.  입력  첫 줄에는 바늘의 수를 나타내는 정수 n(2 ≤ n ≤ 200 000)이 주어진다.  다음 두 줄에는 각각 n개의 정수가 주어지며, 주어지는 정수 ai(0 ≤ ai &lt; 360,000)는 각 사진에서 바늘의 시계 방향 각도를 나타낸다. 이때 바늘의 각도는 특정 순서대로 주어지지는 않는다. 한 줄에는 같은 각도값이 두 번 이상 주어지지 않는다. 즉, 한 시계 안의 모든 각도값은 서로 구분된다.  출력  두 시계 사진이 같은 시각을 나타내고 있다면 \"possible\"을 아니면 \"impossible\"을 출력하시오.     문제 풀이   KMP알고리즘 문제. 시계각도가 0~359999까지 있고 회전 가능하므로 회전 고려하여 길이 720000텍스트 clock1과 길이 360000의 패턴 clock2를 비교한다고 생각. boolean배열로 720000짜리 clock1에 회전 고려한 텍스트 표시, 360000짜리 clock2에 패턴 표시. KMP알고리즘 적용.  코드 import java.io.*; import java.util.StringTokenizer;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int n; \tstatic boolean[] clock1, clock2; \tstatic int[] pi; \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tn = Integer.parseInt(br.readLine()); \t\tclock1 = new boolean[720000]; \t\tclock2 = new boolean[360000]; \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;n; i++) { \t\t\tint n = Integer.parseInt(st.nextToken()); \t\t\tclock1[n] = true; \t\t\tclock1[n + 360000] = true; \t\t} \t\t \t\tst = new StringTokenizer(br.readLine()); \t\tfor(int i=0; i&lt;n; i++) { \t\t\tint n = Integer.parseInt(st.nextToken()); \t\t\tclock2[n] = true; \t\t} \t\tpi = getPi(); \t\t \t\tSystem.out.println(KMP() ? \"possible\" : \"impossible\"); \t\t \t} \tprivate static boolean KMP() { \t\t \t\tint j=0; \t\tfor(int i=0; i&lt;720000; i++) { \t\t\t while(j&gt;0 &amp;&amp; clock1[i] != clock2[j]) { \t\t\t\t j = pi[j-1]; \t\t\t } \t\t\t if(clock1[i] == clock2[j]) { \t\t\t\t if(j==359999) { //\t\t\t\t\t j=pi[j]; \t\t\t\t\t return true; \t\t\t\t } \t\t\t\t else j++; \t\t\t } \t\t } \t\treturn false;\t\t \t} \tprivate static int[] getPi() { \t\t int[] pi = new int[360000]; \t\t int j=0; \t\t for(int i=1; i&lt;360000; i++) { \t\t\t while(j&gt;0 &amp;&amp; clock2[i] != clock2[j]) { \t\t\t\t j = pi[j-1]; \t\t\t } \t\t\t if(clock2[i] == clock2[j]) pi[i] = ++j; \t\t } \t\t return pi; \t} }  "
  },
  
  {
    "title": "BOJ_4354_문자열 제곱(Java)",
    "url": "/posts/BOJ4354%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A0%9C%EA%B3%B1Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-28 04:12:50 +0900",
    "content": "[Platinum V] 문자열 제곱 - 4354  문제 링크  성능 요약  메모리: 97008 KB, 시간: 460 ms  분류  KMP, 문자열  제출 일자  2024년 8월 28일 04:10:34  문제 설명  알파벳 소문자로 이루어진 두 문자열 a와 b가 주어졌을 때, a*b는 두 문자열을 이어붙이는 것을 뜻한다. 예를 들어, a=\"abc\", b=\"def\"일 때, a*b=\"abcdef\"이다.  이러한 이어 붙이는 것을 곱셈으로 생각한다면, 음이 아닌 정수의 제곱도 정의할 수 있다.   \ta^0 = \"\" (빈 문자열) \ta^(n+1) = a*(a^n)   문자열 s가 주어졌을 때, 어떤 문자열 a에 대해서 s=a^n을 만족하는 가장 큰 n을 찾는 프로그램을 작성하시오.  입력  입력은 10개 이하의 테스트 케이스로 이루어져 있다. 각각의 테스트 케이스는 s를 포함한 한 줄로 이루어져 있다. s의 길이는 적어도 1이며, 백만글자를 넘지 않는다. 마지막 테스트 케이스의 다음 줄은 마침표이다.  출력  각각의 테스트 케이스에 대해, s=a^n을 만족하는 가장 큰 n을 찾은 뒤 출력한다.     문제 풀이   KMP알고리즘 문제다. KMP로 마지막까지 반복되는 접두사 길이 체크하고 그 길이만큼 전체 문자열이 딱 떨어진다면 같은 패턴으로 쭉 반복되기에 지수곱 사용가능하므로 문자열길이 / 패턴길이로 답 구하면된다.  코드 import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic String T; \tstatic int L, pi[], maxExp;  \tpublic static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));          \t\twhile (true) {             T = br.readLine();             if (T.equals(\".\")) break;                          maxExp = getMaxExponent();             bw.write(maxExp + \"\\n\");         } \t\tbw.flush();         bw.close();         br.close(); \t}  \tprivate static int getMaxExponent() { \t\tint[] pi = new int[T.length()]; \t\tint j=0;  \t\tint maxExponent = 0; \t\t \t\tfor(int i=1; i&lt;T.length(); i++) { \t\t\twhile(j&gt;0 &amp;&amp; T.charAt(i) != T.charAt(j)) j = pi[j-1]; \t\t\t \t\t\tif(T.charAt(i) == T.charAt(j)) pi[i] = ++j; \t\t} //\t\tSystem.out.println(Arrays.toString(pi)); \t\t         int repeatLen = T.length()-pi[T.length()-1];         return maxExponent = T.length()%repeatLen==0 ? T.length()/repeatLen : 1;  \t\t \t} }   "
  },
  
  {
    "title": "BOJ_1305_광고(Java)",
    "url": "/posts/BOJ1305%EA%B4%91%EA%B3%A0Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-28 03:57:09 +0900",
    "content": "[Platinum IV] 광고 - 1305  문제 링크  성능 요약  메모리: 24096 KB, 시간: 252 ms  분류  KMP, 문자열  제출 일자  2024년 8월 28일 03:32:15  문제 설명  세준이는 길 한가운데에서 전광판을 쳐다보고 있었다. 전광판에는 광고가 흘러나오고 있었다. 한참을 전광판을 쳐다본 세준이는 이 광고가 의미하는 것이 무엇인지 궁금해지기 시작했다.  전광판에는 같은 내용의 문구가 무한히 반복되어 나온다. 또, 전광판의 크기는 전광판에서 한번에 보이는 최대 문자수를 나타낸다. 만약 전광판의 크기가 L이라면, 한번에 L개의 문자를 표시할 수 있는 것이다.  광고업자는 최대한의 광고효과를 내기 위해서 길이가 N인 광고를 무한히 붙여서 광고한다.  예를 들어, 광고 업자 백은진이 광고하고 싶은 내용이 aaba 이고, 전광판의 크기가 6이라면 맨 처음에 보이는 내용은 aabaaa 이다. 시간이 1초가 지날 때마다, 문자는 한 칸씩 옆으로 이동한다. 따라서 처음에 aabaaa가 보였으면 그 다음에는 abaaab가 보인다. 그 다음에는 baaaba가 보인다.  세준이가 어느 순간 전광판을 쳐다봤을 때, 그 때 쓰여 있는 문자가 입력으로 주어졌을 때, 가능한 광고의 길이중 가장 짧은 것을 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 광고판의 크기 L이 주어지고, 둘째 줄에 현재 광고판에 보이는 문자열이 주어진다.  출력  첫째 줄에 가능한 광고의 길이중 가장 짧은 것의 길이를 출력한다.     문제 풀이   광고가 반복된다면, 우리가 본 부분의 앞부분과 뒷부분이 같다. 이 같은 부분을 최대한 길게 찾으면, 그게 반복되는 부분.  예시 : abcabcab pi : [0, 0, 0, 1, 2, 3, 4, 5]  abc가 반복되고 정답은 ( 전체길이 - 3 ) 인 5  KMP 알고리즘의 pi 배열이 바로 이 “앞뒤로 같은 부분”의 길이를 찾아주고, pi 배열의 마지막 값이 바로 가장 긴 “같은 부분”의 길이 그러므고 전체 길이 - pi[마지막]이 최소 광고 길이가 되는 것  코드 import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic String T; \tstatic int L, pi[]; \tstatic List&lt;Integer&gt; positions;  \tpublic static void main(String[] args) throws IOException {         br = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));  \t\tL = Integer.parseInt(br.readLine()); \t\tT = br.readLine(); \t\tSystem.out.println(getMinLength());  \t}  \tprivate static int getMinLength() { \t\tint[] pi = new int[T.length()]; \t\tint j=0;  \t\tint min = 987654321;  \t\tfor(int i=1; i&lt;T.length(); i++) { \t\t\twhile(j&gt;0 &amp;&amp; T.charAt(i) != T.charAt(j)) j = pi[j-1];  \t\t\tif(T.charAt(i) == T.charAt(j)) pi[i] = ++j; \t\t} \t\treturn T.length() - pi[T.length() - 1]; \t} }  "
  },
  
  {
    "title": "BOJ_1786_찾기(Java)",
    "url": "/posts/BOJ1786%EC%B0%BE%EA%B8%B0Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-28 03:14:33 +0900",
    "content": "[Platinum V] 찾기 - 1786  문제 링크  성능 요약  메모리: 55652 KB, 시간: 532 ms  분류  KMP, 문자열  제출 일자  2024년 8월 28일 03:12:40  문제 설명  워드프로세서 등을 사용하는 도중에 찾기 기능을 이용해 본 일이 있을 것이다. 이 기능을 여러분이 실제로 구현해 보도록 하자.  두 개의 문자열 P와 T에 대해, 문자열 P가 문자열 T 중간에 몇 번, 어느 위치에서 나타나는지 알아내는 문제를 '문자열 매칭'이라고 한다. 워드프로세서의 찾기 기능은 이 문자열 매칭 문제를 풀어주는 기능이라고 할 수 있다. 이때의 P는 패턴이라고 부르고 T는 텍스트라고 부른다.  편의상 T의 길이를 n, P의 길이를 m이라고 하자. 일반적으로, n ≥ m이라고 가정해도 무리가 없다.  n&lt;m이면 어차피 P는 T중간에 나타날 수 없기 때문이다. 또, T의 i번째 문자를 T[i]라고 표현하도록 하자. 그러면 물론, P의 i번째 문자는 P[i]라고 표현된다.        1 2 3 4 5 6 7 8 9 … T : [ A B C D A B C D A B D E ]       | | | | | | X P : [ A B C D A B D ]       1 2 3 4 5 6 7  문자열 P가 문자열 T 중간에 나타난다는 것, 즉 문자열 P가 문자열 T와 매칭을 이룬다는 것이 어떤 것인지 위와 아래의 두 예를 통해 알아보자. 위의 예에서 P는, T의 1번 문자에서 시작하는 매칭에 실패했다. T의 7번 문자 T[7]과, P의 7번 문자 P[7]이 서로 다르기 때문이다.  그러나 아래의 예에서 P는, T의 5번 문자에서 시작하는 매칭에 성공했다. T의 5～11번 문자와 P의 1～7번 문자가 서로 하나씩 대응되기 때문이다.        1 2 3 4 5 6 7 8 9 … T : [ A B C D A B C D A B D E ]               | | | | | | | P :         [ A B C D A B D ]               1 2 3 4 5 6 7  가장 단순한 방법으로, 존재하는 모든 매칭을 확인한다면, 시간복잡도가 어떻게 될까? T의 1번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 1～m번 문자와 P의 1～m번 문자를 비교한다면 최대 m번의 연산이 필요하다. 이 비교들이 끝난 후, T의 2번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 2～m+1번 문자와 P의 1～m번 문자를 비교한다면 다시 최대 m번의 연산이 수행된다. 매칭은 T의 n-m+1번 문자에서까지 시작할 수 있으므로, 이러한 방식으로 진행한다면 O( (n-m+1) × m ) = O(nm) 의 시간복잡도를 갖는 알고리즘이 된다.  더 좋은 방법은 없을까? 물론 있다. 위에 제시된 예에서, T[7] ≠ P[7] 이므로 T의 1번 문자에서 시작하는 매칭이 실패임을 알게 된 순간으로 돌아가자. 이때 우리는 매칭이 실패라는 사실에서, T[7] ≠ P[7] 라는 정보만을 얻은 것이 아니다. 오히려 i=1…6에 대해 T[i] = P[i] 라고 하는 귀중한 정보를 얻지 않았는가? 이 정보를 십분 활용하면, O(n)의 시간복잡도 내에 문자열 매칭 문제를 풀어내는 알고리즘을 설계할 수 있다.  P 내부에 존재하는 문자열의 반복에 주목하자. P에서 1, 2번 문자 A, B는 5, 6번 문자로 반복되어 나타난다. 또, T의 1번 문자에서 시작하는 매칭이 7번 문자에서야 실패했으므로 T의 5, 6번 문자도 A, B이다.  따라서 T의 1번 문자에서 시작하는 매칭이 실패한 이후, 그 다음으로 가능한 매칭은 T의 5번 문자에서 시작하는 매칭임을 알 수 있다! 더불어, T의 5～6번 문자는 P의 1～2번 문자와 비교하지 않아도, 서로 같다는 것을 이미 알고 있다! 그러므로 이제는 T의 7번 문자와 P의 3번 문자부터 비교해 나가면 된다.  이제 이 방법을 일반화 해 보자. T의 i번 문자에서 시작하는 매칭을 검사하던 중 T[i+j-1] ≠ P[j]임을 발견했다고 하자. 이렇게 P의 j번 문자에서 매칭이 실패한 경우, P[1…k] = P[j-k…j-1]을 만족하는 최대의 k(≠j-1)에 대해 T의 i+j-1번 문자와 P의 k+1번 문자부터 비교를 계속해 나가면 된다.  이 최대의 k를 j에 대한 함수라고 생각하고, 1～m까지의 각 j값에 대해 최대의 k를 미리 계산해 놓으면 편리할 것이다. 이를 전처리 과정이라고 부르며, O(m)에 완료할 수 있다.  이러한 원리를 이용하여, T와 P가 주어졌을 때, 문자열 매칭 문제를 해결하는 프로그램을 작성하시오.  입력  첫째 줄에 문자열 T가, 둘째 줄에 문자열 P가 주어진다. T와 P의 길이 n, m은 1이상 100만 이하이고, 알파벳 대소문자와 공백으로만 이루어져 있다.  출력  첫째 줄에, T 중간에 P가 몇 번 나타나는지를 나타내는 음이 아닌 정수를 출력한다. 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력한다. 예컨대, T의 i～i+m-1번 문자와 P의 1～m번 문자가 차례로 일치한다면, i를 출력하는 식이다.     문제풀이   KMP알고리즘을 이용해 풀었다. KMP로직을 이해하고 나니 간단한 코드고 선형시간만에 패턴매칭이 가능해졌다.  코드  import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); \tstatic String T, P; \tstatic int[] pi; \tstatic List&lt;Integer&gt; positions;     public static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));     \t         T = br.readLine(); P = br.readLine();                  pi = getPi();                  List&lt;Integer&gt; positions = KMP(); // 일치하는 패턴 시작 위치                           bw.write(positions.size() + \"\\n\");         for (int pos : positions) {             bw.write((pos + 1) + \" \");         }                  bw.flush();         bw.close();         br.close();     }          static List&lt;Integer&gt; KMP() {    \t         positions = new ArrayList&lt;&gt;();                int j = 0;         for (int i = 0; i &lt; T.length(); i++) {             while (j &gt; 0 &amp;&amp; T.charAt(i) != P.charAt(j)) {                 j = pi[j - 1];             }                          if (T.charAt(i) == P.charAt(j)) {             \t// 패턴 찾았을 때                 if (j == P.length() - 1) {                     positions.add(i-(P.length()-1)); //                    System.out.println(T.substring(i-(P.length()-1), i+1));                     j = pi[j];                 } else {                     j++;                 }             }         }                  return positions;     }          static int[] getPi() {     \tint[] pi = new int[P.length()];     \tint j = 0;     \t     \tfor (int i = 1; i &lt; P.length(); i++) {     \t\twhile (j &gt; 0 &amp;&amp; P.charAt(i) != P.charAt(j)) {     \t\t\tj = pi[j - 1];     \t\t}     \t\t     \t\tif (P.charAt(i) == P.charAt(j)) {     \t\t\tpi[i] = ++j;     \t\t}     \t}     \t     \treturn pi;     } }  "
  },
  
  {
    "title": "PGMS_있었는데요 없었습니다(SQL)",
    "url": "/posts/PGME%EC%9E%88%EC%97%88%EB%8A%94%EB%8D%B0%EC%9A%94-%EC%97%86%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4SQL/",
    "categories": "SQL",
    "tags": "sql, 프로그래머스",
    "date": "2024-08-28 02:47:03 +0900",
    "content": "[level 3] 있었는데요 없었습니다 - 59043   문제 링크  성능 요약  메모리: 0.0 MB, 시간: 0.00 ms  구분  코딩테스트 연습 &gt; JOIN  채점결과  Empty  제출 일자  2024년 08월 28일 02:41:52  문제 설명  ANIMAL_INS 테이블은 동물 보호소에 들어온 동물의 정보를 담은 테이블입니다. ANIMAL_INS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, INTAKE_CONDITION, NAME, SEX_UPON_INTAKE는 각각 동물의 아이디, 생물 종, 보호 시작일, 보호 시작 시 상태, 이름, 성별 및 중성화 여부를 나타냅니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   INTAKE_CONDITION VARCHAR(N) FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_INTAKE VARCHAR(N) FALSE          ANIMAL_OUTS 테이블은 동물 보호소에서 입양 보낸 동물의 정보를 담은 테이블입니다. ANIMAL_OUTS 테이블 구조는 다음과 같으며, ANIMAL_ID, ANIMAL_TYPE, DATETIME, NAME, SEX_UPON_OUTCOME는 각각 동물의 아이디, 생물 종, 입양일, 이름, 성별 및 중성화 여부를 나타냅니다. ANIMAL_OUTS 테이블의 ANIMAL_ID는 ANIMAL_INS의 ANIMAL_ID의 외래 키입니다.           NAME TYPE NULLABLE            ANIMAL_ID VARCHAR(N) FALSE   ANIMAL_TYPE VARCHAR(N) FALSE   DATETIME DATETIME FALSE   NAME VARCHAR(N) TRUE   SEX_UPON_OUTCOME VARCHAR(N) FALSE          관리자의 실수로 일부 동물의 입양일이 잘못 입력되었습니다. 보호 시작일보다 입양일이 더 빠른 동물의 아이디와 이름을 조회하는 SQL문을 작성해주세요. 이때 결과는 보호 시작일이 빠른 순으로 조회해야합니다.   예시  예를 들어, ANIMAL_INS 테이블과 ANIMAL_OUTS 테이블이 다음과 같다면  ANIMAL_INS           ANIMAL_ID ANIMAL_TYPE DATETIME INTAKE_CONDITION NAME SEX_UPON_INTAKE            A350276 Cat 2017-08-13 13:50:00 Normal Jewel Spayed Female   A381217 Dog 2017-07-08 09:41:00 Sick Cherokee Neutered Male          ANIMAL_OUTS           ANIMAL_ID ANIMAL_TYPE DATETIME NAME SEX_UPON_OUTCOME            A350276 Cat 2018-01-28 17:51:00 Jewel Spayed Female   A381217 Dog 2017-06-09 18:51:00 Cherokee Neutered Male          SQL문을 실행하면 다음과 같이 나와야 합니다.            ANIMAL_ID NAME            A381217 Cherokee            본 문제는 Kaggle의 \"Austin Animal Center Shelter Intakes and Outcomes\"에서 제공하는 데이터를 사용하였으며 ODbL의 적용을 받습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges   코드 SELECT ai.ANIMAL_ID, ai.NAME     FROM ANIMAL_INS AS ai         INNER JOIN ANIMAL_OUTS AS ao             ON ao.ANIMAL_ID = ai.ANIMAL_ID                 WHERE ai.DATETIME &gt; ao.DATETIME                     ORDER BY ai.DATETIME ASC;  "
  },
  
  {
    "title": "BOJ_1701_Cubeditor(Java)",
    "url": "/posts/BOJ1701CubeditorJava/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-28 02:17:48 +0900",
    "content": "[Gold III] Cubeditor - 1701  문제 링크  성능 요약  메모리: 76480 KB, 시간: 256 ms  분류  KMP, 문자열  제출 일자  2024년 8월 28일 01:16:38  문제 설명  Cubelover는 프로그래밍 언어 Whitespace의 코딩을 도와주는 언어인 Cubelang을 만들었다. Cubelang을 이용해 코딩을 하다보니, 점점 이 언어에 맞는 새로운 에디터가 필요하게 되었다. 오랜 시간 고생한 끝에 새로운 에디터를 만들게 되었고, 그 에디터의 이름은 Cubeditor이다.  텍스트 에디터는 찾기 기능을 지원한다. 대부분의 에디터는 찾으려고 하는 문자열이 단 한 번만 나와도 찾는다. Cubelover는 이 기능은 Cubelang에 부적합하다고 생각했다. Cubelang에서 필요한 기능은 어떤 문자열 내에서 부분 문자열이 두 번 이상 나오는 문자열을 찾는 기능이다. 이때, 두 부분 문자열은 겹쳐도 된다.  예를 들어, abcdabc에서 abc는 두 번 나오기 때문에 검색이 가능하지만, abcd는 한 번 나오기 때문에 검색이 되지를 않는다.  이렇게 어떤 문자열에서 두 번 이상 나오는 부분 문자열은 매우 많을 수도 있다. 이러한 부분 문자열 중에서 가장 길이가 긴 것을 구하는 프로그램을 작성하시오.  예를 들어, abcabcabc에서 abc는 세 번 나오기 때문에 검색할 수 있다. 또, abcabc도 두 번 나오기 때문에 검색할 수 있다. 하지만, abcabca는 한 번 나오기 때문에 검색할 수 없다. 따라서, 두 번 이상 나오는 부분 문자열 중에서 가장 긴 것은 abcabc이기 때문에, 이 문자열이 답이 된다.  입력  첫째 줄에 문자열이 주어진다. 문자열의 길이는 최대 5,000이고, 문자열은 모두 소문자로만 이루어져 있다.  출력  입력에서 주어진 문자열의 두 번이상 나오는 부분문자열 중에서 가장 긴 길이를 출력한다.     문제 풀이     코드 import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic int len, maxLen, pi[]; \tstatic String str; \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tstr = br.readLine(); \t\tlen = str.length();  \t\tint i; \t\tfor(i=0; i&lt;len; i++) { \t\t\tString subString = str.substring(i,len); // 접미사 //\t\t\tSystem.out.println(subString); \t\t\tmaxLen = Math.max(maxLen, KMP(subString)); \t\t} \t\tSystem.out.println(maxLen); \t\t \t} \t \t/** \t * pi라는 실패함수 만들기 \t *  \t * @param subString 비교할 패턴 \t * @return maxLen 최대 패턴 길이 \t */ \tprivate static int KMP(String subString) {  \t\tpi = new int[subString.length()]; \t\tint j=0; int max=0;  \t\tint i; \t\tfor(i = 1; i&lt;subString.length(); i++) { \t\t\t \t\t\twhile(j&gt;0 &amp;&amp; subString.charAt(i) != subString.charAt(j)) { \t\t\t\tj = pi[j-1]; \t\t\t} \t\t\t \t\t\tif(subString.charAt(i) == subString.charAt(j)) { \t\t\t\tpi[i] = ++j; \t\t\t\tmax = Math.max(max, pi[i]); \t\t\t} \t\t\t \t\t} \t\t //\t\tSystem.out.println(Arrays.toString(pi));  \t\treturn max; \t}  }   "
  },
  
  {
    "title": "BOJ_1377_버블소트(Java)",
    "url": "/posts/BOJ1377%EB%B2%84%EB%B8%94%EC%86%8C%ED%8A%B8Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-26 04:23:46 +0900",
    "content": "[Gold II] 버블 소트 - 1377  문제 링크  성능 요약  메모리: 47920 KB, 시간: 300 ms  분류  정렬  제출 일자  2024년 8월 26일 04:16:51  문제 설명  버블 소트 알고리즘을 다음과 같이 C++로 작성했다.  bool changed = false; for (int i=1; i&lt;=N+1; i++) {     changed = false;     for (int j=1; j&lt;=N-i; j++) {         if (A[j] &gt; A[j+1]) {             changed = true;             swap(A[j], A[j+1]);         }     }     if (changed == false) {         cout &lt;&lt; i &lt;&lt; '\\n';         break;     } }   위 소스에서 N은 배열의 크기이고, A는 정렬해야 하는 배열이다. 배열은 A[1]부터 사용한다.  위와 같은 소스를 실행시켰을 때, 어떤 값이 출력되는지 구해보자.  입력  첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다.  출력  정답을 출력한다.  코드     풀이 1 : 메모리 47920KB, 시간 300ms   import java.io.*;  public class Main { \tstatic int N, arr[], count[], sum;     public static void main(String[] args) throws IOException {         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         N = Integer.parseInt(br.readLine());         arr = new int[N];         count = new int[1000001];          /**          * 각 숫자 등장횟수 세기          * 인덱스값의 숫자가 몇번 등장했는지 저장          */         for (int i = 0; i &lt; N; i++) {             arr[i] = Integer.parseInt(br.readLine());             count[arr[i]]++;         }          /**          * 누적 합 계산          * count 순회하며 각 숫자보다 작거나 같은 숫자들의 총 개수 계산          * 이후 count[i]는 i보다 작거나 같은 숫자의 개수 - 1을 나타냄          */         sum = 0;         for (int i = 0; i &lt;= 1000000; i++) {         \tsum += count[i];             count[i] = sum - 1;         }          /**          * 최대 이동 거리 계산          * 각 숫자의 현재 위치와 정렬 후 위치의 차이 중 최댓값 찾기          * i - count[arr[i]]: 현재 위치 - 정렬 후 위치          */         int ans = 0;         for (int i = 0; i &lt; N; i++) {         \tans = Math.max(ans, i - count[arr[i]]);         }          System.out.println(ans + 1);     } }     풀이 2 : 메모리 82748KB, 시간 1488ms   import java.io.*; import java.util.*;  public class Main { \t \tpublic static class Data implements Comparable&lt;Data&gt;{ \t\tint value; \t\tint idx; \t\t \t\tpublic Data(int value, int idx) { \t\t\tthis.value = value; \t\t\tthis.idx = idx; \t\t}  \t\t@Override \t\tpublic int compareTo(Data o) { \t\t\treturn this.value - o.value; \t\t} \t} \t \tstatic BufferedReader br; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tint N = Integer.parseInt(br.readLine()); \t\tData[] data = new Data[N]; \t\t \t\tfor(int i=0; i&lt;N; i++) { \t\t\tdata[i]\t = new Data(Integer.parseInt(br.readLine()), i); \t\t} \t\tArrays.sort(data); \t\t \t\tint max = 0; \t\tfor(int i=0; i&lt;N; i++) { \t\t\tif(max &lt; data[i].idx-i) max = data[i].idx -i; \t\t} \t\tSystem.out.println(max+1); \t} }   "
  },
  
  {
    "title": "Operating System Concepts - (5)",
    "url": "/posts/Operating-System-Concepts-5/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2024-08-26 03:18:23 +0900",
    "content": "   Classical Problems of Synchronization   Two Types of Semaphores    Counting Semaphore            도메인이 0 이상인 임의의 정수값       주로 resource counting 에 사용           Binary Semaphore (= mutex)            0 또는 1 값만 가질 수 있는 semaphore       주로 mutual exclusion (lock/unlock)에 사용           Deadlock and Starvation         Deadlock            둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상       자원을 획득하는 순서를 똑같이 맞춰주면 위의 문제들을 해결할 수 있음                Starvation            indefinite blocking : 프로세스가 suspend 된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상       특정 프로세스들만 자원을 공유하는 상황           Classical Problems of Synchronization         Bounded-Buffer Problem (Producer-Consumer Problem)     Readers and Writers Problem     Dining-Philosophers Problem      Bounded-Buffer Problem (Producer-Consumer Problem)     생산자-소비자의 문제        주황색 원은 생산자가 공유 버퍼에 데이터를 넣어 놓은 상태, 흰색 원은 소비자가 버퍼에서 프로세스를 꺼내간 상태.     데이터를 넣을 때 or 꺼낼 때 lock을 걸어 공유 데이터에 다른 프로세스가 접근하지 못하도록 함.     버퍼가 다 찬 상태에서 버퍼에 데이터를 넣기 위해 생산자가 도착했다고 가정했을 때, 빈 버퍼가 없어 데이터를 넣을 수 없다는 문제가 생김. 소비자가 도착해 버퍼에 있는 데이터를 꺼내 가져갈 때까지 버퍼에 데이터를 삽입할 수 없음. 생산자가 무한 대기 해야하는 상황이 발생. 마찬가지로, 반대 상황 (꺼내갈 데이터가 없어 소비자가 무한 대기하는 현상) 도 발생할 수 있다는 문제점 존재.         Shared Data            buffer 자체 및 buffer 조작 변수 (empty/full buffer의 시작 위치)           Synchronization variables            mutual exclusion (상호 배제) ➡ Need binary semaphore (shared data의 mutual exclusion을 위해)       resource count ➡ Need integer semaphore (남은 full/empty buffer의 수 표시)           Bounded-Buffer Problem    Procucer     do{     P(empty);    P(mutex);    ...    add x to buffer    ...    V(mutex);    V(full); } while(1);           Consumer     do{   produce and item in x    ...     P(full);    P(mutex);    ...    remove an item from buffer to y    ...    V(mutex);    V(empty);    ...    consume the item in y    ... } while(1);           full (내용이 들어있는 버퍼 개수), empty (비어 있는 버퍼 개수), mutex (lock 상태 변수)   P 연산은 자원 획득, V 연산은 자원 반납. 생산자와 소비자의 슈도코드는 반대로 구성되어 있음.   Readers and Writers Problem    한 프로세스가 DB(공유 데이터)에 write 중일 때 다른 프로세스가 접근하면 안됨. (lock을 걸어 접근 못하도록 방지)   read는 동시에 여럿이 해도 문제 없음.   해결 방법 ✔ Writer가 DB에 접근 허가를 아직 얻지 못한 상태에서는 모든 대기중인 Reader들을 다 DB에 접근하게 해준다 ✔ Writer는 대기 중인 Reader가 하나도 없을 때 DB 접근이 허용된다 ✔ 일단 Writer가 DB에 접근 중이면 Reader들은 접근이 금지된다 ✔ Writer가 DB에서 빠져나가야만 Reader의 접근이 허용된다   Shared Data    DB 자체   readcount; /현재 DB에 접근 중인 Reader의 수/   Synchronization variables    mutex : 공유 변수 readcount를 접근하는 코드 (critical section)의 mutual exclusion 보장을 위해 사용.   db : reader와 writer가 공유 DB 자체를 올바르게 접근하게 하는 역할   Readers and Writers Problem Shared data int readcount = 0; DB 자체; Synchronization variables semaphore mutex = 1, db = 1;     Writer     P(db); ... writing DB is performed ... V(db);          ! Starvation 발생 가능      Reader     P(mutex); readcount++; if(readcount == 1) P(db); // block writer V(mutex);                 // readers follow ... reading DB is performed ... P(mutex); readcount--; if(readcount == 0) V(db); // enable writer V(mutex);           read일 때도 lock을 걸긴 하지만, 똑같은 read 작업이 들어왔을 경우 작업 허용   readcount를 증가시킬 때에도 lock이 필요함. 이 과정을 나타내는 변수가 mutex   reader가 계속 도착하면 reader들을 위해 계속 write는 대기 상태에 빠질 수 있음. 이런 경우 기아 상태 발생 가능.   큐에 우선순위를 두어서 지나치게 대기시간이 길지 않도록 하는 해결방법을 통해 기아 상태를 방지할 수 있음. (신호등 비유)   Dining-Philosophers Problem Synchronization variables semaphore chopstick[5]; // initially all values are 1  Philosopher i do { \tP(chopstick[i]);     P(chopstick[(i+1) % 5]);      ...     eat();      ...     V(chopstick[i]);     V(chopstick[(i+1) % 5]);      ...     think();      ... } while(1);     생각하는 일 / 밥먹는 일 두개로 나누어짐   밥을 먹게 되면 왼쪽, 오른쪽 젓가락을 같이 집어 밥을 먹음. 밥을 먹을 때는 옆에 있는 젓가락을 잡아야 먹을 수 있음   젓가락을 공유 자원으로 빗댄 문제   deadlock 문제 발생 가능성 존재        본인이 밥을 먹고 배가 부른 상태여야 젓가락을 놓기 때문에 한 젓가락만 가지고 있는 상태라면 아무도 밥을 먹지 못하고 아무도 젓가락을 놓지 못한 채로 계속 대기할 가능성 존재      앞의 해결방안의 문제점            Deadlock 가능성이 있다       모든 철학자가 동시에 배가 고파져 왼쪽 젓가락 집은경우           해결방안            4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.       젓가락을 두 개 모두 집을 수 있을 때에 젓가락을 집을 수 있게 한다       비대칭 활용 : 짝수 철학자는 왼쪽만, 홀수 철학자는 오른쪽만 먼저 잡을 수 있도록 한다           Dining-Philosophers Problem enum {thinking, hungry, eating} state[5]; semaphore self[5] = 0; semaphore mutex=1;  Philosopher i do { \tpickup(i);     eat();     putdown(i);     think(); } while(1);  void putdown(int i){ \tP(mutex);     state[i] = thinking;     test((i+4) % 5);     test((i+1) % 5);     V(mutex); }  void pickup(int i){ \tP(mutex);     state[i] = hungry;     test(i);     V(mutex);     P(self[i]); }  void test(int i){ \tif(state[(i+4) % 5] != eating &amp;&amp; state[i] == hungry &amp;&amp; state[(i+1) % 5] != eating) {     state[i] = eating;     V(self[i]); \t} }   Monitor          Semaphore의 문제점 ✔ 코딩하기 힘들다. ✔ 정확성(correctness)의 입증이 어렵다. ✔ 자발적 협력이 필요하다. ✔ 한번의 실수가 모든 시스템에 치명적인 영향을 끼친다.           예            Monitor란?            동시 수행중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기 위한 high-level synchronization construct       세마포에 비해 프로그래머의 불안을 확연히 줄여주는 병행 제어 방법       active한 프로세스 하나만이 공유 데이터에 접근할 수 있도록 제어해주는 방법         monitor monitor-name { shared variable declarations procedure body P1(..) {   ... } procedure body P2(..) {   ... } procedure body Pn(..) {   ... } {   initializaion code } }                                    프로시저를 통해서만 shared data에 접근할 수 있도록 하는 것.   lock을 걸 필요가 없음. monitor에 있는 프로시저들이 차례대로 공유 데이터에 접근하기 때문에.   모니터 내에서는 한번에 하나의 프로세스만이 활동 가능 프로그래머가 동기화 제약 조건을 명시적으로 코딩할 필요가 없음   프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 condition variable 사용    condition x,y;   모니터 밖에서 기다리는 프로세스들은 모니터 안에 있는 active process의 개수가 0이 될 때 monitor 안에 접근해서 active한 프로세스가 되는 것.   Condition Variable은 wait와 signal 연산에 의해서만 접근 가능    x.wait(); x.wait() 을 invoke한 프로세스는 다른 프로세스가 x.signal()을 invoke하기 전까지 suspend 된다. x.signal(); x.signal()은 정확하게 하나의 suspend된 프로세스를 resume한다. suspend된 프로세스가 없으면 아무 일도 일어나지 않는다.   Monitor를 통해 개선한 Synchronization problem Monitor Bounded Buffer Implementation  monitor bounded_buffer {     int buffer[N];     condition full, empty;     /* condition var.은 값을 가지지 않고 자신의 큐에 프로세스를        매달아서 sleep 시키거나 큐에서 프로세스를 깨우는 역할만 함 */      void produce(int x)     {         if there is no empty buffer             empty.wait();         add x to an empty buffer         full.signal();     }      void consume(int *x)     {         if there is no full buffer             full.wait();         remove an item from buffer and store it to *x         empty.signal();     } }     full (full인 상태에서 잠들어 있는 프로세스 큐)   empty (empty인 상태에서 잠들어 있는 프로세스 큐)   Dining Philosophers Example monitor dining_philosopher {     enum {thinking, hungry, eating} state[5];     condition self[5];      void pickup(int i) {         state[i] = hungry;         test(i);         if (state[i] != eating)             self[i].wait(); /*wait here*/     }      void putdown(int i) {         state[i] = thinking;         /* test left and right neighbors*/         test((i+4) % 5); /*if L is waiting*/         test((i+1) % 5);     }      void test(int i) {         if ((state[(i + 4) % 5] != eating) &amp;&amp;             (state[i] == hungry) &amp;&amp;             (state[(i + 1) % 5] != eating)) {             state[i] = eating;             self[i].signal(); /*wake up Pi*/         }     }      void init() {         for (int i = 0; i &lt; 5; i++)             state[i] = thinking;     } }  // Each Philosopher: {     pickup(i);     eat();     putdown(i);     think(); } while(1)     pickup(i), putdown(i)가 모니터에 들어간 active process가 되었을 때 실행되는 함수   Deadlock (교착상태)  The Deadlock Problem Deadlock    일련의 프로세스들이 서로가 가진 자원을 기다리며 block된 상태     Resource      하드웨어, 소프트웨어 등을 포함하는 개념   ex) I/O device, CPU cycle, Memory space, semaphore 등   프로세스가 자원을 사용하는 절차 Request –&gt; Allocate –&gt; Use –&gt; Release   Deadlock Example 1    시스템에 2개의 tape drive가 있다.   프로세스 P1, P2 각각이 하나의 tape drive를 보유한 채 다른 하나를 기다리고 있다.   Deadlock Example 2    Binary Semaphores A and B   Deadlock 발생의 4가지 조건 1.Mutual Exclusion (상호 배제)    매 순간 하나의 프로세스만이 자원을 사용할 수 있음.            No preemption (비선점)           프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음            Hold and Wait (보유 대기)           자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음.            Circular wait (순환 대기)           자원을 기다리는 프로세스 간에 사이클이 형성되어야 함.   프로세스 P0…Pn이 존재한다는 가정에서 P0은 P1이 가진 자원을 기다림 P1은 P2이 가진 자원을 기다림 Pn-1은 Pn이 가진 자원을 기다림 Pn은 P0이 가진 자원을 기다림   이 조건들을 충족하지 않으면 교착상태는 발생하지 않음.  Resource-Allocation Graph (자원 할당 그래프)    작은 점들은 인스턴스, P1 -&gt; R2 (Request)   그래프 안에 cycle이 없으면 deadlock이 아니다.   그래프에 cycle이 있고, 인스턴스가 한개밖에 없으면 교착상태. 인스턴스가 여러개일 경우 교착상태일수도, 아닐 수도 있음.   두번째 그림은 인스턴스가 여러개지만, cycle이 2개고 요청한 프로세스가 다 대기상태이므로 교착상태임. (남는 자원이나 반납할 수 있는 자원 존재 X)   세번째 그림은 인스턴스가 두개씩이고, p2 or p4 프로세스가 cycle을 가지고 있지 않아 반납할 경우 대기하고 있는 프로세스에 할당이 가능하기 때문에 교착상태가 아님.   Deadlock의 처리 방법 Deadlock Prevention    자원 할당 시 Deadlock의 4가지 필요 조건 중 어느 하나가 만족되지 않도록 하는 것      가장 강력한 교착 상태 방지 방법   Deadlock 가능성이 아예 없을때만 자원을 할당함.            Mutual Exclusion (상호 배제)                 공유해서는 안되는 자원의 경우 반드시 성립해야 함.                    Hold and Wait (보유 대기)                       프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야 함.       방법 1 ) 프로세스 시작 시 모든 필요한 자원을 할당받게 하는 방법.       방법 2 ) 자원이 필요할 경우 보유 자원을 모두 놓고 다시 요청 (자진 반납) 3.** No Preemption** (비선점)       process가 어떤 자원을 기다려야 하는 경우 이미 보유한 자원이 선점됨       모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작됨.       State를 쉽게 save하고 restore할 수 있는 자원에서 주로 사용 (CPU, memory)                    Circular Wait (순환 대기)                       모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당       예를 들어 순서가 3인 자원 Ri를 보유 중인 프로세스가 순서가 1인 자원 Rj를 할당받기 위해서는 우선 Ri를 release해야 한다.           =&gt; Utilization 저하, throughput 감소, starvation 문제  Deadlock Avoidance         자원 요청에 대한 부가적인 정보를 이용해서 deadlock의 가능성이 없는 경우에만 자원을 할당     자원 할당이 deadlock으로부터 안전(safe)한지를 동적으로 조사해서 안전한 경우에만 할당. (항상 safe 상태 유지)      시스템 state가 원래 state로 돌아올 수 있는 경우에만 자원 할당 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법임.     Safe state            시스템 내의 프로세스들에 대한 safe sequence가 존재하는 상태       시스템이 safe state에 있으면 교착상태가 발생하지 않으며, 시스템이 unsafe state에 있으면 교착상태 발생 가능성이 존재함. 그러므로 Deadlock Avoidance는 시스템이 unsafe state에 들어가지 않는 것을 보장           Safe Sequence            프로세스의 sequence &lt;p1, p2, p3 … pn&gt;이 safe하려면 Pi(1 &lt;= i &lt;= n)의 자원 요청이 가용 자원 + 모든 Pj(j &lt; i)의 보유 자원 에 의해 충족되어야 함.       조건을 만족하면 다음 방법으로 모든 프로세스의 수행을 보장                    Pi의 자원 요청이 즉시 충족될 수 없으면 모든 Pj(j &lt; i) 가 종료될 때까지 기다린다.           Pi-1이 종료되면 Pi의 자원 요청을 만족시켜 수행한다.                           Avoidance Algorithm         Resource Allocation Graph Algorithm (자원 할당 그래프)      리소스 당 하나의 인스턴스일 때 회피 방법            최악의 상황을 가정하기 때문에 교착상태의 가능성이 있는 요청은 받아들이지 않고 그냥 놔둠.       available한 자원이 있다고 해서 모두 할당하는 것이 아니라 교착상태의 발생 가능성을 판별한 후 할당함.                Banker’s Algorithm (은행가 알고리즘) 리소스 당 여러 개의 인스턴스일 때 회피 방법             맨 끝은 추가 요청 가능량.       가용 자원 만으로도 추가 요청 가능량을 모두 충족할 수 있을 때 프로세스 점유 요청을 승낙함. (무조건 최악의 경우를 가정하기 때문에 가용 자원이 추가 요청 가능량을 충족하지 못할 경우 점유 요청 거절. 현재 반환되지 않은 프로세스들이 반환되면 추후 점유 가능할 수 있기 때문에 그때까지 계속 대기)       보수적인 알고리즘. 교착 상태가 절대 발생하지 않도록 회피하는 알고리즘.           Deadlock Detection and Recovery    Deadlock 발생은 허용하되 그에 대한 detection 루틴을 두어 deadlock 발견 시 recover   Resource type 당 single instance일 경우            자원 할당 그래프에서의 cycle이 곧 deadlock을 의미           Resource type 당 multiple instance인 경우            Banker’s algorithm과 유사한 방법 활용           Wait-for graph 알고리즘                     Resource type 당 single instance인 경우              Wait-for graph                    자원 할당 그래프의 변헝           프로세스만으로 node 구성           Pj가 가지고 있는 자원을 Pk가 기다리는 경우 Pk -&gt; Pj                       Algorithm                    Wait-for graph에 cycle이 존재하는지를 주기적으로 조사           O(n^2) -&gt; n의 제곱의 효율성을 가지는 알고리즘.                           Recovery            Process termination                    모든 교착상태 프로세스 kill                       Resource Preemption                    비용을 최소화할 resource(victim)의 선정           safe state로 rollback하여 process를 restart           starvation 문제 발생 우려                            동일한 프로세스가 계속해서 victim으로 선정되는 경우               cost factor에 rollback 횟수도 같이 고려하면 문제 발생 확률 낮아짐.                                                   Deadlock Ignorance    Deadlock을 시스템이 책임지지 않음. Deadlock이 일어나지 않는다고 가정하고 아무런 조치도 취하지 않음.   Deadlock이 매우 드물게 발생하므로 Deadlock에 대한 조치 자체가 더 큰 overhead일 수 있음.   만약, 시스템에 deadlock이 발생한 경우 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처.   UNIX, windows를 포함한 대부분의 OS가 채택   "
  },
  
  {
    "title": "BOJ_3015_오아시스 재결합",
    "url": "/posts/BOJ3015%EC%98%A4%EC%95%84%EC%8B%9C%EC%8A%A4-%EC%9E%AC%EA%B2%B0%ED%95%A9/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-23 10:46:33 +0900",
    "content": "[Platinum V] 오아시스 재결합 - 3015  문제 링크  성능 요약  메모리: 60024 KB, 시간: 432 ms  분류  자료 구조, 스택  제출 일자  2024년 8월 23일 10:42:10  문제 설명   \t오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.   \t이 역사적인 순간을 맞이하기 위해 줄에서서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해 졌다.   \t두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.   \t줄에 서있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.  입력   \t첫째 줄에 줄에서 기다리고 있는 사람의 수 N이 주어진다. (1 ≤ N ≤ 500,000)   \t둘째 줄부터 N개의 줄에는 각 사람의 키가 나노미터 단위로 주어진다. 모든 사람의 키는 231 나노미터 보다 작다.   \t사람들이 서 있는 순서대로 입력이 주어진다.  출력   \t서로 볼 수 있는 쌍의 수를 출력한다.  코드 import java.io.*; import java.util.*;  public class Main {  \t/** \t * height : 키 \t * num : 같은키 가진 연속된 사람 수 \t */ \tstatic class Person { \t\tint height; \t\tint pairNum;  \t\tpublic Person(int height, int pairNum) { \t\t\tthis.height = height; \t\t\tthis.pairNum = pairNum; \t\t} \t\t \t    @Override \t    public String toString() { \t        return \"(\" + height + \",\" + pairNum + \")\"; \t    } \t}  \tstatic BufferedReader br; \tstatic int N, arr[]; \tstatic long ans; \tstatic Stack&lt;Person&gt; stack;  \tpublic static void main(String[] args) throws Exception { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tN = Integer.parseInt(br.readLine()); \t\tarr = new int[N]; \t\tstack = new Stack&lt;&gt;();  \t\tint i; \t\tfor (i = 0; i &lt; N; i++) { \t\t\tarr[i] = Integer.parseInt(br.readLine()); \t\t}  \t\t/** \t\t * 지금 사람보다 키가 작은 사람들은 모두 볼 수 있으므로 볼 수 있는 쌍의 수 추가하고 스택에서 제거. \t\t * 자신보다 큰 사람은 1명만 볼 수 있음 \t\t * 최종적으로 스택에는 키가 중간중간 작은애들 빠지고 내림차순으로 남을것이다. \t\t * 시간복잡도 O(N) \t\t */ \t\t \t\tlong cnt = 1; \t\tint j; \t\tfor (j = 0; j &lt; N; j++) { \t\t\tint tmp = arr[j]; \t\t\tint tmpNum = 1;  //\t        System.out.println(\"\\n처리 중인 사람: 키 \" + tmp); //\t        System.out.println(\"처리 전 스택: \" + stack); \t         \t\t\t// 현재 사람보다 키가 작은 사람들을 스택에서 제거하며 쌍의 수 추가 \t\t\twhile (!stack.isEmpty() &amp;&amp; tmp &gt; stack.peek().height) { \t\t\t\tans += stack.peek().pairNum; \t\t\t\tstack.pop(); //\t            System.out.println(\"팝: \" + stack.pop() + \", ans = \" + ans);  \t\t\t} \t\t\t \t\t\t// 남은 자신보다 크거나 같은 사람들 \t\t\tif (!stack.isEmpty()) { \t\t\t\tif (stack.peek().height == arr[j]) { // 같은 키 \t\t\t\t\tans += stack.peek().pairNum; \t\t\t\t\ttmpNum = stack.peek().pairNum + 1; \t\t\t\t\tif (stack.size() &gt; 1) \t\t\t\t\t\tans++; \t\t\t\t\tstack.pop(); //\t                System.out.println(\"같은 키 처리: \" + stack.pop() + \", ans = \" + ans + \", tmpCnt = \" + tmpNum);  \t\t\t\t} else {  // 자신보다 큰 사람 \t\t\t\t\tans++; //\t                System.out.println(\"큰 사람 처리: ans = \" + ans);  \t\t\t\t} \t\t\t} \t\t\tstack.push(new Person(arr[j], tmpNum)); //\t        System.out.println(\"푸시 후 스택: \" + stack);  \t\t} \t\tSystem.out.println(ans); \t} }  "
  },
  
  {
    "title": "BOJ_1932_정수 삼각형(Java)",
    "url": "/posts/BOJ1932%EC%A0%95%EC%88%98-%EC%82%BC%EA%B0%81%ED%98%95Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-22 12:46:34 +0900",
    "content": "[Silver I] 정수 삼각형 - 1932  문제 링크  성능 요약  메모리: 26956 KB, 시간: 240 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 8월 22일 12:40:24  문제 설명          7       3   8     8   1   0   2   7   4   4 4   5   2   6   5  위 그림은 크기가 5인 정수 삼각형의 한 모습이다.  맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.  삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.  입력  첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.  출력  첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.     풀이 방법     코드 import java.io.BufferedReader; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int n, board[][], dp[][]; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tn = Integer.parseInt(st.nextToken()); \t\tboard = new int[n][n+2]; \t\tdp = new int[n][n+2]; \t\tfor(int i=0; i&lt;n; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j=1; j&lt;=i+1; j++) { \t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken()); \t\t\t} \t\t} \t\tdp[0][1] = board[0][1]; \t\t \t\t \t\tfor(int i=1; i&lt;n; i++) { \t\t\tfor(int j=1; j&lt;=i+1; j++) { \t\t\t\tdp[i][j] = Math.max(dp[i-1][j-1] + board[i][j], dp[i-1][j] + board[i][j]); \t\t\t} \t\t} \t\t \t\tint maxV = dp[n-1][0]; \t\tfor(int j=1; j&lt;=n; j++) { \t\t\tmaxV = Math.max(maxV, dp[n-1][j]); \t\t} \t\tSystem.out.println(maxV); \t} }  "
  },
  
  {
    "title": "BOJ_9465_스티커(Java)",
    "url": "/posts/BOJ9465%EC%8A%A4%ED%8B%B0%EC%BB%A4Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-21 17:11:45 +0900",
    "content": "[Silver I] 스티커 - 9465  문제 링크  성능 요약  메모리: 110508 KB, 시간: 620 ms  분류  다이나믹 프로그래밍  제출 일자  2024년 8월 21일 17:08:35  문제 설명  상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.  상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.    모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.  위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.  입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.   출력  각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.     문제 풀이     코드 import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic StringTokenizer st; \tstatic int T, n, board[][], dp[][]; \t \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); //\t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\t \t\tT = Integer.parseInt(br.readLine()); \t\tint tc; \t\tfor(tc = 0; tc &lt; T; tc++) { \t\t\tn = Integer.parseInt(br.readLine()); \t\t\tboard = new int[2][n]; \t\t\tdp = new int[2][n+1]; \t\t\t \t\t\tint i; \t\t\tfor(i=0; i&lt;2; i++) { \t\t\t\tst = new StringTokenizer(br.readLine()); \t\t\t\tint j; \t\t\t\tfor(j=0; j&lt;n; j++) { \t\t\t\t\tboard[i][j] = Integer.parseInt(st.nextToken()); \t\t\t\t} \t\t\t} \t\t\t \t\t\tdp[0][0] = 0; dp[1][0] = 0; \t\t\tdp[0][1] = board[0][0]; dp[1][1] = board[1][0]; \t\t\t \t\t\tint k ; \t\t\tfor(k=2; k&lt;=n; k++) { \t\t\t\tdp[0][k] = Math.max(dp[1][k-1] + board[0][k-1], dp[1][k-2] + board[0][k-1]); \t\t\t\tdp[1][k] = Math.max(dp[0][k-1] + board[1][k-1], dp[0][k-2] + board[1][k-1]); \t\t\t} \t\t\t \t\t\tSystem.out.println(Math.max(dp[0][n], dp[1][n])); \t\t} \t} }  "
  },
  
  {
    "title": "BOJ_2613_숫자구슬(Java)",
    "url": "/posts/BOJ2613%EC%88%AB%EC%9E%90%EA%B5%AC%EC%8A%ACJava/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-21 15:34:18 +0900",
    "content": "[Gold II] 숫자구슬 - 2613  문제 링크  성능 요약  메모리: 16320 KB, 시간: 144 ms  분류  이분 탐색, 다이나믹 프로그래밍, 그리디 알고리즘, 매개 변수 탐색  제출 일자  2024년 8월 21일 13:59:16  문제 설명  N개의 숫자 구슬이 &lt;그림 1&gt;과 같이 막대에 꿰어져 일자로 놓여 있다. 이들 구슬은 막대에서 빼낼 수 없고, 바꿀 수 없다.    이 숫자 구슬을 M개의 그룹으로 나누었을 때 각각의 그룹의 합 중 최댓값이 최소가 되도록 하려 하다. 예를 들어 세 그룹으로 나눈다고 할 때 &lt;그림 2&gt;와 같이 그룹을 나누면 그룹의 합은 각각 11, 15, 18이 되어 그 중 최댓값은 18이 되고, &lt;그림 3&gt;과 같이 나누면 각 그룹의 합은 각각 17, 12, 15가 되어 그 중 최댓값은 17이 된다. 숫자 구슬의 배열이 위와 같을 때는 그룹의 합 중 최댓값이 17보다 작게 만들 수는 없다. 그룹에 포함된 숫자 구슬의 개수는 0보다 커야 한다.    각 그룹의 합 중 최댓값이 최소가 되도록 M개의 그룹으로 나누었을 때, 그 최댓값과 각 그룹을 구성하는 구슬의 개수를 찾아 출력하는 프로그램을 작성하시오.  입력  첫째 줄에 구슬의 개수 N과 그룹의 수 M이 주어진다. 둘째 줄에는 각 구슬이 적혀진 숫자가 왼쪽부터 차례로 주어진다. N은 300 이하의 자연수, M은 N이하의 자연수이며, 구슬에 적혀진 숫자는 100 이하의 자연수이다.  출력  각 그룹의 합 중 최댓값이 최소가 되도록 M개의 그룹으로 나누었을 때 그 최댓값을 첫째 줄에 출력하고, 둘째 줄에는 각 그룹을 구성하는 구슬의 개수를 왼쪽부터 순서대로 출력한다. 구슬의 개수를 출력할 때는 사이에 한 칸의 공백을 둔다. 만약 그룹의 합의 최댓값이 최소가 되도록 하는 경우가 둘 이상이라면 그 중 하나만을 출력한다.     문제풀이   DP를 이용한 풀이     코드  import java.io.*; import java.util.*;  public class Main {     static int a[], sum[], dp[][], n, m;     static BufferedReader br;     static StringTokenizer st;     public static void main(String[] args) throws IOException {         br = new BufferedReader(new InputStreamReader(System.in)); //        br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));                  a = new int[305];         sum = new int[305];         dp = new int[305][305];                  st = new StringTokenizer(br.readLine());                  n = Integer.parseInt(st.nextToken());         m = Integer.parseInt(st.nextToken());          for (int[] row : dp) {             Arrays.fill(row, Integer.MAX_VALUE);         }          st = new StringTokenizer(br.readLine());         for (int i = 1; i &lt;= n; i++) {             a[i] = Integer.parseInt(st.nextToken());             sum[i] = sum[i - 1] + a[i];             dp[i][1] = sum[i];         }          dp[0][0] = 0;          for (int i = 1; i &lt;= m; i++) { // 그룹 수             for (int j = 1; j &lt;= n; j++) { // 구슬 수                 for (int k = 1; k &lt;= j; k++) {                     dp[j][i] = Math.min(dp[j][i], Math.max(dp[j - k][i - 1], sum[j] - sum[j - k]));                 }             }         }          System.out.println(dp[n][m]);         makeAns(n, m);     }          private static void makeAns(int j, int i) {       \tif (i == 0 &amp;&amp; j == 0) {     \t\treturn;     \t}     \tfor (int k = j; k &gt;= 1; k--) {     \t\tif (Math.max(dp[j - k][i - 1], sum[j] - sum[j - k]) == dp[j][i]) {     \t\t\tmakeAns(j - k, i - 1);     \t\t\tSystem.out.print(k + \" \");     \t\t\treturn;     \t\t}     \t}     } }  "
  },
  
  {
    "title": "BOJ_9935_문자열 폭발(Java)",
    "url": "/posts/BOJ9935%EB%AC%B8%EC%9E%90%EC%97%B4%ED%8F%AD%EB%B0%9CJava/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-21 15:28:06 +0900",
    "content": "[Gold IV] 문자열 폭발 - 9935  문제 링크  성능 요약  메모리: 122684 KB, 시간: 472 ms  분류  자료 구조, 스택, 문자열  제출 일자  2024년 8월 20일 21:17:21  문제 설명  상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.  폭발은 다음과 같은 과정으로 진행된다.   \t문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다. \t새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다. \t폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.   상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 \"FRULA\"를 출력한다.  폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.  입력  첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.  둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.  두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.  출력  첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.  코드 import java.io.*; import java.util.*;  public class Main {     static BufferedReader br;     static BufferedWriter bw;     static StringTokenizer st;     static String str, bomb;     static Deque&lt;Character&gt; deque = new ArrayDeque&lt;Character&gt;();          public static void main(String[] args) throws IOException {         br = new BufferedReader(new InputStreamReader(System.in));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         str = br.readLine();         bomb = br.readLine();           for (int i = 0; i &lt; str.length(); i++) {             deque.addLast(str.charAt(i));             if (deque.size() &gt;= bomb.length()) {                 isBombExist();             }         }                  bw.write(deque.isEmpty() ? \"FRULA\" : makeAns());          bw.flush();         bw.close();         br.close();     }      private static void isBombExist() {         if (deque.size() &lt; bomb.length()) return;          List&lt;Character&gt; temp = new ArrayList&lt;&gt;();         boolean isBomb = true;          for (int i = 0; i &lt; bomb.length(); i++) {             char c = deque.removeLast();             temp.add(c);             if (c != bomb.charAt(bomb.length() - 1 - i)) {                 isBomb = false;                 break;             }         }          if (!isBomb) {             for (int i = temp.size() - 1; i &gt;= 0; i--) {                 deque.addLast(temp.get(i));             }         }     }          private static String makeAns() {         StringBuilder sb = new StringBuilder();         while (!deque.isEmpty()) {             sb.append(deque.pollFirst());         }         return sb.toString();     } }   "
  },
  
  {
    "title": "BOJ_20055_컨베이어 벨트 위의 로봇(Java)",
    "url": "/posts/BOJ20055%EC%BB%A8%EB%B2%A0%EC%9D%B4%EC%96%B4-%EB%B2%A8%ED%8A%B8-%EC%9C%84%EC%9D%98-%EB%A1%9C%EB%B4%87Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-21 15:24:26 +0900",
    "content": "[Gold V] 컨베이어 벨트 위의 로봇 - 20055  문제 링크  성능 요약  메모리: 14512 KB, 시간: 248 ms  분류  구현, 시뮬레이션  제출 일자  2024년 8월 20일 15:17:05  문제 설명  길이가 N인 컨베이어 벨트가 있고, 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다.    벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 2N번 칸은 1번 칸의 위치로 이동한다. i번 칸의 내구도는 Ai이다. 위의 그림에서 1번 칸이 있는 위치를 \"올리는 위치\", N번 칸이 있는 위치를 \"내리는 위치\"라고 한다.  컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다. 언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다.  컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다. 로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다.      \t벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다. \t가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다. 만약 이동할 수 없다면 가만히 있는다. \t \t\t로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다. \t \t \t올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다. \t내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 그렇지 않다면 1번으로 돌아간다.   종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 가장 처음 수행되는 단계는 1번째 단계이다.  입력  첫째 줄에 N, K가 주어진다. 둘째 줄에는 A1, A2, ..., A2N이 주어진다.  출력  몇 번째 단계가 진행 중일때 종료되었는지 출력한다.     문제 풀이     코드 import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStreamWriter; import java.util.StringTokenizer;  public class Main { \t \tprivate static class Belt{ \t\tboolean isRobotOn; \t\tint value; \t\t \t\tBelt(boolean inRobotOn, int value){ \t\t\tthis.isRobotOn = isRobotOn; \t\t\tthis.value = value; \t\t} \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int[] beforeIdx, nextIdx; \tstatic int N, K, L, startIdx, dropIdx, rotateCnt, zeroValueCnt; \tstatic Belt[] conveyorBelt; \tpublic static void main(String[] args) throws IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tN = Integer.parseInt(st.nextToken()); \t\tK = Integer.parseInt(st.nextToken()); \t\tL = 2*N; \t\tbeforeIdx = new int[L]; \t\tnextIdx = new int[L]; \t\tstartIdx = 0; \t\tdropIdx = N-1; \t\t \t\tconveyorBelt = new Belt[L]; \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tint i; \t\tfor(i=0; i&lt;L; i++) { \t\t\tint value = Integer.parseInt(st.nextToken()); \t\t\tif (value == 0) zeroValueCnt++; \t\t\tconveyorBelt[i] = new Belt(false, value);  \t\t} \t\tmakeCircle(); \t\t \t\twhile(zeroValueCnt&lt;K) { \t\t\t \t\t\trotate(); \t\t\tdrop(); \t\t\tmove(); \t\t\taddRobot(); \t\t\t \t\t\trotateCnt++; \t\t} \t\tbw.write(String.valueOf(rotateCnt)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close();\t\t \t}  \tprivate static void rotate() { \t\tstartIdx = (startIdx + (L-1))%L; \t\tdropIdx = (startIdx + N - 1)%L; \t\tdrop(); \t} \t \tprivate static void drop() { \t\tif(conveyorBelt[dropIdx].isRobotOn) conveyorBelt[dropIdx].isRobotOn = false; \t} \t \tprivate static void move() { \t\tdropIdx = (startIdx + N - 1)%L; \t\tint i; \t\tfor(i=N-2; i&gt;=0; i--) { \t\t\tint beforeMoveIdx = (startIdx + i) % L; \t\t\tint afterMoveIdx = (beforeMoveIdx + 1) % L; \t \t\t\tif(conveyorBelt[beforeMoveIdx].isRobotOn &amp;&amp; !conveyorBelt[afterMoveIdx].isRobotOn) { \t\t\t\tif(conveyorBelt[afterMoveIdx].value &gt; 0) { \t\t\t\t\tconveyorBelt[beforeMoveIdx].isRobotOn = false; \t\t\t\t\tconveyorBelt[afterMoveIdx].isRobotOn = true; \t\t\t\t\tconveyorBelt[afterMoveIdx].value -= 1; \t\t\t\t\t \t\t\t\t\tif(conveyorBelt[afterMoveIdx].value == 0) zeroValueCnt++; \t\t\t\t\t \t\t\t\t\tif(afterMoveIdx == dropIdx) conveyorBelt[afterMoveIdx].isRobotOn = false; \t\t\t\t} \t\t\t} \t\t}  \t\t \t} \t \tprivate static void addRobot() { \t\tif(!conveyorBelt[startIdx].isRobotOn &amp;&amp; conveyorBelt[startIdx].value &gt; 0) { \t\t\tconveyorBelt[startIdx].isRobotOn = true; \t\t\tconveyorBelt[startIdx].value -= 1; \t\t\tif(conveyorBelt[startIdx].value &lt;= 0) zeroValueCnt ++; \t\t} \t} \t \tprivate static void makeCircle() { \t\tnextIdx[1] = 2; \t\tbeforeIdx[1] = 2*N-1; \t\tnextIdx[2*N-1] = 1; \t\tbeforeIdx[2*N-1] = 2*N-2; \t\tint i; \t\tfor(i=0; i&lt;2*N; i++) { \t\t\tnextIdx[i] = i+1; \t\t\tbeforeIdx[i] = i-1; \t\t} \t\t \t} }  "
  },
  
  {
    "title": "BOJ_2098_외판원 순회 (Java)",
    "url": "/posts/BOJ2098%EC%99%B8%ED%8C%90%EC%9B%90-%EC%88%9C%ED%9A%8C-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-20 10:09:45 +0900",
    "content": "[Gold I] 외판원 순회 - 2098  문제 링크  성능 요약  메모리: 20188 KB, 시간: 168 ms  분류  비트마스킹, 다이나믹 프로그래밍, 비트필드를 이용한 다이나믹 프로그래밍, 외판원 순회 문제  제출 일자  2024년 8월 19일 21:00:01  문제 설명  외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.  1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.  각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.  N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.  항상 순회할 수 있는 경우만 입력으로 주어진다.  출력  첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.     문제해결     코드 import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); \tstatic StringTokenizer st; \tstatic int N, map[][], dp[][]; \tpublic static void main(String[] args) throws IOException { \t\t// br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tN = Integer.parseInt(br.readLine()); \t\tmap = new int[N][N]; \t\tfor(int i = 0; i &lt; N; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tfor(int j = 0; j &lt; N; j++) { \t\t\t\tmap[i][j] = Integer.parseInt(st.nextToken()); \t\t\t} \t\t}  \t\tdp = new int[N][(1&lt;&lt;N)]; \t\tfor(int i = 0; i &lt; N; i++) { \t\t\tfor(int j = 0; j &lt; 1&lt;&lt;N; j++) { \t\t\t\tdp[i][j] = -1; \t\t\t} \t\t} \t\tSystem.out.println(TSP( 0, 1));; \t\t \t}  \t/** \t * start까지 visited경로로 가는 최소값 반환하는 함수 TSP \t * \t * @param start 현재 출발하는 시작점 \t * @param visited 방문처리 비트마스크 2진수 숫자 \t * @return dp[start][visited]  \t */ \tprivate static int TSP(int start, int visited) { \t\tif(visited == (1&lt;&lt;N) - 1) { \t\t\tif(map[start][0] != 0) { \t\t\t\treturn map[start][0]; \t\t\t} \t\t\telse return 987654321; \t\t}  \t\tif(dp[start][visited]!= -1) return dp[start][visited]; \t\tdp[start][visited] = 987654321; \t\tfor(int i = 0; i &lt; N; i++) {                  \t// 0인 곳과 이미 방문한 곳은 패스 \t\t\tif(map[start][i] == 0 || (visited &amp; (1&lt;&lt;i)) !=0) continue;  \t\t\t// i정점 방문하는 함수 재귀 \t\t\tint value = TSP(i, visited | (1&lt;&lt;i))+ map[start][i]; \t\t\tdp[start][visited] = Math.min(dp[start][visited],  value ); \t\t} \t\treturn dp[start][visited]; \t} }  "
  },
  
  {
    "title": "Docker & Kubernetes - (1)",
    "url": "/posts/Docker-Kubernetes-1/",
    "categories": "공부",
    "tags": "docker, kubernetes",
    "date": "2024-08-12 03:48:18 +0900",
    "content": " 쿠버네티스란? 컨테이너화의 의의와 쿠버네티스의 개요   쿠버네티스 Kubernetes :  컨테이너화된 애플리케이션을 효율적으로 배포하고 운영하기 위해 설계된 오픈 소스 플랫폼.  왜 컨테이너를 사용할까? CI/CD***** (지속적 통합, 지속적 배포) : 사용자에게 새로운 기능과 서비스를 빠르고 안정적으로 제공할 수 있음 그러나 개발자들이 오픈 소스를 사용해 애플리케이션을 개발할 때, 오픈소스의 버전이 바꾸미에 따라 같은 팀의 개발자 사이에 다른 버전을 사용하는 상황이 발생, 개발 환경 차이가 발생하여 생산성과 안정성이 떨어지게 된다.  컨테이너 기술은 애플리케이션 실행에 필요한 라이브러리나 운영체제 패키지 등을 모두 담아서 Immutable Infrastructure (불변의 실행 환경)을 만들고 개발자들 간에 테스트, 운영환경 차이를 없애 개발 생산성 증가와 안정적인 배포를 가능케 한다.          CI/CD(Continuous Integration/Continuous Delivery) : CI란 소프트웨어 개발시 테스트단계에서만 테스트 하는것이 아닌 일상적인 빌드와 테스트를 수행하여 실제 동작을 확인하는 사이클을 돌면서 소프트웨어 품질을 관리. 일반적으로 CI를 위한 전용 소프트웨어 or SaaS를 이용해 자동화. CD는 CI의 범위를 확장해 통합 테스트를 위한 스테이징 환경에 배포, 정식 서비스 배포까지 자동화도구를 사용해 수행.        쿠버네티스의 개요 쿠버네티스는 구글의 사내 운영 시스템인 Borg를 오픈소스로 만든 것. 다음과 같은 기능을 제공    배포 계획에 맞춰 애플리케이션을 신속하게 배포할 수 있다.            컨테이너 개수, CPU 사용률, 메모리 사용량을 설정 가능       저장 공간, 네트워크 접근 제어, 로드 밸런싱 기능 설정 가능           가동 중인 애플리케이션을 스케일 Up/Down 할 수 있다.            요청이 많을 때는 컨테이너 수를 늘려 처리 능력을 높임       요청이 적을때는 컨테이너 수를 줄여 자원 점유율이나 요금을 줄임           새로운 버전의 애플리케이션을 무정지로 업그레이드 할 수 있다.   하드웨어 가동률을 높여 자원 낭비를 줄인다.   "
  },
  
  {
    "title": "BOJ_11286_절댓값 힙 (Java)",
    "url": "/posts/BOJ11286%EC%A0%88%EB%8C%93%EA%B0%92-%ED%9E%99-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-12 03:33:55 +0900",
    "content": "[Silver I] 절댓값 힙 - 11286  문제 링크  성능 요약  메모리: 25872 KB, 시간: 416 ms  분류  자료 구조, 우선순위 큐  제출 일자  2024년 8월 12일 03:31:39  문제 설명  절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.   \t배열에 정수 x (x ≠ 0)를 넣는다. \t배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.   프로그램은 처음에 비어있는 배열에서 시작하게 된다.  입력  첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.  출력  입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.  Code import java.io.*; import java.util.*; import java.lang.*;  public class BOJ_11286_절댓값힙구하기 { \tstatic BufferedReader br; \tstatic int n; \tpublic static void main(String[] args) throws NumberFormatException, IOException { \t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tn = Integer.parseInt(br.readLine()); \t\tPriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((o1, o2) -&gt; { \t\t\tint a = Math.abs(o1); \t\t\tint b = Math.abs(o2); \t\t\tif(a == b) return o1 &lt; o2 ? -1 : 1; \t\t\telse return a - b; \t\t}); \t\t \t\tfor(int i=0; i&lt;n; i++) { \t\t\tint method = Integer.parseInt(br.readLine()); \t\t\tif(method == 0) { \t\t\t\tif (pq.isEmpty()) System.out.println(0); \t\t\t\telse System.out.println(pq.poll()); \t\t\t} else { \t\t\t\tpq.add(method); \t\t\t} \t\t} \t\t \t} }    "
  },
  
  {
    "title": "CODEFORCES CONTESTS - EPIC Institute of Technology Round August 2024 (Div. 1 + Div. 2) - Removals Game",
    "url": "/posts/CODEFORCES-CONTESTS-EPIC-Institute-of-Technology-Round-August-2024-Div.-1-Div.-2-Removals-Game/",
    "categories": "Code, Contests",
    "tags": "Java, codeforces, 알고리즘",
    "date": "2024-08-12 02:37:16 +0900",
    "content": " B. Removals Game  Problem Description  Alice has a permutation a1, a2, ..., an of [1, 2, ..., n], and Bob has another permutation b1, b2, ..., bn of [1, 2, ..., n]. They will play a game with these arrays.  In each turn, the following events happen in order:     Alice chooses either the first or the last element of her array and removes it from the array.   Bob chooses either the first or the last element of his array and removes it from the array.   The game continues for n-1 turns, after which both arrays will have exactly one remaining element: x in array a and y in array b.  If x = y, Bob wins; otherwise, Alice wins. Determine which player will win if both players play optimally.  Input  Each test case consists of multiple cases. The first line contains the number of test cases t (1 ≤ t ≤ 10^4). The description of each test case follows:     The first line of each test case contains an integer n (1 ≤ n ≤ 3 × 10^5).   The next line contains n integers a1, a2, ..., an, which is the permutation for Alice.   The next line contains n integers b1, b2, ..., bn, which is the permutation for Bob.   It is guaranteed that all ai and bi are distinct and the sum of all n does not exceed 3 × 10^5.  Output  For each test case, print a single line with the name of the winner, assuming both players play optimally. Print “Alice” if Alice wins; otherwise, print “Bob”.  Example  Input 2 2 1 2 1 2 3 1 2 3 2 3 1   Output Bob Alice  Note In the first test case, Bob can win the game by deleting the same element as Alice did.  In the second test case, Alice can delete 3  in the first turn, and then in the second turn, delete the element that is different from the one Bob deleted in the first turn to win the game.  Code  import java.io.*; import java.util.*;  public class MinimizeEqualSumSubarrays { \tstatic BufferedReader br; \tstatic StringTokenizer st;     public static void main(String[] args) throws IOException {         // 효율적인 입력을 위해 BufferedReader 사용    \t //        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         st = new StringTokenizer(br.readLine());                  int tc = Integer.parseInt(st.nextToken());         for (int t = 0; t &lt; tc; t++) {             st = new StringTokenizer(br.readLine());             int n = Integer.parseInt(st.nextToken());             int[] alice = new int[n]; // Alice의 순열을 저장할 배열             int[] bob = new int[n]; // Bob의 순열을 저장할 배열              st = new StringTokenizer(br.readLine());             for (int i = 0; i &lt; n; i++) {             \talice[i] = Integer.parseInt(st.nextToken());             }              st = new StringTokenizer(br.readLine());             for (int i = 0; i &lt; n; i++) {                 bob[i] = Integer.parseInt(st.nextToken());             }             System.out.println(solve(n, alice, bob));         }         br.close();     }      /**      * 앨리스 배열 양 끝 포인터와 밥 배열 양 끝 포인터 설정      * 앨리스 배열의 양쪽 끝 숫자가 밥 배열 양 끝 숫자와 전부 다르면 앨리스 승리      * 전부 비교할때까지 진행하며 같은것이 계속 있으면 밥 승리      *       * @param n 숫자 개수      * @param alice 앨리스 배열      * @param bob 밥 배열      * @return 승리자      */     private static String solve(int n, int[] alice, int[] bob) {         int leftA = 0, rightA = n - 1; // Alice 배열의 양 끝 포인터         int leftB = 0, rightB = n - 1; // Bob 배열의 양 끝 포인터          while (leftA &lt;= rightA) {             if (alice[leftA] != bob[leftB] &amp;&amp; alice[leftA] != bob[rightB]) {                 return \"Alice\";             }             if (alice[rightA] != bob[leftB] &amp;&amp; alice[rightA] != bob[rightB]) {                 return \"Alice\";             }              if (alice[leftA] == bob[leftB]) {                 leftA++;                 leftB++;             } else if (alice[leftA] == bob[rightB]) {                 leftA++;                 rightB--;             } else if (alice[rightA] == bob[leftB]) {                 rightA--;                 leftB++;             } else {                 rightA--;                 rightB--;             }         }                  return \"Bob\";     } }  "
  },
  
  {
    "title": "CODEFORCES CONTESTS - EPIC Institute of Technology Round August 2024 (Div. 1 + Div. 2) - Distanced Coloring",
    "url": "/posts/CODEFORCES-CONTESTS-EPIC-Institute-of-Technology-Round-August-2024-Div.-1-Div.-2/",
    "categories": "Code, Contests",
    "tags": "Java, codeforces, 알고리즘",
    "date": "2024-08-12 01:53:17 +0900",
    "content": "  A. Distanced Coloring You received an n×m grid from a mysterious source. The source also gave you a magic positive integer constant k . The source told you to color the grid with some colors, satisfying the following condition:                                    If (x1,y1), (x2,y2) are two distinct cells with the same color, then max(           x1−x2           ,           y1−y2           )≥k.                           You don’t like using too many colors. Please find the minimum number of colors needed to color the grid.  Input Each test contains multiple test cases. The first line contains the number of test cases t (1≤t≤1000 ). The description of the test cases follows. The only line of each test case consists of three positive integers n , m , k (1≤n,m,k≤104 ) — the dimensions of the grid and the magic constant.  Output For each test case, print a single integer — the minimum number of colors needed to color the grid.  Example InputCopy 6 3 3 2 5 1 10000 7 3 4 3 2 7 8 9 6 2 5 4   Output 4 5 12 6 36 8    Code import java.util.*;   public class Main { \tstatic int n, m, k;     public static void main(String[] args) {         Scanner sc = new Scanner(System.in);         int tc = sc.nextInt();         for (int i = 0; i &lt; tc; i++) {             n = sc.nextInt();             m = sc.nextInt();             k = sc.nextInt();             System.out.println(solve(n, m, k));         }      }       private static int solve(int n, int m, int k) {         int row = Math.min(n, k);         int col = Math.min(m, k);         return row * col;     }  "
  },
  
  {
    "title": "CODEFORCES CONTESTS - Round 965 (Div. 2) - Find K Distinct Points with Fixed Center",
    "url": "/posts/CODEFORCES-CONTESTS-Round-965-Div.-2/",
    "categories": "Code, Contests",
    "tags": "Java, codeforces, 알고리즘",
    "date": "2024-08-11 00:19:58 +0900",
    "content": "  A. Find K Distinct Points with Fixed Center time limit per test1 second memory limit per test256 megabytes  I couldn’t think of a good title for this problem, so I decided to learn from LeetCode.   You are given three integers xc, yc, and k (−100≤xc,yc≤100, 1≤k≤1000).  You need to find k distinct points (x1,y1), (x2,y2), …, (xk,yk), having integer coordinates, on the 2D coordinate plane such that:    their center∗ is (xc,yc)   −10^9≤xi,yi≤10^9 for all i from 1 to k It can be proven that at least one set of kk distinct points always exists that satisfies these conditions.   ∗∗The center of kk points (x1,y1x1,y1), (x2,y2x2,y2), ……, (xk,ykxk,yk) is (x1+x2+…+xkk,y1+y2+…+ykk)(x1+x2+…+xkk,y1+y2+…+ykk).  Input The first line contains tt (1≤t≤1001≤t≤100) — the number of test cases. Each test case contains three integers xcxc, ycyc, and kk (−100≤xc,yc≤100−100≤xc,yc≤100, 1≤k≤10001≤k≤1000) — the coordinates of the center and the number of distinct points you must output. It is guaranteed that the sum of kk over all test cases does not exceed 10001000. ####  Output For each test case, output kk lines, the ii-th line containing two space separated integers, xixi and yiyi, (−109≤xi,yi≤109−109≤xi,yi≤109) — denoting the position of the ii-th point. If there are multiple answers, print any of them. It can be shown that a solution always exists under the given constraints.  Example InputCopy 4 10 10 1 0 0 3 -5 -8 8 4 -5 3  OutputCopy 10 10 -1 -1 5 -1 -4 2 -6 -7 -5 -7 -4 -7 -4 -8 -4 -9 -5 -9 -6 -9 -6 -8 1000 -1000 -996 995 8 -10   Code  import java.util.*;   public class Main {     public static void main(String[] args) {         Scanner sc = new Scanner(System.in);         int t = sc.nextInt();                  while (t-- &gt; 0) {             int xc = sc.nextInt();             int yc = sc.nextInt();             int k = sc.nextInt();                          long sumX = 0, sumY = 0;                          for (int i = 0; i &lt; k - 1; i++) {             \t// 충분히 작은 값에서 시작                 int x = i - 500000;                  int y = i - 500000;                 System.out.println(x + \" \" + y);                 sumX += x;                 sumY += y;             }                          // 마지막 점 계산             long lastX = (long)k * xc - sumX;             long lastY = (long)k * yc - sumY;                          // 마지막 점의 좌표가 범위를 벗어나지 않도록 보정             lastX = Math.max(-1000000000, Math.min(1000000000, lastX));             lastY = Math.max(-1000000000, Math.min(1000000000, lastY));                          System.out.println(lastX + \" \" + lastY);         }     } }   "
  },
  
  {
    "title": "Docker Desktop Error",
    "url": "/posts/Docker-Desktop-Error/",
    "categories": "오류, 해결",
    "tags": "docker, error",
    "date": "2024-08-10 21:34:06 +0900",
    "content": "Docker Desktop - Unexpected WSL error   도커 데스크탑을 설치하고 마주한 오류창이다.  오류 메시지는 Windows Subsystem for Linux (WSL)가 아직 시스템에 설치되지 않았음을 나타낸다. Docker Desktop을 실행하기 위해서는 WSL2가 필요하다.  해결방법    WSL 설치하기: 관리자 권한으로 PowerShell을 열고 다음 명령어를 실행합니다:     wsl --install --no-distribution      이 명령어는 WSL을 설치하지만 Linux 배포판은 설치하지 않습니다.      "
  },
  
  {
    "title": "SWEA_Pro_끝말잇기2(Java)",
    "url": "/posts/SWEAPro%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B02Java/",
    "categories": "알고리즘",
    "tags": "Java, SWEA, 알고리즘",
    "date": "2024-08-10 11:23:35 +0900",
    "content": "[Pro] 끝말잇기2  성능 요약  메모리: 106,556 KB, 시간: 546 ms, 코드길이: 3,892 Bytes  제출 일자  2024-08-10 10:49     출처: SW Expert Academy, https://swexpertacademy.com/main/code/problem/problemList.do   코드 import java.io.BufferedReader; import java.io.FileInputStream; import java.io.InputStreamReader; import java.util.*;  class Solution // 기본제공 {     private static BufferedReader br;     private static final UserSolution userSolution = new UserSolution();      private final static int MAX_M = 50000;     private final static int MAX_LEN = 11;      private static final char[][] mWords = new char[MAX_M][MAX_LEN];      private static boolean run() throws Exception     {         StringTokenizer stdin = new StringTokenizer(br.readLine(), \" \");         boolean ok = true;         int N = Integer.parseInt(stdin.nextToken());         int M = Integer.parseInt(stdin.nextToken());          for (int i = 0; i &lt; M; i++)         {             String word = br.readLine();             Arrays.fill(mWords[i], (char)0);             word.getChars(0, word.length(), mWords[i], 0);         }          userSolution.init(N, M, mWords);          int cnt = Integer.parseInt(br.readLine());          for (int i = 0; i &lt; cnt; i++)         {             stdin = new StringTokenizer(br.readLine(), \" \");             int mID, ret, ans;             char mCh;              mID = Integer.parseInt(stdin.nextToken());             mCh = stdin.nextToken().charAt(0);             ret = userSolution.playRound(mID, mCh);             ans = Integer.parseInt(stdin.nextToken());             if (ret != ans)             {                 ok = false;             }         }          return ok;     }      public static void main(String[] args) throws Exception     { //         System.setIn(new java.io.FileInputStream(\"sample_input.txt\"));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"sample_input.txt\")));         StringTokenizer stinit = new StringTokenizer(br.readLine(), \" \");          int T, MARK;         T = Integer.parseInt(stinit.nextToken());         MARK = Integer.parseInt(stinit.nextToken());          for (int tc = 1; tc &lt;= T; tc++)         {             int score = run() ? MARK : 0;             System.out.printf(\"#%d %d\\n\", tc, score);         }          br.close();     } }  /**  * 단어 정렬 및 검색에 용이하도록 Treeset 사용하고  * 사용된 단어 검사는 Hashset으로 하도록 함  *   */ class UserSolution { \t \tstatic HashSet&lt;String&gt; usedWords; \tstatic TreeSet&lt;String&gt;[] words; \tstatic PlayerOrder po; \tstatic StringBuilder sb;      public void init(int N, int M, char[][] mWords) {     \twords = new TreeSet[26];         usedWords = new HashSet&lt;&gt;();                  // 각 알파벳에 대해 트리셋         for(int i=0; i&lt;26; i++) {         \twords[i] = new TreeSet&lt;&gt;();         }          po = new PlayerOrder(N);                  // Treeset에 영단어 첫글자 해당칸에 영단어 추가         for(int i=0; i&lt;M; i++) {             String str = makeWord(mWords[i]);             words[str.charAt(0)-'a'].add(str);         }     }      // void init(int N, int M, char mWords[][])로 M개가 그 길이만큼 2차원배열로 줌 String으로 붙여야함     private String makeWord(char[] word) {         sb = new StringBuilder();         for (char c : word) {             if (c == '\\0') return sb.toString();             else sb.append(c);         }         return sb.toString();     }          /**      * 해당 라운드에서 탈락한 플레이어 ID를 반환      *       * 영단어 선택해서 이전에 쓴 적있는지 보고      * 사용된 단어들을 usedWords에 추가      *       * @param mID 첫번째 턴을 진행할 플레이어 ID ( 1 ≤ mID ≤ N )      * @param mCh 첫번째 플레이어가 선택할 단어의 첫문자 (알파벳 소문자)      * @return 반환값은 탈락자      */     public int playRound(int mID, char mCh) {         Queue&lt;String&gt; addWords = new LinkedList&lt;String&gt;();         po.currentIdx = mID;          /**          * 현재 플레이어가 해당 알파벳으로 시작하는 영단어 있을때까지 찾아서 사전순 가장빠른 단어 선택          * 사용된 영단어에 넣고 단어 뒤집어 추가할 영단어큐에 추가          * 단어 맨 끝 알파벳을 시작 알파벳으로 설정하고 순서 다음으로 패스          *           * 라운드 끝나면 추가할 영단어 다 추가          */         while(!words[mCh-'a'].isEmpty()) {             String selected = words[mCh-'a'].pollFirst();             usedWords.add(selected);                          String reverseSelected = reverse(selected);             addWords.add(reverseSelected);                          mCh = selected.charAt(selected.length()-1);             po.next();         }                  // 현재 라운드 끝났고 현 시점 po는 탈락자         po.dropOut(po.currentIdx);          while(!addWords.isEmpty()) {             String addWord = addWords.poll();             // 이미 사용된 적 있으면 넘어가고 없으면 단어리스트 트리셋에도 추가             if(usedWords.contains(addWord))continue;             else words[addWord.charAt(0)-'a'].add(addWord);         }          return po.currentIdx;     }      private String reverse(String selected) {         StringBuilder sb = new StringBuilder();         for(int i=selected.length()-1; i&gt;=0; i--) {             sb.append(selected.charAt(i));         }         return sb.toString();     } }  /**  * 플레이어 순서 정하기 - 원형 사이클  * 플레이어 수만큼 사이클 만들고  * 앞 뒤 연결  * 플레이어 탈락시 삭제 위해 그 플레이어 앞과 뒤를 연결  */ class PlayerOrder {     int currentIdx;     int[] beforeIdx, nextIdx;      PlayerOrder(int n) {      \tcurrentIdx = 1;         this.beforeIdx = new int[n+1]; // 1부터시작         this.nextIdx = new int[n+1];         setOrder(n);     }      void next() {     \tcurrentIdx = nextIdx[currentIdx];     }          void setOrder(int N) {     \t// 첫 플레이어 앞 뒤 연결         nextIdx[1] = 2;         beforeIdx[1] = N;         // 마지막 플레이어 앞 뒤 연결         nextIdx[N] = 1;         beforeIdx[N] = N-1;         // 그 사이 모든 플레이어 앞 뒤 연결         for(int i=2; i&lt;N; i++) {             nextIdx[i] = i + 1;             beforeIdx[i] = i - 1;         }     }      void dropOut(int current) {         nextIdx[beforeIdx[current]] = nextIdx[current];         beforeIdx[nextIdx[current]] = beforeIdx[current];     } }  "
  },
  
  {
    "title": "BOJ_10840_구간 성분 (Java)",
    "url": "/posts/BOJ10840%EA%B5%AC%EA%B0%84-%EC%84%B1%EB%B6%84/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-08-05 02:24:03 +0900",
    "content": "[Gold I] 구간 성분 - 10840  문제 링크  성능 요약  메모리: 226464 KB, 시간: 936 ms  분류  해싱  제출 일자  2024년 8월 4일 21:34:43  문제 설명  매 초마다 신호를 발생시키는 두 장치 A, B가 있다. 이 신호는 알파벳 소문자의 서열로 표현된다. A, B로부터 발생한 신호를 서열로 표시한 SA, SB의 예는 다음과 같다.   \tSA = [a, f, c, d, r, d, e, s, d, c, f, w, s, z, r] \tSB = [g, e, d, s, r, d, d, e, m, z, r]   신호 서열의 어떤 구간에 포함된 문자의 종류와 개수가 순서에 상관없이 동일하면 이 두 ‘구간의 성분’은 같다고 한다. 아래에서 박스로 표시된 부분은 두 신호 SA, SB에서 성분이 같은 구간을 나타내고 있다.    즉 위의 예와 같이 성분이 같은 구간의 길이는 두 서열에서 반드시 같아야 한다. 그리고 같은 성분 의 구간은 하나 이상 존재할 수 있다. 우리는 두 신호 서열에 각각 존재하는 같은 성분 구간 중에 서 가장 긴 것을 찾으려고 한다.  입력  첫 두 줄에 신호 서열이 공백 없는 하나의 문자열로 각각 주어진다. 이 문자열은 영문 소문자로만 구성되어 있다. 두 입력 문자열의 크기 N, M의 범위는 1 ≤ N, M ≤ 1,500 이다.  출력  두 서열에서 같은 성분을 가진 구간 중에서 가장 긴 구간을 찾아, 그 구간의 길이를 출력해야 한다.      문제 풀이     코드 import java.io.*; import java.util.*;  public class BOJ_10840_구간성분 { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic String A, B; \tstatic boolean isExist = false; // A랑 B에 같은게 있는지 없는지 찾기 위한 변 \tstatic long[] hashTable = new long[26]; // a~z를 31의 거듭제곱으로 표현 \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new  BufferedWriter(new OutputStreamWriter(System.out)); \t\t \t\tString s1 = br.readLine(); String s2 = br.readLine(); \t\tif(s1.length() &gt; s2.length()) { \t\t\tString tmp = s1; \t\t\ts1 = s2; \t\t\ts2 = tmp; \t\t} \t\tA = s1; B = s2; // A 가 B보다 항상 짧거나 같도록만듬. \t\t \t\tfor(int i=0; i&lt;26; i++) { \t\t\tif(i==0) hashTable[0] = 1; \t\t\telse hashTable[i] = 31 * hashTable[i-1]; \t\t} //\t\tSystem.out.println(Arrays.toString(hashTable)); \t\t \t\tint maxLen = 0; \t\tfor(int i=1; i&lt;=A.length(); i++) { // 작은문자열 기준 길이 1부터 그길이 자체까지 비교해봐야함  \t\t\tSet&lt;Long&gt; set_A = new HashSet&lt;Long&gt;(); \t\t\tSet&lt;Long&gt; set_B = new HashSet&lt;Long&gt;(); \t\t\t \t\t\tlong hashVal_A = 0; long hashVal_B = 0; \t\t\tfor(int j = 0; j&lt;= B.length() - i; j++) { \t\t\t\t/** \t\t\t\t * i 길이에 해당하는 만큼 hashVal 구하기 \t\t\t\t * 처음에 hash값 구하고 한칸씩 왼쪽 -1 오른쪽 +1 시키면서 중복부분 기억하여 계산 최적화  \t\t\t\t *  \t\t\t\t */ \t\t\t\tif(j== 0) { \t\t\t\t\thashVal_A = hash(A, i);  \t\t\t\t\thashVal_B = hash(B, i);\t \t\t\t\t} else { \t\t\t\t\t/** \t\t\t\t\t * i길이만큼 자른것이 끝에 도달했는지 체크( unit의 끝 인덱스 j +i - 1, 원래 A의 인덱스 A.length() - 1 \t\t\t\t\t * A \t\t\t\t\t * 빼줄 left = A.charAt(j-1) - 'a' \t\t\t\t\t * 더해줄 right = A.charAt(j + (i - 1)) - 'a' \t\t\t\t\t *  \t\t\t\t\t * B \t\t\t\t\t * 빼줄 left = B.charAt(j-1) - 'a' \t\t\t\t\t * 더해줄 right = B.charAt(j + (i - 1)) - 'a'  \t\t\t\t\t */ \t\t\t\t\tif(j+(i-1) &lt;= A.length() -1) { // 경계조건 check \t\t\t\t\t\thashVal_A = hashVal_A - hashTable[A.charAt(j-1) - 'a'] + hashTable[A.charAt(j + (i - 1))-'a']; \t\t\t\t\t} \t\t\t\t\t \t\t\t\t\thashVal_B =hashVal_B - hashTable[B.charAt(j-1) - 'a'] + hashTable[B.charAt(j + (i - 1))-'a']; \t\t\t\t} \t\t\t\t// 나온 hash값을 각 set_A와 set_B에 추가 \t\t\t\tset_A.add(hashVal_A); \t\t\t\tset_B.add(hashVal_B); \t\t\t \t\t\t} // 길이별 해시값 추가 종료  \t\t\t \t\t\t// 이제 set_A길이 + set_B 길이가 A와 B 중복체크한 의 set과 원소 개수 같은지 check \t\t\tSet&lt;Long&gt; newSet = new HashSet&lt;Long&gt;(); \t\t\tnewSet.addAll(set_A); \t\t\tnewSet.addAll(set_B); \t\t\t \t\t\tisExist = set_A.size() + set_B.size() == newSet.size() ? false : true; \t\t\tif(isExist) maxLen = i; \t\t\t \t\t} //  특정 길이별 계산 종료  \t\t \t\tbw.write(String.valueOf(maxLen)); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close();  \t} \t \t/** \t * 해시값 만들기 - 카운팅 배열로 알파벳 개수 세고 그거 토대로 hash값을 hashTable값 곱해서 만들기 \t *  \t * @param s \t * @param l \t * @return \t */ \tprivate static long hash(String s, int l) { \t\tlong hash = 0; \t\tint[] count = new int[26]; \t\tfor(int i=0; i&lt;l; i++) { \t\t\tcount[s.charAt(i)- 'a']++; \t\t} \t\tfor(int i=0; i&lt; 26; i++) { \t\t\thash += count[i] * hashTable[i]; \t\t} \t\treturn hash; \t} }   "
  },
  
  {
    "title": "Hashing, 해싱 (feat. codetree)",
    "url": "/posts/Hashing-%ED%95%B4%EC%8B%B1-feat.-codetree/",
    "categories": "알고리즘",
    "tags": "알고리즘, 자료구조, 코드트리",
    "date": "2024-08-04 15:49:00 +0900",
    "content": "   Hashing 에 대한 학습 내용을 정리하고자 한다. 학습은 코드트리의 과정으로 진행되었다.   Hashing, 해싱이란 Why do we need to know? 배열에서 값을 찾을 때 인덱스와 같이 값이 있는 위치를 명시하여 그 값을 찾는다. 실제 데이터 관리/접근/조회 및 웹 사이트에서 다루는 경우 이는 최적의 방법은 아니다.  예시로 홈페이지 로그인을 생각해보자. 홈페이지 로그인 request로는 보통 아이디와 비밀번호가 필요하고, 로그인 시 아이디-비밀번호를 입력하면 서버에 저장된 아이디 비밀번호와 비교하여 일치하는지 확인하는 작업을 거칠것이고, 그 결과값에 따라 로그인 성공 실패 여부를 쳐리할 수 있다. 이때, 어떻게 아이디와 비밀번호를 찾는 방법은 어떤것이 있을까?          첫번째 방법으로는 아이디 - 비밀번호를 쌍으로 묶어 저장하는 방식이 있다. 특정 아이디와 특정 비밀번호를 고유 값으로 갖는 쌍의 데이터를 찾아 일치 여부를 확인하는 것이다. 하지만 이 방법의 단점은 대소관계 명시가 어렵다는 점이다. 로그일을 할 때 모든 아이디-비밀번호 쌍을 검색하여 일치정보를 찾는것은 당연히 비효율적이며 값에 특수문자 등이 포함된다면 정렬하기 매우 어려울 것 입니다.           이를 극복하기 위해 만든 두번째 저장 방법이 바로 해싱입니다.     Hashing     해시 함수란 임의의 데이터를 받아, 해당 데이터를 고정된 길이의 특정 값으로 반환하는 함수다. 어떠한 값을 넣더라고 특정 범위에 해당하는 값을 반환한다. 이때 해시함수의 반환값을 0이상의 정수를 반환하도록 설정한다면 배열의 인덱스에 해당하는 값을 저장하는 방식을 택할 수 있다.  이러한 저장 방식을 통해 값을 저장/관리하게되면 CRUD(삽입, 조회, 삭제)를 모두 해시함수 한번을 사용하면 가능하기 때문에 시간복잡도는 O(1)이 된다. 이러한 해시함수의 한계점은 대응할 수 없는 타입이 존재한다는 점이다. 해시함수를 사용할 때 문자열, 숫자, 등 각 타입에 맞는 해시함수가 존재하고 이를 적절하게 골라 사용하게 되는데 배열과 같이 내부에 값이 몇개 존재하는지 불분명한 경우 해시함수에서 사용할 수 없다. 해시함수에서는 배열과 같은 타입을 다루지 않기 때문이다. 그렇다면 해싱은 사용처가 매우 명확해진다. 해싱은 다룰 수 있는 타입의 특정 데이터가 들어온 순서에 상관 없이 CRUD 작업을 할 때 사용하기 좋다.  하지만 항상 문자열 관련으로 해싱을 사용한다는 뜻은 아니고, 배열의 매우 강력한 특성인 index 기반 데이터 정렬을 사용할 경우는 배열이 필요하고, 순서 상관없이 각 데이터가 자주 들어오고 나가는 경우는 해싱이 꼭 필요하다.      정리 Hashing의 특징    배열에 비해, 삭제 연산의 시간복잡도가 더 빠르다.   이중 연결 리스트에 비해, 탐색 연산이 시간복잡도가 더 빠르다.   삽입 삭제, 탐색에 걸리는 시간이 전부 O(1)이다.   해싱은 순서가 정해져 있지 않은 데이터를 처리하기에 적합하다.   해시 함수와 충돌 해시함수충돌에 들어가기에 앞서 언급한 해시 함수의 반환값을 0이상 정수로 만들어 배열의 인덱스와 연결하는 작업에 대해 자세히 알아보자. 이 상황에서 길이가 10인 배열과 예시 해시 함수로 f(x) = x라는 해시함수를 생각해보자. 그 결과  다음과 같이 누락되는 정보가 생긴다. 그럼 다음과 같이 해시함수를 바꿔보자 f(x) = x % 10;  그러면 모든 값을 0~9 인덱스에 할당 시킬 수 있다. 하지만 새로운 문제점이 발생한다. 한 인덱스에 여러 값이 들어가는 상황이 발생할 수 있기때문이다. 우리는 이를 해시 충돌 이라고 한다.  해시 충돌을 해결하기 위해 연결리스트를 사용한다. 이렇게 연결리스트를 통해 값을 저장하는 부분은 해결했지만 데이터를 조회할 때는 연결리스트를 순회해야하기 때문에 O(N)의 시간복잡도를 갖게 된다.  그렇기 때문에 해시 함수를 적절하게 만들어 해시 충돌이 최대한 덜 일어나도록 조정해야한다. 해시 충돌이 거의 일어나지 않으면 해시 함수의 반환값을 이용해 바로 조회, 삽입, 삭제가 가능하며 이 경우에서야 비로소 O(N)의 시간복잡도를 가진다고 할 수 있다. 각 프로그래밍 언어마다 이미 구현되어있는 해시함수는 이를 만족한다고 봐도 무방하다! 또한 해시 충돌을 최대한 줄이기 위해 값이 들어갈 배열 (해시 테이블)의 크기를 미리 크게 정의한다. 일반적으로 들어갈 최대 데이터의 3~4배 정도의 크기로 설정한다.  해시 충돌 정리    해시 함수에서 충돌이 발생하게 되면 그만큼 삽입/삭제/검색 시간이 증가한다.   해시 테이블의 크기를 키우면 충돌은 상대적으로 줄어드나, 메모리를 그만큼 많이 차지하게 된다.   해시 충돌과 효율성 해시 충돌은 성능에 얼마나 악영향을 끼칠까? 충돌되는 값들이 연결리스트로 저장되며, 탐색도 연결리스트의 탐색처럼 진행된다고 가정했을때 최악의 경우 삽입, 삭제, 검색의 시간복잡도는 O(N)이 된다.  "
  },
  
  {
    "title": "AWS RDS 설정 - 프리티어, MySQL",
    "url": "/posts/AWS-RDS-%EC%84%A4%EC%A0%95-%ED%94%84%EB%A6%AC%ED%8B%B0%EC%96%B4-MySQL/",
    "categories": "프로젝트",
    "tags": "aws, ec2, rds",
    "date": "2024-08-01 11:23:34 +0900",
    "content": "프로젝트를 EC2 서버를 사용해 배포하며 DB정보도 RDS를 통해 분산형 관계형 데이터베이스 서비스를 사용하는 김에 정리하게 되었다.     RDS 설정   먼저 아래 링크에서 루트 사용자로 로그인 하자 AWS RDS  좌측 데이터베이스를 클릭하자   RDS 인스턴스를 생성하기 위해 데이터베이스 생성을 클릭하자   필자는 범용적인 설정을 위해 표준생성 해주었다. 손쉬운 설정으로 기본에 커스텀하고싶으면 오른쪽을 선택하자  엔진 옵션 다음으로 사용하는 엔진 유형과 버전을 선택하자. 필자는 MySQL을 사용하고 있어 선택해 주었으며 버전도 선택하였다.  다만 인텔리제이에서 DataGrip을 사용중인데 자동으로 데이터베이스 드라이버를 다운로드 해 가장 최신 버전을 사용중이라면 일치하는 버전이 없을수도 있다.  하지만 일반적으로 MySQL의 마이너 버전 간에는 큰 차이가 없고, 호환성 문제도 거의 발생하지 않아 큰 문제는 없을것이다.    템플릿 다음으로 템플릿을 선택해주자. 프리티어 사용중이라면 프리티어 선택하는것을 권장한다.  아마 프리티어 선택 시 아래 가용성에서 단일 DB 인스턴스가 고정될 것이다.   설정 DB 인스턴스 설정으로 DB 인스턴스 식별자와 자격 증명 설정을 하도록 하자. 식별자 이름을 작성하고 필요하다면 암호를 만들면 된다. 필자는 자체 관리로 마스터 암호를 생성했다. - 비밀번호는 기록이나 기억해 두도록 하자  스토리지 프리티어를 선택했기 때문에 인스턴스 클래스는 버스터블 클래스(t클래스 포함)으로 자동 선택된 것이다.  해당 인스턴스 클래스 중 과금 방지를 위해 db.t2.micro를 선택했다. 스토리지 자동 조정 역시 과금 방지를 위해 체크를 해제하였다. 프리티어 지원 클래스에 db.t2.micro, db.t3.micro, db.t4g.micro가 있다.  **스토리지 설정에서 과금 방지를 위해 프리티어 최대 사용량이 20GiB이므로 20GiB으로 변경하고 스토리지 자동 조정도 꼭 꺼주자. **   연결 연결 설정 에서는 퍼블릭 액세스를 활성화하기 위해 EC2 컴퓨팅 리소스에 연결 안 함 을 선택한다. 나중에 VPC설정으로 EC2서버에서 RDS 접속 가능하다. 퍼블릭 엑세스는 예를 누르고 VPC보안그룹은 특정 그룹에 해당하는 경우에만 RDS 쓸 수 있게 하는 것이므로 새롭게 그룹 만들고 이름 작성하자. ~~_database가 무난하다 추가구성의 포트는 MySQL 기본포트 3306으로 설정했다.    태그 및 데이터베이스 인증은 편한대로 설정하자   추가 구성 데이터베이스 추가 구성에서 20GB이상 스냅샷이 생성되면 프리티어라도 결제될 수 있기 때문에 자동 백업을 비활성화하자.    월별 추정 비용 이렇게 적혀는 있는데 프리티어 한도 내에서 사용하면 과금되지 않으니 그 사용량 내에서 작업하도록 항상 체크하자   생성 후 확인하기      보안그룹 설정   서버에서 DB 접속 가능하게 하기 위한 설정 연결 및 보안에서 보안 그룹 규칙을 보면 Inbound에 자신의 로컬IP, Outbound는 모든 트래픽인 0.0.0.0/0일 것이다. 여기서 현재 보안 그룹 확인하자. Inbound 규칙을 선택 클릭하고 인바운드 규칙 편집. 아래와 같이 인바운드 규칙 추가하자      MySQL과 연결 및 DB, 테이블 생성   MySQL WorkBench사용해서 접속한 뒤 만들어보겠다. 위 Database에서 아까 생성 시 기억해야했던 정보들이 필요하다.    Hostname : 엔드포인트   Username : 마스터 아이디, 필자는 admin   Password : 마스터 암호    이렇게 생성 후 제대로 접속이 된다면 성공이다. 테스트를 진행해보자.    인텔리제이에서 연동하여보자   정상적으로 연결되었으며 잘 작동한다.  이 배포용 DB는 yml에서 연결정보를 다시 적어주어야한다.   datasource:     url: jdbc:mysql://(엔드포인트 추가 괄호는 제거)     username: 사용자 이름 (ex : admin)     password: 비밀번호 추가     driver-class-name: com.mysql.cj.jdbc.Driver      파라미터 그룹   timezone, 인코딩 등 DB 인스턴스 적용 옵션을 지정할 수 있다   편집에 들어가자      character 검색창에 character를 입력하고 아래 체크된 6개 파라미터의 값을 utf8mb4 로 작성후 변경사항 저장   Why? MySQL, MariaDB는 utf8로 세팅하는 경우 이모지(ex: 😄)문자가 입력되지 않아서 utf8mb4 라는 charset을 사용 . 이모지문자를 표현하기 위해서 글자당 최대 4bytes가 필요하지만 utf8에서는 가변3바이트를 사용하기 때문에 이모지문자가 깨지므로 4바이트를 사용하는 utf8mb4로 설정한다.  2. Time Zone 검색창에 time_zone 입력하고 Asia/Seoul 로 작성후 변경사항 저장   3. collation  검색창에 collation 입력하고 아래 2개 파라미터의 값을 utf8mb4_general_ci 로 작성후 변경사항 저장  설명         utf8mb4_general_ci는 MySQL에서 사용하는 문자 집합과 정렬 규칙의 조합입니다. 이 설정은 다음과 같은 의미를 가지고 있습니다:                      utf8mb4: 이는 MySQL의 문자 집합으로, 유니코드 문자 집합의 4바이트 버전입니다. utf8mb4는 utf8보다 더 넓은 범위의 유니코드 문자를 지원하여, 이모지와 같은 4바이트 문자를 포함한 다양한 문자를 저장할 수 있습니다.                       general: 이 부분은 문자 정렬 규칙을 나타냅니다. general은 일반적인 정렬 규칙을 사용하며, 대소문자 구분이 없는 비교를 지원합니다.                       ci: 이는 “case-insensitive”의 약자로, 대소문자를 구분하지 않는다는 의미입니다. 즉, A와 a는 동일한 문자로 간주됩니다.      따라서 utf8mb4_general_ci는 유니코드 문자 집합을 사용하고, 대소문자를 구분하지 않으며, 일반적인 정렬 규칙을 따르는 설정입니다. 이 설정은 대부분의 경우에 적합하며, 다양한 언어와 특수 문자를 처리할 수 있는 유연성을 제공   4. max_connections (선택사항) 이 부분은 동시 클라이언트 연결 수 설정인데 MySQL 5.7: 기본값은 151 MySQL 8.0: 기본값은 151 라고 한다. 기본값이 낮을 경우 설정을 바꿀 수 있을 것 같다. 일단 패스  다 적용했으면 데이터베이스로 돌아가서 자신의 DB선택 후 수정 누르기.  아까 생성할 때 보았던 파트 중 추가 구성으로 내려가   이렇게 자신의 파라미터 그룹으로 변경 후 즉시 적용으로  수정   "
  },
  
  {
    "title": "BOJ_10999_구간 합 구하기 2 (Java)",
    "url": "/posts/BOJ10999%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0-2-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-31 05:12:52 +0900",
    "content": "[Platinum IV] 구간 합 구하기 2 - 10999  문제 링크  성능 요약  메모리: 119644 KB, 시간: 784 ms  분류  세그먼트 트리, 느리게 갱신되는 세그먼트 트리, 자료 구조  제출 일자  2024년 7월 31일 05:05:27  문제 설명  어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째부터 4번째 수에 6을 더하면 1, 2, 9, 10, 5가 되고, 여기서 2번째부터 5번째까지 합을 구하라고 한다면 26을 출력하면 되는 것이다. 그리고 그 상태에서 1번째부터 3번째 수에 2를 빼고 2번째부터 5번째까지 합을 구하라고 한다면 22가 될 것이다.  입력  첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c 또는 a, b, c, d가 주어지는데, a가 1인 경우 b번째 수부터 c번째 수에 d를 더하고, a가 2인 경우에는 b번째 수부터 c번째 수의 합을 구하여 출력하면 된다.  입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.  출력  첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.     풀이 방법   Lazy propagation 학습 및 적용해보았다 Lazy propagation 처음 이해하는데 좀 오래 걸리니 간단히 설명하자면 구간을 업데이트 할 때는 특정 구간을 나타내는 특정 노드가 3가지 변화 중 한가지가 있을 수 있다.    변화없음   일부 변화   전부 변화 2번은 이전 세그먼트트리와 동일하게 업데이트 하면 되는데 3번은 특별하게 처리해야한다. lazy에 저장된 값과 구간의 개수만큼 곱해 더해주고 lazy값을 자식에게 넘겨주는 과정이 필요하다.  그래서 변화하는 것을 lazy propagation으로 위에서부터 차례차례 더할 값을 지연시켜 자식에게 전달하며 더하는 것이다.   import java.io.*; import java.util.*;  public class BOJ_10999_구간합구하기2 { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, K; \tstatic long[] tree, lazy, num;  \tpublic static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());  \t\tint treeHeight = (int) Math.ceil(Math.log(N) / Math.log(2)); \t\tint treeSize = 1 &lt;&lt; (treeHeight + 1);  \t\ttree = new long[treeSize];         lazy = new long[treeSize]; \t\tnum = new long[N+1];  \t\tfor (int i = 1; i &lt;= N; i++) { \t\t\tnum[i] = Long.parseLong(br.readLine()); \t\t} //\t\tSystem.out.println(Arrays.toString(num));  \t\tinit(1, N, 1);  \t\tfor (int i = 0; i &lt; M + K; i++) {             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             long c = Long.parseLong(st.nextToken());              if (a == 1) { // 숫자 업데이트                 long d = Long.parseLong(st.nextToken());                 update_range(1, N, 1, b, (int) c, d);             }              else { // a==2 인 경우 - 합계산                 bw.write(sum(1, N, 1, b, (int) c) + \"\\n\");             }                                             } \t\t         bw.flush();         bw.close();         br.close();  \t}  \t/* \t * 세그먼트 트리 초기화  \t * node : 세그먼트 트리의 정점 번호  \t * start : 이 정점이 관리하는 연속 구간의 왼쪽 끝  \t * end : 이 정점이 관리하는 연속 구간의 오른쪽 끝 \t *  \t */ \tprivate static long init(int start, int end, int node) { // 최솟값 트리  \t\tif (start == end) return tree[node] = num[start];  \t\tint mid = (start + end) / 2;          return tree[node] = init(start, mid, node*2) + init(mid + 1, end, node*2 + 1);  \t}  \t \t/** \t * Lazy propagation을 통해 현재 노드의 지연 값을 처리 \t * 노드의 지연 값(lazy[node])이 0이 아니면, 이 값을 현재 노드에 적용하고 자식 노드에 전달 \t *  \t * @param start \t * @param end \t * @param node \t */ \tprivate static void update_lazy(int start, int end, int node) {         if (lazy[node] != 0) {             tree[node] += (end - start + 1) * lazy[node];             if (start != end) {                 lazy[node*2] += lazy[node];                 lazy[node*2+1] += lazy[node];             }             lazy[node] = 0;         }     } \t \t/* \t * 세그먼트 트리 갱신  \t * node : 세그먼트 트리의 정점 번호  \t * start : 이 정점이 관리하는 연속 구간의 왼쪽 끝  \t * end : 이 정점이 관리하는 연속 구간의 오른쪽 끝 \t * from ~ to : 업데이트할 구간 \t * diff : 새로 더할 차이값 \t *  \t */\t \tprivate static void update_range(int start, int end, int node, int from, int to, long diff) {          \t\tupdate_lazy(start, end, node);          if (to &lt; start || end &lt; from) return;          if (from &lt;= start &amp;&amp; end &lt;= to) {             tree[node] += (end - start + 1) * diff;             if (start != end) {                 lazy[node*2] += diff;                 lazy[node*2+1] += diff;             }             return;         }          int mid = (start + end) / 2;         update_range(start, mid, node*2, from, to, diff);         update_range(mid+1, end, node*2+1, from, to, diff);          tree[node] = tree[node*2] + tree[node*2+1];     } \t \t// from ~ to 구간합 \tprivate static long sum(int start, int end, int node, int from, int to) { \t\t \t\t// 현재 노드의 lazy 값을 처리한 후에 업데이트 적용         update_lazy(start, end, node);          \t\t// 덧셈 항등원 사용 \t\tif (to &lt; start || end &lt; from) return 0;          if (from &lt;= start &amp;&amp; end &lt;= to) return tree[node];          int mid = (start + end) / 2;                  return sum(start, mid, node * 2, from, to) + sum(mid + 1, end, node * 2 + 1, from, to); \t} \t }   참고자료 RANGE OPERATIONS: LAZY PROPAGATION Lazy Propagation in Segment Tree Do we actually need lazy propagation on segment trees? Lazy propagation in segment tree? "
  },
  
  {
    "title": "BOJ_2042_구간 합 구하기 (Java)",
    "url": "/posts/BOJ2042%EA%B5%AC%EA%B0%84-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-31 04:30:33 +0900",
    "content": "[Gold I] 구간 합 구하기 - 2042  문제 링크  성능 요약  메모리: 102764 KB, 시간: 612 ms  분류  세그먼트 트리, 자료 구조  제출 일자  2024년 7월 31일 04:23:35  문제 설명  어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 합을 구하려 한다. 만약에 1,2,3,4,5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 합을 구하라고 한다면 17을 출력하면 되는 것이다. 그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 합을 구하라고 한다면 12가 될 것이다.  입력  첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000) 가 주어진다. M은 수의 변경이 일어나는 횟수이고, K는 구간의 합을 구하는 횟수이다. 그리고 둘째 줄부터 N+1번째 줄까지 N개의 수가 주어진다. 그리고 N+2번째 줄부터 N+M+K+1번째 줄까지 세 개의 정수 a, b, c가 주어지는데, a가 1인 경우 b(1 ≤ b ≤ N)번째 수를 c로 바꾸고 a가 2인 경우에는 b(1 ≤ b ≤ N)번째 수부터 c(b ≤ c ≤ N)번째 수까지의 합을 구하여 출력하면 된다.  입력으로 주어지는 모든 수는 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.  출력  첫째 줄부터 K줄에 걸쳐 구한 구간의 합을 출력한다. 단, 정답은 -263보다 크거나 같고, 263-1보다 작거나 같은 정수이다.     문제풀이   세그먼트트리에서 update부분만 고려해보았다.    범위 밖이라면 종료   리프 노드시 변경            해당 노드를 값을 변경하고 그 위 부모도 전부 합 새로 계산           코드 import java.io.*; import java.util.*;  public class BOJ_2042_구간합구하기 { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, K; \tstatic long[] tree, num;  \tpublic static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken());         K = Integer.parseInt(st.nextToken());  \t\tint treeHeight = (int) Math.ceil(Math.log(N) / Math.log(2)); \t\tint treeSize = 1 &lt;&lt; (treeHeight + 1);  \t\ttree = new long[treeSize]; \t\tnum = new long[N+1];  \t\tfor (int i = 1; i &lt;= N; i++) { \t\t\tnum[i] = Long.parseLong(br.readLine()); \t\t} //\t\tSystem.out.println(Arrays.toString(num));  \t\tinit(1, N, 1);  \t\tfor (int i = 0; i &lt; M + K; i++) {             st = new StringTokenizer(br.readLine());             int a = Integer.parseInt(st.nextToken());             int b = Integer.parseInt(st.nextToken());             long c = Long.parseLong(st.nextToken());              if (a == 1) { // 숫자 업데이트                 update(1, N, 1, b, c);                 num[b] = c;             }              else { // a==2 인 경우 - 합계산                 bw.write(sum(1, N, 1, b, (int) c) + \"\\n\");             }                                             } \t\t         bw.flush();         bw.close();         br.close();  \t}  \t/* \t * 세그먼트 트리 초기화  \t * node : 세그먼트 트리의 정점 번호  \t * start : 이 정점이 관리하는 연속 구간의 왼쪽 끝  \t * end : 이 정점이 관리하는 연속 구간의 오른쪽 끝 \t *  \t */ \tprivate static long init(int start, int end, int node) { // 최솟값 트리  \t\tif (start == end) return tree[node] = num[start];  \t\tint mid = (start + end) / 2;          return tree[node] = init(start, mid, node*2) + init(mid + 1, end, node*2 + 1);  \t}  \t/* \t * 세그먼트 트리 갱신  \t * node : 세그먼트 트리의 정점 번호  \t * start : 이 정점이 관리하는 연속 구간의 왼쪽 끝  \t * end : 이 정점이 관리하는 연속 구간의 오른쪽 끝 \t * idx : 업데이트할 위치 \t * value : 새로 업데이트 할 값 \t *  \t */\t \tprivate static void update(int start, int end, int node, int idx, long value) { \t\t         if (idx &lt; start || end &lt; idx) return;  \t\t// 리프 노드시 변경         if (start == end) {             tree[node] = value;             return;         } \t\t \t    else { \t    \tint mid = (start + end) / 2; \t\t         \t    \t// 왼쪽자식구간 \t        update(start, mid, node * 2, idx, value); \t         \t        // 오른쪽자식구간 \t        update(mid + 1, end, node * 2 + 1, idx, value);\t\t          \t        // 부모노드도 합 바뀌니까 자식 노드 업데이트 후 바뀐 자식 합으로 계산 다시해줌  \t\t    tree[node] = tree[node * 2] + tree[node * 2 + 1]; \t    }  \t         \t} \t \t// from ~ to 구간합 \tprivate static long sum(int start, int end, int node, int from, int to) { \t\t \t\t// 덧셈 항등원 사용 \t\tif (to &lt; start || end &lt; from) return 0;          if (from &lt;= start &amp;&amp; end &lt;= to) return tree[node];          int mid = (start + end) / 2;                  return sum(start, mid, node * 2, from, to) + sum(mid + 1, end, node * 2 + 1, from, to); \t} \t }  "
  },
  
  {
    "title": "BOJ_최솟값과 최댓값_2357 (Java)",
    "url": "/posts/BOJ%EC%B5%9C%EC%86%9F%EA%B0%92%EA%B3%BC-%EC%B5%9C%EB%8C%93%EA%B0%922357-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-31 03:17:55 +0900",
    "content": "[Gold I] 최솟값과 최댓값 - 2357  문제 링크  성능 요약  메모리: 58600 KB, 시간: 696 ms  분류  세그먼트 트리, 자료 구조  제출 일자  2024년 7월 31일 03:07:55  문제 설명  N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수, 또는 제일 큰 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.  여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최소, 최댓값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.  입력  첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.  출력  M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 최솟값, 최댓값 순서로 출력한다.     ## 문제 풀이   이전 풀었던 세그먼트 트리와 같다. 이전 학습하며 정리한 필기를 복기     코드 import java.io.*; import java.util.*;  public class BOJ_2357_최솟값과최댓값 { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M; \tstatic int[] minTree, maxTree, num;  \tpublic static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tint treeHeight = (int) Math.ceil(Math.log(N) / Math.log(2)); \t\tint treeSize = (int) Math.pow(2, treeHeight + 1) - 1;  \t\tminTree = new int[treeSize]; \t\tmaxTree = new int[treeSize]; \t\tnum = new int[N+1];  \t\tfor (int i = 1; i &lt;= N; i++) { \t\t\tnum[i] = Integer.parseInt(br.readLine()); \t\t} \t\t// System.out.println(Arrays.toString(num));  \t\tinitMinTree(1, N, 1); \t\tinitMaxTree(1, N, 1);  \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint from = Integer.parseInt(st.nextToken()); \t\t\tint to = Integer.parseInt(st.nextToken()); \t\t\tbw.write(getMin(1, N, 1, from, to) + \" \" + getMax(1, N, 1, from, to) + \"\\n\"); \t\t} \t\t         bw.flush();         bw.close();         br.close();  \t}  \t/* \t * 세그먼트 트리 초기화  \t * node : 세그먼트 트리의 정점 번호  \t * start : 이 정점이 관리하는 연속 구간의 왼쪽 끝  \t * end : 이 정점이 관리하는 연속 구간의 오른쪽 끝 \t *  \t */ \tprivate static int initMinTree(int start, int end, int node) { // 최솟값 트리  \t\tif (start == end) return minTree[node] = num[start];  \t\tint mid = (start + end) / 2;  \t\treturn minTree[node] = Math.min(initMinTree(start, mid, node*2), initMinTree(mid + 1, end, node*2 + 1));  \t} \t \tprivate static int initMaxTree(int start, int end, int node) { // 최댓값 트리 \t\t \t\tif (start == end) return maxTree[node] = num[start]; \t\t \t\tint mid = (start + end) / 2; \t\t \t\treturn maxTree[node] = Math.max(initMaxTree(start, mid, node*2), initMaxTree(mid + 1, end, node*2 + 1)); \t\t \t}  \t// from ~ to 구간 최솟값 \tprivate static int getMin(int start, int end, int node, int from, int to) { \t\t// 보고있는 노드의 구간이 원하는 범위 밖인 경우 \t\tif (from &gt; end || to &lt; start) return Integer.MAX_VALUE;  \t\t// 보고있는 노드의 구간이 원하는 범위 안인 경우 \t\tif (from &lt;= start &amp;&amp; to &gt;= end) return minTree[node];  \t\t// 그 외 걸치는 경우는 재귀적으로 두 자식노드로 나눠서 최솟값 구하기 \t\tint mid = (start + end) / 2; \t\t \t\treturn Math.min(getMin(start, mid, node*2, from, to), getMin(mid + 1, end, node*2 + 1, from, to)); \t \t} \t \t// from ~ to 구간 최댓값 \tprivate static int getMax(int start, int end, int node, int from, int to) { \t\t// 보고있는 노드의 구간이 원하는 범위 밖인 경우 \t\tif (from &gt; end || to &lt; start) return Integer.MIN_VALUE; \t\t \t\t// 보고있는 노드의 구간이 원하는 범위 안인 경우 \t\tif (from &lt;= start &amp;&amp; to &gt;= end) return maxTree[node]; \t\t \t\t// 그 외 걸치는 경우는 재귀적으로 두 자식노드로 나눠서 최댓값 구하기 \t\tint mid = (start + end) / 2; \t\t \t\treturn Math.max(getMax(start, mid, node*2, from, to), getMax(mid + 1, end, node*2 + 1, from, to)); \t\t \t}  }   "
  },
  
  {
    "title": "BOJ_10868_최솟값 (Java)",
    "url": "/posts/BOJ10868%EC%B5%9C%EC%86%9F%EA%B0%92-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-31 03:14:43 +0900",
    "content": "[Gold I] 최솟값 - 10868  문제 링크  성능 요약  메모리: 53688 KB, 시간: 648 ms  분류  세그먼트 트리, 희소 배열, 자료 구조  제출 일자  2024년 7월 31일 03:09:03  문제 설명  N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.  여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최솟값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.  입력  첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.  출력  M개의 줄에 입력받은 순서대로 각 a, b에 대한 답을 출력한다.     문제 풀이         세그먼트트리에 대한 공부 후 문제를 바로 풀어보았다. 기본적으로 알아야 할 부분은 세그먼트 트리의 높이와 크기, init과정 및 최대값, 최소값, 구간합 구하는 과정을 알아야 한다.  코드 import java.io.*; import java.util.*;  public class BOJ_10868_최솟값 { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M; \tstatic int[] tree, num;  \tpublic static void main(String[] args) throws IOException { //        br = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));  \t\tst = new StringTokenizer(br.readLine()); \t\tN = Integer.parseInt(st.nextToken()); \t\tM = Integer.parseInt(st.nextToken()); \t\tint treeHeight = (int) Math.ceil(Math.log(N) / Math.log(2)); \t\tint treeSize = (int) Math.pow(2, treeHeight + 1) - 1;  \t\ttree = new int[treeSize]; \t\tnum = new int[N+1];  \t\tfor (int i = 1; i &lt;= N; i++) { \t\t\tnum[i] = Integer.parseInt(br.readLine()); \t\t} \t\t// System.out.println(Arrays.toString(num));  \t\tinit(1, N, 1);  \t\tfor (int i = 0; i &lt; M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint from = Integer.parseInt(st.nextToken()); \t\t\tint to = Integer.parseInt(st.nextToken());  \t\t\tbw.write(getMin(1, N, 1, from, to) + \"\\n\"); \t\t} \t\t     bw.flush();     bw.close();     br.close(); \t}  \t/* \t * 세그먼트 트리 초기화  \t * node : 세그먼트 트리의 정점 번호  \t * start : 이 정점이 관리하는 연속 구간의 왼쪽 끝  \t * end : 이 정점이 관리하는 연속 구간의 오른쪽 끝 \t *  \t */ \tprivate static int init(int start, int end, int node) {  \t\tif (start == end) return tree[node] = num[start];  \t\tint mid = (start + end) / 2;  \t\treturn tree[node] = Math.min(init(start, mid, node*2), init(mid + 1, end, node*2 + 1));  \t}  \t// from ~ to 구간 최솟값 \tprivate static int getMin(int start, int end, int node, int from, int to) { \t\t// 보고있는 노드의 구간이 원하는 범위 밖인 경우 \t\tif (from &gt; end || to &lt; start) return Integer.MAX_VALUE;  \t\t// 보고있는 노드의 구간이 원하는 범위 안인 경우 \t\tif (from &lt;= start &amp;&amp; to &gt;= end) return tree[node];  \t\t// 그 외 걸치는 경우는 재귀적으로 두 자식노드로 나눠서 최솟값 구하기 \t\tint mid = (start + end) / 2; \t\t \t\treturn Math.min(getMin(start, mid, node*2, from, to), getMin(mid + 1, end, node*2 + 1, from, to)); \t \t}  }  "
  },
  
  {
    "title": "Operating System Concepts - (4)",
    "url": "/posts/Operating-System-Concepts-4/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2024-07-29 03:10:52 +0900",
    "content": "   병행제어   데이터의 접근      Race Condition(경쟁상태)     중복 접근이 발생하는 경우 결과 값에 문제가 발생해 원치 않은 결과를 얻게 될 수 있다   OS 에서 Race Condition이 발생하는 경우    Kernel 수행 중 인터럽트 발생 (interrupt handler vs kernel)             중요한 변수값을 kernel이 처리하는 경우 interrupt 처리를 disable 시켜서 kernel이 수행하는 프로세스가 종료된 후 interrupt를 처리하는 방식으로 문제를 주로 해결함.           Process가 System Call을 발생시켜 Kernel mode로 수행 중인데 문맥교환(Context Switch)이 발생하는 경우        해결방안 : 커널 모드에서 수행 중일 때는 CPU를 preempt하지 않음. 커널 모드에서 사용자 모드로 돌아갈 때 preempt   3.** Multiprocessor에서 shared memory 내의 kernel data**      방법 1은 큰 overhead발생으로 비효율적임   lock을 걸어서 다른 어느 누구도 현재 사용하고 있는 data에 접근하지 못하도록 하는 해결법.   프로세스가 끝난 후에는 lock을 해제하여 다른 프로세스도 사용할 수 있도록 처리함.   Process Synchronization Problem    shared data(공유 데이터)의 concurrent access(동시 접근)은 데이터의 inconsistency(불일치)를 발생시킬 수 있다.   Consistency(일관성) 유지를 위해서는 cooperating procee(협력 프로세스)간의 orderly execution(실행 순서)를 정의해주는 메커니즘이 필요하다.   Race Condition            여러 프로세스들이 동시에 공유 데이터를 접근하는 상황       데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 바뀜           race condition을 막기 위해서는 공존하 프로세스(concurrent process)가 동기화(Synchronize)되어야 한다.   ## The Critical-Section Problem    n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우   각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재   문제점 : 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 함   Initial Attempts to solve problem    두 개의 프로세스가 있다고 가정. P0, P1 : 프로세스들의 일반적인 구조      do {    entry section    critical section    exit section    reminder section  } while(1);           Synchronization variable : 프로세스들은 수행의 동기화(Synchronize)를 위해 몇몇 변수를 공유할 수 있음   프로그램적 해결법의 충족 조건    Mutual Exclusion (상호 배제)            프로세스 Pi가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 그들의 critical section에 들어가면 안 된다.       프로세스는 서로 배타적이어야 한다.           Progress (진행)            아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해 주어야 한다.       만족하지 못하는 경우가 있기 때문에 당연하지만 중요한 충족 조건임.           Bounded Waiting (유한 대기)            프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용할 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.       starvation(기아 상태)이 발생하지 않는 것을 의미함.           가정    모든 프로세스의 수행 속도는 0보다 크다   프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.   Synchronization Algorithm Method 1         Synchronization variable int turn; -&gt; 어떤 프로세스의 차례인지를 나타내는 변수값으로 사용 initially turn = 0; =&gt; P1 can enter its critical section if(turn == i)      Process P0     do { while (turn != 0);  # My turn? 0은 자기자신 critical section turn = 1;           # Now it's your turn 1이 다른 프로세스 remainder section } while(1);           Process P1     do { while (turn != 1);  # My turn?  critical section turn = 0;           # Now it's your turn remainder section } while(1);           turn 변수값을 파악 후 while문의 조건이 true면 무한루프를 돌면서 대기. 나머지 프로세스는 critical section에 진입. 나머지 프로세스가 critical section에서 빠져나오면 turn 변수값의 값이 변경되므로 대기하던 프로세스는 while문에서 빠져나와 critical section에 진입 가능하게 됨.   Satisfies mutual exclusion, but not progress (과잉 양보) -반드시 한번씩 교대로 들어가야만 함. (swap-turn) turn 값을 내 값으로 바꿔줘야만 내가 critical section에 들어갈 수 있음.   만약 특정 프로세스가 더 빈번히 critical section에 들어가야 한다면 turn 변수값을 변경하지 않고 계속 critical section을 점유하게 될 수도 있으므로 이 알고리즘은 완벽한 알고리즘은 아님.   Method 2    Synchronization variable boolean flag[2]; initially flag[all] = false; =&gt; No one is in CS (critical section)        Pi ready to enter its critical section if (flag[i] == true)      Process Pi     do { flag[i] = true;   # Pretend I am in (프로세스에 들어가고 싶다는 의사 표시) while (flag[j]);  # Is It also in? than wait (프로세스가 이미 점유되고 있는지 확인) critical section flag[i] = false;  # I'm out now remainder section } while(1);           Satisfies mutual exclusion, but not progress requirement.   둘 다 2행까지 수행 후 끊임 없이 양보하는 상황 발생 가능   Method 3 (Peterson’s Algorithm)    Combined synchronization variables of algorithms 1 and 2   Process Pi     do { flag[i] = true;   # My intention is to enter ... turn = j;         # set to its turn while (flag[j] &amp;&amp; turn == j);  critical section flag[i] = false;  # I'm out now remainder section } while(1);           Meets all three requirements. solves the critical section problem for two processes.   Busy waiting (= spin lock, 계속 CPU와 memory를 사용하면서 waiting)   Synchronization Hardware    하드웨어적으로 Test &amp; Modify를 동시에 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결됨.   Mutual Exclusion with Test &amp; set            Synchronization variable boolean lock = false           do {   while (Test_and_Set(lock));    critical section   lock = false;         remainder section } while(1);     하드웨어적으로 읽는 작업과 값을 세팅하는 작업을 동시에 할 수 있다는 가정 하에 만들어진 해결 방법   Semaphonrs (세마포) - 추상 자료형    lock을 걸고 lock을 푸는 과정을 쉽게 구현   자원을 얻고 반납하는 과정을 효율적으로 정의   Semaphore S            Integer variable (정수)       아래의 두 가지 atomic 연산에 의해서만 접근 가능                p(S): 자원을 획득      while(S &lt;= 0) do no-op;  # wait  S--;           누군가가 자원을 반납하면 S를 1 감소시키고 작업을 실행   추상적으로 연산을 구현해놓은 것        자원이 있으면 가져가는 것이고 없으면 while문을 돌면서 대기하는 것. (busy-wait은 발생하게 됨.)           V(S): 자원을 반납     S++;           Critical Section of n Processes Synchronization variable semaphore mutex;  # 추상 변수처럼 semaphore 정의  Process Pi; do {   P(mutex);   critical section   V(mutex);   remainder section } while(1);     busy-wait은 효율적이지 못함. (= spin lock)   Block &amp; Wake-up 방식의 구현 (= sleep lock)   Block / Wakeup Implementation    Semaphore를 다음과 같이 정의      typedef struct {   int value;            # Semaphore   struct process *L;    # process wait queue } semaphore;           block과 wakeup을 다음과 같이 가정            block : 세마포를 획득할 수 없으면, 커널은 block을 호출한 프로세스를 suspend 시킴. 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음.       wakeup(P) : block된 프로세스 P를 wakeup 시킴. 이 프로세스의 PCB를 ready queue로 옮김.           semaphore 연산이 이제 다음과 같이 정의됨.     p(S):     S.value++;                       # 자원을 다 쓰고 나면 S.value 값 증가시키기 (반납) if(S.value &lt;= 0) {   remove a process P from S.L;   # ready queue에서 삭제   wakeup(P);                     # 만약 잠들어 있다면, 프로세스 깨우기 }              V(S):  S.value--;                  # Prepare to enter  if(S.value &lt; 0) {           # 자원 여분 X. Semaphore 획득 실패 (대기 상태)    add this process to S.L;  # ready queue에 추가    block();                  # block 상태  }    Busy-Wait vs Block &amp; Wakeup    Critical Section의 경쟁이 치열한 경우(길이가 긴 경우) Block &amp; wakeup이 적당.   Critical Section의 경쟁이 치열하지 않은 경우(길이가 매우 짧은 경우) Block &amp; Wakeup 오버헤드가 busy-wait 오버헤드보다 더 커질 수 있음   Block &amp; wakeup 방식이 일반적으로 더 효율적임.   Types of Semaphores    Counting Semaphore            도메인이 0 이상인 임의의 정수값       주로 resource counting 에 사용 -Binary Semaphore (= mutex)       0 또는 1 값만 가질 수 있는 semaphore       주로 mutual exclusion (lock/unlock)에 사용           "
  },
  
  {
    "title": "BOJ_19951_태상이의 훈련소 생활 (Java)",
    "url": "/posts/BOJ19951%ED%83%9C%EC%83%81%EC%9D%B4%EC%9D%98-%ED%9B%88%EB%A0%A8%EC%86%8C-%EC%83%9D%ED%99%9C/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-24 04:37:46 +0900",
    "content": "[Gold V] 태상이의 훈련소 생활 - 19951  문제 링크  성능 요약  메모리: 76688 KB, 시간: 740 ms  분류  누적 합  제출 일자  2024년 7월 24일 04:34:46  문제 설명  2020년 5월 14일 논산훈련소에 입대한 태상이는 첫 총기 훈련에서 가스 조절기를 잃어버리는 중대한 실수를 범했다. 그로 인해, 태상이는 조교들에게 눈총을 받게 되었다. 조교들은 태상이에게 연병장(운동장)의 흙을 옮기는 일을 주고 제대로 수행하지 못하면 징계를 내리려고 한다.  연병장은 일렬로 이어진 N개의 칸으로 이루어져 있으며 각 칸마다 높이를 가지고 있고, 첫 번째 칸부터 순서대로 1번, 2번, 3번, ..., N번 칸으로 명칭이 붙어있다. 조교들은 총 M명이 있으며, 각 조교들은 태상이에게 a번 칸부터 b번 칸까지 높이 k만큼 흙을 덮거나 파내라고 지시한다. 흙은 주변 산에서 얼마든지 구할 수 있으므로 절대로 부족하지 않다.  태상이는 각 조교의 지시를 각각 수행하면, 다른 조교의 지시로 흙을 덮어둔 칸을 다시 파내기도 하는 비효율적인 일이 발생하는 것을 깨달았다. 그래서 태상이는 각 조교의 지시를 모아 연병장 각 칸의 최종 높이를 미리 구해 한 번에 일을 수행하려고 한다.  불쌍한 태상이를 위해 조교들의 지시를 모두 수행한 뒤 연병장 각 칸의 높이를 구하자.  입력  첫 줄에 연병장의 크기 N과 조교의 수 M이 주어진다.  둘째 줄에 연병장 각 칸의 높이 Hi가 순서대로 N개 주어진다.  셋째 줄부터 M개의 줄에 각 조교의 지시가 주어진다.  각 조교의 지시는 세 개의 정수 a, b, k로 이루어져 있다.   \tk ≥ 0인 경우 a번 칸부터 b번 칸까지 높이가 각각 |k| 만큼 늘어나도록 흙을 덮어야 한다. \tk &lt; 0인 경우 a번 칸부터 b번 칸까지 높이가 각각 |k| 만큼 줄어들도록 흙을 파내야 한다.   출력  모든 지시를 수행한 뒤 연병장 각 칸의 높이를 공백을 사이에 두고 출력한다.     문제 풀이     코드 import java.io.*; import java.util.*;  public class BOJ_19951_태상이의훈련소생활 { \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, height[], sum[], a, b, k; \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine());\t \t\tStringBuilder sb = new StringBuilder(); \t \t\tN = Integer.valueOf(st.nextToken()); \t\tM = Integer.valueOf(st.nextToken()); \t\t \t\tst = new StringTokenizer(br.readLine());\t \t\theight = new int[N+1]; \t\tsum = new int[N+2]; \t\tfor(int i=1; i&lt;=N; i++) {\t \t\t\theight[i] = Integer.valueOf(st.nextToken()); \t\t}  \t\tfor(int i=0; i&lt;M; i++) { \t\t\tst = new StringTokenizer(br.readLine());\t \t\t\ta = Integer.valueOf(st.nextToken()); \t\t\tb = Integer.valueOf(st.nextToken()); \t\t\tk = Integer.valueOf(st.nextToken()); \t\t\tsum[a] += k; \t\t\tsum[b+1] -= k; \t\t} \t\t \t\tfor(int i=1; i&lt;=N; i++) {\t \t\t\tsum[i] += sum[i-1]; \t\t} \t\t \t\tfor(int i=1; i&lt;=N; i++) {\t \t\t\theight[i] += sum[i]; \t\t\tsb.append(height[i] + \" \"); \t\t} \t\tbw.write(sb.toString()); \t\tbw.flush(); \t\tbw.close(); \t\tbr.close(); \t} }   "
  },
  
  {
    "title": "BOJ_5972_택배배송 (Java)",
    "url": "/posts/BOJ5972%ED%83%9D%EB%B0%B0%EB%B0%B0%EC%86%A1-Java-zfwwpzaj/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-24 03:59:50 +0900",
    "content": "[Gold V] 택배 배송 - 5972  문제 링크  성능 요약  메모리: 42300 KB, 시간: 456 ms  분류  데이크스트라, 그래프 이론, 최단 경로  제출 일자  2024년 7월 24일 03:35:55  문제 설명  농부 현서는 농부 찬홍이에게 택배를 배달해줘야 합니다. 그리고 지금, 갈 준비를 하고 있습니다. 평화롭게 가려면 가는 길에 만나는 모든 소들에게 맛있는 여물을 줘야 합니다. 물론 현서는 구두쇠라서 최소한의 소들을 만나면서 지나가고 싶습니다.  농부 현서에게는 지도가 있습니다. N (1 &lt;= N &lt;= 50,000) 개의 헛간과, 소들의 길인 M (1 &lt;= M &lt;= 50,000) 개의 양방향 길이 그려져 있고, 각각의 길은 C_i (0 &lt;= C_i &lt;= 1,000) 마리의 소가 있습니다. 소들의 길은 두 개의 떨어진 헛간인 A_i 와 B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N; A_i != B_i)를 잇습니다. 두 개의 헛간은 하나 이상의 길로 연결되어 있을 수도 있습니다. 농부 현서는 헛간 1에 있고 농부 찬홍이는 헛간 N에 있습니다.  다음 지도를 참고하세요.             [2]---           / |    \\          /1 |     \\ 6         /   |      \\      [1]   0|    --[3]         \\   |   /     \\2         4\\  |  /4      [6]           \\ | /       /1            [4]-----[5]                  3    농부 현서가 선택할 수 있는 최선의 통로는 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 입니다. 왜냐하면 여물의 총합이 1 + 0 + 3 + 1 = 5 이기 때문입니다.  농부 현서의 지도가 주어지고, 지나가는 길에 소를 만나면 줘야할 여물의 비용이 주어질 때 최소 여물은 얼마일까요? 농부 현서는 가는 길의 길이는 고려하지 않습니다.  입력  첫째 줄에 N과 M이 공백을 사이에 두고 주어집니다.  둘째 줄부터 M+1번째 줄까지 세 개의 정수 A_i, B_i, C_i가 주어집니다.  출력  첫째 줄에 농부 현서가 가져가야 될 최소 여물을 출력합니다.     문제 풀이   다익스트라 사용  코드 import java.io.*; import java.util.*;  public class BOJ_5972_택배배송 { \t \tstatic class Delivery implements Comparable&lt;Delivery&gt;{ \t\tint V; \t\tint W; \t\tpublic Delivery(int V, int W){ \t\t\tthis.V = V; // 도착정점 \t\t\tthis.W = W; // 가중치 \t\t} \t\t \t\t@Override \t\tpublic int compareTo(Delivery o) { \t\t\treturn this.W - o.W; \t\t} \t\t \t} \t \tstatic BufferedReader br; \tstatic BufferedWriter bw; \tstatic StringTokenizer st; \tstatic int N, M, min_hay[]; \tstatic ArrayList&lt;Delivery&gt;[] map; \tpublic static void main(String[] args) throws IOException { //\t\tbr = new BufferedReader(new InputStreamReader(System.in)); \t\tbr = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))); \t\tbw = new BufferedWriter(new OutputStreamWriter(System.out)); \t\tst = new StringTokenizer(br.readLine()); \t\t \t\tN = Integer.valueOf(st.nextToken()); // 헛간 \t\tM = Integer.valueOf(st.nextToken()); // 간선 \t\t \t\tmap = new ArrayList[N+1]; \t\tfor(int i=1; i&lt;=N; i++) { \t\t\tmap[i] = new ArrayList&lt;&gt;(); \t\t} \t\t \t\tfor(int i=0; i&lt;M; i++) { \t\t\tst = new StringTokenizer(br.readLine()); \t\t\tint A = Integer.valueOf(st.nextToken()); \t\t\tint B = Integer.valueOf(st.nextToken()); \t\t\tint V = Integer.valueOf(st.nextToken()); \t\t\t \t\t\t//양방향연결 \t\t\tmap[A].add(new Delivery(B, V)); \t\t\tmap[B].add(new Delivery(A, V)); \t\t} \t\t \t\tmin_hay = new int[N+1]; // 정점까지 최소 필요 건초 저장 \t\tArrays.fill(min_hay, 987654321); \t\tmin_hay[1] = 0; \t\t// 1 -&gt; N 가기 \t\tdijkstra(); \t\t         bw.write(String.valueOf(min_hay[N]));         bw.flush();         bw.close();         br.close(); \t} \tprivate static void dijkstra() { \t\tPriorityQueue&lt;Delivery&gt; pq = new PriorityQueue&lt;Delivery&gt;(); \t\tpq.offer(new Delivery(1, 0)); \t\t \t\twhile(!pq.isEmpty()) { \t\t\tDelivery current = pq.poll(); \t\t\tint currentFrom = current.V; \t\t\tint currentCow = current.W; \t\t\t \t\t\t// 이미 현재까지 건초수가 currentFrom까지의 최소건초보다 크면 다른 경로가 더 최소란 뜻이므로 볼 필요가 없다 \t\t\tif(currentCow &gt; min_hay[currentFrom]) continue; \t\t\t \t\t\tfor(Delivery d : map[currentFrom]) { \t\t\t\tint newVertex = d.V; \t\t\t\tint newCowSum = currentCow + d.W; \t\t\t\tif(newCowSum &lt; min_hay[newVertex]) { \t\t\t\t\tpq.offer(new Delivery(newVertex, newCowSum)); \t\t\t\t\tmin_hay[newVertex] = newCowSum; \t\t\t\t} \t\t\t} \t\t} \t} }   "
  },
  
  {
    "title": "PGMS_단속카메라 - 42884 (Java)",
    "url": "/posts/PGMS%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC-42884/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2024-07-24 03:48:20 +0900",
    "content": "[level 3] 단속카메라 - 42884  문제 링크  성능 요약  메모리: 53.5 MB, 시간: 8.09 ms  구분  코딩테스트 연습 &gt; 탐욕법（Greedy）  채점결과  정확성: 50.0효율성: 50.0합계: 100.0 / 100.0  제출 일자  2024년 07월 24일 02:53:42  문제 설명  고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다.  고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.  제한사항   차량의 대수는 1대 이상 10,000대 이하입니다. routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다. 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난것으로 간주합니다. 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.   입출력 예           routes return            [[-20,-15], [-14,-5], [-18,-13], [-5,-3]] 2          입출력 예 설명  -5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다.  -15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     코드 import java.io.*; import java.util.*;  class Solution {     class Car implements Comparable&lt;Car&gt;{         int in;         int out;                  Car(int in, int out){             this.in = in;             this.out = out;         }                  @Override         public int compareTo(Car o){             return this.out - o.out;         }     }          public int solution(int[][] routes) {         int ans = 0;         int camera = Integer.MIN_VALUE;         ArrayList&lt;Car&gt; car = new ArrayList&lt;&gt;();          for (int i = 0; i &lt; routes.length; i++) {             car.add(new Car(routes[i][0], routes[i][1]));         }                  Collections.sort(car);         for(Car c : car){             if(camera &lt; c.in){                 ans++;                 camera = c.out;             }         }                  return ans;     } }  "
  },
  
  {
    "title": "BOJ_32031_석고모형만들기 (Java)",
    "url": "/posts/BOJ32031%EC%84%9D%EA%B3%A0%EB%AA%A8%ED%98%95%EB%A7%8C%EB%93%A4%EA%B8%B0-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-24 03:42:54 +0900",
    "content": "[Gold II] 석고 모형 만들기 - 32031  문제 링크  성능 요약  메모리: 24888 KB, 시간: 212 ms  분류  너비 우선 탐색, 자료 구조, 분리 집합, 플러드 필, 기하학, 3차원 기하학, 그래프 이론, 그래프 탐색, 구현  제출 일자  2024년 7월 24일 02:11:22  문제 설명  현우는 틀에 석고를 붓고 굳혀서 다양한 모양을 만들어 보는 취미가 있다. 현우가 이번에 준비한 틀은 세로 길이가 R, 가로 길이가 C, 높이가 1인 직육면체 모양이다.  만들어진 모양이 단순하면 석고 모형을 만드는 재미가 떨어진다. 그래서 현우는 지름과 높이가 1인 원기둥을 R × C개 가져왔다. 현우는 원기둥을 모두 틀 안에 배치한 다음 빈 공간에 석고를 붓기로 했다.  원기둥을 틀에 배치할 때에는, 틀을 R × C개의 단위 정육면체로 나눈 뒤 각 단위 정육면체 안에 꼭 맞게 넣어야 한다. 원기둥을 배치할 수 있는 방향은 세 가지가 있는데, 회전축이 가로를 향하거나, 세로를 향하거나, 바닥에 수직이도록 놓을 수 있다.  현우가 원기둥을 모두 배치하고 나면 틀에 석고를 부어 굳힌 뒤 모든 원기둥을 제거할 것이다. 그러면 여러 개의 분리된 석고 조각이 만들어진다. 예를 들어, 세로 길이가 1이고 가로 길이가 2인 직육면체 틀에 두 원기둥을 회전축이 바닥에 수직이도록 배치한다면 총 6개의 석고 조각이 만들어진다.    한편, 위 예시에서 원기둥 하나의 회전축이 세로를 향하도록 배치를 바꾼다면 총 5개의 석고 조각이 만들어진다.    현우가 틀에 원기둥을 배치하는 방법이 주어졌을 때, 총 몇 개의 석고 조각이 만들어질지 구해 보자.  입력  첫째 줄에 틀의 세로 길이와 가로 길이를 나타내는 정수 R와 C가 공백을 사이에 두고 주어진다. (1 ≤ R, C ≤ 200)  다음 R개의 줄에 걸쳐 현우가 틀에 원기둥을 배치하는 방법이 주어진다. 각 줄에는 길이 C의 문자열이 주어지며, 문자열을 구성하는 문자의 의미는 아래와 같다.   \tH: 회전축이 가로를 향하는 원기둥 \tI: 회전축이 세로를 향하는 원기둥 \tO: 회전축이 바닥에 수직인 원기둥   출력  첫 줄에 석고를 굳힌 뒤 원기둥을 모두 제거하면 만들어지는 석고 조각의 개수를 출력한다.     문제 풀이      코드 import java.io.*; import java.util.*;  public class Main { \tstatic BufferedReader br; \tstatic BufferedWriter bw;     static StringTokenizer st;     static int[] parents = new int[320000];     static int R, C, extended_R, extended_C, ans;     static char[][] c = new char[200][201];     public static void main(String[] args) throws IOException { //      br = new BufferedReader(new InputStreamReader(System.in));         br = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));         bw = new BufferedWriter(new OutputStreamWriter(System.out));         st = new StringTokenizer(br.readLine());                  R = Integer.parseInt(st.nextToken());         C = Integer.parseInt(st.nextToken());     \textended_R = R * 2;     \textended_C = C * 2;          Arrays.fill(parents, -1);          for (int i = 0; i &lt; R; i++) {             c[i] = br.readLine().toCharArray();             for (int j = 0; j &lt; C; j++) {             \tcylinder(i, j, c[i][j]);                 connect(i, j);             }         }  \t\t/* \t\t * 결과 계산 루트 노드 값이 음수인 것의 개수 셈 \t\t * 이 개수가 연결되지 않은 영역의 수 \t\t */                 ans = 0;         for (int i = 0; i &lt; 8* R * C; i++) {             if (parents[i] &lt; 0) ans++;         }                  bw.write(String.valueOf(ans));         bw.flush();         bw.close();         br.close();     }      public static int find(int x) {         if (parents[x] &lt; 0) return x;         return parents[x] = find(parents[x]);  //        return parents[x] &lt; 0 ? x : (parents[x] = find(parents[x]));     }      public static boolean isDivided(int x, int y) {         x = find(x);         y = find(y);         // 붙어있으면         if (x == y) return false;         // 나뉘어졌으면         parents[x] += parents[y]; // 집합 합치기         parents[y] = x; // y의 부모를 x로         return true;     }      public static void cylinder(int r, int c, char cylinder) {     \t/*      \t *  2x2 셀로 확장     \t * (r, c) -&gt; (2r, 2c), (2r, 2c+1), (2r+1, 2c), (2r+1, 2c+1)     \t * (2r, 2c)     : a[0](1층) a[4](2층)     \t * (2r, 2c+1)   : a[1](1층) a[5](2층)     \t * (2r+1, 2c)   : a[2](1층) a[6](2층)     \t * (2r+1, 2c+1) : a[3](1층) a[7](2층)     \t *      \t */         int doubled_r = r * 2, doubled_c = c * 2;         int[] arr = new int[8];         // 3차원을 1차원으로!         // 2배 확대시킨 위치 인덱스 a[0] ~ a[3]         arr[0] = doubled_r * extended_C + doubled_c;         arr[1] = doubled_r * extended_C + doubled_c + 1;         arr[2] = (doubled_r + 1) * extended_C + doubled_c;         arr[3] = (doubled_r + 1) * extended_C + doubled_c + 1;                  // a[0] ~ a[3]가 2층에 위치한 형태         for (int k = 4; k &lt; 8; k++) arr[k] = arr[k - 4] + extended_R * extended_C;                  if (cylinder == 'O') {        \t         \tisDivided(arr[0], arr[4]);             isDivided(arr[1], arr[5]);             isDivided(arr[2], arr[6]);             isDivided(arr[3], arr[7]);         }         else if (cylinder == 'I') {             isDivided(arr[0], arr[2]);             isDivided(arr[1], arr[3]);             isDivided(arr[4], arr[6]);             isDivided(arr[5], arr[7]);         }         else if (cylinder == 'H') {             isDivided(arr[0], arr[1]);             isDivided(arr[2], arr[3]);             isDivided(arr[4], arr[5]);             isDivided(arr[6], arr[7]);         }     }      public static void connect(int r, int c) {         int doubled_r = r * 2, doubled_j = c * 2;         int[] arr = new int[8];         arr[0] = doubled_r * extended_C + doubled_j + 1;         arr[1] = (doubled_r + 1) * extended_C + doubled_j + 1;         arr[2] = (doubled_r + 1) * extended_C + doubled_j;         arr[3] = (doubled_r + 1) * extended_C + doubled_j + 1;                  for (int k = 4; k &lt; 8; k++) arr[k] = arr[k - 4] + extended_R * extended_C;                  for (int k = 0; k &lt; 8; k++) {         \t// a[0], a[1], a[4], a[5]면서 마지막 열이 아닐때 가로로 연결             if (k % 4 &lt;= 1 &amp;&amp; c + 1 &lt; C) isDivided(arr[k], arr[k] + 1);                          // a[2], a[3], a[6], a[7]면서 마지막 행이 아닐때 세로로 연결             if (k % 4 &gt; 1 &amp;&amp; r + 1 &lt; R) isDivided(arr[k], arr[k] + extended_C);         }     } }   "
  },
  
  {
    "title": "AWS S3 버킷 설정 및 파일 관리",
    "url": "/posts/AWS-S3-%EB%B2%84%ED%82%B7-%EC%84%A4%EC%A0%95-%EB%B0%8F-%ED%8C%8C%EC%9D%BC-%EA%B4%80%EB%A6%AC/",
    "categories": "프로젝트",
    "tags": "IntelliJ, Java, Springboot, aws",
    "date": "2024-07-23 13:04:20 +0900",
    "content": "이전 프로젝트에서 이미지 저장을 S3 버킷으로 진행하였고 이번에도 사용하게 되어 이 김에 정리하게 되었다.   먼저 아래 링크에서 루트 사용자로 로그인 하도록 하자  AWS 콘솔  공식 가이드를 보고 싶으면  Getting started with Amazon S3 해당 사이트 방문해 읽어보면 좋을 것 같다.  설명 및 장단점 등은 다른 글에도 많으니 생략하고 사용방법 및 설정을 다루어 보자.  AWS S3 버킷 생성 S3를 사용하여 파일을 관리하기 위해선 먼저 버킷이라는 객체 관리 컨테이너를 만들어야한다. 사용할 버킷 이름을 작성하면 된다. 중복되지 않는 버킷 이름을 작성하고 언하는 리전을 선택(오른쪽 상단 닉네임 왼쪽에서 설정 가능)   이후 업로드한 사진을 확인하기 위해 퍼블릭엑세스 차단을 해제한다    나머지는 그대로 설정해줬다   IAM 사용자 생성 IAM사용자를 생성해 S3접근 권한을 부여해야한다. 엑세스키와 시크릿키를 사용하기 때문에 꼭 저장하고 이 값은 절대 외부에 노출되어선 안되니 주의해야한다. 필자는 git으로 관리할 때 .ignore파일에 application-secret파일에 DB정보나 엑세스/시크릿 키 등 주요 정보를 포함시켰다.   직접 정책 연결을 선택하고  AmazonS3FullAccess를 포함시키고 사용자 생성   다시 IAM으로 들어가 사용자를 클릭하고 엑세스 키 만들기를 누른다.   보안 개선을 위한 사용사례 및 대안 고려인데 크게 차이가 없다   이후 설명 태그 설정은 선택사항이기에 넘겼고 엑세스키를 만들었다.   .csv파일로 저장하도록 하는걸 추천!  권한 설정 버킷 정책을 편집을 클릭하고 본인의 버킷 ARN을 복사한 뒤 정책생성기를 누른다.       Select Type of Policy 에서 S3 Bucket - Policy를 선택   Principal에 * 입력   Actions에서 원하는 액션 체크 : 필자는 Get Object, Put Object, Delete Object 체크하였다   Amazon Resource Name (ARN) 에 위에서 복사한 ARN을 입력한 후 /* 입력            ex)arn:aws:s3:::버킷이름/* Add Statement 클릭           이후 Generate Policy하여 만들어진 JSON Document 복사후 변경에 붙여넣고 저장  이제 퍼블릭 설정이 완료되었다.  CORS 권한 설정 [     {         \"AllowedHeaders\": [             \"*\"         ],         \"AllowedMethods\": [             \"GET\",             \"PUT\",             \"DELETE\"         ],         \"AllowedOrigins\": [             \"*\"         ],         \"ExposeHeaders\": [             \"x-amz-server-side-encryption\",             \"x-amz-request-id\",             \"x-amz-id-2\"         ],         \"MaxAgeSeconds\": 3000     } ]  붙여넣고 저장하면 된다.  SpringBoot 설정 및 연동 build.gradle / pom.xml Spring Cloud AWS Starter 해당 mvn사이트로 가서 의존성을 가져와 원하는대로 추가해주면 된다     //AWS     // https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-aws     implementation group: 'org.springframework.cloud', name: 'spring-cloud-starter-aws', version: '2.2.6.RELEASE'   pom.xml도 비슷하다 \t\t&lt;dependency&gt; \t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; \t\t\t&lt;artifactId&gt;spring-cloud-starter-aws&lt;/artifactId&gt; \t\t\t&lt;version&gt;2.0.1.RELEASE&lt;/version&gt; \t\t&lt;/dependency&gt; \t\t&lt;dependency&gt; \t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; \t\t\t&lt;artifactId&gt;spring-cloud-aws-context&lt;/artifactId&gt; \t\t\t&lt;version&gt;1.2.1.RELEASE&lt;/version&gt; \t\t&lt;/dependency&gt; \t\t&lt;dependency&gt; \t\t\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; \t\t\t&lt;artifactId&gt;spring-cloud-aws-autoconfigure&lt;/artifactId&gt; \t\t\t&lt;version&gt;1.2.1.RELEASE&lt;/version&gt; \t\t&lt;/dependency&gt; \t\t&lt;dependency&gt; \t\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \t\t\t&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; \t\t&lt;/dependency&gt; \t\t&lt;dependency&gt; \t\t    &lt;groupId&gt;com.amazonaws&lt;/groupId&gt; \t\t    &lt;artifactId&gt;aws-java-sdk-s3&lt;/artifactId&gt; \t\t    &lt;version&gt;1.11.1001&lt;/version&gt; \t\t&lt;/dependency&gt;   application.properties / application.yml  application.properties spring.servlet.multipart.max-file-size=10MB spring.servlet.multipart.max-request-size=10MB spring.config.import=application-secret.properties  # AWS credentials cloud.aws.credentials.access-key=엑세스키 cloud.aws.credentials.secret-key=시크릿 엑세스 키 cloud.aws.stack.auto=false  # AWS region and S3 bucket cloud.aws.region.static=리전 cloud.aws.s3.bucket=버킷이름   application.yml # Multipart servlet:   multipart:     enabled: true     max-file-size: 10MB     max-request-size: 10MB  # AWS cloud:   aws:     credentials:       accessKey: 엑세스키       secretKey: 시크릿 엑세스 키     region:       static: 리전     stack:       auto: false     s3:       bucket: 버킷이름   S3Config package com.ssafy.picple.AwsS3;  import com.amazonaws.auth.AWSStaticCredentialsProvider; import com.amazonaws.auth.BasicAWSCredentials; import com.amazonaws.services.s3.AmazonS3Client; import com.amazonaws.services.s3.AmazonS3ClientBuilder; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration;  @Configuration public class S3Config {     @Value(\"${cloud.aws.credentials.access-key}\")     private String accessKey;      @Value(\"${cloud.aws.credentials.secret-key}\")     private String secretKey;      @Value(\"${cloud.aws.region.static}\")     private String region;      @Bean     public AmazonS3Client amazonS3Client() {         BasicAWSCredentials basicAWSCredentials = new BasicAWSCredentials(accessKey, secretKey);         return (AmazonS3Client) AmazonS3ClientBuilder.standard()                 .withRegion(region)                 .withCredentials(new AWSStaticCredentialsProvider(basicAWSCredentials))                 .build();     } }   S3FileUploadService package com.ssafy.picple.AwsS3;  import com.amazonaws.SdkClientException; import com.amazonaws.services.s3.AmazonS3; import com.amazonaws.services.s3.model.DeleteObjectRequest; import com.amazonaws.services.s3.model.GetObjectRequest; import com.amazonaws.services.s3.model.ObjectMetadata; import com.amazonaws.services.s3.model.S3Object; import com.ssafy.picple.config.baseResponse.BaseException; import com.ssafy.picple.config.baseResponse.BaseResponseStatus; import lombok.RequiredArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Service; import org.springframework.web.multipart.MultipartFile;  import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; import java.util.UUID; import java.util.logging.Logger;  @Service @Slf4j @RequiredArgsConstructor public class S3FileUploadService {     private static final Logger logger = Logger.getLogger(S3FileUploadService.class.getName());     private final AmazonS3 s3Client;      @Value(\"${cloud.aws.s3.bucket}\")     private String bucketName;      private final String defaultUrl = \"https://picple.s3.ap-northeast-2.amazonaws.com\";      public String uploadFile(MultipartFile file) throws IOException, BaseException {         String originalFilename = file.getOriginalFilename();          try {             s3Client.putObject(bucketName, originalFilename, file.getInputStream(), getObjectMetadata(file));             return defaultUrl + \"/\" + originalFilename;         } catch (SdkClientException e) {             throw new BaseException(BaseResponseStatus.FILE_UPLOAD_ERROR);         }     }      // MultipartFile 사이즈랑 타입 명시용     private ObjectMetadata getObjectMetadata(MultipartFile file) {         ObjectMetadata objectMetadata = new ObjectMetadata();         objectMetadata.setContentType(file.getContentType());         objectMetadata.setContentLength(file.getSize());         return objectMetadata;     }      private String generateFileName(MultipartFile file) { //        return UUID.randomUUID().toString() + \"-\" + file.getOriginalFilename(); // 중복안되게 랜덤하게 넣으려면 이렇게 그때그때 UUID붙여서         return file.getOriginalFilename();     }      // 인코딩 필요하면 사용     // 파일 이름을 UTF-8로 인코딩     public static String encodeFileName(String fileName) {         try {             return URLEncoder.encode(fileName, \"UTF-8\");         } catch (UnsupportedEncodingException e) {             e.printStackTrace();             return fileName; // 인코딩 실패 시 원래 파일 이름 리턴         }     }      public S3Object downloadFile(String fileName) throws BaseException {         try {             return s3Client.getObject(new GetObjectRequest(bucketName, fileName));         } catch (SdkClientException e) {             throw new BaseException(BaseResponseStatus.FILE_DOWNLOAD_ERROR);         }     }      public void deleteFile(String file) throws BaseException {         try {             s3Client.deleteObject(new DeleteObjectRequest(bucketName, file));         } catch (SdkClientException e) {             throw new BaseException(BaseResponseStatus.FILE_DELETE_ERROR);         }     }  }  아래부턴 원하는대로 엔티티부터 코딩하면 된다. 다음은 내가 사용했던 컨트롤러 예시들 Controller Maven, JDBC, MyBatis사용 프로젝트 package com.fitdo.controller;  import java.io.IOException; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestPart; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.multipart.MultipartFile;  import com.fitdo.model.dto.Follow; import com.fitdo.model.dto.Post; import com.fitdo.model.dto.User; import com.fitdo.model.service.CommentService; import com.fitdo.model.service.FollowService; import com.fitdo.model.service.PostService; import com.fitdo.model.service.S3FileUploadServiceImpl; import com.fitdo.model.service.UserService;  import io.swagger.v3.oas.annotations.Operation; import io.swagger.v3.oas.annotations.tags.Tag; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import jakarta.servlet.http.HttpSession; import jakarta.validation.Valid;  @RestController @RequestMapping(\"/post\") @Tag(name = \"PostRestController\", description = \"게시물 관리\") @CrossOrigin(\"*\") public class PostRestController {  \t@Autowired \tprivate PostService ps;  \t@Autowired \tprivate UserService us;  \t@Autowired \tprivate S3FileUploadServiceImpl ss;  \t@Autowired \tprivate FollowService fs; \t \t@Autowired \tprivate CommentService cs;  \t// 게시물 전체 조회 \t@GetMapping(\"/\") \t@Operation(summary = \"게시물 전체 조회\") \tpublic ResponseEntity&lt;List&lt;Post&gt;&gt; getAllPosts() { \t\tList&lt;Post&gt; posts = ps.getPost(); \t\tif (posts == null || posts.size() == 0) { \t\t\treturn new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); \t\t} \t\treturn new ResponseEntity&lt;&gt;(posts, HttpStatus.OK); \t}  \t// 게시물 전체 조회 + 프사 + 댓글수 \t@GetMapping(\"/withImg\") \t@Operation(summary = \"게시물 전체 조회 + 프사 + 댓글수\") \tpublic ResponseEntity&lt;List&lt;Post&gt;&gt; getAllPostsWithProfileImg() { \t\tList&lt;Post&gt; posts = ps.getPostWithUserProfileImg(); \t\tfor (Post post : posts) { \t\t\tUser user = us.searchById(post.getPostUserId()).get(0); \t        int commentsNum = cs.getCommentNum(post.getPostId()); \t\t\t// 사용자 정보가 null이 아닌 경우에만 설정 \t\t\tif (user != null) { \t\t\t\tpost.setUser(user); \t\t\t\tpost.setCommentNum(commentsNum); \t\t\t} \t\t}  \t\tSystem.out.println(posts); \t\tif (posts == null || posts.size() == 0) { \t\t\treturn new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); \t\t} \t\treturn new ResponseEntity&lt;&gt;(posts, HttpStatus.OK); \t}  \t// 팔로우 하는 유저 게시물 전체 조회 + 본인포함 \t@GetMapping(\"/followee/{userId}\") \t@Operation(summary = \"팔로우 하는 유저 게시물 전체 조회 + 본인포함\") \tpublic ResponseEntity&lt;List&lt;Post&gt;&gt; getFolloweePosts(@PathVariable(\"userId\") String userId) {  \t\tList&lt;Follow&gt; followee = fs.selectFolloweeList(userId); \t\tSystem.out.println(\"내가 팔로우 하는 사람들 객체 : \" + followee);  \t\tList&lt;String&gt; followeeUserId = new LinkedList&lt;&gt;(); \t\tfor (Follow follow : followee) { \t\t\tfolloweeUserId.add(follow.getToUserId()); \t\t} \t\tSystem.out.println(\"내가 팔로우 하는 사람들 아이디 목록 : \" + followeeUserId);  \t\t// 나도추가 \t\tfolloweeUserId.add(userId);  \t\t// 내가 볼 팔로우하는 사람들의 게시물 리스트 \t\tList&lt;Post&gt; myFolloweePosts = new ArrayList&lt;&gt;(); \t\tfor (String followeeId : followeeUserId) { \t\t\tList&lt;Post&gt; userPosts = ps.selectPostsByUserId(followeeId); \t\t\tmyFolloweePosts.addAll(userPosts); \t\t}  \t\tList&lt;Post&gt; posts = myFolloweePosts; \t\tfor (Post post : posts) { \t\t\tUser user = us.searchById(post.getPostUserId()).get(0); \t\t\t// 사용자 정보가 null이 아닌 경우에만 설정 \t\t\tif (user != null) { \t\t\t\tpost.setUser(user); \t\t\t} \t\t}  \t\tif (posts == null || posts.size() == 0) { \t\t\treturn new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT); \t\t} \t\treturn new ResponseEntity&lt;&gt;(posts, HttpStatus.OK); \t}  \t// 게시물 상세 조회 \t@GetMapping(\"/{postId}\") \t@Operation(summary = \"게시물 상세 조회\") \tpublic ResponseEntity&lt;Post&gt; getOnePost(@PathVariable int postId) { \t\tPost post = ps.selectOnePost(postId); \t\tif (post != null) { \t\t\treturn new ResponseEntity&lt;&gt;(post, HttpStatus.OK); \t\t} else { \t\t\treturn ResponseEntity.notFound().build(); \t\t} \t}  \t// 게시물 상세 조회 \t@GetMapping(\"/getPostByUserId/{postUserId}\") \t@Operation(summary = \"게시물 유저아이디로 상세 조회 + 유저 정보\") \tpublic ResponseEntity&lt;Post&gt; getOnePostByUserId(@PathVariable String postUserId) { \t\tPost post = ps.selectPostsByUserId(postUserId).get(0); \t\tUser user = us.searchById(postUserId).get(0); \t\tif (user != null) { \t\t\tpost.setUser(user); \t\t} \t\tif (post != null) { \t\t\treturn new ResponseEntity&lt;&gt;(post, HttpStatus.OK); \t\t} else { \t\t\treturn ResponseEntity.notFound().build(); \t\t} \t} \t \t// 게시물들 유저아이디 일치하는 사람으로 조회 \t@GetMapping(\"/getPostsListByUserId/{postUserId}\") \t@Operation(summary = \"게시물들 리스트 유저아이디로 상세 조회 - 게시물들 여러개 받는 거\") \tpublic ResponseEntity&lt;?&gt; getPostsListByUserId(@PathVariable String postUserId) { \t\tList&lt;Post&gt; posts = ps.selectPostlistByUserId(postUserId); \t\tif (posts != null) { \t\t\treturn new ResponseEntity&lt;&gt;(posts, HttpStatus.OK); \t\t} else { \t\t\treturn ResponseEntity.notFound().build(); \t\t} \t} \t \t// 게시물 등록 \t@PostMapping(\"/addpost/{postUserId}\") \t@Operation(summary = \"게시물 등록\") \tpublic ResponseEntity&lt;?&gt; createPost(@PathVariable(\"postUserId\") String postUserId, @RequestBody Post post, \t\t\tHttpSession session, HttpServletRequest request, HttpServletResponse response) { //\t\tUser user = (User) session.getAttribute(\"user\"); //\t\tSystem.out.println(\"user : \" + user); //        Cookie myCookie = new Cookie(\"myUserId : \", user.getUserid()); //        System.out.println(myCookie.getName()); //        System.out.println(myCookie.getValue()); //\t\tCookie[] cookies = request.getCookies(); //\t    if (cookies != null) { //\t        for (Cookie cookie : cookies) { //\t\t        System.out.println(\"cookie.getName() : \" + cookie.getName()); //\t\t        System.out.println(\"cookie.getValue() : \" + cookie.getValue()); //\t        } //\t    }  \t\t// Swagger통신시 세션저장이 안되는 문제점 해결 할 때 까지 테스트용 임시user \"ssafy\"생성  //\t\tif (user == null) { //\t\t\t// 세션에 사용자 정보가 없을 때 임시로 사용자 객체 생성 //\t        user = new User(); //\t        user.setUserid(\"ssafy\"); //\t        // 임시로 생성한 사용자 객체를 세션에 저장 //\t        session.setAttribute(\"user\", user); ////\t\t\treturn new ResponseEntity&lt;&gt;(\"로그인이 필요합니다!\", HttpStatus.UNAUTHORIZED); //\t\t}  //\t\tpost.setPostUserId(user.getUserid());  \t\t// User객체까지 등록할 때 프론트단으로 넘겨줄거임 \t\tUser user = us.searchById(postUserId).get(0); \t\tpost.setPostUserId(user.getUserid()); \t\tpost.setUser(user); \t\tSystem.out.println(\"postUserId : \" + post.getPostUserId()); \t\tSystem.out.println(\"user : \" + user); \t\tSystem.out.println(\"userId : \" + user.getUserid()); \t\tSystem.out.println(\"userProfileImg : \" + user.getProfileImg());  \t\tint result = 0; \t\ttry { \t\t\tresult = ps.createPost(post, request); \t\t} catch (IllegalStateException e) { \t\t\te.printStackTrace(); \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 등록 실패!\"); \t\t} catch (IOException e) { \t\t\te.printStackTrace(); \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 등록 실패!\"); \t\t} \t\tif (result &gt; 0) { \t\t\treturn new ResponseEntity&lt;&gt;(\"게시물 등록 성공!\", HttpStatus.CREATED); \t\t} else { \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 등록 실패!\"); \t\t} \t}  \t// 게시물 등록 및 이미지 업로드 \t@PostMapping(value = \"/addpostWithImg/{postUserId}\", consumes = \"multipart/form-data\") \t@Operation(summary = \"게시물 등록 및 이미지 업로드\") \tpublic ResponseEntity&lt;?&gt; createPostWithImage(@PathVariable(\"postUserId\") String postUserId, \t\t\t@RequestPart(\"post\") @Valid Post post, @RequestPart(\"file\") MultipartFile file, HttpSession session, \t\t\tHttpServletRequest request, HttpServletResponse response) throws IOException {  \t\tint result = 0; \t\ttry { //\t    \tSystem.out.println(\"https://fit-do.s3.ap-southeast-2.amazonaws.com/\"+file.getOriginalFilename()); //\t        post.setPostImg(\"https://fit-do.s3.ap-southeast-2.amazonaws.com/\"+file.getOriginalFilename());  \t\t\tString fileUrl = ss.uploadFile(file); \t\t\tSystem.out.println(\"fileUrl : \" + fileUrl); \t\t\tpost.setPostImg(fileUrl);  \t\t\t// User객체까지 등록할 때 프론트단으로 넘겨줄거임 \t\t\tUser user = us.searchById(postUserId).get(0); \t\t\tpost.setPostUserId(user.getUserid()); \t\t\tpost.setUser(user); \t\t\tSystem.out.println(\"postUserId : \" + post.getPostUserId()); \t\t\tSystem.out.println(\"user : \" + user); \t\t\tSystem.out.println(\"userId : \" + user.getUserid()); \t\t\tSystem.out.println(\"userProfileImg : \" + user.getProfileImg());  \t\t\tresult = ps.createPost(post, request); \t\t\tif (result &gt; 0) { \t\t\t\treturn new ResponseEntity&lt;&gt;(\"게시물 등록 성공!\", HttpStatus.CREATED); \t\t\t} else { \t\t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 등록 실패!\"); \t\t\t} \t\t} catch (IllegalStateException e) { \t\t\te.printStackTrace(); \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 등록 실패!\"); \t\t} catch (IOException e) { \t\t\te.printStackTrace(); \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 등록 실패!\"); \t\t} \t}  \t// 게시물 수정 \t@PutMapping(\"/{postId}\") \t@Operation(summary = \"게시물 수정\") \tpublic ResponseEntity&lt;String&gt; updatePost(@PathVariable int postId, @RequestBody Post post) { \t\tpost.setPostId(postId); \t\tint result = ps.updatePost(post); \t\tif (result &gt; 0) { \t\t\treturn ResponseEntity.ok(\"게시물 수정 성공!\"); \t\t} else { \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 수정 실패\"); \t\t} \t}  \t// 게시물 사진 수정 \t@PutMapping(value = \"/{postid}/updateImage\", consumes = \"multipart/form-data\") \t@Operation(summary = \"게시물 사진 수정\") \tpublic ResponseEntity&lt;String&gt; updatePostImg(@PathVariable int postid, @RequestPart MultipartFile file) \t\t\tthrows IOException { \t\ttry { \t\t\tString url = ss.uploadFile(file); \t\t\tSystem.out.println(\"게시물 사진 url : \" + url);  \t\t\tPost post = ps.selectOnePost(postid);  \t\t\tif (post == null) { \t\t\t\treturn new ResponseEntity&lt;&gt;(\"해당 게시물이 존재하지 않음\", HttpStatus.NOT_FOUND); \t\t\t} \t\t\tint updateImg = ps.updatePostImageUrl(postid, url); \t\t\tSystem.out.println(\"updateImage : \" + updateImg);  \t\t\treturn new ResponseEntity&lt;&gt;(\"게시물 사진 수정 성공!\", HttpStatus.OK); \t\t} catch (IOException e) { \t\t\treturn new ResponseEntity&lt;&gt;(\"사진 업로드 실패\", HttpStatus.BAD_REQUEST); \t\t} \t}  \t// 게시물 삭제 \t@DeleteMapping(\"/{postId}\") \t@Operation(summary = \"게시물 삭제\") \tpublic ResponseEntity&lt;String&gt; deletePost(@PathVariable int postId) { \t\tint result = ps.deletePost(postId); \t\tif (result &gt; 0) { \t\t\treturn ResponseEntity.ok(\"게시물 삭제!\"); \t\t} else { \t\t\treturn ResponseEntity.status(HttpStatus.BAD_REQUEST).body(\"게시물 삭제 실패\"); \t\t} \t} }   Gradle, JPA사용 프로젝트 package com.ssafy.picple.domain.photo.controller;  import com.ssafy.picple.AwsS3.S3FileUploadService; import com.ssafy.picple.config.baseResponse.BaseResponseStatus; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController;  import com.ssafy.picple.config.baseResponse.BaseResponse; import com.ssafy.picple.domain.photo.entity.Photo; import com.ssafy.picple.domain.photo.service.PhotoService;  import lombok.RequiredArgsConstructor; import org.springframework.web.multipart.MultipartFile;  @RestController @RequestMapping(\"/photo\") @RequiredArgsConstructor public class PhotoController {  \tprivate final PhotoService photoService; \tprivate final S3FileUploadService s3FileUploadService;  \t@PostMapping(\"\") \tpublic BaseResponse&lt;?&gt; savePhoto(@RequestBody Photo photo, MultipartFile file) { \t\ttry { \t\t\tString photoUrl = s3FileUploadService.uploadFile(file);  \t\t\tPhoto newPhoto = Photo.builder() \t\t\t\t\t.photoUrl(photoUrl) \t\t\t\t\t.isShared(false) \t\t\t\t\t.isDeleted(false) \t\t\t\t\t.build(); \t\t\treturn new BaseResponse&lt;&gt;(photoService.insertPhoto(newPhoto)); \t\t} catch (Exception e) { \t\t\treturn new BaseResponse&lt;&gt;(BaseResponseStatus.FILE_UPLOAD_ERROR); \t\t} \t}  }   "
  },
  
  {
    "title": "Operating System Concepts - (3)",
    "url": "/posts/Operating-System-Concepts-3/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2024-07-21 23:24:01 +0900",
    "content": "   프로세스 관리 ( ch.3 )   Process Creation (프로세스 생성)    Parent Process (부모 프로세스) 가 Children Process (자식 프로세스) 생성 ( 복제 생성; 프로세스가 또 다른 프로세스를 만드는 구조)   프로세스의 트리(계층 구조)가 형성됨   프로세스는 자원을 필요로 하고 자원은 운영체제(OS)로부터 받거나 부모와 공유함            자원의 공유                    부모와 자식이 모든 자원을 공유하는 모델           일부를 공유하는 모델 (모든 자원을 공유하는 것보다 더 효율적임) ex) Linux           전혀 공유하지 않는 모델                           Execution (수행)   부모와 자식 공존하며 수행되는 모델   자식이 terminate될 때까지 부모가 기다리는(wait = blocked) 모델   주소 공간(Address space)            자식은 부모의 문맥(공간)을 복사 (binary and OS data) -&gt; Code, Data, Stack 전부 복사                    Data : 전역변수 &amp; 데이터 그대로 가져감           Stack : 현재 어디서부터 실행되었는가? 가 저장됨 -&gt; 그 위치부터 시작                       PC(Program Counter) Register도 그대로 복사       자식은 그 공간에 새로운 프로그램을 올림           Copy-on-Write(COW)    Write가 발생했을 때 Copy가 실행되는 것   내용이 변경된 경우에만 Copy를 진행, 그 전까진 공유만 함            Ex) Unix                    fork() 시스템 콜이 새로운 프로세스를 생성           부모를 그대로 복사 (OS data except PID + binary)           주소 공간 할당           시스템 콜이 호출되는 것이므로 OS가 해당 작업(프로세스 생성)을 대신 수행하는 의미!                       fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림.           &lt; 프로세스의 생성과정 &gt;    부모 프로세스의 복제 (자식 프로세스 생성) –&gt; fork()   새로운 프로세스를 주소 공간에 덮어씌움 –&gt; exec()   Process Termination (프로세스 종료)     Exit() - 프로세스가 마지막 명령을 수행한 후 OS에 알려줌            자식이 부모에게 output data 보냄 (via wait)       OS로 프로세스의 각종 자원들이 반납됨.       프로세스에서 자식 프로세스가 먼저 종료되고 부모 프로세스가 종료되어야 함           부모 프로세스가 자식 프로세스의 수행을 종료시킴 ( abort - 강제 종료 )            자식이 할당 자원의 한계치를 넘어섬       자식에게 할당된 태스크가 더 이상 필요하지 않음       부모가 종료(exit)하는 경우                    OS는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 하지 않음           강제 종료 시에도 자식 프로세스가 먼저 종료 후 부모 프로세스가 종료되기 때문에 단계적 종료가 발생                           fork() System Call     A process is created by the fork() system call            ✔ creates a new address space that is a duplicate of the caller - 발신자의 중복된 새 주소 공간을 만듦         int main() {     int pid;     pid = fork();      # fork() 함수가 실행되면 하나의 프로세스가 더 생성된다고 이해하는 것이 쉬움.     if(pid == 0) {         printf(\"\\nHello, I am child!\\n\");     } eise if (pid &gt; 0) {         printf(\"\\nHello, I am parent!\\n\");     } }                           exec() System Call     A process can execute a different program by the exec() system call            ✔ replaces the memory image of the caller with a new program - 발신자의 메모리 이미지를 새 프로그램으로 대체         int main() {     int pid;     pid = fork();      # fork() 함수가 실행되면 하나의 프로세스가 더 생성된다고 이해하는 것이 쉬움.     if(pid == 0) {           # this is child         printf(\"\\nHello, I am child! Now I'll run date \\n\");         execlp(\"/bin/date\", \"/bin/date\", (char *) 0);         # execlp는 새로운 프로그램으로 덮어씌우는 함수, ( char * ) 0 은 제로포인터     } eise if (pid &gt; 0) {            # this is parent         printf(\"\\nHello, I am parent!\\n\");     } }                           wait() System Call     자식이 종료(terminate)될 때까지 부모가 기다리는(wait = blocked) 모델            프로세스 A가 wait() 시스템 콜을 호출하면                    커널은 child가 종료될 때까지 프로세스 A를 sleep 시킴 (block 상태)           child process가 종료되면 커널은 프로세스 A를 깨움 (ready 상태)                           \tmain {       int childPID;       S1;       childPID = fork();       # 0이면 자식 프로세스를 위한 코드 생성       if(childPID == 0) {       } else {         # 부모 프로세스인 경우 wait() 실행         # 자식 프로세스가 종료될 때까지 기다리는 모델         wait();       }       S2;     }   정리 💡 프로세스와 관련된 시스템 콜    fork() - Create a child (copy)            부모 프로세스에서 복제하여 자식 프로세스 생성           exec() - overlay new image            새로운 프로그램으로 덮어씌우는 시스템 콜           wait() - sleep until child is done            자식 프로세스가 종료될 때까지 대기           exit() - frees all the resources, notify parent            모든 자원을 반납하고 부모 프로세스에게 종료되었다고 알림.           exit() System Call     프로세스의 종료            자발적 종료                    마지막 statement 수행 후 exit() 시스템 콜을 통해 중료 수행됨           프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌                       비자발적 종료                    부모 프로세스가 자식 프로세스를 강제 종료시킴                            자식 프로세스가 한계치를 넘어서는 자원 요청               자식에게 할당된 Task가 더 이상 필요하지 않음                                   키보드로 kill, break 등을 친 경우           부모가 종료하는 경우                            부모 프로세스가 종료되기 전에 자식들이 먼저 종료됨                                                      ## 프로세스 간 협력 (p.137 참조)      Independent Process (독립적 프로세스)            프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함       경우에 따라서는 프로세스가 협력을 해야만 서로 효율적으로 실행되기도 함           Cooperating Process (협력 프로세스)            프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음           IPC : Interprocess Communication (프로세스 간 협력 메커니즘)            메세지를 전달하는 방법                    Message passing : 커널을 통해 메시지 전달.                            프로세스 A가 프로세스 B에게 메세지를 전달함으로써 프로세스 B가 작업을 수행하는 것. 중간 커널이 메신저 역할을 해줌                                               주소 공간을 공유하는 방법                    shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 메커니즘이 있음.           🚩 thread : Thread는 사실상 하나의 프로세스이므로 프로세스간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능                           Message Passing    Message System            프로세스 사이에 Shared variable (공유 변수)를 일체 사용하지 않고 통신하는 시스템       Communication 방법에 관계 없이 운영체제 커널이 메세지를 전달하는 통신을 진행           Direct Communication            통신하려는 프로세스의 이름을 명시적으로 표시            Indirect Communication            mailbox(or port)를 통해 메세지를 간접 전달       mailbox 역시 커널 안에 존재하는 것.            IPC Interprocess Communication     각각 주소공간이 따로 있지만, 일부의 shared 공간을 같이 사용하는 형태   kernel에 명령을 보내 shared 공간을 쓴다는 것을 알려야 사용 가능함.      CPU Scheduling   CPU and I/O Bursts in Program Execution     명령어 실행 도중 I/O 작업으로 넘어가면 wait이 발생하게 됨.   CPU만 연속적으로 사용하는 CPU burst 상태와 I/O만 연속되어 발생하는 I/O Burst 상태가 반복되게 됨.   주로 사람이 연결되어 있는 프로그램에서 주로 반복되는 형태가 많이 발생함 (interactive한 job)   프로그램의 종류에 따라 빈도나 유형이 각각 다름.   CPU-burst time의 분포     여러 종류의 job(=process)이 섞여 있기 때문에 CPU 스케쥴링이 필요            interactive job에게 적절한 response 제공 필요       CPU와 I/O 장치 등 시스템 자원을 골고루, 효율적으로 사용 -&gt; CPU Scheduling이 필요한 이유       중간에 I/O가 많으면 CPU bust time이 적음. (= I/O bound job) -&gt; 반대가 CPU bound job                CPU를 많이 사용하는 것은 CPU bound job이라고 보는게 맞고, I/O bound job은 I/O가 빈번하기 때문에 스위칭이 잦아 CPU 사용률이 많아 보이는 것. (frequency가 높은 이유)      I/O bound job에 CPU 먼저 줘야하는 이유            먼저 I/O해서 뒤 작업 하려고       사람 측면에서 I/O 했는데 반응 느리면 답답하기 때문에           CPU Scheduler &amp; Dispatcher    CPU Scheduler Ready 상태의 프로세스 중에서 이번에 CPU를 줄 프로세스를 고른다. OS의 특정적인 기능 (code)를 Scheduler라고 부르는 것.        Dispatcher CPU의 제어권을 CPU Scheduler에 의해 선택된 프로세스에게 넘긴다. 이 과정을 context switch(문맥 교환)라고 한다.      CPU 얻는 과정            얻는과정                    ready -&gt; running                       빼았는과정                    running -&gt; ready           running -&gt; blocked                           CPU 스케쥴링이 필요한 경우 프로세스에게 다음과 같은 상태 변화가 있는 경우 스케쥴링이 필요하다.            Running -&gt; Blocked (예 : I/O 를 요청하는 System call) - I/O같이 오래 걸리는 작업 하게되면 다른것에 CPU를 줌       Running -&gt; Ready (예 : 할당시간만료로 timer interrupt) - 특정 작업만 오래 CPU 쓰게 할 수 없으므로 강제로 뺐음       Blocked -&gt; Ready (예 : I/O 완료 후 인터럽트) - CPU얻을 수 있는 권한 부여 - 강제로 줌       Terminate           ✔ 1,4에서의 스케쥴링은 nonpreemptive (강제 x, 자진 반납)      ✔ 1,4번을 제외한 스케쥴링은 preemptive (강제로 문맥교환 발생)      Scheduling Criteria - Performance Index(스케쥴링 성능 척도)    CPU Utilization (이용률) ; Keep the CPU as busy as possible            CPU가 놀지 않고 일한 시간의 비율           Throughput (처리량) ; # of processes that complete their execution per time unit            주어진 시간 동안 몇개의 작업을 처리했는지에 대한 비율           Turnaround Time (소요 시간, 평균 시간) ; amount of time to execute a particular process            CPU를 쓰기 시작해서 I/O 처리를 위해 종료할 때까지 (뺏길 때까지) 걸린 시간 (CPU burst time)           Waiting Time (대기 시간) ; amount of time a process has been waiting in the ready queue            CPU를 쓰기까지의 순서를 기다리는 시간       waiting time은 여러 차례 발생하는 대기 시간을 합친 시간을 의미함 (response time과 조금 다름)           Response time (응답 시간) ; amount of time it takes from when a request was submitted until the first response is produced, not output (for time-sharing environment)            처음으로 CPU를 점유하기까지 걸린 시간              Scheduling Algorithm (p.226 참조)   FCFS (First-Come First-Served)        먼저 온 순서대로 작업을 처리하는 것.     비선점형 스케쥴링 (non-preemptive)     그닥 효율적이진 않음. (짧게 쓰는 작업들이 대기중이더라도 만약 긴 작업이 실행중이라면 계속 그 작업이 끝날때까지 대기해야 하기 때문에)     앞에 어떤 유형의 프로세스가 존재하느냐에 따라 효율이 굉장히 달라짐     Convoy effect : short process behind long process ( 짧은 프로세스가 긴 프로세스로 인해 오래 기다리는 것 )      SJF (Shortest-Job First)    _CPU burst time_이 제일 짧은 프로세스에게 제일 먼저 CPU를 점유하게 해주는 것. ( Choose the job with the smallest expected CPU burst )   Non-preemptive            average waiting time이 제일 적은 스케쥴링 기법       일단 한번 CPU를 점유하면 더 짧은 프로세스가 도착하더라도 이미 진행중인 프로세스의 CPU burst time이 끝날때까지 대기           Preemptive (Shortest-Remaining-Time-First : SRTF)            현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 빼앗김           SJF is optimal            주어진 프로세스들에 대해** minimum average waiting time**을 보장           다음 CPU Burst Time 예측    다음 CPU burst time은 추정만 가능   과거의 CPU burst time을 이용해서 추정(exponential averaging)     Priority Scheduling (우선순위 스케쥴링)    A priority number(integer) is associated with each process   highest priority를 가진 프로세스에게 CPU 할당 (smallest integer = highest priority)            Preemptive       nonpreemptive           SJF는 일종의 priority scheduling            priority = predicted next CPU burst time           Problem            Starvation : low priority processes may never execute           Solution            Aging : as time progresses increase the priority of the process           Round Robin (RR)    현대적인 스케쥴링 기법은 거의 Round Robin을 사용함   각 프로세스는 동일한 크기의 할당 시간 (time quantum)을 가짐. ( 일반적으로 10-100 milliseconds )   할당 시간이 지나면 프로세스는 선점당하고, ready queue의 제일 뒤에 가서 다시 줄을 선다. 응답 시간이 제일 빠른 스케쥴링 기법   n개의 프로세스가 ready queue에 있고, 할당 시간이 q_time unit인 경우 각 프로세스는 최대 q_time unit 단위로 CPU 시간의 1/n을 얻는다.  =&gt; 어떤 프로세스도 (n-1)q time unit 이상을 기다리지 않음   Performance            q large (할당 시간이 큰 경우) =&gt; FCFS(FIFO)       q small (할당 시간이 작은 경우) =&gt; context switch 오버헤드가 커지기 때문에 부하 발생 가능성 커짐.              Multilevel Queue (p.235 참조)      Ready Queue를 여러 개로 분할            foreground (interactive)       background (batch - no human interaction)           각 큐는 독립적인 스케쥴링 알고리즘을 가짐            foreground (RR)       background (FCFS)           큐에 대한 스케쥴링이 필요            fixed priority scheduling                    serve all from foreground then from background           possibility of starvation : 우선순위가 낮은 프로세스에서는 기아 현상이 발생할 수 있음 ex) batch processes, student processes                       time slice                    starvation을 방지하기 위한 방법으로 사용           각 큐에 CPU time을 적절한 비율로 할당 ex) 80%는 foreground에 20%는 background에                                    Multilevel Feedback Queue      처음 들어오는 프로세스는 가장 높은 우선순위를 가지는 queue에 보냄. (quantum이 가장 짧음)   가장 높은 우선순위 queue에서 작업이 끝나지 않았을 경우 그 다음 우선순위를 가지는 queue로 할당됨 ===&gt; 프로세스가 다른 큐로 이동 가능. Aging을 위와 같은 방식으로 구현하는 원리   CPU burst time이 짧은 프로세스에게 우선순위가 높게 적용되는 알고리즘   CPU burst time 예측이 필요 없다는 장점 보유   Multilevel-feedback-queue schedular를 정의하는 파라미터들            Queue의 수       각 큐의 scheduling algorithm       Process를 상위 큐로 보내는 기준       Process를 하위 큐로 내쫒는 기준       Process가 CPU Service를 받으려 할 때 들어갈 큐를 결정하는 기준                Multiple-Processor Scheduling      CPU가 여러 개인 경우 스케쥴링은 더욱 복잡해진다.   Homogeneous processor인 경우            Queue에 한줄로 세워서 각 프로세스가 알아서 꺼내가게 할 수 있다.       반드시 특정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해진다. ( 보통 우선순위를 부여해 특정 프로세서에 수행되도록 처리함. )           Load Sharing            일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요       별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법           Symmetric Multiprocessing (SMP)            각 프로세서가 각자 알아서 스케줄링 결정           Asymmetric Multiprocessing            하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름.           Real-Time Scheduling    정해진 시간 (deadline)안에 반드시 수행되어야 하는 프로세스 스케쥴링   주로 미리 스케쥴링을 해서 적재적소에 배치되도록 함.   Hard Real-time systems            정해진 시간 안에 반드시 끝내도록 스케쥴링 해야 함.           Soft Real-time computing            일반 프로세스에 비해 높은 priority를 갖도록 해야 함.           Thread Scheduling    Local Scheduling            User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케쥴링할지 결정           Global Scheduling            Kernel level thread의 경우 일반 프로세스와 마찬가지로 커널의 단기 스케쥴러가 어떤 thread를 스케쥴링할지 결정           Real Time Scheduling    정해진 시간(Deadline)안에 반드시 수행되어야 하는 프로세스 스케줄링   주로 미리 스케줄링을 해서 적재적소에 배치되도록 함   Hard Reat-time systems            정해진 시간 안에 반드시 끝내도록 스케줄링 해야함           Soft Real-time computing            일반 프로세스에 비해 높은 priority를 갖도록 해야 함.           Thread Scheduling    Local Scheduling            User level thread의 경우 사용자 수준의 thread library에 의해 어떤 thread를 스케쥴링할지 결정           Global Scheduling            Kernel level thread의 경우 일반 프로세스와 마찬가지로 커널의 단기 스케쥴러가 어떤 thread를 스케쥴링할지 결정           Scheduling Algorithm Evaluation    Queueing models            굉장히 이론적인 평가 방법       확률 분포로 주어지는 arrival rate와 service rate 등을 통해 각종 performance index 값을 계산           Implementation(구현) &amp; Measurement(성능 측정)            실제 시스템에 알고리즘을 구현하여 실제 작업(workload)에 대해서 성능을 측정 및 비교       사용하기 어려운 방법 (직접 OS kernel을 수정해야 함.)           Simulation (모의 실험)            알고리즘을 모의 프로그램으로 작성 후 trace를 입력으로 하여 결과 비교          "
  },
  
  {
    "title": "Operating System Concepts - (2)",
    "url": "/posts/Operating-System-Concepts-2/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2024-07-14 23:37:40 +0900",
    "content": "   컴퓨터 시스템의 구조 (Ch2)      하드 디스크는 input device/output device 둘 다의 역할을 한다.            cpu안에는 memory보다 빠른 저장 공간이 있음. 이를 register라고 함.           Interrupt line은 항상 프로그램이 memory 영역만을 사용해서 작동하기는 어렵기 때문에, I/O device 접근을 위해 프로그램 실행 중 interrupt를 걸어 해당 device에서 데이터를 읽거나 쓴다.      Mode Bit (p.26 참조)        사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요.   cpu는 항상 interrupt line을 체크해 프로그램 실행 중 interrupt가 발생했는지를 확인함.   트랩이나 인터럽트가 발생할 때마다, 하드웨어는 사용자 모드에서 -&gt; 커널모드로 전환.(즉 mode bit를 0으로 변경)   Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원   1 (User mode) : 사용자 프로그램 수행 운영체제가 CPU에서 실행중. 모든지 실행을 할 수 있음. 0 (Monitor mode, kernel mode, system mode) : OS Code 수행     보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 “특권 명령”으로 규정   Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꿈   사용자 프로그램에게 CPU넘기기 전 mode bit 1로 세팅      Timer (p.28 참조)      타이머 : 사용자 프로그램이 무한루프(Infinite loop)에 빠지거나 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지해야한다.            정해진 시간이 흐른 뒤(초기에 정해진 시간을 할당함) 운영체제에게 제어권이 넘어가도록 인터럽트 하도록 설정할 수 있다.       Timer는 특정 프로그램이 cpu를 독점하는 것을 막기 위한 역할을 수행함. Timer에 값을 세팅한 후 프로그램을 cpu에 전달함. 세팅한 시간이 지나면 interrupt를 걸어 프로그램이 멈추도록 함.       타이머는 매 클럭 틱 때마다 1씩 감소       타이머 값이 0이 되면 타이머 인터럽트 발생       CPU를 특정 프로그램이 독점하는 것으로부터 보호           타이머는 time sharing을 구현하기 위해 널리 이용됨.   타이머는 현재 시간을 계산하기 위해서도 사용됨.      Interrupt (인터럽트) (p.540 참조)   Interrupt(인터럽트) 컨트롤러가 장치 드라이버에게 작업을 사실을 어떻게 알릴까? 인터럽트를 통해서!     하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. 인터넙트는 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.   즉 컴퓨터에서 신호를 보내 이벤트 발생을 알리는 것을 의미한다.        보통 컴퓨터에서 여러 작업을 동시에 처리하는데, 기존 작업을 중단하고 타 작업을 진행해야 할 때 인터럽트 신호를 보내 기존작업을 중단하라고 신호를 보낸다. 그러면 커널이 작업을 멈추고 인터럽트 처리한 뒤 기존 작업으로 돌아온다.       Trap(트랩) : 소프트웨어에 의해 발생하는 인터럽트        하드웨어는 System Bus(시스템 버스) 를 통해 CPU에 신호 보내서 인터럽트 발생시키고, 소프트웨어는 System Call(시스템 콜) 이라는 명령으로 인터럽트 발생시킨다.      인터럽트 당한 시점의 레지스터와 program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.   Interrupt(넓은 의미)            interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트. 일반적인 의미의 interrupt.       trap (소프트웨어 인터럽트)                    Exception : 프로그램이 오류를 범한 경우           System Call : 프로그램이 커널 함수를 호출하는 경우                           인터럽트 관련 용어            인터럽트 벡터                    해당 인터럽트의 처리 루틴 주소를 가지고 있음.                       인터럽트 처리 루틴 ( = Interrupt Service Routine, 인터럽트 핸들러)                    해당 인터럽트를 처리하는 커널 함수                              System Call(시스템 콜) (p.24, 26 참조)   시스템 콜         사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것       Trap : 하드웨어 인터럽트와 다르게 Trap(트랩, 또는 오류)가 있는데, 이는 Exception(ex: 0으로 나누거나 유효하지 않은 메모리 엑세스) 또는 사용자 프로그램의 특정 요청 때문에 발생하는 소프트웨어 생성 인터럽트이다.   이 특정 요청은 시스템 콜이라는 특수 연산을 실행하여 요청되고 운영체제가 제공하는 서비스가 수행될 것을 요구한다.       I/O Structure (입출력구조) (p.15 참조)   동기식 입출력과 비동기식 입출력(p. 550참조)    동기식 장치는 시스템의 다른 측면과 조율하여 일정한 응답시간을 보인다. 반면 비동기식 장치는 다른 이벤트와 조율 없이 불규칙한 혹은 예측 불가능한 응답시간을 보인다.   동기식 입출력(Synchronous I/O)            I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감       구현방법 1                    I/O가 끝날 때까지 CPU 낭비시킬 수 있음           매 시점 하나의 I/O만 일어날 수 있음                       구현방법 2                    I/O가 완료될 때까지 해당 프로그램에서 CPU 빼앗음           I/O처리를 기다리는 줄에 그 프로그램을 줄세움           다른 프로그램에게 CPU 제공                       비동기식 입출력(Asynchronous I/O)                    I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감                           + 추가 설명    입출력을 요청한 프로세스가 입출력이 끝날 때까지 대기상태일 경우 동기식 입출력.   입출력을 요청한 프로세스가 종료시까지 대기하지 않고 CPU가 새로운 instruction를 실행할 경우 비동기식 입출력.   #### * 두 경우 모두 I/O의 완료는 인터럽트로 알려줌     I/O Device Controller     해당 I/O 장치 유형을 관리하고 제어하는 일종의 작은 CPU – cpu보다 device가 처리 속도가 느리기 때문에 이러한 처리를 관리해주는 역할을 device controller가 수행함.   제어 정보를 위해 control register, status register를 가짐 (CPU의 지시를 위한 register) – cpu안에는 memory보다 빠른 저장 공간이 있음. 이를 register라고 함.   local buffer를 가짐 (일종의 data register), local buffer는 일종의 각 디바이스 별 작업 공간.   I/O는 실제 Device와 Local Buffer 사이에서 일어남.   Device Controller는 I/O 가 끝났을 경우 interrupt로 CPU에 그 사실을 알림   device driver (장치 구동기) : OS Code 중 각 장치별 처리 루틴을 의미함 -&gt; Software 영역   device Controller (장치 제어기) : 각 장치를 통제하는 일종의 작은 CPU -&gt; Hardware   DMA (Direct Memory Access) 직접 메모리 엑세스 (p.15, 546 참조)    인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는데는 좋지만 NVS I/O와 같은 대량 데이터 이동에 사용될 때 높은 오버헤드를 유발할 수 있다.   빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용   CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송   바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴    서로 다른 입출력 기계어    I/O를 수행하는 sepcial instruction에 의해   Memory Mapped I/O에 의해       저장장치 계층 구조  (p.14 참조)      internal 기억장치들은 주로 휘발성 기억장치들, external 기억장치들은 주로 비휘발성 기억장치로 구성된다.   CPU가 직접 접근 가능한 primary 저장장치들은 register, cache memory, main memory 이렇게 세가지 이다.   용량이 적을수록 속도도 빠르고 가격이 비싸며, 용량이 클수록 속도도 느리고 가격이 저렴하다.   register와 main memory간의 속도 차이를 줄이기 위해 cache memory 를 사용한다.        프로세스 관리 (Ch3)   프로그램 실행(Memory Load)     각 프로그램마다 독자적인 주소 공간이 생기며, 그 안에는 stack, data, code로 영역이 나누어져 있다.   stack : 함수를 호출하거나 리턴할때 데이터를 임시 보관하는 영역            사용자 프로그램마다 커널 스택을 따로 사용함.           data : 변수, 전역 변수 저장. 프로그램이 사용하는 자료구조 영역.            프로세스를 관리하기 위한 자료구조(PCB) 저장       CPU, Memory, Disk를 관리하기 위한 자료구조 저장.           code : 프로그램의 기계어 코드를 저장하는 영역. 커널 코드            시스템 콜, 인터럽트 처리 코드       자원 관리를 위한 코드       편리한 서비스 제공을 위한 코드           커널 주소 공간의 내용      코드 : 커널 코드            시스템 콜, 인터럽트 처리 코드       자원 관리를 위한 코드       편리한 서비스 제공을 위한 코드           데이터 : 모든 하드웨어 관리하는 자료구조들과 모든 프로세스들 관리하는 자료구조(PCB)가지고 있다.   스택 : 각 프로세스별 커넉 스택이 들어간다   사용자 프로그램이 사용하는 함수    함수 (function)            사용자 정의 함수                    자신의 프로그램에서 정의한 함수                       라이브러리 함수                    자신의 프로그램에서 정의하지 않고 갖다 쓴 함수           자신의 프로그램의 실행 파일에 포함되어 있다.                       커널 함수                    운영체제 프로그램의 함수           커널 함수의 호출 = 시스템 콜                            프로그램의 실행       내가 정의한 함수 or 라이브러리 함수 실행 : 내 주소공간에 있는 함수가 사용자 모드에서 실행됨   system call : CPU제어권이 운영체제에 넘어가서, 커널모드에서 운영체제 주소공간에 있는 코드가 실행됨   프로세스의 개념    Process is a program in execution (실행중인 프로그램)   프로세스의 문맥(context)            CPU의 수행 상태를 나타내는 하드웨어 문맥.                    Program Counter           각종 Register                       프로세스의 주소 공간                    code, data, stack                       프로세스 관련                    PCB (Process Control Block)           Kernel stack                           프로세스의 상태 (p.121 참조)     프로세스는 상태가 변경되면서 수행된다.            New(새로운)                    프로세스가 생성중인 상태                       Running(실행)                    CPU를 잡고 Instructionm을 수행중인 상태                       Ready(준비)                    CPU를 기다리는 상태 (메모리 등 다른 조건을 모두 만족하고)                       Blocked (waiting, sleep) (대기)                    CPU를 주어도 당장 instruction을 수행할 수 없는 상태           Process 자신이 요청한 event (ex. I/O) 가 즉시 만족되지 않아 이를 기다리는 상태 ex) 디스크에서 파일을 얽어와야 하는 경우           =&gt;자신이 요청한 event 완료시 Ready                       Terminated(종료)                    수행(execution)이 끝난 상태                       Suspended (Stopped) -&gt; 중기 스케쥴러로 인해 발생한 상태                    CPU에서 뿐만 아니라 외부적인 이유로 프로세스의 수행이 정지된 상태           프로세스는 통째로 디스크에 swap out 된다. ex) 사용자가 프로그램을 일시 정지 시킨 경우 (break key) 시스템이 여러 이유로 프로세스를 잠시 중단시킴 (메모리에 너무 많은 프로세스가 올라와 있을 때)           외부적인 이유로 프로세스 정지 - 외부에서 resume해주어야 Active                           프로세스 상태도   Process Control Block(PCB) (p.121 참조)    운영체제가 각 프로세스를 관리 및 제어하기 위해 프로세스당 유지하는 상태 정보를 저장해놓은 자료구조   프로세스가 진행됨에 따라 PCB는 변경되기도 하며, 프로세스가 종료되면 PCB도 사라지는 것이 특징이다.   운영체제가 PCB에 빠르게 접근하기 위해 Process Table 을 사용하며, PID를 통해 원하는 PCB 위치에 쉽게 접근할 수 있다.   구성 요소    (1) OS가 관리상 사용하는 정보            Pointer (프로세스의 현재 위치)       Process State (생성, 준비, 실행, 대기, 종료의 프로세스의 상태)       Process number (PID, 프로세스를 식별하기 위한 고유한 ID)       Scheduling Information, priority           (2) CPU 수행 관련 하드웨어 값            Program counter (실행 될 다음 명령어의 주소)       registers (CPU 레지스터 Infomation)           (3) 메모리 관련 (memory limits)            Code, data, stack 등의 운영체제 메모리 관리 및 위치 정보를 포함하며, 페이지 및 세그먼트 테이블 등을 저장           (4) 파일 관련 (list of open files)            Open file descriptors(프로세스 실행을 위해 열린 파일 목록)       그 외 리소스 관련 정보들            Context Switch (문맥교환) (p.127 참조)    CPU코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요하다.   CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정   CPU가 다른 프로세스에서 넘어갈 때 운영체제는 다음을 수행            CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장       CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어 Register에 적재함.                CPU를 비롯한 자원을 이미 프로세스가 사용중인 상태에서 다른 프로세스가 자원을 사용해야 할 경우에 프로세스의 상태(문맥 / Context)를 보관하고 새로운 프로세스의 상태를 적재하는 것을 말함      System call이나 Interrupt 발생시 반드시 context switch가 일어나는 것은 아님. (1) 사용자 프로세스 A(user mode) =&gt; interrupt or system call =&gt; ISR or system call 함수 (kernel mode) =&gt; 문맥교환 없이 user mode 복귀 =&gt; 샤용자 프로세스 A (user mode) (2) 사용자 프로세스 A(user mode) =&gt; timer interrupt or I/O 요청 system call =&gt;  kernel mode =&gt; context switch 발생 =&gt; 사용자 프로세스 B (user mode) =&gt; (1)의 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 save 해야 하지만, 문맥교환을 해야하는 (2)의 경우 훨씬 그 부담이 큼. (ex) cache memory flush)   프로세스를 스케줄링하기 위한 큐 (p.123 참조)    Job Queue            현재 시스템 내에 있는 모든 프로세스의 집합       Ready Queue, Device Queue가 모두 Job Queue 내에 포함되어 있음.           Ready Queue            현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합           Device Queue            I/O device의 처리를 기다리는 프로세스의 집합           프로세스들은 각 큐들을 오가며 수행된다.      Scheduler(스케쥴러) (p.123 참조)    Long-term scheduler (Job scheduler or 장기 스케쥴러)            시작 프로세스 중 어떤 것들을 ready queue로 보낼 지 결정       프로세스에 memory 및 각종 자원을 주는 문제를 다루는 스케쥴러       degree of Multiprogramming(메모리에 프로그램이 몇 개 올라가 있는가?) 을 제어       time sharing system에는 보통 장기 스케쥴러가 존재하지 않음. (무조건 ready 상태)           Short-term scheduler (CPU scheduler or 단기 스케쥴러)            어떤 프로세스를 다음 번에 running 시킬지 결정       프로세스에 CPU를 주는 문제       짧은 시간 단위로 스케쥴러가 이루어짐. 그러므로 충분히 빨라야 함 (millisecond 단위)           Medium-term scheduler (Swapper or 중기 스케쥴러)            여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫒아냄       프로세스에게서 memory를 뺏는 문제       중기 스케쥴러가 CPU 사용에서는 효율적 역할을 수행함.       degree of Multiprogramming(메모리에 프로그램이 몇 개 올라가 있는가?) 을 제어           상세 프로세스 상태도 ( With active and inactive &amp;&amp; User mode Running vs monitor mode Running)   Thread     CPU 수행단위   “A thread(or lightweight process) is a basic unit of CPU utilization”   Thread의 구성            program counter       register set       stack space           Thread가 동료 thread와 공유하는 부분(=task)            code section       data section       OS resources                전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다.      장점            다중 스레드로 구성된 task 구조에서는 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 테스크 내의 다른 스레드가 실행(Running)되어 빠른 처리를 할 수 있다.       동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다.       스레드를 사용하면 병렬성을 높일 수 있다. 각 thread들이 여러 개의 CPU에서 동시 실행되게 되면 빠르게 작업을 수행할 수 있음 .            Responsiveness (응답성)            여러개의 쓰레드를 사용하게 되면, 여러 프로세스의 작업을 동시에 수행할 수 있기 때문에 응답이 빨라진다.       ex) multi-threaded Web -&gt; if one thread is blocked(ex. network) another thread continues(ex. display)           Resource Sharing (자원 공유)            쓰레드는 하나의 프로세스로 그 안의 CPU의 수행 단위만을 여러개 두는 차원이므로 자원을 공유하면서 더 많은 작업을 수행할 수 있다는 장점이 있다.       n threads can share binary code, data, resource of the process           Economy            쓰레드간의 switching은 오버헤드 없이 빠르게 동작이 가능하기 때문에 훨씬 경제적이다.       프로세스를 creating or switching 하는 것보다 훨씬 오버헤드가 적음 (Solaris의 경우 각각 30배, 5배의 오버헤드 차이가 발생함)       creating &amp; CPU switching thread (rather than a process)       Solaris의 경우 위 2가지 overhead가 각각 30배, 5배 빠름           Utilization of Multi Process Architectures            멀티 프로세서 환경에서 여러개의 쓰레드를 병렬적으로 수행할 수 있으므로 훨씬 효율적임.       each thread may be running in parallel on a different processor 작성할 목록           Implementation of Threads    Kernel Threads            커널이 Thread를 관리. 시스템 스케쥴러가 커널 스레드를 관리한다.       Windows       Solaris       Digital UNIX, Mach           Library 지원 (User Threads)            OS는 Thread에 대해 모르고, Libary(사용자) 차원에서 thread 관리하는 방식이므로 구현에 제약이 있음.       POSIX Pthreads       Mach C-Threads       Solaris Threads       Real-time Threads           추가 학습 Mode bit 저장위치  출처(참고문헌) Where is the mode bit? "
  },
  
  {
    "title": "Operating System Concepts",
    "url": "/posts/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/",
    "categories": "운영체제",
    "tags": "공룡책, 운영체제",
    "date": "2024-07-07 21:25:40 +0900",
    "content": "   운영체제 개요 (Ch1. Overview)   운영체제란?  컴퓨터 하드웨어를 관리하는 소프트웨어. 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. 컴퓨터에서 항상 실행되는 프로그램이다. (일반적으로 커널이라고 함)  운영체제의 목적 : 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공.  컴퓨터 시스템 - 하드웨어 , 운영체제, 응용프로그램, 사용자로 구성.    하드웨어 : 중앙처리장치 (CPU) + 메모리 및 입출력장치(I/O)로 구성, 기본 계산용 자원 제공.        응용프로그램 : 워드프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등 사용자의 계산문제 해결을 위해 자원이 어떻게 사용될 지 정의.     사용자 관점 사용자는 PC앞에서 작업하고 시스템의 목표는 사용자가 수행하는 작업을 최대화하는 것이다. 운영체제는 사용의 용이성을 위해 설계되었으며 사용자들이 자원을 공평하게 사용할 수 있도록 한다.      시스템 관점 컴퓨터 관점에서 운영체제는 하드뒈어와 가장 밀접한 프로그램이므로 자원할당자로 볼 수 있음. 컴퓨터 시스템은 문제를 해결하기위해 요구되는 자원들 즉, CPU시간, 메모리공간, 저장장치 공간, 입출력장치 등을 가진다. 다른 관점으로는 여러가지 입출력 장치와 사용자 프로그램을 제어하는 제어프로그램 으로도 본다.  운영체제의 기능    CPU스케줄링 : CPU가 어떤 프로그램에게 CPU사용권을 줄 지 결정   메모리 관리 : 한정된 메모리를 어떻게 쪼개어 쓸 지 결정 - 운영체제 및 여러 프로그램들   디스크 스케줄링 : 디스크에 들어온 요청을 어떤 순서로 처리할 지 결정   인터럽트, 캐싱 : 빠른 CPU와 느린 I/O 장치간 속도차를 어떻게 극복할 지 결정 (ps. CPU는 일반적으로 메모리에 비해 100배 빠르고 디스크에 비해 100만배 빠르다)   운영체제의 분류    동시 작업 가능 여부            Single tasking(단일 작업) : 한 번에 하나의 작업만 처리  ex) MS-DOS 프롬프트 상에서는 한 명령의 수행을 끝내기 전에 다른 명령을 수행시킬 수 없음       Multi tasking(다중 작업) : 동시에 두 개 이상의 작업 처리  ex) UNIX/MS Windows 등에서는 한 명령의 수행이 끝나기 전에 다른 명령이나 프로그램을 수행할 수 있음           사용자의 수            Single User(단일 사용자) ex) MS-DOS, MS Windows       Multi User(다중 사용자) ex) UNIX, NT server           처리 방식            Batch Processing(일괄 처리)                    작업 요청의 일정량 모아서 한꺼번에 처리           작업이 완전 종료될 때까지 기다려야 함 ex) 초기 Punch Card 처리 시스템                       Time Sharing(시분할)                    여러 작업을 수행할 때 컴퓨터 처리 능력을 일정한 시간 단위로 분할하여 사용           일괄 처리 시스템에 비해 짧은 응답 시간을 가짐 : UNIX 등           Interactive한 방식                       Realtime OS(실시간 운영체제)                    처리기의 작동이나 데이터의 흐름에 엄격한 시간제약이 있을 때 사용           정해진 시간안에 어떤 일이 반드시 종료됨이 보장되어야 하는 실시간 시스템을 위한 OS ex) 원자로/공장 제어, 미사일 제어, 반도체 장비, 로보트 제어           확장                            Hard realtime system(경성 실시간 시스템)               Soft realtime system(연성 실시간 시스템) - 비디오                                                       CPU 스케줄링 (p.226 참조)   스케줄링 알고리즘 CPU 스케줄링은 준비 큐에 있는 어느 프로세스이 CPU코어를 할당할 것인지를 결정하는 문제를 다룬다. 최신 CPU아키텍처에는 여러개의 처리코어가 있지만 한개의 처리코어를 가진 CPU가 한개인 시스템으로 가정해 한번에 1개의 프로세스를 실행할 수 있다고 생각하자.  1. First-Come, First-Served Scheduling(선입 선처리 스케줄링)    가장 간단한 CPU스케줄링 알고리즘   CPU를 먼저 요청하는 프로세스가 먼저 할당한다. FIFO 선입선출 방식(구현이 쉬움)   프로세스 처리 순서에 따라 성능이 매우 달라진다.   모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 Convoy Effect(호위효과)가 발생할 수 있다.   먼저 온 프로세스가 끝날때까지 운영체제가 개입하지 않는 비선점 스케줄링 방식에 주의!   2. Shortest-Job-First-Scheduling (최단 작업 우선 스케줄링)    Shortest-next-CPU-burst; 최단 다음 CPU 버스트 알고리즘   가장 작은 CPU버스트를 가진 프로세스를 할당한다.   위 Convoy Effect를 해결할 수 있다.   주어진 프로세스 집합에 대해 최소의 평균 대기시간을 가지기 때문에 최적이라 할 수 있다. 하지만 다음 CPU버스트 길이를 할 순 없어 근사값을 구한다.            일반적인 CPU버스트 길이(다음 CPU버스트 예상하기 위함) : Tn+1 = a*Tn _ (1+a)Tn , (0 &lt;= a &lt;= 1)           CPU버스트 시간이 긴 프로세스는 계속 밀려 Starvation Effect가 발생할 수 있다. -&gt; 영원히 수행될 수 없음   버스트 시간이 짧은 프로세스가 끝날때까지 운영체제가 개입하지 않는 비선점 스케줄링 방식   3. Round-Robin Scheduling (라운드 로빈 스케줄링)    선입 선처리 스케줄링과 유사하지만 시스템이 프로세스들 사이를 옮겨다닐 수 있도록 선점이 추가된다.   Time quantum(시간 할당량) 단위로 여러 프로세스를 번갈아가며 프로세서에 할당.   CPU스케줄러는 준비 큐를 돌면서 한번에 한 프로세스에 한 번의 시간 할당량동안 CPU를 할당한다.   한번의 시간할당량 이후에 인터럽트를 걸도록 (timer)타이머를 설정한 후 프로세스를 dispatch한다(준비상태에서 실행상태로).   시간 할당량에 따라 운영체제가 계속 개입하는 선점 스케줄링 방식!      메모리 관리 (p.452 참조)   Memory Management  메인 메모리는 현대 컴퓨터 시스템의 핵심이며, 바이트의 대용량 배열이다. 그리고 각 바이트는 자신의 주소를 가진다. 프로그램이 수행될 때 절대 주소(Abolute addresses)로 매핑(Mapping)되어 메모리에 로드되고 메모리의 프로그램 명령어와 데이터에 접근한다. 메모리 관리는 여러 요인을 고려해야 하는 작업이며, 특히 시스템의 하드웨어 설계에 좌우된다.  운영체제는 메모리 관리를 위해 메모리의 어떤 부분이 어디에 쓰이는지, 누가 사용하는지 추적하고, 어떤 프로세스와 데이터가 메모리의 안팎으로 옮겨질지 결정한다. 또한 메모리 공간을 할당하고 해제하는 것도 운영체제가 하는 일이다.  Page Replacement         한정적인 메모리를 효율적으로 사용하기 위한 기법, 메모리에 올려진 페이지 중 어떤 것을 내리고 어떤 새로운 페이지를 올릴지를 결정하는 규칙이다.           페이지 결함이 발생할 때 페이지 교체 절차            디스크에서 페이지의 위치를 찾는다       빈 프레임을 찾는다. 빈 프레임이 있으면 거기 페이지를 적재하고, 없으면 페이지 교체 알고리즘을 이용하여 희생 프레임을 선택한다. 이후 희생 프레임에 있는 페이지를 디스크에 쓰고,  프레임에 새 페이지를 적재한다.       페이지 테이블과 프레임 테이블을 변경한다.       프로세스를 재개한다.           1. FIFO 페이지 교체    가장 먼저 메모리에 올려진 페이지를 교체하는 방식   현실성과 효율성이 떨어져서 실제로 잘 사용되지는 않는다.    2. Optimal Page Replacement(최적 페이지 교체)    앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 방식   일반 OS에서는 구현 불가(예측이 불가능 하기 때문)   3. LRU Page Replacement(LRU 페이지 교체)    최근의 과거를 가까운 미래의 근사치로 본다면 가장 오랜기간 사용되지 않은 페이지를 교체하는 방식.   LRU알고리즘은 페이지마다 마지막 사용시간을 유지.   Counters(계수기)방식 혹은 Stack(스택) 방식으로 구현            Counters방식 : 각 페이지 항목마다 사용 시간 필드를 넣고 CPU에 논리적인 시계나 계수기를 추가. 메모리가 접근될 때 마다 시간 증가. 페이지 테이블이 변경될 때 마다 시간 값을 관리해야하며 시간값의 Overflow도 고려해야함.       Stack방식 : 페이지 번호의 스택을 유지하는 방법. 페이지가 참조될 대 마다 페이지 번호는 스택 중간에서 제거되어 Top에 위치하게 되고 Bottom은 가장 오랫동안 이용되지 않은 페이지. Doubly Linked List로 구현.           프로세스에 프레임을 더 주었는데 오히려 페이지 폴트율은 더 증가하는 Belady’s anomaly를 야기하지 않는다.  (ps. *페이지 폴트는 프로세스가 참조하려는 가상 메모리 페이지가 현재 물리적 메모리에 로드되어 있지 않을 때 발생. 이는 메모리 접근 시도 중에 발생하는 인터럽트 또는 예외 상황.)   4. Least Frequently Used 알고리즘(LFU)    참고횟수가 가장 적은 페이지를 교체하는 방식   why? 활발하게 사용되는 페이지는 큰 참조 횟수값을 갖게될거라는 점   맹점 : 어떤 프로세스가 그 초기단계에서는 한 페이지를 집중적으로 많이 사용하지만 그 후로 다시는 이 페이지를 사용하지 않는 경우   해결책 : 참조 횟수를 일정한 시간마다 하나씩 오른쪽으로 시프트해서 지수적으로 그 영향력을 감소시킬 수는 있다.   5. Most Frequently Used 알고리즘(MFU)    반대로 가장 작은 참조회수를 가진 페이지가 가장 최근 참조된것이고, 앞으로 사용될 것이라는 판단에 근거한다.      디스크 스케줄링 (p.492, 500참조)   Access time(디스크 접근시간)의 구성    Seek Time(탐색시간) - 디스크 암을 원하는 실린더로 이동하는데 필요한 시간   Rotational latency(회전지연) - 원하는 섹터가 디스크 헤드 위치까지 회전하는 데 걸리는 시간   Transfer time - 드라이브와 컴퓨터 간의 데이터 흐름의 속도   Disk Scheduling(디스크 스케줄링)    seek time을 최소화 하는것이 목표   seek time = seek distance   1. FCFS Scheduling(선입 선처리 스케줄링)    가장 단순한 방법, 헤드 움직임을 최적화 하지 않기 때문에 성능은 나쁠 수 있다.   2. SSTF Scheduling(Shortest Seek Time First)    탐색 시간이 가장 작은 것부터 처리하는 방식   문제점 : Starvation 현상   3. SCAN Scheduling(SCAN 스케줄링)    Disk Arm(디스크 암)이 디스크의 한 끝에서 시작하여 다른 끝으로 이동하며, 가는 길에 있는 요청을 모두 처리하는 방식.   다른 한쪽 끝에 도달하면 (또는 그쪽 방향으로 더는 대기하고 있는 요청이 없으면) 역방향으로 이동하면서 오는 길에 있는 요청을 모두 처리한다. 즉 헤드는 디스크 양쪽을 계속해서 가로지르며 왕복한다.   흡사 엘리베이터와 비슷하다고 하여 Elevator Algorithm이라고도 부른다.      저장장치 계층구조와 캐싱(Caching) (p.14, 33 참조)   Interrupt(인터럽트)  컨트롤러가 장치 드라이버에게 작업을 사실을 어떻게 알릴까? 인터럽트를 통해서!    하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. 인터넙트는 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분이다.   즉 컴퓨터에서 신호를 보내 이벤트 발생을 알리는 것을 의미한다.   보통 컴퓨터에서 여러 작업을 동시에 처리하는데, 기존 작업을 중단하고 타 작업을 진행해야 할 때 인터럽트 신호를 보내 기존작업을 중단하라고 신호를 보낸다. 그러면 커널이 작업을 멈추고 인터럽트 처리한 뒤 기존 작업으로 돌아온다.    Trap(트랩) : 소프트웨어에 의해 발생하는 인터럽트   하드웨어는 System Bus(시스템 버스) 를 통해 CPU에 신호 보내서 인터럽트 발생시키고, 소프트웨어는 System Call(시스템 콜) 이라는 명령으로 인터럽트 발생시킨다.   Cache Management(캐시 관리)    굉장히 빠르가 작은 저장장치   Caching (캐싱) : 캐시메모리를 사용해 컴퓨터의 속도를 높이는 기술   우리가 특정 정보가 필요할 경우, 우리는 먼저 캐시에 그 정보가 있는지를 조사한다.            만약 캐시에 있으면 그 정보를 캐시로부터 직접 사용       만약 없으면 메인 메모리 시스템으로부터 그 정보를 가져와서 사용하고, 다음에 곧 사용될 확률이 높다는 가정하에 캐시에 넣는다.             플래시 메모리    플래시 메모리            반도체 장치(하드 디스크 : 마그네틱)       NAND형(스토리지), NOR형(임베디드 코드저장용)           플래시메모리의 특징            Nonvolatile       Low power consumption       Shock resisteance       Small size       Lightweight       쓰기 횟수 제약           플래시메모리의 사용 형태            휴대폰, PDA등 임베디드 시스템 구성용       USB용 메모리 스틱       디지털카메라 등의 SD카드, CompactFlash, Smart Media card       모바일 장치 뿐 아니라 대용량 시스템에서 SSD(Solid State Drive)란 이름으로 하드디스크 대체 시도                     운영체제의 분류 p16                           추가 학습 용어    Multitasking   Multiprogramming   Time sharing   Multiprocess   구분            위 용어들은 컴퓨터에서 여러 작업을 동시에 수행하는 것을 뜻한다.       Multiprogramming은 여러 프로그램이 메모리에 올라가 있음을 강조       Time Sharing은 CPU의 시간을 분할하여 나누어 쓴다는 의미를 강조       *Multiprocessor : 하나의 컴퓨터에 CPU가 여러개 붙어있음을 의미           출처(참고문헌) Bélády’s anomaly "
  },
  
  {
    "title": "BOJ_1806_부분합 (Java)",
    "url": "/posts/BOJ1806%EB%B6%80%EB%B6%84%ED%95%A9-Java/",
    "categories": "알고리즘",
    "tags": "Java, 백준, 알고리즘",
    "date": "2024-07-03 15:16:45 +0900",
    "content": "[Gold IV] 부분합 - 1806  문제 링크  성능 요약  메모리: 102172 KB, 시간: 740 ms  분류  누적 합, 두 포인터  제출 일자  2024년 7월 3일 15:20:10  문제 설명  10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.  입력  첫째 줄에 N (10 ≤ N &lt; 100,000)과 S (0 &lt; S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.  출력  첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.  import java.io.File; import java.io.FileNotFoundException; import java.util.Arrays; import java.util.Scanner;  public class BOJ_1806_부분합 { \tstatic int L, R, N, S, len=Integer.MAX_VALUE; \tstatic int[] arr; \tstatic boolean flag = false; \tpublic static void main(String[] args) throws FileNotFoundException { //\t\tScanner sc = new Scanner(System.in); \t\tScanner sc = new Scanner(new File(\"input.txt\")); \t\t \t\tN = sc.nextInt(); \t\tS = sc.nextInt(); \t\tarr = new int[N]; \t\tfor(int i=0; i&lt;N; i++) arr[i] = sc.nextInt(); \t\t \t\tL = 0; R = L; \t\tint sum = arr[L]; \t\twhile(R &lt; N) { \t\t\tif(sum &gt;= S) { \t\t\t\tflag = true; \t\t\t\tlen = Math.min(len, R-L+1); \t\t\t\tSystem.out.println(L + \"~\" + R + \" / 합 : \" + sum + \"/ len : \" + len); \t\t\t\tsum -= arr[L++]; \t\t\t} \t\t\telse { \t\t\t\tif(R == N-1) break; \t\t\t\tSystem.out.println(L + \"~\" + R + \" / 합 : \" + sum + \"/ len : \" + len); \t\t\t\tsum += arr[++R]; \t\t\t} \t\t} \t\twhile(sum&gt;=S) { \t\t\tflag = true; \t\t\tlen = Math.min(len, R-L+1); \t\t\tsum -= arr[L++]; \t\t} \t\tlen = flag? len:0; \t\tSystem.out.println(len); \t} }   "
  },
  
  {
    "title": "Kafka 연습",
    "url": "/posts/Kafka-Test/",
    "categories": "공부",
    "tags": "kafka",
    "date": "2024-06-27 15:30:40 +0900",
    "content": "Kafka 연습  mac에서 혼자 kafka를 연습해보았다  참고 링크 : https://ojava.tistory.com/205 \t\t  https://devocean.sk.com/experts/techBoardDetail.do?ID=163709           + 오류 구글링  카프카 브로커 실행중인지 확인 ps -ef | grep kafka   카프카 브로커 실행 kafka_2.12-3.7.0/bin/kafka-server-start.sh kafka_2.12-3.7.0/config/server.properties   이후 토픽 만들고,  Kafka의 콘솔 컨슈머를 사용하여 로컬 호스트에서 실행 중인 Kafka 서버의 localhost:9092에 연결하고, kguswo-test01 토픽에서 메시지를 소비하도록 지정하는 명령어 kafka_2.12-3.7.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic kguswo-test01   메시지 생산 kafka_2.12-3.7.0/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic kguswo-test01   메시지 소비 kafka_2.12-3.7.0/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic kguswo-test01 --from-beginning   토픽 목록 조회 ~/kafka_2.12-3.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list   kguswo-test01이라는 토픽 생성 ~/kafka_2.12-3.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --topic kguswo-test01 --partitions 1 --replication-factor 1 --create   토픽 삭제 ~/kafka_2.12-3.7.0/bin/kafka-topics.sh --bootstrap-server localhost:9092 --delete --topic kguswo-test01   결과화면    "
  },
  
  {
    "title": "PGMS-조이스틱 (JAVA)",
    "url": "/posts/PGMS-%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1-JAVA/",
    "categories": "알고리즘",
    "tags": "Java, 알고리즘, 프로그래머스",
    "date": "2024-05-29 19:55:14 +0900",
    "content": "[level 2] 조이스틱 - 42860  문제 링크  성능 요약  메모리: 73.3 MB, 시간: 0.05 ms  구분  코딩테스트 연습 &gt; 탐욕법（Greedy）  채점결과  정확성: 100.0합계: 100.0 / 100.0  제출 일자  2024년 05월 29일 17:18:39  문제 설명  조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다. ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA  조이스틱을 각 방향으로 움직이면 아래와 같습니다. ▲ - 다음 알파벳 ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로) ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서) ▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)  예를 들어 아래의 방법으로 \"JAZ\"를 만들 수 있습니다. - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다. - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다. - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다. 따라서 11번 이동시켜 \"JAZ\"를 만들 수 있고, 이때가 최소 이동입니다.  만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.  제한 사항   name은 알파벳 대문자로만 이루어져 있습니다. name의 길이는 1 이상 20 이하입니다.   입출력 예           name return            \"JEROEN\" 56   \"JAN\" 23          출처  ※ 공지 - 2019년 2월 28일 테스트케이스가 추가되었습니다. ※ 공지 - 2022년 1월 14일 지문 수정 및 테스트케이스가 추가되었습니다. 이로 인해 이전에 통과하던 코드가 더 이상 통과하지 않을 수 있습니다.     출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges      문제 풀이     코드  class Solution {     public int solution(String name) {         int answer = 0;         int len = name.length();         int start = 0;         int move = len - 1; // 쭉 오른쪽 갈 때                  if(len == 1) return name.charAt(0) - 'A';                  // 알파벳만         for (int i = 0; i &lt; len; ++i) {             answer += Math.min(name.charAt(i)- 'A',  26-(name.charAt(i) - 'A'));         }                  // 위치만( AAAAA 같이 연속된 A있으면 역으로 하는게 이득)         while (start &lt; len) {              int end = start + 1;             while (end &lt;= len - 1 &amp;&amp; name.charAt(end) == 'A') {                 end++;             }             move = Math.min(move, Math.min(start, len - end) + start + len - end);             start++;         }                  return Math.min(answer + len - 1, answer + move);     } }  "
  }
  
]

