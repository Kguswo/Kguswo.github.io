

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-12-18T18:46:38+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Real MySQL 8.0 : 서브쿼리, CTE, 잠금을 사용하는 SELECT</title>
    <link href="https://kguswo.github.io/posts/Real-MySQL-8.0-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-CTE-%EC%9E%A0%EA%B8%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-SELECT/" rel="alternate" type="text/html" title="Real MySQL 8.0 : 서브쿼리, CTE, 잠금을 사용하는 SELECT" />
    <published>2025-12-15T19:54:47+09:00</published>
  
    <updated>2025-12-15T19:54:47+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Real-MySQL-8.0-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-CTE-%EC%9E%A0%EA%B8%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-SELECT/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Real-MySQL-8.0-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-CTE-%EC%9E%A0%EA%B8%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-SELECT/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="데이터베이스" />
    
  

  <summary>들어가며  Real MySQL 8.0 2권 11장에서는 쿼리 작성과 최적화에 대해 다룬다. 이 글에서는 그중 11.4.10 서브쿼리, 11.4.11 CTE(Common Table Expression), 11.4.13 잠금을 사용하는 SELECT를 정리한다.  서브쿼리는 MySQL 5.5 이하에서 성능이 좋지 않아 기피 대상이었지만, MySQL 8.0에서는 세미 조인 최적화 등 다양한 최적화 기법이 도입되어 상황이 크게 달라졌다. CTE는 MySQL 8.0에서 새롭게 도입된 기능으로, 복잡한 쿼리의 가독성을 높이고 재귀 쿼리를 가능하게 한다. 잠금을 사용하는 SELECT는 동시성 제어의 핵심으로, MySQL 8.0.1부터 NOWAIT과 SKIP LOCKED 옵션이 추가되어 더욱 유연한 잠금 제어가 가능해...</summary>

  </entry>

  
  <entry>
    <title>선착순 쿠폰 발급과 동시성 문제</title>
    <link href="https://kguswo.github.io/posts/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EB%B0%9C%EA%B8%89%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C/" rel="alternate" type="text/html" title="선착순 쿠폰 발급과 동시성 문제" />
    <published>2025-12-15T19:28:40+09:00</published>
  
    <updated>2025-12-15T19:28:40+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EB%B0%9C%EA%B8%89%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EB%B0%9C%EA%B8%89%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="공부" />
    
  

  <summary>들어가며  Real MySQL 8.0 11.4.13 "잠금을 사용하는 SELECT" 를 읽다 보면, 선착순 쿠폰 발급 시 동시에 1000개의 요청이 들어오는 상황을 예로 들며 NOWAIT과 SKIP LOCKED를 설명한다. 책에서는 간단히 언급하고 넘어가지만, 실제로 이 문제를 해결하려면 상당히 깊은 이해가 필요하다.  특히 배달, 커머스 기업 등에서는 선착순 쿠폰 발급 요청이 동시에 수백, 수천만개가 들어온다고 한다.  이 글에서는 선착순 쿠폰 발급의 동시성 문제가 왜 발생하는지, 그리고 MySQL의 잠금 기능부터 Redis, Kafka를 활용한 대규모 처리까지 단계별로 살펴본다. 필자는 Java 코드로 진행하고자 한다.    Race Condition  선착순 100명에게 쿠폰을 발급하는 요구사항을...</summary>

  </entry>

  
  <entry>
    <title>지연된 조인 실행계획 테스트</title>
    <link href="https://kguswo.github.io/posts/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%A1%B0%EC%9D%B8-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-%ED%85%8C%EC%8A%A4%ED%8A%B8/" rel="alternate" type="text/html" title="지연된 조인 실행계획 테스트" />
    <published>2025-12-13T14:03:15+09:00</published>
  
    <updated>2025-12-13T14:03:15+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%A1%B0%EC%9D%B8-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-%ED%85%8C%EC%8A%A4%ED%8A%B8/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%A1%B0%EC%9D%B8-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-%ED%85%8C%EC%8A%A4%ED%8A%B8/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="공부" />
    
  

  <summary>지연된 조인     드라이빙 테이블만으로 필요한 데이터를 먼저 필터링한 후, 최소한의 레코드로만 조인을 수행하는 기법이다.   조인을 사용하는 쿼리에서 GROUP BY, ORDER BY, LIMIT 등이 함께 사용될 때 성능을 높이기 위해 조인을 최대한 늦추고 필요한 데이터만 먼저 필터링한다.  같은 결과를 반환하는 두 쿼리를 예시로 진행해보자.  SELECT e.* FROM salaries s, employees e WHERE e.emp_no = s.emp_no     AND s.emp_no BETWEEN 10001 AND 15000  -- 5,000명 대상 GROUP BY s.emp_no ORDER BY SUM(s.salary) DESC LIMIT 10;     0.031 sec / 0.000 se...</summary>

  </entry>

  
  <entry>
    <title>Real MySQL - SELECT</title>
    <link href="https://kguswo.github.io/posts/Real-MySQL-SELECT/" rel="alternate" type="text/html" title="Real MySQL - SELECT" />
    <published>2025-12-13T13:26:29+09:00</published>
  
    <updated>2025-12-13T13:26:29+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Real-MySQL-SELECT/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Real-MySQL-SELECT/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="데이터베이스" />
    
  

  <summary>Real MySQL 8.0 : 11장 쿼리 작성 및 최적화 (2) - SELECT  들어가며  SELECT 문은 데이터베이스에서 가장 많이 사용되는 SQL 문이다. 단순히 데이터를 조회하는 것처럼 보이지만, 내부적으로는 여러 단계의 처리 과정을 거치며 인덱스 활용 여부에 따라 성능이 크게 달라진다. 이번 글에서는 Real MySQL 8.0 2권 11장의 SELECT 관련 내용 중 11.4.1 SELECT 절의 처리 순서 부터 11.4.9 ORDER BY 까지를 정리한다.    SELECT 절의 처리 순서  SELECT 문장을 작성할 때 각 절(FROM, WHERE, GROUP BY 등)은 특정 순서로 작성해야 하지만, 실제 처리 순서는 작성 순서와 다르다.  SELECT s.emp_no, COUNT(D...</summary>

  </entry>

  
  <entry>
    <title>레디스 기본 개념</title>
    <link href="https://kguswo.github.io/posts/%EB%A0%88%EB%94%94%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/" rel="alternate" type="text/html" title="레디스 기본 개념" />
    <published>2025-12-10T02:47:02+09:00</published>
  
    <updated>2025-12-10T02:47:02+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EB%A0%88%EB%94%94%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EB%A0%88%EB%94%94%EC%8A%A4-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="Redis_For_Developers" />
    
  

  <summary>3장 : 레디스 기본 개념  들어가며  레디스는 단순한 키-값 저장소가 아니다. 다양한 자료 구조를 지원하는 데이터 구조 서버 라고 표현하는 것이 더 정확하다. 기존의 키-값 저장소가 문자열 키와 문자열 값만을 연결했다면, 레디스는 String, List, Hash, Set, Sorted Set 등 복잡한 자료 구조를 지원한다.  이번 장에서는 레디스가 제공하는 자료 구조들의 특징과 사용법을 살펴보고, 키를 효율적으로 관리하는 방법까지 알아본다.    레디스의 자료 구조  String  String은 레디스에서 가장 기본적인 자료 구조 다. 키와 연결할 수 있는 가장 단순한 유형의 값이며, 레디스의 키가 문자열이므로 문자열을 다른 문자열에 매핑하는 구조라고 볼 수 있다.  String 타입에는 모든 종...</summary>

  </entry>

</feed>


