

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-10-02T18:56:11+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[Effective Java] - toString을 항상 재정의하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - toString을 항상 재정의하라" />
    <published>2025-10-02T06:42:48+09:00</published>
  
    <updated>2025-10-02T06:42:48+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 12 : toString을 항상 재정의하라  들어가며 자바에서 클래스를 만들 때 equals(), hashCode() 재정의의 중요성은 잘 알고 있다. 하지만 toString() 메서드의 재정의는 종종 간과된다.  이펙티브 자바 아이템 12는 toString()을 항상 재정의하는 것이 얼마나 중요한지 강조한다.  Object의 기본 toString은 쓸모가 없다  개발자가 toString()을 재정의하지 않으면 java.lang.Object 클래스의 기본 구현이 상속된다. 실제 JDK의 Object.toString() 구현을 보자.  /**  * Returns a string representation of the object.  * @implSpec  * The {@code toString}...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 다 쓴 객체 참조를 해제하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 다 쓴 객체 참조를 해제하라" />
    <published>2025-10-02T06:20:05+09:00</published>
  
    <updated>2025-10-02T06:20:05+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 7 다 쓴 객체 참조를 해제하라  들어가며  자바 개발자라면 누구나 가비지 컬렉터(Garbage Collector, GC) 덕분에 C/C++ 처럼 직접 메모리 관리에 신경 쓸 일이 거의 없다고 생각할 것이다. 실제로 가비지 컬렉터 구현은 매우 효율적이라고 알려져 있기도 하다.  이번 아이템에서는 이러한 오해를 깨트리고 우리가 예상치 못했던 순간에 자바에서 발생할 수 있는 메모리 누수(Memory Leak) 의 위험성을 강조한다.  메모리 누수는 어떻게 발생할까?  GC는 사용하지 않는 객체를 자동으로 회수하지만 문제는 우리가 ‘다 쓴 객체’라고 생각해도 GC는 ‘살아있는 참조(Live Reference)’가 남아있다고 착각하는 상황 이다. 이로 인해 메모리 누수가 발생하며, 장기적으로는 GC ...</summary>

  </entry>

  
  <entry>
    <title>인텔리제이 테스트 실행 시 ClassNotFoundException 오류 해결</title>
    <link href="https://kguswo.github.io/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C-ClassNotFoundException-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/" rel="alternate" type="text/html" title="인텔리제이 테스트 실행 시 ClassNotFoundException 오류 해결" />
    <published>2025-10-01T16:52:28+09:00</published>
  
    <updated>2025-10-01T16:52:28+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C-ClassNotFoundException-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C-ClassNotFoundException-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="오류_해결" />
    
  

  <summary>들어가며     이번에 과제전형을 진행하는 중 인텔리제이 오류를 겪어 해결과정을 정리해두고자 한다. 어느 회사 과제, 과제 내용, 그리고 관련된 내용이나 코드는 전혀 없음을 미리 밝힌다.   오류 상황  macOS 에서 Intellij 로 Spring Boot 프로젝트를 작업했다. 빌드 및 실행, 테스트 모두 잘 되는 상황이었다.  이를 Windows 환경에서도 잘 되는지 검증하고자 .zip으로 압축하여 윈도우 환경에서 실행해보았다.  빌드 및 실행을 잘 된다…    애플리케이션 실행은 잘 되는 상황이다.  테스트 오류??      오류가 발생했다.  Windows에서는  start build\reports\tests\test\index.html   macOS에서는  open  build\reports...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 생성자에 매개변수가 많다면 빌더를 고려하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EB%A7%8E%EB%8B%A4%EB%A9%B4-%EB%B9%8C%EB%8D%94%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 생성자에 매개변수가 많다면 빌더를 고려하라" />
    <published>2025-09-25T09:38:48+09:00</published>
  
    <updated>2025-09-25T09:38:48+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EB%A7%8E%EB%8B%A4%EB%A9%B4-%EB%B9%8C%EB%8D%94%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EB%A7%8E%EB%8B%A4%EB%A9%B4-%EB%B9%8C%EB%8D%94%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 2 생성자에 매개변수가 많다면 빌더를 고려하라  들어가며  생성자에 매개변수가 많으면 사용하기도 어렵고, 매개변수의 의미를 파악하기 힘들다는 문제가 있다.  예를 들어, 또 비슷한 타입의 매개변수가 여러 개일 때는 순서를 잘못 넣으면 컴파일 시점에서 오류가 발생하지 않아 실수를 유발하기도 한다. 이 경우 점층적 생성자 패턴과 자바빈즈 패턴이 전통적인 해결책으로 사용되었으나 각각 단점이 존재한다.  이번 글에서 빌더 패턴의 구체적인 구조와 사용법, 그리고 장점을 자세히 살펴보자.  점층적 생성자 패턴  생성자에 매개변수가 많은 객체를 만들 때 전통적인 점층적 생성자 패턴을 사용하면, 매번 모든 매개변수를 나열하는 생성자가 필요해져 생성자의 수가 급격하게 늘어난다.  점층적 생성자 패턴(teles...</summary>

  </entry>

  
  <entry>
    <title>Spring AI에 대하여</title>
    <link href="https://kguswo.github.io/posts/Spring-AI%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/" rel="alternate" type="text/html" title="Spring AI에 대하여" />
    <published>2025-09-21T01:32:30+09:00</published>
  
    <updated>2025-09-21T01:32:30+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Spring-AI%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Spring-AI%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="공부" />
    
  

  <summary>들어가며   최근 AI와 LLM이 소프트웨어 개발의 새로운 패러다임으로 자리 잡으면서, 기존 Spring 생태계에서도 이러한 변화에 대응할 수 있는 프레임워크가 필요해졌다. Spring AI는 이런 요구에 응답하여 탄생한 프레임워크로, Spring 개발자들이 익숙한 방식으로 AI 기능을 통합할 수 있게 해준다.  AI에 큰 관심과 향후 커리어에 AI를 접목하고싶은 서버 개발자로서, 이 글을 통해 Spring AI의 핵심 개념들을 기술적으로 간단히 살펴보고 실제 구현에서 고려해야 할 세부사항들을 정리해보려 한다.  Spring AI란?   Spring AI는 AI 엔지니어링을 위한 애플리케이션 프레임워크다. 핵심 목표는 Spring 생태계의 설계 원칙인 이식성(Portability)과 모듈화 설계(Mod...</summary>

  </entry>

</feed>


