

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-10-14T10:32:35+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[Effective Java] - 상속보다는 컴포지션을 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 상속보다는 컴포지션을 사용하라" />
    <published>2025-10-14T06:33:36+09:00</published>
  
    <updated>2025-10-14T06:33:36+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 18. 상속보다는 컴포지션을 사용하라  들어가며 상속(inheritance)은 코드 재사용의 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다. 이번 아이템에서는 상속의 문제점과 이를 해결하는 컴포지션(composition) 방식에 대해 알아본다.     주의: 여기서 말하는 상속은 클래스가 다른 클래스를 확장하는 구현 상속을 말한다. 인터페이스 상속(클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장)과는 무관하다.   상속의 문제점  1. 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다  상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - Comparable을 구현할지 고려하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - Comparable을 구현할지 고려하라" />
    <published>2025-10-14T05:03:12+09:00</published>
  
    <updated>2025-10-14T05:03:12+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 14 : Comparable을 구현할지 고려하라  들어가며  객체들을 정렬해야 하는 상황에 종종 직면한다. 학생들을 성적순으로, 상품들을 가격순으로, 직원들을 입사일순으로 정렬하는 등의 작업 등이 있다.  Java는 이러한 정렬 작업을 위해 Comparable 과 Comparator 라는 두 가지 강력한 도구를 제공한다.이번 아이템 14에서는 Comparable 인터페이스를 구현할 때 지켜야 할 규약과 주의사항, 그리고 Comparator 와의 차이점을 살펴보며, 언제 어떤 방식을 선택해야 하는지 알아본다.    Comparable 인터페이스란?     객체 간의 순서를 비교할 수 있게 해주는 인터페이스.   Comparable 인터페이스를 구현하면 그 클래스의 인스턴스들에는 자연적인 순서가 ...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - toString을 항상 재정의하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - toString을 항상 재정의하라" />
    <published>2025-10-02T06:42:48+09:00</published>
  
    <updated>2025-10-02T06:42:48+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 12 : toString을 항상 재정의하라  들어가며 자바에서 클래스를 만들 때 equals(), hashCode() 재정의의 중요성은 잘 알고 있다. 하지만 toString() 메서드의 재정의는 종종 간과된다.  이펙티브 자바 아이템 12는 toString()을 항상 재정의하는 것이 얼마나 중요한지 강조한다.  Object의 기본 toString은 쓸모가 없다  개발자가 toString()을 재정의하지 않으면 java.lang.Object 클래스의 기본 구현이 상속된다. 실제 JDK의 Object.toString() 구현을 보자.  /**  * Returns a string representation of the object.  * @implSpec  * The {@code toString}...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 다 쓴 객체 참조를 해제하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 다 쓴 객체 참조를 해제하라" />
    <published>2025-10-02T06:20:05+09:00</published>
  
    <updated>2025-10-02T06:20:05+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 7 다 쓴 객체 참조를 해제하라  들어가며  자바 개발자라면 누구나 가비지 컬렉터(Garbage Collector, GC) 덕분에 C/C++ 처럼 직접 메모리 관리에 신경 쓸 일이 거의 없다고 생각할 것이다. 실제로 가비지 컬렉터 구현은 매우 효율적이라고 알려져 있기도 하다.  이번 아이템에서는 이러한 오해를 깨트리고 우리가 예상치 못했던 순간에 자바에서 발생할 수 있는 메모리 누수(Memory Leak) 의 위험성을 강조한다.  메모리 누수는 어떻게 발생할까?  GC는 사용하지 않는 객체를 자동으로 회수하지만 문제는 우리가 ‘다 쓴 객체’라고 생각해도 GC는 ‘살아있는 참조(Live Reference)’가 남아있다고 착각하는 상황 이다. 이로 인해 메모리 누수가 발생하며, 장기적으로는 GC ...</summary>

  </entry>

  
  <entry>
    <title>인텔리제이 테스트 실행 시 ClassNotFoundException 오류 해결</title>
    <link href="https://kguswo.github.io/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C-ClassNotFoundException-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/" rel="alternate" type="text/html" title="인텔리제이 테스트 실행 시 ClassNotFoundException 오류 해결" />
    <published>2025-10-01T16:52:28+09:00</published>
  
    <updated>2025-10-01T16:52:28+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C-ClassNotFoundException-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EC%9D%B8%ED%85%94%EB%A6%AC%EC%A0%9C%EC%9D%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%8B%A4%ED%96%89-%EC%8B%9C-ClassNotFoundException-%EC%98%A4%EB%A5%98-%ED%95%B4%EA%B2%B0/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="오류_해결" />
    
  

  <summary>들어가며     이번에 과제전형을 진행하는 중 인텔리제이 오류를 겪어 해결과정을 정리해두고자 한다. 어느 회사 과제, 과제 내용, 그리고 관련된 내용이나 코드는 전혀 없음을 미리 밝힌다.   오류 상황  macOS 에서 Intellij 로 Spring Boot 프로젝트를 작업했다. 빌드 및 실행, 테스트 모두 잘 되는 상황이었다.  이를 Windows 환경에서도 잘 되는지 검증하고자 .zip으로 압축하여 윈도우 환경에서 실행해보았다.  빌드 및 실행을 잘 된다…    애플리케이션 실행은 잘 되는 상황이다.  테스트 오류??      오류가 발생했다.  Windows에서는  start build\reports\tests\test\index.html   macOS에서는  open  build\reports...</summary>

  </entry>

</feed>


