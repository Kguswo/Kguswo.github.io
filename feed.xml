

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-10-18T10:28:48+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[Effective Java] - 멤버 클래스는 되도록 static으로 만들라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 멤버 클래스는 되도록 static으로 만들라" />
    <published>2025-10-17T17:34:28+09:00</published>
  
    <updated>2025-10-17T17:34:28+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 24 : 멤버 클래스는 되도록 static으로 만들라  들어가며  중첩 클래스(nested class)는 다른 클래스 안에 정의된 클래스를 말한다. 중첩 클래스는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야 한다. 중첩 클래스의 종류는 네 가지다.     정적 멤버 클래스   (비정적) 멤버 클래스   익명 클래스   지역 클래스   이 중 첫 번째를 제외한 나머지는 내부 클래스(inner class)에 해당한다. 이번 아이템에서는 각 중첩 클래스를 언제, 왜 사용해야 하는지 이야기한다.    정적 멤버 클래스  정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스와...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 인터페이스는 구현하는 쪽을 생각해 설계하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 인터페이스는 구현하는 쪽을 생각해 설계하라" />
    <published>2025-10-17T17:32:46+09:00</published>
  
    <updated>2025-10-17T17:32:46+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 21 : 인터페이스는 구현하는 쪽을 생각해 설계하라  들어가며 자바 8 이전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다. 인터페이스에 메서드를 추가하면 보통은 컴파일 오류가 났다. 추가된 메서드가 우연히 기존 구현체에 이미 존재할 가능성은 아주 낮았기 때문이다.  자바 8에서는 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드(default method) 를 소개했다. 디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.    디폴트 메서드의 등장  /**  * Removes all of the elements of this collection that satisfy the ...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 상속보다는 컴포지션을 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 상속보다는 컴포지션을 사용하라" />
    <published>2025-10-14T06:33:36+09:00</published>
  
    <updated>2025-10-14T06:33:36+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 18. 상속보다는 컴포지션을 사용하라  들어가며 상속(inheritance)은 코드 재사용의 강력한 수단이지만, 항상 최선은 아니다. 잘못 사용하면 오류를 내기 쉬운 소프트웨어를 만들게 된다. 이번 아이템에서는 상속의 문제점과 이를 해결하는 컴포지션(composition) 방식에 대해 알아본다.     주의: 여기서 말하는 상속은 클래스가 다른 클래스를 확장하는 구현 상속을 말한다. 인터페이스 상속(클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장)과는 무관하다.   상속의 문제점  1. 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다  상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - Comparable을 구현할지 고려하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - Comparable을 구현할지 고려하라" />
    <published>2025-10-14T05:03:12+09:00</published>
  
    <updated>2025-10-14T05:03:12+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 14 : Comparable을 구현할지 고려하라  들어가며  객체들을 정렬해야 하는 상황에 종종 직면한다. 학생들을 성적순으로, 상품들을 가격순으로, 직원들을 입사일순으로 정렬하는 등의 작업 등이 있다.  Java는 이러한 정렬 작업을 위해 Comparable 과 Comparator 라는 두 가지 강력한 도구를 제공한다.이번 아이템 14에서는 Comparable 인터페이스를 구현할 때 지켜야 할 규약과 주의사항, 그리고 Comparator 와의 차이점을 살펴보며, 언제 어떤 방식을 선택해야 하는지 알아본다.    Comparable 인터페이스란?     객체 간의 순서를 비교할 수 있게 해주는 인터페이스.   Comparable 인터페이스를 구현하면 그 클래스의 인스턴스들에는 자연적인 순서가 ...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - toString을 항상 재정의하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - toString을 항상 재정의하라" />
    <published>2025-10-02T06:42:48+09:00</published>
  
    <updated>2025-10-02T06:42:48+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 12 : toString을 항상 재정의하라  들어가며 자바에서 클래스를 만들 때 equals(), hashCode() 재정의의 중요성은 잘 알고 있다. 하지만 toString() 메서드의 재정의는 종종 간과된다.  이펙티브 자바 아이템 12는 toString()을 항상 재정의하는 것이 얼마나 중요한지 강조한다.  Object의 기본 toString은 쓸모가 없다  개발자가 toString()을 재정의하지 않으면 java.lang.Object 클래스의 기본 구현이 상속된다. 실제 JDK의 Object.toString() 구현을 보자.  /**  * Returns a string representation of the object.  * @implSpec  * The {@code toString}...</summary>

  </entry>

</feed>


