

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-10-24T18:42:53+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>[Effective Java] - 비트 필드 대신 EnumSet 을 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%B9%84%ED%8A%B8-%ED%95%84%EB%93%9C-%EB%8C%80%EC%8B%A0-EnumSet-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 비트 필드 대신 EnumSet 을 사용하라" />
    <published>2025-10-24T18:10:35+09:00</published>
  
    <updated>2025-10-24T18:10:35+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%B9%84%ED%8A%B8-%ED%95%84%EB%93%9C-%EB%8C%80%EC%8B%A0-EnumSet-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%B9%84%ED%8A%B8-%ED%95%84%EB%93%9C-%EB%8C%80%EC%8B%A0-EnumSet-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 36 : 비트 필드 대신 EnumSet을 사용하라  들어가며  열거 타입을 집합으로 사용해야 할 때가 있다. 예컨대 텍스트 스타일을 표현할 때 굵게, 기울임, 밑줄, 취소선 등 여러 스타일을 동시에 적용할 수 있어야 한다. 과거에는 이런 경우 각 상수에 서로 다른 2의 거듭제곱 값을 할당한 비트 필드(bit field) 방식을 사용했다.  그러나 자바에는 비트 필드보다 훨씬 나은 대안이 있다. 바로 EnumSet 이다. EnumSet은 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현하며, Set 인터페이스를 완벽히 구현하고, 타입 안전하며, 다른 Set 구현체와도 함께 사용할 수 있다.  이번 아이템에서는 비트 필드의 문제점을 살펴보고, EnumSet이 왜 더 나은 선택인지 깊이 있게 ...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%9D%B8%EC%88%98%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%93%B8-%EB%95%8C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 제네릭과 가변인수를 함께 쓸 때는 신중하라" />
    <published>2025-10-24T11:59:03+09:00</published>
  
    <updated>2025-10-24T11:59:03+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%9D%B8%EC%88%98%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%93%B8-%EB%95%8C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%9D%B8%EC%88%98%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%93%B8-%EB%95%8C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 32 : 제네릭과 가변인수를 함께 쓸 때는 신중하라  들어가며  가변인수(varargs)는 메서드에 임의 개수의 인수를 전달할 수 있게 해주는 편리한 기능이다. 하지만 제네릭과 함께 사용하면 타입 안전성에 심각한 구멍이 생긴다. 이번 아이템에서는 제네릭 varargs의 위험성과 이를 안전하게 사용하는 방법을 알아본다.    가변인수와 제네릭의 근본적인 충돌  실체화 불가 타입(Non-Reifiable Type)  먼저 핵심 개념부터 이해하자. 실체화(Reification) 란 타입 정보가 런타임에도 완전히 유지되는 것을 의미한다. // 실체화 타입 - 런타임에 타입 정보 유지 String[] strings = new String[10]; Object[] objects = strings; obj...</summary>

  </entry>

  
  <entry>
    <title>Java Basic Questions (1부)</title>
    <link href="https://kguswo.github.io/posts/Java-Basic-Questions-1%EB%B6%80/" rel="alternate" type="text/html" title="Java Basic Questions (1부)" />
    <published>2025-10-24T01:50:29+09:00</published>
  
    <updated>2025-10-24T01:50:29+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Java-Basic-Questions-1%EB%B6%80/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Java-Basic-Questions-1%EB%B6%80/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="JavaGuide" />
    
  

  <summary>들어가며 Java의 기본 개념에 대한 공부를 하며 중국어 자료를 한국어로 다시 정리하고자 한다.  기본 개념과 상식  자바 언어의 특징은 무엇인가?     배우기 쉽다. (구문이 간단하고 배우기 쉬움)   객체 지향 (캡슐화, 상속, 다형성 등)   플랫폼 독립성 (Java 가상 머신; JVM은 플랫폼 독립성을 구현한다)   멀티스레드 지원 (C++ 언어는 내장된 멀티스레드 메커니즘이 없어서 운영체제의 멀티스레드 기능을 호출해야 하지만, Java 언어는 멀티스레드를 지원한다.) 2011년 C++ 11 부터 C++ 는 Windows, Linux, MacOS에서 스레드를 생성하는데 사용할 수 있는 멀티스레딩 라이브러리를 도입했다. - std::thread.std::async 참고자료 : std::threa...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 이왕이면 제네릭 메서드로 만들라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%9D%B4%EC%99%95%EC%9D%B4%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 이왕이면 제네릭 메서드로 만들라" />
    <published>2025-10-21T15:55:24+09:00</published>
  
    <updated>2025-10-21T15:55:24+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%9D%B4%EC%99%95%EC%9D%B4%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%9D%B4%EC%99%95%EC%9D%B4%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 30 : 이왕이면 제네릭 메서드로 만들라  들어가며  클래스와 마찬가지로 메서드도 제네릭으로 만들 수 있다. Collections의 알고리즘 메서드(binarySearch, sort 등)는 모두 제네릭이다. 제네릭 메서드는 클라이언트가 직접 형변환을 해야 하는 메서드보다 훨씬 안전하고 사용하기 쉽다. 이번 아이템에서는 제네릭 메서드를 작성하는 방법과 그 이점을 살펴본다.    제네릭 메서드의 필요성  먼저 타입 안전하지 않은 메서드의 예를 살펴보자.  // 잘못된 예 - raw 타입 사용 public static Set union(Set s1, Set s2) {     Set result = new HashSet(s1);     result.addAll(s2);     return result...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 비검사 경고를 제거하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC-ihbnz2cv/" rel="alternate" type="text/html" title="[Effective Java] - 비검사 경고를 제거하라" />
    <published>2025-10-21T15:39:04+09:00</published>
  
    <updated>2025-10-21T15:39:04+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC-ihbnz2cv/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC-ihbnz2cv/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 27 : 비검사 경고를 제거하라  들어가며  제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 마주하게 된다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 그것이다. 제네릭에 익숙해질수록 마주치는 경고 수는 줄어들지만, 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하기는 어렵다.  많은 비검사 경고는 쉽게 제거할 수 있다. 코드를 조금만 수정하면 경고가 사라지는 경우가 대부분이다.  제거하기 어려운 경고도 있지만, 할 수 있는 한 모든 비검사 경고를 제거하자. 모두 제거한다면 그 코드는 타입 안전성이 보장된다. 즉, 런타임에 ClassCastException 이 발생할 일이 없고, 의도한 대로 잘 동작하리라 확신할 수 ...</summary>

  </entry>

</feed>


