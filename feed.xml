

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-11-04T11:21:27+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>프리코스 3주차를 진행하며</title>
    <link href="https://kguswo.github.io/posts/%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-3%EC%A3%BC%EC%B0%A8%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EB%A9%B0/" rel="alternate" type="text/html" title="프리코스 3주차를 진행하며" />
    <published>2025-11-04T01:54:57+09:00</published>
  
    <updated>2025-11-04T01:54:57+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-3%EC%A3%BC%EC%B0%A8%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EB%A9%B0/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-3%EC%A3%BC%EC%B0%A8%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%98%EB%A9%B0/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="우아한테크코스" />
    
  

  <summary>들어가며     우아한테크코스 8기 프리코스 3주차 과제는 로또 게임 구현이었다. 1주차 문자열 계산기는 단순 로직, 2주차 자동차 경주는 객체 만들기에 집중했다면, 이번엔 객체들이 서로 협력하는 구조를 만들어야 했다. 그리고 생각보다 훨씬 복잡했다. “당첨 번호도 로또인가?”, “비교는 누가 하지?”, “일급 컬렉션은 어디까지 책임져야 하지?” 끝도 없이 쏟아지는 질문들 속에서 하나씩 답을 찾아가는 과정을 기록하고자 한다.       1. 로또 vs 당첨 번호: 같은 객체로 할까 다른 객체로 할까?  처음 요구사항을 읽으며 클래스 구조를 상상해봤다.  “로또가 있고, 당첨 번호가 있고, 비교하고… 음, 간단한데?”  근데 막상 설계하려니 막막했다.    Q. 당첨 번호도 Lotto 클래스를 쓸까?  ...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 스트림에서는 부작용 없는 함수를 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC-ohr7peg4/" rel="alternate" type="text/html" title="[Effective Java] - 스트림에서는 부작용 없는 함수를 사용하라" />
    <published>2025-10-31T11:46:09+09:00</published>
  
    <updated>2025-10-31T11:46:09+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC-ohr7peg4/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC-ohr7peg4/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 46 : 스트림에서는 부작용 없는 함수를 사용하라  들어가며  스트림은 그저 또 하나의 API가 아니다. 함수형 프로그래밍에 기초한 패러다임이다. 스트림이 제공하는 표현력, 속도, 병렬성을 얻으려면 API는 물론이고 이 패러다임까지 함께 받아들여야 한다.  스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분 이다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수 여야 한다. 순수 함수란 오직 입력만이 결과에 영향을 주는 함수다. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다. 이를 위해서는 스트림 연산에 건네는 함수 객체는 모두 부작용(side effect)이 없어야 한다.    잘못된 스트림 코드  먼저 스트림을 잘못 사...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 람다보다는 메서드 참조를 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 람다보다는 메서드 참조를 사용하라" />
    <published>2025-10-31T10:41:11+09:00</published>
  
    <updated>2025-10-31T10:41:11+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 43 : 람다보다는 메서드 참조를 사용하라  들어가며  Java 8에서 람다가 도입되면서 익명 클래스보다 간결하게 함수 객체를 만들 수 있게 되었다. 그런데 람다보다 더 간결하게 만드는 방법이 있다. 바로 메서드 참조(method reference) 다. 메서드 참조를 사용하면 람다의 간결함을 넘어 더욱 명확하고 읽기 쉬운 코드를 작성할 수 있다.  이번 아이템에서는 람다와 메서드 참조를 비교하며, 언제 메서드 참조를 사용해야 하는지, 그리고 메서드 참조의 다섯 가지 유형에 대해 깊이 있게 알아본다.    람다에서 메서드 참조로  아래 코드는 Map에 키가 없으면 1을 저장하고, 있으면 기존 값에 1을 더한다.  map.merge(key, 1, (count, incr) -&amp;gt; count +...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 익명 클래스보다는 람다를 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EC%9D%B5%EB%AA%85-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%9E%8C%EB%8B%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 익명 클래스보다는 람다를 사용하라" />
    <published>2025-10-28T15:50:53+09:00</published>
  
    <updated>2025-10-28T15:50:53+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EC%9D%B5%EB%AA%85-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%9E%8C%EB%8B%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EC%9D%B5%EB%AA%85-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%9E%8C%EB%8B%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 42 : 익명 클래스보다는 람다를 사용하라  들어가며  예전 자바에서 함수 타입을 표현할 때는 추상 메서드를 하나만 담은 인터페이스(또는 추상 클래스)를 사용했다. 이런 인터페이스의 인스턴스를 함수 객체(function object) 라고 하여, 특정 함수나 동작을 나타내는 데 사용했다. JDK 1.1부터 함수 객체를 만드는 주요 수단은 익명 클래스 였다.  하지만 익명 클래스 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다. 자바 8에서 추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 함수형 인터페이스 라 불리게 되었고, 자바는 이런 함수형 인터페이스의 인스턴스를 람다식(lambda expression) 을 사용해 만들 수 있게 되었다. 람다는 함수나 익명...</summary>

  </entry>

  
  <entry>
    <title>[Effective Java] - 명명 패턴보다 애너테이션을 사용하라</title>
    <link href="https://kguswo.github.io/posts/Effective-Java-%EB%AA%85%EB%AA%85-%ED%8C%A8%ED%84%B4%EB%B3%B4%EB%8B%A4-%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" rel="alternate" type="text/html" title="[Effective Java] - 명명 패턴보다 애너테이션을 사용하라" />
    <published>2025-10-28T15:33:32+09:00</published>
  
    <updated>2025-10-28T15:33:32+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Effective-Java-%EB%AA%85%EB%AA%85-%ED%8C%A8%ED%84%B4%EB%B3%B4%EB%8B%A4-%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Effective-Java-%EB%AA%85%EB%AA%85-%ED%8C%A8%ED%84%B4%EB%B3%B4%EB%8B%A4-%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="개발서적" />
    
    <category term="이펙티브자바" />
    
  

  <summary>Item 39 : 명명 패턴보다 애너테이션을 사용하라  들어가며  전통적으로 Java에서는 특정 요소에 추가적인 정보나 처리 방식을 부여하기 위해 명명 패턴(naming pattern) 을 사용해왔다. 예를 들어, JUnit 3 버전까지는 테스트 메서드의 이름을 test로 시작하도록 강제했다. 하지만 명명 패턴은 여러 가지 단점을 가지고 있으며, Java 5부터 도입된 애너테이션(annotation) 이 이를 완벽하게 대체할 수 있는 해법을 제공한다.  이 글에서는 명명 패턴의 문제점을 구체적으로 살펴보고, 애너테이션이 어떻게 이를 해결하는지, 그리고 실제로 애너테이션을 어떻게 설계하고 사용해야 하는지 깊이 있게 다룬다.    명명 패턴의 문제점  명명 패턴은 단순해 보이지만, 다음과 같은 심각한 문제...</summary>

  </entry>

</feed>


