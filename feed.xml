

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Chirpy</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2025-08-26T11:20:27+08:00</updated>
  <author>
    <name>your_full_name</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 your_full_name </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title></title>
    <link href="/posts/2025-01-10-boj2698-java/" rel="alternate" type="text/html" title="" />
    <published>2025-08-26T11:20:27+08:00</published>
  
    <updated>2025-08-26T11:20:27+08:00</updated>
  
    <id>/posts/2025-01-10-boj2698-java/</id>
    <content type="text/html" src="/posts/2025-01-10-boj2698-java/" />
    <author>
      <name>your_full_name</name>
    </author>

  
    
  

  <summary>[Gold IV] 인접한 비트의 개수 - 2698  문제 링크  성능 요약  메모리: 16600 KB, 시간: 116 ms  분류  다이나믹 프로그래밍  제출 일자  2025년 1월 10일 16:59:47  문제 설명  0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다. S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.  s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn  위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어, 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.  수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인 수열 S의 개수...</summary>

  </entry>

  
  <entry>
    <title></title>
    <link href="/posts/2025-01-05-boj9251lcs-java-c/" rel="alternate" type="text/html" title="" />
    <published>2025-08-26T11:20:27+08:00</published>
  
    <updated>2025-08-26T11:20:27+08:00</updated>
  
    <id>/posts/2025-01-05-boj9251lcs-java-c/</id>
    <content type="text/html" src="/posts/2025-01-05-boj9251lcs-java-c/" />
    <author>
      <name>your_full_name</name>
    </author>

  
    
  

  <summary>[Gold V] LCS - 9251  문제 링크  성능 요약  메모리: 6004 KB, 시간: 4 ms  분류  다이나믹 프로그래밍, 문자열  제출 일자  2025년 1월 5일 22:52:41  문제 설명  LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.  예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.  입력  첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.  출력  첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.     문제 풀이     상세 로직 설명     ...</summary>

  </entry>

  
  <entry>
    <title></title>
    <link href="/posts/2025-01-01-leetcode11container-with-most-water-java-c/" rel="alternate" type="text/html" title="" />
    <published>2025-08-26T11:20:27+08:00</published>
  
    <updated>2025-08-26T11:20:27+08:00</updated>
  
    <id>/posts/2025-01-01-leetcode11container-with-most-water-java-c/</id>
    <content type="text/html" src="/posts/2025-01-01-leetcode11container-with-most-water-java-c/" />
    <author>
      <name>your_full_name</name>
    </author>

  
    
  

  <summary>11. Container With Most Water Medium  You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).  Find two lines that together with the x-axis form a container, such that the container contains the most water.  Return the maximum amount of water a container can store.  Notice that you may not sla...</summary>

  </entry>

  
  <entry>
    <title></title>
    <link href="/posts/2025-01-01-leet146lrucache-java/" rel="alternate" type="text/html" title="" />
    <published>2025-08-26T11:20:27+08:00</published>
  
    <updated>2025-08-26T11:20:27+08:00</updated>
  
    <id>/posts/2025-01-01-leet146lrucache-java/</id>
    <content type="text/html" src="/posts/2025-01-01-leet146lrucache-java/" />
    <author>
      <name>your_full_name</name>
    </author>

  
    
  

  <summary>146. LRU Cache Medium  Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  Implement the LRUCache class:   	LRUCache(int capacity) Initialize the LRU cache with positive size capacity. 	int get(int key) Return the value of the key if the key exists, otherwise return -1. 	void put(int key, int value) Update the value of the key if the key exists. Otherwise...</summary>

  </entry>

  
  <entry>
    <title></title>
    <link href="/posts/2024-12-31-boj23829/" rel="alternate" type="text/html" title="" />
    <published>2025-08-26T11:20:27+08:00</published>
  
    <updated>2025-08-26T11:20:27+08:00</updated>
  
    <id>/posts/2024-12-31-boj23829/</id>
    <content type="text/html" src="/posts/2024-12-31-boj23829/" />
    <author>
      <name>your_full_name</name>
    </author>

  
    
  

  <summary>[Gold IV] 인문예술탐사주간 - 23829  문제 링크  성능 요약  메모리: 45380 KB, 시간: 684 ms  분류  이분 탐색, 누적 합  제출 일자  2024년 12월 31일 14:48:28  문제 설명  태영이는 SASA의 축제라고 불리는 “인문예술탐사주간”을 보내게 되었다. “인문예술탐사주간”을 맞이하여 세종호수공원에 가게 된 태영이는 아름다운 경치에 놀라움을 금치 못했다.  세종호수공원은 일직선으로 뻗어있는 모습이다. 이 공원에는 나무가 총 $N$ 그루 있으며, $i$ 번째 나무의 위치는 $P_i$이다.  태영이는 카메라를 들고 파노라마 사진을 $Q$ 번 찍어, 이 아름다운 풍경을 담으려고 한다. 태영이는 이 사진에 점수를 매기려고 하는데, 사진의 점수는 사진을 찍은 위치로부터 각...</summary>

  </entry>

</feed>


