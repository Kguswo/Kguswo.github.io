

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://kguswo.github.io/</id>
  <title>Now's Log</title>
  <subtitle>프로그래밍, 개발 팁과 프로젝트를 공유하는 기술 블로그입니다.</subtitle>
  <updated>2025-12-18T20:35:12+09:00</updated>
  <author>
    <name>Hyeon Jae Kim</name>
    <uri>https://kguswo.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://kguswo.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://kguswo.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Hyeon Jae Kim </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>GROUP BY가 포함된 JOIN UPDATE</title>
    <link href="https://kguswo.github.io/posts/GROUP-BY%EA%B0%80-%ED%8F%AC%ED%95%A8%EB%90%9C-JOIN-UPDATE/" rel="alternate" type="text/html" title="GROUP BY가 포함된 JOIN UPDATE" />
    <published>2025-12-18T19:48:41+09:00</published>
  
    <updated>2025-12-18T19:48:41+09:00</updated>
  
    <id>https://kguswo.github.io/posts/GROUP-BY%EA%B0%80-%ED%8F%AC%ED%95%A8%EB%90%9C-JOIN-UPDATE/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/GROUP-BY%EA%B0%80-%ED%8F%AC%ED%95%A8%EB%90%9C-JOIN-UPDATE/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="데이터베이스" />
    
  

  <summary>들어가며  MySQL에서 JOIN UPDATE는 다른 테이블의 데이터를 참조하여 특정 테이블을 업데이트할 때 사용하는 강력한 기능이다. 그런데 여기에 GROUP BY를 사용하려 하면 갑자기 문법 오류가 발생한다. 왜 그럴까? 이번 글에서는 JOIN UPDATE에서 GROUP BY가 왜 안 되는지, 그리고 이 문제를 해결하기 위한 파생 테이블 , STRAIGHT_JOIN , JOIN_ORDER 힌트 , LATERAL 조인 까지 깊이 있게 다뤄본다. 각 방식의 실행 계획을 직접 비교하여 어떤 차이가 있는지도 확인해보자.    문제 상황: GROUP BY가 포함된 JOIN UPDATE  부서별 직원 수를 departments 테이블에 저장하고 싶다고 가정하자.  -- 먼저 emp_count 칼럼 추가 ALT...</summary>

  </entry>

  
  <entry>
    <title>Real MySQL - INSERT, UPDATE, DELETE</title>
    <link href="https://kguswo.github.io/posts/Real-MySQL-INSERT-UPDATE-DELETE/" rel="alternate" type="text/html" title="Real MySQL - INSERT, UPDATE, DELETE" />
    <published>2025-12-18T18:56:36+09:00</published>
  
    <updated>2025-12-18T18:56:36+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Real-MySQL-INSERT-UPDATE-DELETE/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Real-MySQL-INSERT-UPDATE-DELETE/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="데이터베이스" />
    
  

  <summary>들어가며  SELECT 문은 데이터를 조회하는 데 사용되지만, 실제 서비스에서는 데이터의 생성, 수정, 삭제가 빈번하게 발생한다. INSERT, UPDATE, DELETE는 데이터를 변경하는 DML(Data Manipulation Language)로, 잘못 사용하면 성능 저하는 물론 데이터 무결성에도 심각한 영향을 줄 수 있다. 이번 글에서는 Real MySQL 8.0 2권 11장의 INSERT 고급 옵션, LOAD DATA 명령, 성능을 위한 테이블 구조, 그리고 UPDATE와 DELETE의 다양한 활용법에 대해 다룬다.    INSERT  INSERT 문은 단순해 보이지만, MySQL에서는 다양한 고급 옵션을 제공한다. 이 옵션들을 적절히 활용하면 중복 처리, 대량 데이터 적재, 성능 최적화 등 다...</summary>

  </entry>

  
  <entry>
    <title>Real MySQL 8.0 : 서브쿼리, CTE, 잠금을 사용하는 SELECT</title>
    <link href="https://kguswo.github.io/posts/Real-MySQL-8.0-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-CTE-%EC%9E%A0%EA%B8%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-SELECT/" rel="alternate" type="text/html" title="Real MySQL 8.0 : 서브쿼리, CTE, 잠금을 사용하는 SELECT" />
    <published>2025-12-15T19:54:47+09:00</published>
  
    <updated>2025-12-15T19:54:47+09:00</updated>
  
    <id>https://kguswo.github.io/posts/Real-MySQL-8.0-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-CTE-%EC%9E%A0%EA%B8%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-SELECT/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/Real-MySQL-8.0-%EC%84%9C%EB%B8%8C%EC%BF%BC%EB%A6%AC-CTE-%EC%9E%A0%EA%B8%88%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-SELECT/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="데이터베이스" />
    
  

  <summary>들어가며  Real MySQL 8.0 2권 11장에서는 쿼리 작성과 최적화에 대해 다룬다. 이 글에서는 그중 11.4.10 서브쿼리, 11.4.11 CTE(Common Table Expression), 11.4.13 잠금을 사용하는 SELECT를 정리한다.  서브쿼리는 MySQL 5.5 이하에서 성능이 좋지 않아 기피 대상이었지만, MySQL 8.0에서는 세미 조인 최적화 등 다양한 최적화 기법이 도입되어 상황이 크게 달라졌다. CTE는 MySQL 8.0에서 새롭게 도입된 기능으로, 복잡한 쿼리의 가독성을 높이고 재귀 쿼리를 가능하게 한다. 잠금을 사용하는 SELECT는 동시성 제어의 핵심으로, MySQL 8.0.1부터 NOWAIT과 SKIP LOCKED 옵션이 추가되어 더욱 유연한 잠금 제어가 가능해...</summary>

  </entry>

  
  <entry>
    <title>선착순 쿠폰 발급과 동시성 문제</title>
    <link href="https://kguswo.github.io/posts/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EB%B0%9C%EA%B8%89%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C/" rel="alternate" type="text/html" title="선착순 쿠폰 발급과 동시성 문제" />
    <published>2025-12-15T19:28:40+09:00</published>
  
    <updated>2025-12-15T19:28:40+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EB%B0%9C%EA%B8%89%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EC%84%A0%EC%B0%A9%EC%88%9C-%EC%BF%A0%ED%8F%B0-%EB%B0%9C%EA%B8%89%EA%B3%BC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="공부" />
    
  

  <summary>들어가며  Real MySQL 8.0 11.4.13 "잠금을 사용하는 SELECT" 를 읽다 보면, 선착순 쿠폰 발급 시 동시에 1000개의 요청이 들어오는 상황을 예로 들며 NOWAIT과 SKIP LOCKED를 설명한다. 책에서는 간단히 언급하고 넘어가지만, 실제로 이 문제를 해결하려면 상당히 깊은 이해가 필요하다.  특히 배달, 커머스 기업 등에서는 선착순 쿠폰 발급 요청이 동시에 수백, 수천만개가 들어온다고 한다.  이 글에서는 선착순 쿠폰 발급의 동시성 문제가 왜 발생하는지, 그리고 MySQL의 잠금 기능부터 Redis, Kafka를 활용한 대규모 처리까지 단계별로 살펴본다. 필자는 Java 코드로 진행하고자 한다.    Race Condition  선착순 100명에게 쿠폰을 발급하는 요구사항을...</summary>

  </entry>

  
  <entry>
    <title>지연된 조인 실행계획 테스트</title>
    <link href="https://kguswo.github.io/posts/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%A1%B0%EC%9D%B8-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-%ED%85%8C%EC%8A%A4%ED%8A%B8/" rel="alternate" type="text/html" title="지연된 조인 실행계획 테스트" />
    <published>2025-12-13T14:03:15+09:00</published>
  
    <updated>2025-12-13T14:03:15+09:00</updated>
  
    <id>https://kguswo.github.io/posts/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%A1%B0%EC%9D%B8-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-%ED%85%8C%EC%8A%A4%ED%8A%B8/</id>
    <content type="text/html" src="https://kguswo.github.io/posts/%EC%A7%80%EC%97%B0%EB%90%9C-%EC%A1%B0%EC%9D%B8-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-%ED%85%8C%EC%8A%A4%ED%8A%B8/" />
    <author>
      <name>Hyeon Jae Kim</name>
    </author>

  
    
    <category term="데이터베이스" />
    
  

  <summary>지연된 조인     드라이빙 테이블만으로 필요한 데이터를 먼저 필터링한 후, 최소한의 레코드로만 조인을 수행하는 기법이다.   조인을 사용하는 쿼리에서 GROUP BY, ORDER BY, LIMIT 등이 함께 사용될 때 성능을 높이기 위해 조인을 최대한 늦추고 필요한 데이터만 먼저 필터링한다.  같은 결과를 반환하는 두 쿼리를 예시로 진행해보자.  SELECT e.* FROM salaries s, employees e WHERE e.emp_no = s.emp_no     AND s.emp_no BETWEEN 10001 AND 15000  -- 5,000명 대상 GROUP BY s.emp_no ORDER BY SUM(s.salary) DESC LIMIT 10;     0.031 sec / 0.000 se...</summary>

  </entry>

</feed>


